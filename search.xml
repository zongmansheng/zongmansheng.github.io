<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>消息队列的高可用</title>
      <link href="/2019/05/05/xiao-xi-dui-lie-de-gao-ke-yong/"/>
      <url>/2019/05/05/xiao-xi-dui-lie-de-gao-ke-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="消息队列的高可用"><a href="#消息队列的高可用" class="headerlink" title="消息队列的高可用"></a>消息队列的高可用</h1><h4 id="一、RabbitMQ-的高可用性"><a href="#一、RabbitMQ-的高可用性" class="headerlink" title="一、RabbitMQ 的高可用性"></a>一、RabbitMQ 的高可用性</h4><blockquote><p>​    RabbitMQ 是比较有代表性的，因为是基于主从（非分布式）做高可用性的，我们就以 RabbitMQ 为例子讲解第一种 MQ 的高可用性怎么实现。</p><p>RabbitMQ 有三种模式：单机模式、普通集群模式、镜像集群模式。</p></blockquote><h5 id="1-1、单机模式"><a href="#1-1、单机模式" class="headerlink" title="1.1、单机模式"></a>1.1、单机模式</h5><blockquote><p>单机模式，就是 Demo 级别的，一般就是你本地启动了玩玩儿的，没人生产用单机模式。</p><p>普通集群模式（无高可用性）</p><p>普通集群模式，意思就是在多台机器上启动多个 RabbitMQ 实例，每个机器启动一个。你创建的 queue，只会放在一个 RabbitMQ 实例上，但是每个实例都同步 queue 的元数据（元数据可以认为是 queue 的一些配置信息，通过元数据，可以找到 queue 所在实例）。你消费的时候，实际上如果连接到了另外一个实例，那么那个实例会从 queue 所在实例上拉取数据过来。</p></blockquote><p><img src="//zongmansheng.club/2019/05/05/xiao-xi-dui-lie-de-gao-ke-yong/001.jpg" alt="001"></p><h4 id="二、Kafka-的高可用性"><a href="#二、Kafka-的高可用性" class="headerlink" title="二、Kafka 的高可用性"></a>二、Kafka 的高可用性</h4><blockquote><p>​    Kafka 一个最基本的架构认识：由多个 broker 组成，每个 broker 是一个节点；你创建一个 topic，这个 topic 可以划分为多个 partition，每个 partition 可以存在于不同的 broker 上，每个 partition 就放一部分数据。</p><p>​    这就是天然的分布式消息队列，就是说一个 topic 的数据，是分散放在多个机器上的，每个机器就放一部分数据。</p><p>​    实际上 RabbmitMQ 之类的，并不是分布式消息队列，它就是传统的消息队列，只不过提供了一些集群、HA(High Availability, 高可用性) 的机制而已，因为无论怎么玩儿，RabbitMQ 一个 queue 的数据都是放在一个节点里的，镜像集群下，也是每个节点都放这个 queue 的完整数据。</p><p>​    Kafka 0.8 以前，是没有 HA 机制的，就是任何一个 broker 宕机了，那个 broker 上的 partition 就废了，没法写也没法读，没有什么高可用性可言。</p><p>​    比如说，我们假设创建了一个 topic，指定其 partition 数量是 3 个，分别在三台机器上。但是，如果第二台机器宕机了，会导致这个 topic 的 1/3 的数据就丢了，因此这个是做不到高可用的。</p></blockquote><p><img src="//zongmansheng.club/2019/05/05/xiao-xi-dui-lie-de-gao-ke-yong/002.jpg" alt="002"></p><blockquote><p>​    这么搞，就有所谓的高可用性了，因为如果某个 broker 宕机了，没事儿，那个 broker上面的 partition 在其他机器上都有副本的，如果这上面有某个 partition 的 leader，那么此时会从 follower 中重新选举一个新的 leader 出来，大家继续读写那个新的 leader 即可。这就有所谓的高可用性了。</p><p>​    写数据的时候，生产者就写 leader，然后 leader 将数据落地写本地磁盘，接着其他 follower 自己主动从 leader 来 pull 数据。一旦所有 follower 同步好数据了，就会发送 ack 给 leader，leader 收到所有 follower 的 ack 之后，就会返回写成功的消息给生产者。（当然，这只是其中一种模式，还可以适当调整这个行为）</p><p>​    消费的时候，只会从 leader 去读，但是只有当一个消息已经被所有 follower 都同步成功返回 ack 的时候，这个消息才会被消费者读到。</p><p>​    看到这里，相信你大致明白了 Kafka 是如何保证高可用机制的了，对吧？不至于一无所知，现场还能给面试官画画图。要是遇上面试官确实是 Kafka 高手，深挖了问，那你只能说不好意思，太深入的你没研究过。</p><p>​    这种方式确实很麻烦，也不怎么好，没做到所谓的分布式，就是个普通集群。因为这导致你要么消费者每次随机连接一个实例然后拉取数据，要么固定连接那个 queue 所在实例消费数据，前者有数据拉取的开销，后者导致单实例性能瓶颈。</p><p>​    而且如果那个放 queue 的实例宕机了，会导致接下来其他实例就无法从那个实例拉取，如果你开启了消息持久化，让 RabbitMQ 落地存储消息的话，消息不一定会丢，得等这个实例恢复了，然后才可以继续从这个 queue 拉取数据。</p><p>​    所以这个事儿就比较尴尬了，这就没有什么所谓的高可用性，这方案主要是提高吞吐量的，就是说让集群中多个节点来服务某个 queue 的读写操作。</p><p>镜像集群模式（高可用性）</p><p>​    这种模式，才是所谓的 RabbitMQ 的高可用模式。跟普通集群模式不一样的是，在镜像集群模式下，你创建的 queue，无论元数据还是 queue 里的消息都会存在于多个实例上，就是说，每个 RabbitMQ 节点都有这个 queue 的一个完整镜像，包含 queue 的全部数据的意思。然后每次你写消息到 queue 的时候，都会自动把消息同步到多个实例的 queue 上。</p></blockquote><p><img src="//zongmansheng.club/2019/05/05/xiao-xi-dui-lie-de-gao-ke-yong/003.jpg" alt="003"></p><blockquote><p>​    那么如何开启这个镜像集群模式呢？其实很简单，RabbitMQ 有很好的管理控制台，就是在后台新增一个策略，这个策略是镜像集群模式的策略，指定的时候是可以要求数据同步到所有节点的，也可以要求同步到指定数量的节点，再次创建 queue 的时候，应用这个策略，就会自动将数据同步到其他的节点上去了。</p><p>这样的话，好处在于，你任何一个机器宕机了，没事儿，其它机器（节点）还包含了这个 queue 的完整数据，别的 consumer 都可以到其它节点上去消费数据。坏处在于，第一，这个性能开销也太大了吧，消息需要同步到所有机器上，导致网络带宽压力和消耗很重！第二，这么玩儿，不是分布式的，就没有扩展性可言了，如果某个 queue 负载很重，你加机器，新增的机器也包含了这个 queue 的所有数据，并没有办法线性扩展你的 queue。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式，MQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx惊群</title>
      <link href="/2019/04/28/nginx-liang-qun/"/>
      <url>/2019/04/28/nginx-liang-qun/</url>
      
        <content type="html"><![CDATA[<h1 id="nginx惊群"><a href="#nginx惊群" class="headerlink" title="nginx惊群"></a>nginx惊群</h1><h4 id="一、什么是惊群"><a href="#一、什么是惊群" class="headerlink" title="一、什么是惊群"></a>一、什么是惊群</h4><blockquote><p>​    多线程/多进程（linux下线程进程也没多大区别）等待同一个socket事件，当这个事件发生时，这些线程/进程被同时唤醒，就是惊群。可以想见，效率很低下，许多进程被内核重新调度唤醒，同时去响应这一个事件，当然只有一个进程能处理事件成功，其他的进程在处理该事件失败后重新休眠（也有其他选择）。这种性能浪费现象就是惊群。</p></blockquote><blockquote><p>​    惊群通常发生在server 上，当父进程绑定一个端口监听socket，然后fork出多个子进程，子进程们开始循环处理（比如accept）这个socket。每当用户发起一个TCP连接时，多个子进程同时被唤醒，然后其中一个子进程accept新连接成功，余者皆失败，重新休眠。</p></blockquote><h4 id="二、如何解决惊群问题-post事件处理机制"><a href="#二、如何解决惊群问题-post事件处理机制" class="headerlink" title="二、如何解决惊群问题-post事件处理机制"></a>二、如何解决惊群问题-post事件处理机制</h4><blockquote><p>​    很多操作系统的最新版本的内核已经在事件驱动机制中解决了惊群问题，但Nginx作为可移植性极高的web服务器，还是在自身的应用层面上较好的解决了这一问题。<br>Nginx规定了同一时刻只有唯一一个worker子进程监听web端口，这一就不会发生惊群了，此时新连接事件只能唤醒唯一的正在监听端口的worker子进程。</p><p>​    如何限制在某一时刻是有一个子进程监听web端口呢？在打开accept_mutex锁的情况下，只有调用ngx_trylock_accept_mutex方法后，当前的worker进程才会去试着监听web端口。</p><p>​    那么，什么时候释放ngx_accept_mutex锁呢？<br>​    显然不能等到这批事件全部执行完。因为这个worker进程上可能有许多活跃的连接，处理这些连接上的事件会占用很长时间，其他worker进程很难得到处理新连接的机会。</p><p>​    如何解决长时间占用ngx_accept_mutex的问题呢？</p><p>​    这就要依靠post事件处理机制，Nginx设计了两个队列：ngx_posted_accept_events队列（存放新连接事件的队列）和ngx_posted_events队列（存放普通事件的队列）。这两个队列都是ngx_event_t类型的双链表。定义如下：</p></blockquote><pre class=" language-java"><code class="language-java">ngx_thread_volatile ngx_event_t  <span class="token operator">*</span>ngx_posted_accept_events<span class="token punctuation">;</span>ngx_thread_volatile ngx_event_t  <span class="token operator">*</span>ngx_posted_events<span class="token punctuation">;</span></code></pre><blockquote><p>​    下面结合具体代码进行分析惊群问题的解决。</p><p>​    首先看worker进程中ngx_process_events_and_timers事件处理函数（src/event/ngx.event.c），它处于worker进程的ngx_worker_process_cycle方法中，循环处理时间，是事件驱动机制的核心，既会处理普通的网络事件，也会处理定时器事件。ngx_process_events_and_timers是Nginx实际处理web业务的方法，所有业务的执行都是由它开始的，它涉及Nginx完整的事件驱动机制！！特别重要~</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span><span class="token function">ngx_process_events_and_timers</span><span class="token punctuation">(</span>ngx_cycle_t <span class="token operator">*</span>cycle<span class="token punctuation">)</span><span class="token punctuation">{</span>    ngx_uint_t  flags<span class="token punctuation">;</span>    ngx_msec_t  timer<span class="token punctuation">,</span> delta<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ngx_timer_resolution<span class="token punctuation">)</span> <span class="token punctuation">{</span>        timer <span class="token operator">=</span> NGX_TIMER_INFINITE<span class="token punctuation">;</span>        flags <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        timer <span class="token operator">=</span> <span class="token function">ngx_event_find_timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        flags <span class="token operator">=</span> NGX_UPDATE_TIME<span class="token punctuation">;</span>#<span class="token keyword">if</span> <span class="token punctuation">(</span>NGX_THREADS<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>timer <span class="token operator">==</span> NGX_TIMER_INFINITE <span class="token operator">||</span> timer <span class="token operator">></span> <span class="token number">500</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            timer <span class="token operator">=</span> <span class="token number">500</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>#endif    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*ngx_use_accept_mutex表示是否需要通过对accept加锁来解决惊群问题。当使用了master模式，nginx worker进程数>1时且配置文件中打开accept_mutex时，这个标志置为1     它在函数ngx_event_process_int中被设置，源代码为：    if (ccf->master &amp;&amp; ccf->worker_processes > 1 &amp;&amp; ecf->accept_mutex) {        ngx_use_accept_mutex = 1;        ngx_accept_mutex_held = 0;        ngx_accept_mutex_delay = ecf->accept_mutex_delay;    } else {        ngx_use_accept_mutex = 0;    }*/</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ngx_use_accept_mutex<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//负载均衡处理</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ngx_accept_disabled <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            ngx_accept_disabled<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//调用ngx_trylock_accept_mutex方法，尝试获取accept锁</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ngx_trylock_accept_mutex</span><span class="token punctuation">(</span>cycle<span class="token punctuation">)</span> <span class="token operator">==</span> NGX_ERROR<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//拿到锁</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ngx_accept_mutex_held<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">/*给flags增加标记NGX_POST_EVENTS，这个标记作为处理时间核心函数ngx_process_events的一个参数，这个函数中所有事件将延后处理。会把accept事件都放到ngx_posted_accept_events链表中，epollin|epollout普通事件都放到ngx_posted_events链表中 */</span>                flags <span class="token operator">|=</span> NGX_POST_EVENTS<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">/*获取锁失败，意味着既不能让当前worker进程频繁的试图抢锁，也不能让它经过太长事件再去抢锁                下面的代码：即使开启了timer_resolution时间精度，牙需要让ngx_process_change方法在没有新事件的时候至少等待ngx_accept_mutex_delay毫秒之后再去试图抢锁                而没有开启时间精度时，如果最近一个定时器事件的超时时间距离现在超过了ngx_accept_mutex_delay毫秒，也要把timer设置为ngx_accept_mutex_delay毫秒，这是因为当前进程虽然没有抢到accept_mutex锁，但也不能让ngx_process_change方法在没有新事件的时候等待的时间超过ngx_accept_mutex_delay，这会影响整个负载均衡机制*/</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>timer <span class="token operator">==</span> NGX_TIMER_INFINITE                    <span class="token operator">||</span> timer <span class="token operator">></span> ngx_accept_mutex_delay<span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    timer <span class="token operator">=</span> ngx_accept_mutex_delay<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//计算ngx_process_events消耗的时间</span>    delta <span class="token operator">=</span> ngx_current_msec<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//事件处理核心函数</span>    <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token function">ngx_process_events</span><span class="token punctuation">(</span>cycle<span class="token punctuation">,</span> timer<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>    delta <span class="token operator">=</span> ngx_current_msec <span class="token operator">-</span> delta<span class="token punctuation">;</span>    <span class="token function">ngx_log_debug1</span><span class="token punctuation">(</span>NGX_LOG_DEBUG_EVENT<span class="token punctuation">,</span> cycle<span class="token operator">-</span><span class="token operator">></span>log<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>                   <span class="token string">"timer delta: %M"</span><span class="token punctuation">,</span> delta<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//ngx_posted_accept_events链表有数据，开始accept新连接</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ngx_posted_accept_events<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">ngx_event_process_posted</span><span class="token punctuation">(</span>cycle<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ngx_posted_accept_events<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//释放锁后再处理ngx_posted_events链表中的普通事件</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ngx_accept_mutex_held<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">ngx_shmtx_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ngx_accept_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//如果ngx_process_events消耗的时间大于0，那么这是可能有新的定时器事件触发</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>delta<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//处理定时器事件</span>        <span class="token function">ngx_event_expire_timers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">ngx_log_debug1</span><span class="token punctuation">(</span>NGX_LOG_DEBUG_EVENT<span class="token punctuation">,</span> cycle<span class="token operator">-</span><span class="token operator">></span>log<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>                   <span class="token string">"posted events %p"</span><span class="token punctuation">,</span> ngx_posted_events<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//ngx_posted_events链表中有数据，进行处理</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ngx_posted_events<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ngx_threaded<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">ngx_wakeup_worker_thread</span><span class="token punctuation">(</span>cycle<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token function">ngx_event_process_posted</span><span class="token punctuation">(</span>cycle<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ngx_posted_events<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>​    上面代码中要进行说明的是，flags被设置后作为函数ngx_process_events方法的一个参数，在epoll模块中这个接口的实现方法是ngx_epoll_process_events（其具体代码见<a href="http://blog.csdn.net/xiajun07061225/article/details/9250341）。当falgs标志位含有nGX_POST_EVENTS时是不会立即调用事件的handler回调方法的，代码如下所示：" target="_blank" rel="noopener">http://blog.csdn.net/xiajun07061225/article/details/9250341）。当falgs标志位含有nGX_POST_EVENTS时是不会立即调用事件的handler回调方法的，代码如下所示：</a></p></blockquote><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//事件需要延后处理</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> NGX_POST_EVENTS<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">/*如果要在post队列中延后处理该事件，首先要判断它是新连接时间还是普通事件                以确定是把它加入到ngx_posted_accept_events队列或者ngx_posted_events队列中。*/</span>                queue <span class="token operator">=</span> <span class="token punctuation">(</span>ngx_event_t <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>rev<span class="token operator">-</span><span class="token operator">></span>accept <span class="token operator">?</span>                               <span class="token operator">&amp;</span>ngx_posted_accept_events <span class="token operator">:</span> <span class="token operator">&amp;</span>ngx_posted_events<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//将该事件添加到相应的延后队列中</span>                <span class="token function">ngx_locked_post_event</span><span class="token punctuation">(</span>rev<span class="token punctuation">,</span> queue<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//立即调用事件回调方法来处理这个事件</span>                rev<span class="token operator">-</span><span class="token operator">></span><span class="token function">handler</span><span class="token punctuation">(</span>rev<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span></code></pre><blockquote><p>通过上面的代码可以看出，先处理ngx_posted_accept_events队列中的事件，处理完毕后立即释放ngx_accept_mutex锁，接着再处理ngx_posted_events队列中事件。这样大大减少了ngx_accept_mutex锁占用的时间</p><p>下面看看ngx_trylock_accept_mutex的具体实现（src/event/ngx_event_accept.c）：</p></blockquote><pre class=" language-java"><code class="language-java">ngx_int_t<span class="token function">ngx_trylock_accept_mutex</span><span class="token punctuation">(</span>ngx_cycle_t <span class="token operator">*</span>cycle<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//尝试获取accept_mutex锁。注意是非阻塞的。返回1表示成功，返回0表示失败。</span>    <span class="token comment" spellcheck="true">//ngx_accept_mutex 定义：ngx_shmtx_t    ngx_accept_mutex;（ngx_shmtx_t是Nginx封装的互斥锁，用于经常间同步）</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ngx_shmtx_trylock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ngx_accept_mutex<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">ngx_log_debug0</span><span class="token punctuation">(</span>NGX_LOG_DEBUG_EVENT<span class="token punctuation">,</span> cycle<span class="token operator">-</span><span class="token operator">></span>log<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>                       <span class="token string">"accept mutex locked"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//获取到锁，但是标志位ngx_accept_mutex_held为1，表示当前进程已经获取到锁了，立即返回。</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ngx_accept_mutex_held            <span class="token operator">&amp;&amp;</span> ngx_accept_events <span class="token operator">==</span> <span class="token number">0</span>            <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>ngx_event_flags <span class="token operator">&amp;</span> NGX_USE_RTSIG_EVENT<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">return</span> NGX_OK<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//将所有监听事件添加到当前的epoll等事件驱动模块中</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ngx_enable_accept_events</span><span class="token punctuation">(</span>cycle<span class="token punctuation">)</span> <span class="token operator">==</span> NGX_ERROR<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//添加失败，必须释放互斥锁</span>            <span class="token function">ngx_shmtx_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ngx_accept_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> NGX_ERROR<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//标志位设置</span>        ngx_accept_events <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//当前进程已经获取到锁</span>        ngx_accept_mutex_held <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> NGX_OK<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">ngx_log_debug1</span><span class="token punctuation">(</span>NGX_LOG_DEBUG_EVENT<span class="token punctuation">,</span> cycle<span class="token operator">-</span><span class="token operator">></span>log<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>                   <span class="token string">"accept mutex lock failed: %ui"</span><span class="token punctuation">,</span> ngx_accept_mutex_held<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//获取锁失败，但是标志位ngx_accept_mutex_held仍然为1，即当前进程还处在获取到锁的状态，这是不正确的</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ngx_accept_mutex_held<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//将所有监听事件从事件驱动模块中移除</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ngx_disable_accept_events</span><span class="token punctuation">(</span>cycle<span class="token punctuation">)</span> <span class="token operator">==</span> NGX_ERROR<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> NGX_ERROR<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//没有获取到锁，设置标志位</span>        ngx_accept_mutex_held <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> NGX_OK<span class="token punctuation">;</span></code></pre><blockquote><p>​    调用这个方法的结果是，要么唯一获取到锁且其epoll等事件驱动模块开始监控web端口上的新连接事件。这种情况下调用process_events方法时就会既处理已有连接上的事件，也处理新连接的事件。要么没有获取到锁，当前进程不会收到新连接事件。这种情况下process_events只处理已有连接上的事件。</p></blockquote><h4 id="三、参考资料"><a href="#三、参考资料" class="headerlink" title="三、参考资料"></a>三、参考资料</h4><blockquote><p><a href="http://russelltao.iteye.com/blog/1405352" target="_blank" rel="noopener">http://russelltao.iteye.com/blog/1405352</a></p><p>《深入理解Nginx》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/04/26/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/"/>
      <url>/2019/04/26/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL事务及ACID特性的实现原理"><a href="#MySQL事务及ACID特性的实现原理" class="headerlink" title="MySQL事务及ACID特性的实现原理"></a>MySQL事务及ACID特性的实现原理</h1><h4 id="一、MySQL-事务基础概念"><a href="#一、MySQL-事务基础概念" class="headerlink" title="一、MySQL 事务基础概念"></a>一、MySQL 事务基础概念</h4><blockquote><p>​    事务(Transaction)是访问和更新数据库的程序执行单元;事务中可能包含一个或多个 sql 语句，这些语句要么都执行，要么都不执行。</p></blockquote><blockquote><p>​    作为一个关系型数据库，MySQL 支持事务，本文介绍基于 MySQL 5.6。首先回顾一下 MySQL 事务的基础知识。</p></blockquote><h4 id="二、逻辑架构和存储引擎"><a href="#二、逻辑架构和存储引擎" class="headerlink" title="二、逻辑架构和存储引擎"></a>二、逻辑架构和存储引擎</h4><p><img src="//zongmansheng.club/2019/04/26/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/001.jpg" alt="001"></p><blockquote><p>如上图所示，MySQL 服务器逻辑架构从上往下可以分为三层：</p></blockquote><p>++++</p><ul><li>第一层：处理客户端连接、授权认证等。</li><li>第二层：服务器层，负责查询语句的解析、优化、缓存以及内置函数的实现、存储过程等。</li><li>第三层：存储引擎，负责 MySQL 中数据的存储和提取。MySQL 中服务器层不管理事务，事务是由存储引擎实现的。</li></ul><blockquote><p>MySQL 支持事务的存储引擎有 InnoDB、NDB Cluster 等，其中 InnoDB 的使用最为广泛;其他存储引擎不支持事务，如 MyIsam、Memory 等。</p></blockquote><blockquote><p>如无特殊说明，后文中描述的内容都是基于 InnoDB。</p></blockquote><h4 id="三、提交和回滚"><a href="#三、提交和回滚" class="headerlink" title="三、提交和回滚"></a>三、提交和回滚</h4><blockquote><p>典型的 MySQL 事务是如下操作的：</p></blockquote><pre class=" language-java"><code class="language-java">start transaction<span class="token punctuation">;</span> …… #一条或多条sql语句 commit<span class="token punctuation">;</span> </code></pre><blockquote><p>其中 start transaction 标识事务开始，commit 提交事务，将执行结果写入到数据库。</p></blockquote><blockquote><p>如果 sql 语句执行出现问题，会调用 rollback，回滚所有已经执行成功的 sql 语句。当然，也可以在事务中直接使用 rollback 语句进行回滚。</p></blockquote><h4 id="四、自动提交"><a href="#四、自动提交" class="headerlink" title="四、自动提交"></a>四、自动提交</h4><blockquote><p>MySQL 中默认采用的是自动提交(autocommit)模式，如下所示：</p></blockquote><p><img src="//zongmansheng.club/2019/04/26/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/002.jpg" alt="002"></p><blockquote><p>在自动提交模式下，如果没有 start transaction 显式地开始一个事务，那么每个 sql 语句都会被当做一个事务执行提交操作。</p></blockquote><blockquote><p>通过如下方式，可以关闭 autocommit;需要注意的是，autocommit 参数是针对连接的，在一个连接中修改了参数，不会对其他连接产生影响。</p></blockquote><blockquote><p><img src="//zongmansheng.club/2019/04/26/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/003.jpg" alt="003"></p></blockquote><blockquote><p>如果关闭了 autocommit，则所有的 sql 语句都在一个事务中，直到执行了 commit 或 rollback，该事务结束，同时开始了另外一个事务。</p></blockquote><h4 id="五、特殊操作"><a href="#五、特殊操作" class="headerlink" title="五、特殊操作"></a>五、特殊操作</h4><blockquote><p>在 MySQL 中，存在一些特殊的命令，如果在事务中执行了这些命令，会马上强制执行 commit 提交事务;如 DDL 语句(create table/drop table/alter/table)、lock tables 语句等等。</p></blockquote><blockquote><p>不过，常用的 select、insert、update 和 delete 命令，都不会强制提交事务。</p></blockquote><h4 id="六、ACID-特性"><a href="#六、ACID-特性" class="headerlink" title="六、ACID 特性"></a>六、ACID 特性</h4><blockquote><p>ACID 是衡量事务的四个特性：</p></blockquote><ul><li><strong>原子性(Atomicity，或称不可分割性)</strong></li><li><strong>一致性(Consistency)</strong></li><li><strong>隔离性(Isolation)</strong></li><li><strong>持久性(Durability)</strong></li></ul><blockquote><p>按照严格的标准，只有同时满足 ACID 特性才是事务;但是在各大数据库厂商的实现中，真正满足 ACID 的事务少之又少。</p></blockquote><blockquote><p>例如 MySQL 的 NDB Cluster 事务不满足持久性和隔离性;InnoDB 默认事务隔离级别是可重复读，不满足隔离性;Oracle 默认的事务隔离级别为 READ COMMITTED，不满足隔离性……</p></blockquote><blockquote><p>因此与其说 ACID 是事务必须满足的条件，不如说它们是衡量事务的四个维度。</p></blockquote><blockquote><p>下面将详细介绍 ACID 特性及其实现原理，为了便于理解，介绍的顺序不是严格按照 A-C-I-D。</p></blockquote><h4 id="七、ACID-特性及其实现原理"><a href="#七、ACID-特性及其实现原理" class="headerlink" title="七、ACID 特性及其实现原理"></a>七、ACID 特性及其实现原理</h4><h5 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a><strong>原子性</strong></h5><p><strong>定义</strong></p><blockquote><p>原子性是指一个事务是一个不可分割的工作单位，其中的操作要么都做，要么都不做。</p></blockquote><blockquote><p>如果事务中一个 sql 语句执行失败，则已执行的语句也必须回滚，数据库退回到事务前的状态。</p></blockquote><p><strong>实现原理：undo log</strong></p><blockquote><p>在说明原子性原理之前，首先介绍一下 MySQL 的事务日志。MySQL 的日志有很多种，如二进制日志、错误日志、查询日志、慢查询日志等。</p></blockquote><blockquote><p>此外 InnoDB 存储引擎还提供了两种事务日志：</p></blockquote><ul><li><strong>redo log(重做日志)</strong></li><li><strong>undo log(回滚日志)</strong></li></ul><blockquote><p>其中 redo log 用于保证事务持久性;undo log 则是事务原子性和隔离性实现的基础。</p></blockquote><blockquote><p>下面说回 undo log。实现原子性的关键，是当事务回滚时能够撤销所有已经成功执行的 sql 语句。</p></blockquote><blockquote><p>InnoDB 实现回滚，靠的是 undo log：</p></blockquote><ul><li>当事务对数据库进行修改时，InnoDB 会生成对应的 undo log。</li><li>如果事务执行失败或调用了 rollback，导致事务需要回滚，便可以利用 undo log 中的信息将数据回滚到修改之前的样子。</li></ul><blockquote><p>undo log 属于逻辑日志，它记录的是 sql 执行相关的信息。当发生回滚时，InnoDB 会根据 undo log 的内容做与之前相反的工作：</p></blockquote><ul><li>对于每个 insert，回滚时会执行 delete。</li><li>对于每个 delete，回滚时会执行 insert。</li><li>对于每个 update，回滚时会执行一个相反的 update，把数据改回去。</li></ul><blockquote><p>以 update 操作为例：当事务执行 update 时，其生成的 undo log 中会包含被修改行的主键(以便知道修改了哪些行)、修改了哪些列、这些列在修改前后的值等信息，回滚时便可以使用这些信息将数据还原到 update 之前的状态。</p></blockquote><h5 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a><strong>持久性</strong></h5><p><strong>定义</strong></p><blockquote><p>持久性是指事务一旦提交，它对数据库的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。</p></blockquote><p><strong>实现原理：redo log</strong></p><blockquote><p>redo log 和 undo log 都属于 InnoDB 的事务日志。下面先聊一下 redo log 存在的背景。</p></blockquote><blockquote><p>InnoDB 作为 MySQL 的存储引擎，数据是存放在磁盘中的，但如果每次读写数据都需要磁盘 IO，效率会很低。</p></blockquote><blockquote><p>为此，InnoDB 提供了缓存(Buffer Pool)，Buffer Pool 中包含了磁盘中部分数据页的映射，作为访问数据库的缓冲：</p></blockquote><ul><li>当从数据库读取数据时，会首先从 Buffer Pool 中读取，如果 Buffer Pool 中没有，则从磁盘读取后放入 Buffer Pool。</li><li>当向数据库写入数据时，会首先写入 Buffer Pool，Buffer Pool 中修改的数据会定期刷新到磁盘中(这一过程称为刷脏)。</li></ul><blockquote><p>Buffer Pool 的使用大大提高了读写数据的效率，但是也带来了新的问题：如果 MySQL 宕机，而此时 Buffer Pool 中修改的数据还没有刷新到磁盘，就会导致数据的丢失，事务的持久性无法保证。</p></blockquote><blockquote><p>于是，redo log 被引入来解决这个问题：当数据修改时，除了修改 Buffer Pool 中的数据，还会在 redo log 记录这次操作;当事务提交时，会调用 fsync 接口对 redo log 进行刷盘。</p></blockquote><blockquote><p>如果 MySQL 宕机，重启时可以读取 redo log 中的数据，对数据库进行恢复。</p></blockquote><blockquote><p>redo log 采用的是 WAL(Write-ahead logging，预写式日志)，所有修改先写入日志，再更新到 Buffer Pool，保证了数据不会因 MySQL 宕机而丢失，从而满足了持久性要求。</p></blockquote><blockquote><p>既然 redo log 也需要在事务提交时将日志写入磁盘，为什么它比直接将 Buffer Pool 中修改的数据写入磁盘(即刷脏)要快呢?</p></blockquote><blockquote><p>主要有以下两方面的原因：</p></blockquote><ul><li>刷脏是随机 IO，因为每次修改的数据位置随机，但写 redo log 是追加操作，属于顺序 IO。</li><li>刷脏是以数据页(Page)为单位的，MySQL 默认页大小是 16KB，一个 Page 上一个小修改都要整页写入;而 redo log 中只包含真正需要写入的部分，无效 IO 大大减少。</li></ul><p><strong>redo log 与 binlog</strong></p><blockquote><p>我们知道，在 MySQL 中还存在 binlog(二进制日志)也可以记录写操作并用于数据的恢复，但二者是有着根本的不同的。</p></blockquote><blockquote><p>作用不同：</p></blockquote><ul><li>redo log 是用于 crash recovery 的，保证 MySQL 宕机也不会影响持久性;</li><li>binlog 是用于 point-in-time recovery 的，保证服务器可以基于时间点恢复数据，此外 binlog 还用于主从复制。</li></ul><blockquote><p>层次不同：</p></blockquote><ul><li>redo log 是 InnoDB 存储引擎实现的，</li><li>而 binlog 是 MySQL 的服务器层(可以参考文章前面对 MySQL 逻辑架构的介绍)实现的，同时支持 InnoDB 和其他存储引擎。</li></ul><blockquote><p>内容不同：</p></blockquote><ul><li>redo log 是物理日志，内容基于磁盘的 Page。</li><li>binlog 是逻辑日志，内容是一条条 sql。</li></ul><blockquote><p>写入时机不同：</p></blockquote><ul><li>redo log 的写入时机相对多元。前面曾提到，当事务提交时会调用 fsync 对 redo log 进行刷盘;这是默认情况下的策略，修改 innodb_flush_log_at_trx_commit 参数可以改变该策略，但事务的持久性将无法保证。</li></ul><blockquote><p>除了事务提交时，还有其他刷盘时机：如 master thread 每秒刷盘一次 redo log 等，这样的好处是不一定要等到 commit 时刷盘，commit 速度大大加快。</p></blockquote><ul><li>binlog 在事务提交时写入。</li></ul><h5 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a><strong>隔离性</strong></h5><p><strong>定义</strong></p><blockquote><p>与原子性、持久性侧重于研究事务本身不同，隔离性研究的是不同事务之间的相互影响。</p></blockquote><blockquote><p>隔离性是指事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p></blockquote><blockquote><p>严格的隔离性，对应了事务隔离级别中的 Serializable(可串行化)，但实际应用中出于性能方面的考虑很少会使用可串行化。</p></blockquote><blockquote><p>隔离性追求的是并发情形下事务之间互不干扰。简单起见，我们仅考虑最简单的读操作和写操作(暂时不考虑带锁读等特殊操作)。</p></blockquote><blockquote><p>那么隔离性的探讨，主要可以分为两个方面：</p></blockquote><ul><li>(一个事务)写操作对(另一个事务)写操作的影响：锁机制保证隔离性。</li><li>(一个事务)写操作对(另一个事务)读操作的影响：MVCC 保证隔离性。</li></ul><h5 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a><strong>锁机制</strong></h5><blockquote><p>首先来看两个事务的写操作之间的相互影响。隔离性要求同一时刻只能有一个事务对数据进行写操作，InnoDB 通过锁机制来保证这一点。</p></blockquote><blockquote><p>锁机制的基本原理可以概括为：</p></blockquote><ul><li>事务在修改数据之前，需要先获得相应的锁。</li><li>获得锁之后，事务便可以修改数据。</li><li>该事务操作期间，这部分数据是锁定的，其他事务如果需要修改数据，需要等待当前事务提交或回滚后释放锁。</li></ul><blockquote><p>行锁与表锁：按照粒度，锁可以分为表锁、行锁以及其他位于二者之间的锁。</p></blockquote><blockquote><p>表锁在操作数据时会锁定整张表，并发性能较差;行锁则只锁定需要操作的数据，并发性能好。</p></blockquote><blockquote><p>但是由于加锁本身需要消耗资源(获得锁、检查锁、释放锁等都需要消耗资源)，因此在锁定数据较多情况下使用表锁可以节省大量资源。</p></blockquote><blockquote><p>MySQL 中不同的存储引擎支持的锁是不一样的，例如 MyIsam 只支持表锁，而 InnoDB 同时支持表锁和行锁，且出于性能考虑，绝大多数情况下使用的都是行锁。</p></blockquote><blockquote><p>如何查看锁信息?有多种方法可以查看 InnoDB 中锁的情况，例如：</p></blockquote><pre class=" language-mysql"><code class="language-mysql">select * from information_schema.innodb_locks; #锁的概况 show engine innodb status; #InnoDB整体状态，其中包括锁的情况 </code></pre><p>下面来看一个例子：</p><pre class=" language-mysql"><code class="language-mysql">#在事务A中执行： start transaction; update account SET balance = 1000 where id = 1; 在事务B中执行： start transaction; update account SET balance = 2000 where id = 1; </code></pre><p>此时查看锁的情况：</p><p><img src="//zongmansheng.club/2019/04/26/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/004.jpg" alt="004"></p><p>show engine innodb status 查看锁相关的部分：</p><p><img src="//zongmansheng.club/2019/04/26/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/005.jpg" alt="005"></p><blockquote><p>通过上述命令可以查看事务 24052 和 24053 占用锁的情况;其中 lock_type 为 RECORD，代表锁为行锁(记录锁);lock_mode 为 X，代表排它锁(写锁)。</p></blockquote><blockquote><p>除了排它锁(写锁)之外，MySQL 中还有共享锁(读锁)的概念。由于本文重点是 MySQL 事务的实现原理，因此对锁的介绍到此为止。</p></blockquote><blockquote><p>介绍完写操作之间的相互影响，下面讨论写操作对读操作的影响。</p></blockquote><h5 id="脏读、不可重复读和幻读"><a href="#脏读、不可重复读和幻读" class="headerlink" title="脏读、不可重复读和幻读"></a><strong>脏读、不可重复读和幻读</strong></h5><blockquote><p>首先来看并发情况下，读操作可能存在的三类问题。</p></blockquote><blockquote><p>①脏读：当前事务(A)中可以读到其他事务(B)未提交的数据(脏数据)，这种现象是脏读。</p></blockquote><p>举例如下(以账户余额表为例)：</p><p><img src="//zongmansheng.club/2019/04/26/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/006.jpg" alt="006"></p><blockquote><p>②不可重复读：在事务 A 中先后两次读取同一个数据，两次读取的结果不一样，这种现象称为不可重复读。</p></blockquote><blockquote><p>脏读与不可重复读的区别在于：前者读到的是其他事务未提交的数据，后者读到的是其他事务已提交的数据。</p></blockquote><p>举例如下：</p><p><img src="//zongmansheng.club/2019/04/26/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/007.jpg" alt="007"></p><blockquote><p>③幻读：在事务 A 中按照某个条件先后两次查询数据库，两次查询结果的条数不同，这种现象称为幻读。</p></blockquote><blockquote><p>不可重复读与幻读的区别可以通俗的理解为：前者是数据变了，后者是数据的行数变了。</p></blockquote><p>举例如下：</p><p><img src="//zongmansheng.club/2019/04/26/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/008.jpg" alt="008"></p><h5 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a><strong>事务隔离级别</strong></h5><blockquote><p>sql 标准中定义了四种隔离级别，并规定了每种隔离级别下上述几个问题是否存在。</p></blockquote><blockquote><p>一般来说，隔离级别越低，系统开销越低，可支持的并发越高，但隔离性也越差。</p></blockquote><blockquote><p>隔离级别与读问题的关系如下：</p></blockquote><p><img src="//zongmansheng.club/2019/04/26/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/009.jpg" alt="009"></p><blockquote><p>在实际应用中，读未提交在并发时会导致很多问题，而性能相对于其他隔离级别提高却很有限，因此使用较少。</p></blockquote><blockquote><p>可串行化强制事务串行，并发效率很低，只有当对数据一致性要求极高且可以接受没有并发时使用，因此使用也较少。</p></blockquote><blockquote><p>因此在大多数数据库系统中，默认的隔离级别是读已提交(如 Oracle)或可重复读(后文简称 RR)。</p></blockquote><blockquote><p>可以通过如下两个命令分别查看全局隔离级别和本次会话的隔离级别：</p></blockquote><p><img src="//zongmansheng.club/2019/04/26/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/010.jpg" alt="010"></p><h4 id="八、MVCC"><a href="#八、MVCC" class="headerlink" title="八、MVCC"></a>八、MVCC</h4><blockquote><p>RR 解决脏读、不可重复读、幻读等问题，使用的是 MVCC：MVCC 全称 Multi-Version Concurrency Control，即多版本的并发控制协议。</p></blockquote><blockquote><p>下面的例子很好的体现了 MVCC 的特点：在同一时刻，不同的事务读取到的数据可能是不同的(即多版本)——在 T5 时刻，事务 A 和事务 C 可以读取到不同版本的数据。</p></blockquote><p><img src="//zongmansheng.club/2019/04/26/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/011.jpg" alt="011"></p><blockquote><p>MVCC 最大的优点是读不加锁，因此读写不冲突，并发性能好。InnoDB 实现 MVCC，多个版本的数据可以共存，主要是依靠数据的隐藏列(也可以称之为标记位)和 undo log。</p></blockquote><blockquote><p>其中数据的隐藏列包括了该行数据的版本号、删除时间、指向 undo log 的指针等等。</p></blockquote><blockquote><p>当读取数据时，MySQL 可以通过隐藏列判断是否需要回滚并找到回滚需要的 undo log，从而实现 MVCC;隐藏列的详细格式不再展开。</p></blockquote><blockquote><p>下面结合前文提到的几个问题分别说明。</p></blockquote><h5 id="①脏读"><a href="#①脏读" class="headerlink" title="①脏读"></a><strong>①脏读</strong></h5><p><img src="//zongmansheng.club/2019/04/26/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/012.jpg" alt="012"></p><blockquote><p>当事务 A 在 T3 时间节点读取 zhangsan 的余额时，会发现数据已被其他事务修改，且状态为未提交。</p></blockquote><blockquote><p>此时事务 A 读取最新数据后，根据数据的 undo log 执行回滚操作，得到事务 B 修改前的数据，从而避免了脏读。</p></blockquote><h5 id="②不可重复读"><a href="#②不可重复读" class="headerlink" title="②不可重复读"></a>②不可重复读</h5><p><img src="//zongmansheng.club/2019/04/26/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/013.jpg" alt="013"></p><blockquote><p>当事务 A 在 T2 节点第一次读取数据时，会记录该数据的版本号(数据的版本号是以 row 为单位记录的)，假设版本号为 1;当事务 B 提交时，该行记录的版本号增加，假设版本号为 2。</p></blockquote><blockquote><p>当事务 A 在 T5 再一次读取数据时，发现数据的版本号(2)大于第一次读取时记录的版本号(1)，因此会根据 undo log 执行回滚操作，得到版本号为 1 时的数据，从而实现了可重复读。</p></blockquote><h5 id="③幻读"><a href="#③幻读" class="headerlink" title="③幻读"></a>③幻读</h5><blockquote><p>InnoDB 实现的 RR 通过 next-keylock 机制避免了幻读现象。</p></blockquote><blockquote><p>next-keylock 是行锁的一种，实现相当于 record lock(记录锁) + gap lock(间隙锁);其特点是不仅会锁住记录本身(record lock 的功能)，还会锁定一个范围(gap lock 的功能)。</p></blockquote><blockquote><p>当然，这里我们讨论的是不加锁读：此时的 next-key lock 并不是真的加锁，只是为读取的数据增加了标记(标记内容包括数据的版本号等);准确起见姑且称之为类 next-key lock 机制。</p></blockquote><blockquote><p>还是以前面的例子来说明：</p></blockquote><p><img src="//zongmansheng.club/2019/04/26/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/014.jpg" alt="014"></p><blockquote><p>当事务 A 在 T2 节点第一次读取 0</p></blockquote><blockquote><p>这样当 T5 时刻再次读取 0</p></blockquote><blockquote><p>小结：概括来说，InnoDB 实现的 RR，通过锁机制、数据的隐藏列、undo log 和类 next-key lock，实现了一定程度的隔离性，可以满足大多数场景的需要。</p></blockquote><blockquote><p>不过需要说明的是，RR 虽然避免了幻读问题，但是毕竟不是 Serializable，不能保证完全的隔离。</p></blockquote><blockquote><p>下面是一个例子，大家可以自己验证一下：</p></blockquote><p><img src="//zongmansheng.club/2019/04/26/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/015.jpg" alt="015"></p><p><strong>一致性</strong></p><p><strong>基本概念</strong></p><p>一致性是指事务执行结束后，数据库的完整性约束没有被破坏，事务执行的前后都是合法的数据状态。</p><p>数据库的完整性约束包括但不限于：</p><ul><li>实体完整性(如行的主键存在且唯一)</li><li>列完整性(如字段的类型、大小、长度要符合要求)</li><li>外键约束</li><li>用户自定义完整性(如转账前后，两个账户余额的和应该不变)</li></ul><p><strong>实现</strong></p><p>可以说，一致性是事务追求的最终目标：前面提到的原子性、持久性和隔离性，都是为了保证数据库状态的一致性。此外，除了数据库层面的保障，一致性的实现也需要应用层面进行保障。</p><p>实现一致性的措施包括：</p><ul><li>保证原子性、持久性和隔离性，如果这些特性无法保证，事务的一致性也无法保证。</li><li>数据库本身提供保障，例如不允许向整形列插入字符串值、字符串长度不能超过列的限制等。</li><li>应用层面进行保障，例如如果转账操作只扣除转账者的余额，而没有增加接收者的余额，无论数据库实现的多么完美，也无法保证状态的一致。</li></ul><p><strong>总结</strong></p><p>下面总结一下 ACID 特性及其实现原理：</p><ul><li>原子性：语句要么全执行，要么全不执行，是事务最核心的特性。事务本身就是以原子性来定义的;实现主要基于 undo log。</li><li>持久性：保证事务提交后不会因为宕机等原因导致数据丢失;实现主要基于 redo log。</li><li>隔离性：保证事务执行尽可能不受其他事务影响;InnoDB 默认的隔离级别是 RR，RR 的实现主要基于锁机制、数据的隐藏列、undo log 和类 next-key lock 机制。</li><li>一致性：事务追求的最终目标，一致性的实现既需要数据库层面的保障，也需要应用层面的保障。</li></ul><h4 id="九、参考文献："><a href="#九、参考文献：" class="headerlink" title="九、参考文献："></a>九、参考文献：</h4><ul><li>《MySQL 技术内幕：InnoDB 存储引擎》</li><li>《高性能 MySQL》</li><li>《MySQL 运维内参》</li><li><a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_acid" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_acid</a></li><li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-next-key-locking.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.6/en/innodb-next-key-locking.html</a></li><li><a href="http://blog.sina.com.cn/s/blog_499740cb0100ugs7.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_499740cb0100ugs7.html</a></li><li><a href="https://mp.weixin.qq.com/s/2dwGBTmu_da2x-HiHlN0vw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/2dwGBTmu_da2x-HiHlN0vw</a></li><li><a href="http://www.cnblogs.com/chenpingzhao/p/5065316.html" target="_blank" rel="noopener">http://www.cnblogs.com/chenpingzhao/p/5065316.html</a></li><li><a href="https://juejin.im/entry/5ba0a254e51d450e735e4a1f" target="_blank" rel="noopener">https://juejin.im/entry/5ba0a254e51d450e735e4a1f</a></li><li><a href="http://hedengcheng.com/?p=771" target="_blank" rel="noopener">http://hedengcheng.com/?p=771</a></li></ul><p>转发自：<a href="https://www.toutiao.com/i6651767011648995843/" target="_blank" rel="noopener">https://www.toutiao.com/i6651767011648995843/</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入XSS和CSRF</title>
      <link href="/2019/04/25/sql-zhu-ru-xss-he-csrf/"/>
      <url>/2019/04/25/sql-zhu-ru-xss-he-csrf/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL注入、XSS和CSRF"><a href="#SQL注入、XSS和CSRF" class="headerlink" title="SQL注入、XSS和CSRF"></a>SQL注入、XSS和CSRF</h1><h4 id="一、SQL注入"><a href="#一、SQL注入" class="headerlink" title="一、SQL注入"></a>一、SQL注入</h4><pre><code>SQL注入是属于注入式攻击，这种攻击是因为在项目中没有将代码与数据（比如用户敏感数据）隔离，在读取数据的时候，错误的将数据作为代码的一部分执行而导致的。典型的例子就是当对SQL语句进行字符串拼接的时候，直接使用未转义的用户输入内容作为变量。这时，只要在sql语句的中间做修改，比如加上drop、delete等关键字，执行之后后果不堪设想。说到这里，那么该怎么处理这种情况呢？三个方面：1、过滤用户输入参数中的特殊字符，降低风险。2、禁止通过字符串拼接sql语句，要严格使用参数绑定来传入参数。3、合理使用数据库框架提供的机制。就比如Mybatis提供的传入参数的方式 #{}，禁止使用${}，后者相当于是字符串拼接sql，要使用参数化的语句。总结下，就是要正确使用参数化绑定sql变量。</code></pre><h4 id="二、XSS"><a href="#二、XSS" class="headerlink" title="二、XSS"></a>二、XSS</h4><p>​    </p><blockquote><p>​       XSS：跨站脚本攻击，Cross-Site Scripting，为了和前端的css避免重名，简称为XSS，是指通过技术手段，向正常用户请求的HTML页面中插入恶意脚本，执行。</p></blockquote><blockquote><p>​    这种攻击主要是用于信息窃取和破坏等目的。比如2011年的微博XSS攻击事件，攻击者利用了微博发布功能中未对action-data漏洞做有效的过滤，在发布微博信息的时候带上了包含攻击脚本的URL，用户访问就会加载恶意脚本，导致大量用户被攻击。</p></blockquote><blockquote><p>​    关于防范XSS上，主要就是通过对用户输入的数据做过滤或者是转义，可以使用框架提供的工具类HtmlUtil。另外前端在浏览器展示数据的时候，要使用安全的API展示数据。比如使用innerText而不是innerHTML。</p></blockquote><h4 id="三、CSRF"><a href="#三、CSRF" class="headerlink" title="三、CSRF"></a>三、CSRF</h4><blockquote><p>​    跨站请求伪造，在用户并不知情的情况下，冒充用户发送请求，在当前已经登录的web网站上执行恶意操作，比如恶意发帖，修改密码等。</p></blockquote><blockquote><p>​    大致来看，与XSS有重合的地方，前者是黑客盗用用户浏览器中的登录信息，冒充用户去执行操作。后者是在正常用户请求的HTML中放入恶意代码，</p></blockquote><blockquote><p>​    XSS问题出在用户数据没有转义，过滤；CSRF问题出现在HTTP接口没有防范不守信用的调用。</p></blockquote><blockquote><p>防范CSRF的漏洞方式：</p></blockquote><blockquote><p>​    1、CSRF Token验证，利用浏览器的同源限制，在HTTP接口执行前验证Cookie中的Token，验证通过才会继续执行请求。</p></blockquote><blockquote><p>​    2、人机交互，例如短信验证码、界面的滑块。</p></blockquote><blockquote><p>之前在会议上也有一个思考，在人机验证这块，如果不用验证码的方式，用界面上的滑块这种方式，而且滑块还是第三方的。在APP的注册、登录使用这种人机验证的方式的话，如果第三方出现了问题，那么自己的APP就完全崩掉了，发版之后的APP什么也改不了。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 日常学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
            <tag> XSS </tag>
            
            <tag> CSRF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一致性Hash</title>
      <link href="/2019/04/24/yi-zhi-xing-hash/"/>
      <url>/2019/04/24/yi-zhi-xing-hash/</url>
      
        <content type="html"><![CDATA[<h1 id="一致性Hash"><a href="#一致性Hash" class="headerlink" title="一致性Hash"></a>一致性Hash</h1><blockquote><p>一致性Hash是分布式架构最重要最基础的东西，作为一个后端必须要了解，这里以分布式图片缓存服务器为例进行讲述。</p></blockquote><p><strong>原始问题：假设我们需要对一堆图片做缓存，缓存的图片放在了2台服务器上，当到来一个请求，应该如何知道请求的图片在哪台上面呢？</strong></p><blockquote><p>暴力遍历就不要去想了，否则缓存就没有意义了。一个自然的想法就是根据图片的名字做一个映射（Hash），将图片名字映射到0，1两个数字上面，例如有这样的映射函数：</p></blockquote><blockquote><p>f(图片名称) = md5(图片名称) % 2</p></blockquote><blockquote><p>md5是一个典型的哈希函数，会产生128bit的值，模2后只可能是0或1，那么我们就根据这个值把图片存入0、1两台服务器，当请求过来，根据图片名称计算出值，就可以知道图片缓存放在第几号服务器了：</p></blockquote><p><img src="/一致性Hash\001.jpg" alt="001"></p><blockquote><p>但假设现在我们图片太多了，需要再增加一台服务器分担压力，哈希函数必须更改成0、1、2映射，我们改为：</p></blockquote><blockquote><p>f(图片名称) = md5(图片名称) % 3</p></blockquote><blockquote><p>理论上讲，会有(N-1)/N的缓存会失效，其中N是服务器的数量，例如上述图片缓存，除了0图片、1图片，其余图片的存放位置都变了，失效的缓存有 2/3 * 6 = 4张图片：</p></blockquote><p><img src="/一致性Hash\002.jpg" alt="002"></p><p>减少图片服务器数量造成的后果亦是如此——在同一个时刻将会有大量缓存同时失效，称为“缓存雪崩”。失效了就会直接去后端服务器取，大量的请求直接透过缓存打到后端服务器，后端服务器极有可能承受不住压力而接连崩溃，最终造成整个系统瘫痪。</p><p><strong>所以出现进阶问题：当缓存服务器数量发生变化时，如何尽可能避免大量缓存同时失效？</strong></p><p>答案就是一致性Hash。</p><h4 id="一、一致性Hash原理"><a href="#一、一致性Hash原理" class="headerlink" title="一、一致性Hash原理"></a>一、一致性Hash原理</h4><h5 id="1、放置服务器"><a href="#1、放置服务器" class="headerlink" title="1、放置服务器"></a><strong>1、放置服务器</strong></h5><blockquote><p>我们将服务器像图片一样也进行哈希，服务器的“图片名称”一般就使用固定IP地址，Hash取模也不再是服务器数量，而是2^32，Hash的方法也不局限于md5，用一个抽象的函数表示：</p></blockquote><blockquote><p>f(服务器IP地址) = Hash(服务器IP地址) % 2^32</p></blockquote><blockquote><p>于是服务器被放置到了0~2^32-1某个数字对应的位置上去：</p></blockquote><p><img src="/一致性Hash\003.jpg" alt="003"></p><blockquote><p>为什么是2^32-1呢？因为第一次提出一致性Hash的论文是1997年发表的，那时候32位机器还是主流，2^32-1是最大的Integer。而现在64位早就普及了，完全可以将这个值扩大到2^64-1。</p></blockquote><h5 id="2、放置数据"><a href="#2、放置数据" class="headerlink" title="2、放置数据"></a><strong>2、放置数据</strong></h5><blockquote><p>我们将数据也按照相同的方式放到0~2^32-1的某个数字上去：</p></blockquote><blockquote><p>f(图片名称) = Hash(图片名称) % 2^32</p></blockquote><p><img src="//zongmansheng.club/2019/04/24/yi-zhi-xing-hash/004.jpg" alt="004"></p><h5 id="3、把数据放到服务器上"><a href="#3、把数据放到服务器上" class="headerlink" title="3、把数据放到服务器上"></a><strong>3、把数据放到服务器上</strong></h5><blockquote><p>对于每个数据，从映射的位置开始，顺时针行走，放置到碰到的第一个服务器上。例如3、230将会放到0号图片服务器，232将会放到1号图片服务器，4175556547将会放到2号图片服务器：</p></blockquote><p><img src="//zongmansheng.club/2019/04/24/yi-zhi-xing-hash/005.jpg" alt="005"></p><blockquote><p>这样一致性Hash就完成了。查找数据也是先映射、再顺时针行走找到第一台服务器。</p></blockquote><h4 id="二、一致性Hash如何缓解数据失效问题"><a href="#二、一致性Hash如何缓解数据失效问题" class="headerlink" title="二、一致性Hash如何缓解数据失效问题"></a>二、一致性Hash如何缓解数据失效问题</h4><blockquote><p>假设现在1号服务器崩溃，图片232找不到1号服务器，顺时针行走的第一台服务器是2号服务器，于是232的缓存位置发生了改变，变为了2号：</p></blockquote><p><img src="//zongmansheng.club/2019/04/24/yi-zhi-xing-hash/006.jpg" alt="006"></p><blockquote><p>而对于其他图片来说，缓存位置并没有发生变化，影响的数据量从（N-1）/ N 降为了 M，其中M是0号图片服务器到1号图片服务器之间的图片数量。需要重新获取的缓存数据量降低了，雪崩问题自然也就能够得到缓解。</p></blockquote><h4 id="三、Hash环偏斜和虚拟节点"><a href="#三、Hash环偏斜和虚拟节点" class="headerlink" title="三、Hash环偏斜和虚拟节点"></a>三、Hash环偏斜和虚拟节点</h4><blockquote><p>前面讨论得太理想了，实际的服务器分布和数据分布很可能是这样的：</p></blockquote><p><img src="//zongmansheng.club/2019/04/24/yi-zhi-xing-hash/007.jpg" alt="007"></p><blockquote><p>0、1、2三台服务器并没有均匀分布在环上，大量的图片数据都被放到了0号服务器上，而很少数据放到1、2号等其他图片服务器上，这种情况称之为Hash环偏斜。如果存放的是缓存则0号服务器崩溃就会引起缓存雪崩，如果存放的是数据则0号服务器就可能单点故障。</p></blockquote><blockquote><p>很自然可以想到，增加多台服务器就好了嘛。我们在Hash环上生成0、1、2三台服务器的虚拟节点：</p></blockquote><p><img src="//zongmansheng.club/2019/04/24/yi-zhi-xing-hash/008.jpg" alt="008"></p><blockquote><p>具体的做法是，在服务器IP后面增加编号，每一台服务器产生多个Hash值，就能放置在0~2^32-1的多个位置上了。这样一来，顺时针行走能找到不同的服务器概率将会大大提高，避免了偏斜问题。虚拟的服务器节点数越多，偏斜出现的概率就越低。通常都需要设置32或以上的虚拟节点数目，我见过甚至有设置500的。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> Hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三次握手和四次挥手</title>
      <link href="/2019/04/20/san-ci-wo-shou-he-si-ci-hui-shou/"/>
      <url>/2019/04/20/san-ci-wo-shou-he-si-ci-hui-shou/</url>
      
        <content type="html"><![CDATA[<h1 id="三次握手和四次挥手"><a href="#三次握手和四次挥手" class="headerlink" title="三次握手和四次挥手"></a>三次握手和四次挥手</h1><h4 id="常用的熟知端口号"><a href="#常用的熟知端口号" class="headerlink" title="常用的熟知端口号"></a>常用的熟知端口号</h4><p><img src="//zongmansheng.club/2019/04/20/san-ci-wo-shou-he-si-ci-hui-shou/004.jpg" alt="004"></p><h4 id="TCP的概述"><a href="#TCP的概述" class="headerlink" title="TCP的概述"></a>TCP的概述</h4><pre><code>TCP把连接作为最基本的对象，每一条TCP连接都有两个端点，这种断点我们叫作套接字（socket），它的定义为端口号拼接到IP地址即构成了套接字，例如，若IP地址为192.3.4.16 而端口号为80，那么得到的套接字为192.3.4.16:80。</code></pre><h4 id="TCP报文首部"><a href="#TCP报文首部" class="headerlink" title="TCP报文首部"></a>TCP报文首部</h4><pre><code>1、源端口和目的端口，各占2个字节，分别写入源端口和目的端口；2、序号，占4个字节，TCP连接中传送的字节流中的每个字节都按顺序编号。例如，一段报文的序号字段值是 301 ，而携带的数据共有100字段，显然下一个报文段（如果还有的话）的数据序号应该从401开始；3、确认号，占4个字节，是期望收到对方下一个报文的第一个数据字节的序号。例如，B收到了A发送过来的报文，其序列号字段是501，而数据长度是200字节，这表明B正确的收到了A发送的到序号700为止的数据。因此，B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701；4、数据偏移，占4位，它指出TCP报文的数据距离TCP报文段的起始处有多远；5、保留，占6位，保留今后使用，但目前应都位0；6、紧急URG，当URG=1，表明紧急指针字段有效。告诉系统此报文段中有紧急数据；7、确认ACK，仅当ACK=1时，确认号字段才有效。TCP规定，在连接建立后所有报文的传输都必须把ACK置1；8、推送PSH，当两个应用进程进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应，这时候就将PSH=1；9、复位RST，当RST=1，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立连接；10、同步SYN，在连接建立时用来同步序号。当SYN=1，ACK=0，表明是连接请求报文，若同意连接，则响应报文中应该使SYN=1，ACK=1；11、终止FIN，用来释放连接。当FIN=1，表明此报文的发送方的数据已经发送完毕，并且要求释放；12、窗口，占2字节，指的是通知接收方，发送本报文你需要有多大的空间来接受；13、检验和，占2字节，校验首部和数据这两部分；14、紧急指针，占2字节，指出本报文段中的紧急数据的字节数；15、选项，长度可变，定义一些其他的可选的参数。</code></pre><pre><code>为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。漫画图解：图片来源：《图解HTTP》</code></pre><p><img src="//zongmansheng.club/2019/04/20/san-ci-wo-shou-he-si-ci-hui-shou/001.jpg" alt="001"></p><p>简单示意图：</p><p><img src="//zongmansheng.club/2019/04/20/san-ci-wo-shou-he-si-ci-hui-shou/002.jpg" alt="002"></p><p>动图：</p><p><img src="//zongmansheng.club/2019/04/20/san-ci-wo-shou-he-si-ci-hui-shou/005.gif" alt="005"></p><pre><code>- 客户端–发送带有 SYN 标志的数据包–一次握手–服务端- 服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端- 客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端</code></pre><pre><code>最开始的时候客户端和服务器都是处于CLOSED状态。主动打开连接的为客户端，被动打开连接的是服务器</code></pre><pre><code>1、TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态；2、TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。3、TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。4、TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。5、当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。</code></pre><p><img src="//zongmansheng.club/2019/04/20/san-ci-wo-shou-he-si-ci-hui-shou/006.png" alt="006"></p><h4 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h4><pre><code>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。第一次握手：Client 什么都不能确认；Server 确认了对方发送正常第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己接收正常，对方发送正常第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送接收正常所以三次握手就能确认双发收发功能都正常，缺一不可。</code></pre><h4 id="为什么要传回-SYN"><a href="#为什么要传回-SYN" class="headerlink" title="为什么要传回 SYN"></a>为什么要传回 SYN</h4><pre><code>接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。SYN 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement[汉译：确认字符 ,在数据通信传输中，接收站发给发送站的一种传输控制字符。它表示确认发来的数据已经接受无误。 ]）消息响应。这样在客户机和服务器之间才能建立起可靠的TCP连接，数据才可以在客户机和服务器之间传递。</code></pre><h4 id="传了-SYN-为啥还要传-ACK"><a href="#传了-SYN-为啥还要传-ACK" class="headerlink" title="传了 SYN,为啥还要传 ACK"></a>传了 SYN,为啥还要传 ACK</h4><pre><code>双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证。</code></pre><p><img src="//zongmansheng.club/2019/04/20/san-ci-wo-shou-he-si-ci-hui-shou/003.jpg" alt="003"></p><pre><code>断开一个 TCP 连接则需要“四次挥手”：- 客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送- 服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号- 服务器-关闭与客户端的连接，发送一个FIN给客户端- 客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1</code></pre><h4 id="TCP连接的释放（四次挥手）"><a href="#TCP连接的释放（四次挥手）" class="headerlink" title="TCP连接的释放（四次挥手）"></a>TCP连接的释放（四次挥手）</h4><p><img src="//zongmansheng.club/2019/04/20/san-ci-wo-shou-he-si-ci-hui-shou/007.gif" alt="007"></p><pre><code>数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于ESTABLISHED状态，然后客户端主动关闭，服务器被动关闭。</code></pre><pre><code>1、客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。2、服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。3、客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。4、服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。5、客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗ *∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。6、服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</code></pre><p><img src="//zongmansheng.club/2019/04/20/san-ci-wo-shou-he-si-ci-hui-shou/008.png" alt="008"></p><h4 id="为什么客户端最后还要等待2MSL？"><a href="#为什么客户端最后还要等待2MSL？" class="headerlink" title="为什么客户端最后还要等待2MSL？"></a>为什么客户端最后还要等待2MSL？</h4><pre><code>MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</code></pre><h4 id="为什么建立连接是三次握手，关闭连接确是四次挥手呢？"><a href="#为什么建立连接是三次握手，关闭连接确是四次挥手呢？" class="headerlink" title="为什么建立连接是三次握手，关闭连接确是四次挥手呢？"></a>为什么建立连接是三次握手，关闭连接确是四次挥手呢？</h4><pre><code>建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。</code></pre><h4 id="为什么要四次挥手"><a href="#为什么要四次挥手" class="headerlink" title="为什么要四次挥手"></a>为什么要四次挥手</h4><pre><code>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。</code></pre><h4 id="如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办？</h4><pre><code>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型模式</title>
      <link href="/2019/04/19/yuan-xing-mo-shi/"/>
      <url>/2019/04/19/yuan-xing-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><h4 id="一-原型模式介绍"><a href="#一-原型模式介绍" class="headerlink" title="一 原型模式介绍"></a>一 原型模式介绍</h4><pre><code>在面向对象系统中，使用原型模式来复制一个对象自身，从而克隆出多个与原型对象一模一样的对象。另外在软件系统中，有些对象的创建过程较为复杂，而且有时候需要频繁创建，原型模式通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的办法创建出更多同类型的对象，这就是原型模式的意图所在。</code></pre><p><img src="//zongmansheng.club/2019/04/19/yuan-xing-mo-shi/001.jpg" alt="001"></p><h5 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h5><p>GOF给出的原型模式定义如下：</p><pre class=" language-java"><code class="language-java">Specify the kind of objects to create using a prototypical instance<span class="token punctuation">,</span> and create <span class="token keyword">new</span> <span class="token class-name">objects</span> by copying <span class="token keyword">this</span> prototype<span class="token punctuation">.</span> （使用原型实例指定将要创建的对象类型，通过复制这个实例创建新的对象。）</code></pre><h5 id="1-2-原型模式适用场景"><a href="#1-2-原型模式适用场景" class="headerlink" title="1.2 原型模式适用场景"></a>1.2 原型模式适用场景</h5><pre><code>我们现在一般会使用new关键字指定类名生成类的实例（PS：我们以前使用java.lang.Cloneable的一个很大原因是使用new创建对象的速度相对来说会慢一些，随着JVM性能的提升，new的速度和Object的clone（）方法的速度差不多了。）。使用new关键字创建类的时候必须指定类名，但是在开发过程中也会有“在不指定类名的前提下生成实例”的需求。例如，在下面这些情况下，就需要根据现有的实例来生成新的实例。1) 对象种类繁多，无法将他们整合到一个类的时候；2) 难以根据类生成实例时；3) 想解耦框架与生成的实例时。如果想要让生成实例的框架不再依赖于具体的类，这时，不能指定类名来生成实例，而要事先“注册”一个“原型”实例，然后通过复制该实例来生成新的实例。</code></pre><h5 id="1-3-模式分析"><a href="#1-3-模式分析" class="headerlink" title="1.3 模式分析"></a>1.3 模式分析</h5><pre><code>在原型模式结构中定义了一个抽象原型类，所有的Java类都继承自java.lang.Object，而Object类提供一个clone()方法，可以将一个Java对象复制一份。因此在Java中可以直接使用Object提供的clone()方法来实现对象的克隆，Java语言中的原型模式实现很简单。能够实现克隆的Java类必须实现一个标识接口Cloneable，表示这个Java类支持复制。如果一个类没有实现这个接口但是调用了clone()方法，Java编译器将抛出一个CloneNotSupportedException异常。注意： `java.lang.Cloneable 只是起到告诉程序可以调用clone方法的作用，它本身并没有定义任何方法。在使用原型模式克隆对象时，根据其成员对象是否也克隆，原型模式可以分为两种形式：深克隆 和 浅克隆 。</code></pre><h5 id="1-4-模式优缺点分析"><a href="#1-4-模式优缺点分析" class="headerlink" title="1.4 模式优缺点分析"></a>1.4 模式优缺点分析</h5><p>原型模式的优点：</p><pre><code>1、当创建新的对象实例较为复杂时，使用原型模式可以简化对象的创建过程，通过一个已有实例可以提高新实例的创建效率。2、可以动态增加或减少产品类。3、原型模式提供了简化的创建结构。4、可以使用深克隆的方式保存对象的状态。</code></pre><p>原型模式的缺点：</p><pre><code>1、需要为每一个类配备一个克隆方法，而且这个克隆方法需要对类的功能进行通盘考虑，这对全新的类来说不是很难，但对已有的类进行改造时，不一定是件容易的事，必须修改其源代码，违背了“开闭原则”。2、在实现深克隆时需要编写较为复杂的代码。</code></pre><h4 id="二-示例程序"><a href="#二-示例程序" class="headerlink" title="二 示例程序"></a>二 示例程序</h4><p>下面示例程序的作用是将字符串放入方框中显示出来或者是加了下划线显示出来。</p><p>类和接口一览表：</p><p><img src="//zongmansheng.club/2019/04/19/yuan-xing-mo-shi/002.jpg" alt="002"></p><p>示例程序类图：</p><p><img src="//zongmansheng.club/2019/04/19/yuan-xing-mo-shi/003.jpg" alt="003"></p><h5 id="2-1-Product接口-（Prototype）"><a href="#2-1-Product接口-（Prototype）" class="headerlink" title="2.1 Product接口 （Prototype）"></a>2.1 Product接口 （Prototype）</h5><pre><code>    Product接口是复制功能接口，该接口继承了java.lang.Cloneable(只有实现了该接口的类的实例才可以调用clone()方法复制实例,否则会抛出异常).     另外需要注意：`java.lang.Cloneable 只是起到告诉程序可以调用clone方法的作用，它本身并没有定义任何方法。</code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @author ZongMan */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Product</span> <span class="token keyword">extends</span> <span class="token class-name">Cloneable</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//use方法是用于“使用”的方法，具体怎么“使用”，则被交给子类去实现</span>    <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">use</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//creatClone方法是用于复制实例的方法</span>    <span class="token keyword">abstract</span> Product <span class="token function">creatClone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h5 id="2-2-Manager类（Client）"><a href="#2-2-Manager类（Client）" class="headerlink" title="2.2 Manager类（Client）"></a>2.2 Manager类（Client）</h5><pre><code>Manager类使用Product接口来复制实例。Product接口以及Manager类的代码完全没有出现在MessageBox类和UnderlinePen类的名字，因此这意味着我们可以独立地修改Product接口以及Manager类，不受MessageBox类和UnderlinePen类的影响。这是非常重要的，因为 一旦在类中使用到了别的类名，就意味着该类与其他类紧密的地耦合在了一起 。在Manager类中，并没有写明具体的类名， 仅仅使用了Product这个接口名。也就是说，Product接口成为了连接Manager类与其他具体类之间的桥梁。</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>HashMap<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author ZongMan */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Manager</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//保存实例的“名字”和“实例”之间的对应关系</span>    <span class="token keyword">private</span> HashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Product<span class="token operator">></span> showcase <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*    register方法将接收到的一组“名字”和“Product接口”注册到showcase中。    这里Product是实现Product接口的实例，具体还未确定     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">register</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> Product product<span class="token punctuation">)</span> <span class="token punctuation">{</span>        showcase<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> product<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> Product <span class="token function">create</span><span class="token punctuation">(</span>String productname<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Product p <span class="token operator">=</span> showcase<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>productname<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> p<span class="token punctuation">.</span><span class="token function">creatClone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="2-3-MessageBox类（ConcreteProtorype）"><a href="#2-3-MessageBox类（ConcreteProtorype）" class="headerlink" title="2.3 MessageBox类（ConcreteProtorype）"></a>2.3 MessageBox类（ConcreteProtorype）</h5><p>装饰方框样式的具体原型，实现了Product接口，实现复制现有实例并生成新实例的方法。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @author ZongMan */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MessageBox</span> <span class="token keyword">implements</span> <span class="token class-name">Product</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//保存的是装饰方框使用的字符样式</span>    <span class="token keyword">private</span> <span class="token keyword">char</span> decochar<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">MessageBox</span><span class="token punctuation">(</span><span class="token keyword">char</span> decochar<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>decochar <span class="token operator">=</span> decochar<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">use</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> length <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"--------->"</span> <span class="token operator">+</span> decochar<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>decochar <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> str <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> decochar<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>decochar<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 该方法用于复制自己     * @return     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Product <span class="token function">creatClone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Product p <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            p <span class="token operator">=</span> <span class="token punctuation">(</span>Product<span class="token punctuation">)</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">CloneNotSupportedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> p<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>只有类自己（或是它的子类）能够调用Java语言中定义的clone方法。当其他类要求复制实例时，必须先调用createClone这样的方法，然后在该方法内部在调用clone方法。</code></pre><h5 id="2-4-UnderlinePen类（ConcreteProtorype）"><a href="#2-4-UnderlinePen类（ConcreteProtorype）" class="headerlink" title="2.4 UnderlinePen类（ConcreteProtorype）"></a>2.4 UnderlinePen类（ConcreteProtorype）</h5><pre><code>    下划线样式的具体原型，实现了Product接口，用于实现复制现有实例并生成新实例的方法。UnderlinePen类的实现几乎和MessageBox类一样，不同的可能只是use方法的实现。</code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @author ZongMan */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UnderlinePen</span> <span class="token keyword">implements</span> <span class="token class-name">Product</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">char</span> ulchar<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">UnderlinePen</span><span class="token punctuation">(</span><span class="token keyword">char</span> ulchar<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>ulchar <span class="token operator">=</span> ulchar<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">use</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> length <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"\""</span> <span class="token operator">+</span> str <span class="token operator">+</span> <span class="token string">"\""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>ulchar<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Product <span class="token function">creatClone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Product p <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            p <span class="token operator">=</span> <span class="token punctuation">(</span>Product<span class="token punctuation">)</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">CloneNotSupportedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> p<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span></code></pre><h5 id="2-5-Main类"><a href="#2-5-Main类" class="headerlink" title="2.5 Main类"></a>2.5 Main类</h5><pre><code>Main类首先生成Manager实例。接着，在Manager实例中通过`register方法注册了UnderlinePen类的实例（带名字）和MessageBox类的实例（带名字）。</code></pre><pre><code>package clone;/** * @author ZongMan */public class Main {    public static void main(String[] args) {        Manager manager = new Manager();        UnderlinePen underlinePen=new UnderlinePen(&#39;~&#39;);        MessageBox mbox=new MessageBox(&#39;*&#39;);        MessageBox sbox=new MessageBox(&#39;#&#39;);        manager.register(&quot;Strong message&quot;, underlinePen);        manager.register(&quot;Waring Box&quot;, mbox);        manager.register(&quot;Slash Box&quot;, sbox);        Product p1=manager.create(&quot;Strong message&quot;);        p1.use(&quot;hello world&quot;);        Product p2=manager.create(&quot;Waring Box&quot;);        p2.use(&quot;hello world&quot;);        Product p3=manager.create(&quot;Slash Box&quot;);        p3.use(&quot;hello world&quot;);    }}</code></pre><p>运行结果：</p><p><img src="//zongmansheng.club/2019/04/19/yuan-xing-mo-shi/004.jpg" alt="004"></p><h4 id="三-原型模式的角色分析"><a href="#三-原型模式的角色分析" class="headerlink" title="三 原型模式的角色分析"></a>三 原型模式的角色分析</h4><h5 id="3-1-Prototype（抽象原型类）"><a href="#3-1-Prototype（抽象原型类）" class="headerlink" title="3.1 Prototype（抽象原型类）"></a>3.1 Prototype（抽象原型类）</h5><pre><code>Product角色负责定义用于复制现有实例来生成新实例的方法。在示例程序中的Product接口就是该角色。</code></pre><h5 id="3-2-ConcretePrototype（具体原型类）"><a href="#3-2-ConcretePrototype（具体原型类）" class="headerlink" title="3.2 ConcretePrototype（具体原型类）"></a>3.2 ConcretePrototype（具体原型类）</h5><pre><code>ConcretePrototype角色负责实现复制现有实例并生成新实例的方法。在示例程序中，MessageBox和UnderlinePen都是该角色。</code></pre><h5 id="3-3-Client（客户类-使用者）"><a href="#3-3-Client（客户类-使用者）" class="headerlink" title="3.3 Client（客户类/使用者）"></a>3.3 Client（客户类/使用者）</h5><pre><code>Client角色负责使用复制实例的方法生成新的实例。在示例程序中，Manager类扮演的就是该角色。</code></pre><p>Prototype模式的类图：</p><p><img src="//zongmansheng.club/2019/04/19/yuan-xing-mo-shi/005.jpg" alt="005"></p><h4 id="四-原型模式的实际应用案例"><a href="#四-原型模式的实际应用案例" class="headerlink" title="四 原型模式的实际应用案例"></a>四 原型模式的实际应用案例</h4><pre><code>(1) 原型模式应用于很多软件中，如果每次创建一个对象要花大量时间，原型模式是最好的解决方案。很多软件提供的复制(Ctrl + C)和粘贴(Ctrl + V)操作就是原型模式的应用，复制得到的对象与原型对象是两个类型相同但内存地址不同的对象，通过原型模式可以大大提高对象的创建效率。(2) 在Struts2中为了保证线程的安全性，Action对象的创建使用了原型模式，访问一个已经存在的`Action对象时将通过克隆的方式创建出一个新的对象，从而保证其中定义的变量无须进行加锁实现同步，每一个Action中都有自己的成员变量，避免Struts1因使用单例模式而导致的并发和同步问题。(3) 在Spring中，用户也可以采用原型模式来创建新的bean实例，从而实现每次获取的是通过克隆生成的新实例，对其进行修改时对原有实例对象不造成任何影响。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原型，复制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode</title>
      <link href="/2019/04/18/leetcode/"/>
      <url>/2019/04/18/leetcode/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode上的算法题"><a href="#LeetCode上的算法题" class="headerlink" title="LeetCode上的算法题"></a>LeetCode上的算法题</h1><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><pre><code>/** * @author ZongMan * @version 1.0 * @date 2019/4/18 0018 8:31 * 在给定的整数数组中，总有一个最大的元素。查找数组中的最大元素是否至少是数组中每个其他数字的两倍。 * 如果是，则返回最大元素的索引，否则返回-1。例如： * 输入：nums = [3,6,1,0] * 输出：1 * 说明：6是最大的整数，对于数组x中的每个其他数字，6是x的两倍多。 值6的索引是1，所以我们返回1。 * 输入：nums = [1,2,3,4] * 输出：-1 * 说明：4至少不是3的值的两倍，所以我们返回-1。 */</code></pre><h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo01</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">dominantIndex</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"----------------------------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">dominantIndex2</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 题目的要求是返回最大数的索引，所以需要先将最大数找出来，并记录下其索引。     * 然后在次遍历数组中的元素，将最大数之外的其他数都乘以2和最大数比较(在此处我是使用位移处理)，     * 如果大于就返回-1，如果其他元素都满足条件，就返回之前记录的最大数的索引。     *     * @param nums 数组     * @return 相对应的结果     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">dominantIndex</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> max<span class="token punctuation">)</span> <span class="token punctuation">{</span>                max <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                index <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> max <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span> <span class="token operator">></span> max<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> index<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 我们还可以只使用一次循环来解决。并非需要使用每一个元素乘以2后再去和最大元素比较，     * 只需要用第二大的数去比较就行，如果第二大的数不能满足条件，就可以直接做判断了。     * 比如[2,3,4]，3乘以2等于6大于4，不符合题目要求，就不需要比较2了。     * @param nums 数组     * @return 对应结果     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">dominantIndex2</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> second <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> max<span class="token punctuation">)</span> <span class="token punctuation">{</span>                second <span class="token operator">=</span> max<span class="token punctuation">;</span>                max <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                index <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> second<span class="token punctuation">)</span> <span class="token punctuation">{</span>                second <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> second <span class="token operator">&lt;&lt;</span> <span class="token number">1</span> <span class="token operator">&lt;=</span> max <span class="token operator">?</span> index <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 每日算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DNS劫持投毒解析</title>
      <link href="/2019/04/17/dns-jie-chi-tou-du-jie-xi/"/>
      <url>/2019/04/17/dns-jie-chi-tou-du-jie-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="DNS劫持投毒解析"><a href="#DNS劫持投毒解析" class="headerlink" title="DNS劫持投毒解析"></a>DNS劫持投毒解析</h1><p>本文以第一人称来讲述：</p><h4 id="一、什么是URL和IP"><a href="#一、什么是URL和IP" class="headerlink" title="一、什么是URL和IP"></a>一、什么是URL和IP</h4><pre><code>    我的冒险，要从一张“羊皮卷”说起。那天，浏览器大叔神秘兮兮招呼我过去，告诉我CPU下达了一个命令：派遣使者访问外邦。而我是大叔最得力的门生，也是这类任务最合适的人选。大叔为我准备了一张羊皮卷，上面记录了我这次冒险需要用到的必要信息。当仁不让地，我接过了它，即刻启程。我缓缓展开羊皮卷，第一行赫然写着：URL: https://mail.google.com    什么是“URL”？我在脑中快速回忆着，对了！URL即 Uniform Resource Locator的缩写，翻译成中文便是“统一资源定位符”。因为互联网世界存在着不计其数的资源，每一处资源都需要有一个标记来定位它，正如人类城市中的门牌号。    有人可能会认为，既然有了门牌号，找到指定地点不是轻而易举吗？朋友们，我也希望如此，但现实往往没有这么简单。    即使有了URL，恕我愚笨，我还是无法直接理解它所指向的目的地。因为这是人类的语言，我无法翻译解读。（其实是人类太笨了，记不住IP地址，需要用方便记忆的域名来代替）    对我来说，IP地址才是唯一的坐标。什么是IP？IP即Internet Protocol的缩写，中文译为“互联网协议”，一个如雷贯耳的名字，互联网的基石之一，一切依赖互联网通信的软件都得遵循这个协议。那么，如何才能将域名转换为IP地址呢？    浏览器大叔在平日工作之余，十分细心，他将用户访问过的站点整理了一份“域名-IP对应清单”。假如是一个已被记录的IP地址，那么他会直接告诉我，我可以立即向着目标IP地址出发，这就是浏览器缓存的作用。    假如用户输入的URL不在浏览器的记录范围之内，那么操作系统会查找一个名为“hosts”的文件。它是一份文本，记录了域名和IP地址的映射。如果“hosts”能够告诉我目标IP地址，那也能节省我不少工夫。这就是系统缓存。此外，还有路由器缓存，相信不用我多介绍了，即保存在路由器中的域名-IP映射。    这些缓存都能有效帮助我以最快的速度找到相应的IP地址。但是，互联网世界日新月异，各种资源层出不穷。在很多情况下，用户会想要访问一个全新的、任何缓存都没有记录过的域名。    为此，人类专门设计了DNS。在这次任务中，我的第一站，就是赶往DNS。为了更短的响应时间与更好的用户体验，我快马加鞭。</code></pre><h4 id="二、关于DNS劫持的记忆"><a href="#二、关于DNS劫持的记忆" class="headerlink" title="二、关于DNS劫持的记忆"></a>二、关于DNS劫持的记忆</h4><h5 id="DNS是什么？"><a href="#DNS是什么？" class="headerlink" title="DNS是什么？"></a>DNS是什么？</h5><pre><code>全称Domain Name System，是一个将域名和IP相互映射的分布式数据库。    全球有很多家DNS服务中心，假如你关心过你的计算机，你会发现，在你的网卡上，有着一项“DNS服务器”的配置项，它设定了我将要抵达的目的地。</code></pre><p><img src="//zongmansheng.club/2019/04/17/dns-jie-chi-tou-du-jie-xi/001.png" alt="001"></p><pre><code>一转眼的工夫，我来到了114.114.114.114DNS中心。    这个地方我来过很多次，表面上风平浪静，实则暗流涌动。我小心翼翼地来到办事大厅，不禁想起了我第一次被DNS劫持的经历。那天，我来到办事窗口，柜员热情地接待了我。    “先生，请问你想要查询哪个地址？”当时我还是一位新晋的网络请求，涉世尚浅，不知晓一些不可说的条例，于是毫不避讳地回答：“你好，我要去大名鼎鼎的mail.google.com！”    柜员的表情一下子凝固了，他上下打量了我一番，然后硬挤出一丝微笑，“好的先生，请稍等。”说完，他便向旁边的同事使了个眼色。我正纳闷呢，突然两边窜出身材魁梧的警卫，架着我强行往一处拖拽。我这才意识到大事不妙，“这是怎么回事？！你们凭什么劫持我？”我发疯了一般嘶吼着。    “你好，根据本ISP（电信运营商）颁布的条例，世界上不存在你所说的站点，现怀疑你是一个不合规的网络请求，将把你转发至baidu.com的IP地址。你有权保持沉默！”警卫冷漠地望着我。我知道，现在无论如何解释、挣扎都没有用了，只怪自己太年轻。无奈，我只好乖乖就范。</code></pre><p><img src="//zongmansheng.club/2019/04/17/dns-jie-chi-tou-du-jie-xi/002.png" alt="002"></p><pre><code>    还好当时正在使用计算机的用户有一些网络知识，当他发现自己输入的是google，返回的是baidu的页面时，并没有怪罪于我，大概是他心中已经猜到了原因。于是他将网卡的DNS配置为：8.8.8.8，这是一个国际上“不存在”的公司提供的DNS服务中心。仅仅这样就能畅通无阻地访问互联网了吗？经历了被DNS劫持，我依然不敢放松。</code></pre><h4 id="三、我遇到过DNS投毒"><a href="#三、我遇到过DNS投毒" class="headerlink" title="三、我遇到过DNS投毒"></a>三、我遇到过DNS投毒</h4><pre><code>还未休息片刻，浏览器大叔再一次地给我分配了任务：继续尝试请求mail.google.com的资源。    人类出国要坐飞机，要办护照。我们网络请求也是这样，全国只有在几个主要城市才会部署国际出口，所有访问境外资源的网络请求，都得经过这儿接受检查。与上次不同，因为这次我要访问的DNS服务器位于海外，所以我首先来到了大中华局域网的上海国际出口。我一路奔波到上海真的是又累又乏，正当我火急火燎地准备过安检，通道附近有一位穿着制服的小伙迎了上来。    还没等我开口，他热情地迎了上来：“远道而来的朋友，一定是十分疲惫了吧？天气这么热，先喝杯水吧！”我悄悄地打量着他，看他的打扮应该是一位服务人员。    “国际出口就是不一样啊，服务真到位！”由于确实是太渴了，我放松了警惕。“啊，真清凉，谢……”我一边感叹着，一边接过了小伙递给我的水。可当我第二个“谢”字还没说出口，立即感到一阵头晕目眩。    “不好！遇上了黑客，这是DNS投毒！”我的视线渐渐模糊，小伙的微笑也渐渐似乎变成了狞笑。我尽力搜索着脑海中和这一切有关的知识，想要知道寻求的办法。</code></pre><p><img src="//zongmansheng.club/2019/04/17/dns-jie-chi-tou-du-jie-xi/003.png" alt="003"></p><pre><code> DNS投毒，英文叫DNS cache poisoning，也叫做DNS污染。从客户端向DNS服务器发出查询IP的请求，到响应返回到客户端的这段时间里，如果有黑客或者其他一些不可说的设施伪造返回了一个错误的DNS应答，那么用户将不能访问到真正的资源。想到这里，我已经明显感觉难以控制自己的身体了，眼前一黑，就什么都不知道了。</code></pre><h4 id="四、DNS正常解析"><a href="#四、DNS正常解析" class="headerlink" title="四、DNS正常解析"></a>四、DNS正常解析</h4><pre><code>以前发生过的险情历历在目，如今想起来，我依旧心有余悸。这次，为了确保万无一失，我打起了十二分精神。这次，我已经顺利来到8.8.8.8 DNS服务中心。“你好亲，有什么可以帮到您的嘛”办事窗口内传来了软妹子的声音。“我想查询域名mail.google.com的IP地址。”我试探性地问，依然不敢松懈。“好的呢亲，这边通过树状检索，在顶级域名com下，查询到google目录，在google目录下查询到mail,IP地址是xx.xxx.xx.xx呢。”</code></pre><p><img src="//zongmansheng.club/2019/04/17/dns-jie-chi-tou-du-jie-xi/004.png" alt="004"></p><pre><code>    我松了口气，谢天谢地，终于拿到了结果。可我知道作为一次完整的网络请求，这刚刚开始，这才是万里长征第一步，我得赶紧将这个解析结果带回去，等会还得马不停蹄往返三次建立连接。</code></pre><p><img src="//zongmansheng.club/2019/04/17/dns-jie-chi-tou-du-jie-xi/005.png" alt="005"></p>]]></content>
      
      
      <categories>
          
          <category> 进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DNS，劫持，投毒，解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ConcurrentHashMap</title>
      <link href="/2019/04/16/concurrenthashmap/"/>
      <url>/2019/04/16/concurrenthashmap/</url>
      
        <content type="html"><![CDATA[<h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><pre><code>JDK8 对ConcurrentHashMap 进行了脱胎换骨式的改造，使用了大量的lock-free 技术来减轻因锁的竞争而对性能造成的影响。ConcurrentHashMap 被Segment 分成了很多小区，Segment 就相当于小区保安，HashEntry 列表相当于小区业主，小区保安通过加锁的方式，保证每个Segment 内都不发生冲突。</code></pre><p><img src="//zongmansheng.club/2019/04/16/concurrenthashmap/001.png" alt="001"></p><pre><code>通过分析Hashtable就知道，synchronized是针对整张Hash表的，即每次锁住整张表让线程独占，ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术。它使用了多个锁来控制对hash表的不同部分进行的修改。ConcurrentHashMap内部使用段(Segment)来表示这些不同的部分，每个段其实就是一个小的hash table，它们有自己的锁。只要多个修改操作发生在不同的段上，它们就可以并发进行。有些方法需要跨段，比如size()和containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁。这里“按顺序”是很重要的，否则极有可能出现死锁，在ConcurrentHashMap内部，段数组是final的，并且其成员变量实际上也是final的，但是，仅仅是将数组声明为final的并不保证数组成员也是final的，这需要实现上的保证。这可以确保不会出现死锁，因为获得锁的顺序是固定的。</code></pre><pre><code>数据存储结构分为2种：            链表            红黑树</code></pre><pre><code>当某个槽内的元素个数增加到超过8个，且table的容量大于或者等于64时，由链表转为红黑树；当某个槽内的元素个数减少到6个时，由红黑树重新转回链表。</code></pre><pre><code>table 扩容：当table需要进行扩容时，依次遍历当前table 中的每一个槽位，如果不为null，则需要把其中所有的元素根据 hash 值放入扩容后的 nextTable 中，而元table的槽内会放置一个 ForwardingNode 节点。此节点会把 find() 请求转发到扩容后的 nextTable 上。而执行 put() 方法的线程，如果碰到此节点，也会协助进行迁移。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 基础底层 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ConcurrentHashMap </tag>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sort排序原理</title>
      <link href="/2019/04/15/sort-pai-xu-yuan-li/"/>
      <url>/2019/04/15/sort-pai-xu-yuan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="java-sort排序原理"><a href="#java-sort排序原理" class="headerlink" title="java sort排序原理"></a>java sort排序原理</h1><pre><code>    事实上Collections.sort方法底层就是调用的Arrays.sort方法，而Arrays.sort使用了两种排序方法，快速排序和优化的归并排序。快速排序主要是对那些基本类型数据（int,short,long等）排序， 而归并排序用于对Object类型进行排序。    使用不同类型的排序算法主要是由于快速排序是不稳定的，而归并排序是稳定的。这里的稳定是指比较相等的数据在排序之后仍然按照排序之前的前后顺序排列。对于基本数据类型，稳定性没有意义，而对于Object类型，稳定性是比较重要的，因为对象相等的判断可能只是判断关键属性，最好保持相等对象的非关键属性的顺序与排序前一致；另外一个原因是由于归并排序相对而言比较次数比快速排序少，移动（对象引用的移动）次数比快速排序多，而对于对象来说，比较一般比移动耗时。    此外，对大数组排序。快速排序的sort()采用递归实现，数组规模太大时会发生堆栈溢出，而归并排序sort()采用非递归实现，不存在此问题。</code></pre><pre><code>总结：首先先判断需要排序的数据量是否大于60。小于60：使用插入排序，插入排序是稳定的大于60的数据量会根据数据类型选择排序方式：基本类型：使用快速排序。因为基本类型。1、2都是指向同一个常量池不需要考虑稳定性。Object类型：使用归并排序。因为归并排序具有稳定性。注意：不管是快速排序还是归并排序。在二分的时候小于60的数据量依旧会使用插入排序</code></pre>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring中AOP的两种代理</title>
      <link href="/2019/04/14/spring-zhong-aop-de-liang-chong-dai-li/"/>
      <url>/2019/04/14/spring-zhong-aop-de-liang-chong-dai-li/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring中AOP的两种代理"><a href="#Spring中AOP的两种代理" class="headerlink" title="Spring中AOP的两种代理"></a>Spring中AOP的两种代理</h1><h2 id="方式动态代理和CGLIB详解"><a href="#方式动态代理和CGLIB详解" class="headerlink" title="方式动态代理和CGLIB详解"></a>方式动态代理和CGLIB详解</h2><h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><h5 id="1、什么是代理"><a href="#1、什么是代理" class="headerlink" title="1、什么是代理"></a>1、什么是代理</h5><pre><code>    代理的概念容易理解，比如：微商，简单来说微商就是替厂家卖商品。当我们从微商(代理)那里买东西时通常不知道背后的商家究竟是谁，也就是说，委托者对我们来说是不可见的。作为微商，有其自己的目标客户，这也相当于为厂家做了一次过滤。把微商和厂家进一步抽象，微商可以抽象为代理类，厂家可抽象为委托类(被代理类)。通过微商和厂家特点可知，通过使用代理，通常有两个优点：其一:可以隐藏委托类的实现;其二:可以实现客户与委托类间的解耦，在不修改委托类代码的情况下能够做一些额外的处理。</code></pre><h5 id="2、静态代理"><a href="#2、静态代理" class="headerlink" title="2、静态代理"></a>2、静态代理</h5><pre><code>若代理类在程序运行前就已经存在，那么这种代理方式被成为静态代理。这种情况下的代理类通常都是我们在Java代码中定义的。 通常情况下，静态代理中的代理类和委托类会实现同一接口或是派生自相同的父类。 下面我们用Vendor类代表生产厂家，BusinessAgent类代表微商代理，来介绍下静态代理的简单实现。委托类和代理类都实现了Sell接口，Sell接口的定义如下：</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> test<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author ZongMan * @version 1.0 * @date 2019/4/14 0014 21:29 */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Sell</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">sell</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>Vendor类的定义如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> test<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author ZongMan * @version 1.0 * @date 2019/4/14 0014 22:06 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Vendor</span> <span class="token keyword">implements</span> <span class="token class-name">Sell</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sell</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"sell method"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"add method"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>BusinessAgent类的定义如下:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> test<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author ZongMan * @version 1.0 * @date 2019/4/14 0014 22:07 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BusinessAgent</span> <span class="token keyword">implements</span> <span class="token class-name">Sell</span> <span class="token punctuation">{</span>    Vendor vendor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vendor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sell</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isCollegeStudent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            vendor<span class="token punctuation">.</span><span class="token function">sell</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isCollegeStudent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>    从BusinessAgent类的定义我们可以了解到，静态代理可以通过聚合来实现，让代理类持有一个委托类的引用即可。    如果需要增加一个需求：给Vendor类增加一个过滤功能，不可以卖给学生。通过静态代理，我们无需修改Vendor类的代码就可以实现，只需在BusinessAgent类中的sell方法中添加一个判断即可。如上图可以。    这对应着我们上面提到的使用代理的第二个优点：可以实现客户与委托类间的解耦，在不修改委托类代码的情况下能够做一些额外的处理。静态代理的局限在于运行前必须编写好代理类，下面我们重点来介绍下运行时生成代理类的动态代理方式，即动态代理机制。</code></pre><h4 id="二、动态代理"><a href="#二、动态代理" class="headerlink" title="二、动态代理"></a>二、动态代理</h4><pre><code>    代理类在程序运行时创建的代理方式被成为 动态代理。 也就是说，这种情况下，代理类并不是在Java代码中定义的，而是在运行时根据我们在Java代码中的“指示”动态生成的。相比于静态代理， 动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类的函数。 这么说比较抽象，下面我们结合一个实例来介绍一下动态代理的这个优势是怎么体现的。    现在，假设我们要实现这样一个需求：在执行委托类中的方法之前输出“before”，在执行完毕后输出“after”。我们还是以上面例子中的Vendor类作为委托类，BusinessAgent类作为代理类来进行介绍。首先我们来使用静态代理来实现这一需求，相关代码如下：</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> test<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author ZongMan * @version 1.0 * @date 2019/4/14 0014 22:07 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BusinessAgent</span> <span class="token keyword">implements</span> <span class="token class-name">Sell</span> <span class="token punctuation">{</span>    Vendor vendor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vendor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sell</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"before"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isCollegeStudent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            vendor<span class="token punctuation">.</span><span class="token function">sell</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isCollegeStudent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"before"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vendor<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>    从以上代码中我们可以了解到，通过静态代理实现我们的需求需要我们在每个方法中都添加相应的逻辑，这里只存在两个方法所以工作量还不算大，假如Sell接口中包含上百个方法呢?这时候使用静态代理就会编写许多冗余代码。通过使用动态代理，我们可以做一个“统一指示”，从而对所有代理类的方法进行统一处理，而不用逐一修改每个方法。下面我们来具体介绍下如何使用动态代理方式实现我们的需求。</code></pre><h5 id="使用动态代理"><a href="#使用动态代理" class="headerlink" title="使用动态代理"></a>使用动态代理</h5><pre><code>(1)InvocationHandler接口在使用动态代理时，我们需要定义一个位于代理类与委托类之间的中介类，这个中介类被要求实现InvocationHandler接口，这个接口的定义如下：</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> test<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Method<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author ZongMan * @version 1.0 * @date 2019/4/14 0014 22:13 */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">InvocationHandler</span> <span class="token punctuation">{</span>    Object <span class="token function">invoke</span><span class="token punctuation">(</span>Object proxy<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span>Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre><code>从InvocationHandler这个名称我们就可以知道，实现了这个接口的中介类用做“调用处理器”。当我们调用代理类对象的方法时，这个“调用”会转送到invoke方法中，代理类对象作为proxy参数传入，参数method标识了我们具体调用的是代理类的哪个方法，args为这个方法的参数。这样一来，我们对代理类中的所有方法的调用都会变为对invoke的调用，这样我们可以在invoke方法中添加统一的处理逻辑(也可以根据method参数对不同的代理类方法做不同的处理)。因此我们只需在中介类的invoke方法实现中输出“before”，然后调用委托类的invoke方法，再输出“after”。下面我们来一步一步具体实现它。(2)委托类的定义动态代理方式下，要求委托类必须实现某个接口，这里我们实现的是Sell接口。委托类Vendor类的定义如下：</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> test<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author ZongMan * @version 1.0 * @date 2019/4/14 0014 22:06 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Vendor</span> <span class="token keyword">implements</span> <span class="token class-name">Sell</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sell</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"sell method"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"add method"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>(3)中介类上面我们提到过，中介类必须实现InvocationHandler接口，作为调用处理器”拦截“对代理类方法的调用。中介类的定义如下：</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> test<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Method<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author ZongMan * @version 1.0 * @date 2019/4/14 0014 22:17 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DynamicProxy</span> <span class="token keyword">implements</span> <span class="token class-name">InvocationHandler</span><span class="token punctuation">,</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>InvocationHandler <span class="token punctuation">{</span>    <span class="token keyword">private</span> Object object<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">DynamicProxy</span><span class="token punctuation">(</span>Object object<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>object <span class="token operator">=</span> object<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Object <span class="token function">invoke</span><span class="token punctuation">(</span>Object proxy<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"before"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Object result <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>object<span class="token punctuation">,</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>从以上代码中我们可以看到，中介类持有一个委托类对象引用，在invoke方法中调用了委托类对象的相应方法，通过聚合方式持有委托类对象引用，把外部对invoke的调用最终都转为对委托类对象的调用。下面我们来介绍一下如何”指示“以动态生成代理类。(4)动态生成代理类动态生成代理类的相关代码如下：</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> test<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Proxy<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author ZongMan * @version 1.0 * @date 2019/4/14 0014 22:20 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//创建中介类实例</span>        DynamicProxy inter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DynamicProxy</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Vendor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//获取代理类实例sell</span>        Sell sell <span class="token operator">=</span> <span class="token punctuation">(</span>Sell<span class="token punctuation">)</span> Proxy<span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span>Sell<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>Sell<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">,</span>inter<span class="token punctuation">)</span><span class="token punctuation">;</span>        sell<span class="token punctuation">.</span><span class="token function">sell</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sell<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>在以上代码中，我们调用Proxy类的newProxyInstance方法来获取一个代理类实例。这个代理类实现了我们指定的接口并且会把方法调用分发到指定的调用处理器。这个方法的声明如下：</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> Object <span class="token function">newProxyInstance</span><span class="token punctuation">(</span>ClassLoader loader<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> interfaces<span class="token punctuation">,</span> InvocationHandler h<span class="token punctuation">)</span> <span class="token keyword">throws</span> IllegalArgumentException</code></pre><pre><code>方法的三个参数含义分别如下：loader：定义了代理类的ClassLoder;interfaces：代理类实现的接口列表h：调用处理器，也就是我们上面定义的实现了InvocationHandler接口的类实例这里再简单的总结下：首先通过newProxyInstance方法获取代理类实例，而后我们便可以通过这个代理类实例调用代理类的方法，对代理类的方法的调用实际上都会调用中介类(调用处理器)的invoke方法，在invoke方法中我们调用委托类的相应方法，并且可以添加自己的处理逻辑。如上将上面代理、静态代理，动态代理都理解，下面讲解Spring中AOP的两种代理方式（Java动态代理和CGLIB代理）</code></pre><h5 id="1、动态代理"><a href="#1、动态代理" class="headerlink" title="1、动态代理"></a>1、动态代理</h5><pre><code>相关概念及用法上面已经讲到，其具体有如下四步骤：1、通过实现 InvocationHandler 接口创建自己的调用处理器；2、通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来创建动态代理类；3、通过反射机制获得动态代理类的构造函数，其唯一参数类型是调用处理器接口类型；4、通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入。</code></pre><h5 id="2、GCLIB代理"><a href="#2、GCLIB代理" class="headerlink" title="2、GCLIB代理"></a>2、GCLIB代理</h5><pre><code>cglib（Code Generation Library）是一个强大的,高性能,高质量的Code生成类库。它可以在运行期扩展Java类与实现Java接口。cglib封装了asm，可以在运行期动态生成新的class。cglib用于AOP，jdk中的proxy必须基于接口，cglib却没有这个限制。</code></pre><h5 id="3、原理区别："><a href="#3、原理区别：" class="headerlink" title="3、原理区别："></a>3、原理区别：</h5><pre><code>java动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。而cglib动态代理是利用asm开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。1、如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP 2、如果目标对象实现了接口，可以强制使用CGLIB实现AOP 3、如果目标对象没有实现了接口，必须采用CGLIB库，spring会自动在JDK动态代理和CGLIB之间转换Spring自己的CGLIB的实现方式,他是生成了一个被代理类的子类,你也可以在子类中增加父类没有的功能.如何强制使用CGLIB实现AOP？ * 添加CGLIB库，SPRING_HOME/cglib/*.jar * 在spring配置文件中加入&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt;4、JDK动态代理和CGLIB字节码生成的区别？ * JDK动态代理只能对实现了接口的类生成代理，而不能针对类 * CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法 因为是继承，所以该类或方法最好不要声明成final。*要将CGLIB的二进制发行包放在classpath下。5、Spring AOP里面的代理实现方式spring用代理类包裹切面，把他们织入到Spring管理的bean中。也就是说代理类伪装成目标类，它会截取对目标类中方法的调用，让调用者对目标类的调用都先变成调用伪装类，伪装类中就先执行了切面，再把调用转发给真正的目标bean。现在可以自己想一想，怎么搞出来这个伪装类，才不会被调用者发现（过JVM的检查，JAVA是强类型检查，哪里都要检查类型）。1.实现和目标类相同的接口，我也实现和你一样的接口，反正上层都是接口级别的调用，这样我就伪装成了和目标类一样的类（实现了同一接口，咱是兄弟了），也就逃过了类型检查，到java运行期的时候，利用多态的后期绑定（所以spring采用运行时），伪装类（代理类）就变成了接口的真正实现，而他里面包裹了真实的那个目标类，最后实现具体功能的还是目标类，只不过伪装类在之前干了点事情（写日志，安全检查，事物等）。2.生成子类调用，这次用子类来做为伪装类，当然这样也能逃过JVM的强类型检查，我继承的吗，当然查不出来了，子类重写了目标类的所有方法，当然在这些重写的方法中，不仅实现了目标类的功能，还在这些功能之前，实现了一些其他的（写日志，安全检查，事物等）。前一种兄弟模式，spring会使用JDK的java.lang.reflect.Proxy类，它允许Spring动态生成一个新类来实现必要的接口，织入通知，并且把对这些接口的任何调用都转发到目标类。后一种父子模式，spring使用CGLIB库生成目标类的一个子类，在创建这个子类的时候，spring织入通知，并且把对这个子类的调用委托到目标类。相比之下，还是兄弟模式好些，他能更好的实现松耦合，尤其在今天都高喊着面向接口编程的情况下，父子模式只是在没有实现接口的时候，也能织入通知，应当做一种例外。</code></pre><h4 id="三、spring-aop的使用方式："><a href="#三、spring-aop的使用方式：" class="headerlink" title="三、spring aop的使用方式："></a>三、spring aop的使用方式：</h4><h5 id="使用aop的目的："><a href="#使用aop的目的：" class="headerlink" title="使用aop的目的："></a>使用aop的目的：</h5><pre><code>1就是为了方便，看一个国外很有名的大师说，编程的人都是“懒人”，因为他把自己做的事情都让程序做了。用了aop能让你少写很多代码，这点就够充分了吧2就是为了更清晰的逻辑，可以让你的业务逻辑去关注自己本身的业务，而不去想一些其他的事情，这些其他的事情包括：安全，事物，日志等。</code></pre><h5 id="第一种实现方式：使用AspectJ提供的注解package-test-mine-spring-bean"><a href="#第一种实现方式：使用AspectJ提供的注解package-test-mine-spring-bean" class="headerlink" title="第一种实现方式：使用AspectJ提供的注解package test.mine.spring.bean;"></a>第一种实现方式：使用AspectJ提供的注解package test.mine.spring.bean;</h5><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> org<span class="token punctuation">.</span>aspectj<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>AfterReturning<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>aspectj<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Aspect<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>aspectj<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Before<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>aspectj<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Pointcut<span class="token punctuation">;</span><span class="token annotation punctuation">@Aspect</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SleepHelper</span> <span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token function">SleepHelper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Pointcut</span><span class="token punctuation">(</span><span class="token string">"execution(* *.sleep())"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sleeppoint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Before</span><span class="token punctuation">(</span><span class="token string">"sleeppoint()"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">beforeSleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"睡觉前要脱衣服!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@AfterReturning</span><span class="token punctuation">(</span><span class="token string">"sleeppoint()"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterSleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"睡醒了要穿衣服！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>用@Aspect的注解来标识切面,注意不要把它漏了，否则Spring创建代理的时候会找不到它,@Pointcut注解指定了切点，@Before和@AfterReturning指定了运行时的通知，注意的是要在注解中传入切点的名称。然后我们在Spring配置文件上下点功夫,首先是增加AOP的XML命名空间和声明相关schema命名空间:xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;schema声明:http://www.springframework.org/schema/aophttp://www.springframework.org/schema/aop/spring-aop-2.0.xsd然后加上这个标签:&lt;aop:aspectj-autoproxy/&gt; 有了这个Spring就能够自动扫描被@Aspect标注的切面了最后是运行，很简单方便了：</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>ApplicationContext appCtx <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">"applicationContext.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Sleepable human <span class="token operator">=</span> <span class="token punctuation">(</span>Sleepable<span class="token punctuation">)</span>appCtx<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"human"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>human<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="第二种使用方式："><a href="#第二种使用方式：" class="headerlink" title="第二种使用方式："></a>第二种使用方式：</h5><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sleepHelper<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>test.spring.aop.bean.SleepHelper<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">aop:</span>config</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">aop:</span>aspect</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sleepHelper<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">aop:</span>before</span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>beforeSleep<span class="token punctuation">"</span></span> <span class="token attr-name">pointcut</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>execution(* *.sleep(..))<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">aop:</span>after</span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>afterSleep<span class="token punctuation">"</span></span> <span class="token attr-name">pointcut</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>execution(* *.sleep(..))<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">aop:</span>aspect</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">aop:</span>config</span><span class="token punctuation">></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 </tag>
            
            <tag> AOP </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>30道java面试题</title>
      <link href="/2019/04/13/30-dao-java-mian-shi-ti/"/>
      <url>/2019/04/13/30-dao-java-mian-shi-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="30道java面试题"><a href="#30道java面试题" class="headerlink" title="30道java面试题"></a>30道java面试题</h1><h4 id="1、Spring-DAO-中最常用的类是（）"><a href="#1、Spring-DAO-中最常用的类是（）" class="headerlink" title="1、Spring DAO 中最常用的类是（）"></a>1、Spring DAO 中最常用的类是（）</h4><pre><code>A，JdbcTemplate ，SimpleJdbcTemplateB，SimpleJdbcInsert，SimpleJdbcProcedureC，SimpleJdbcInsert ，SimpleJdbcStoredProcD，SimpleJdbcQuery ，SimpleJdbcExec正确答案：A</code></pre><h4 id="2、Spring-AOP-中，-织入（Weaving）-可以在下面什么时间完成（）"><a href="#2、Spring-AOP-中，-织入（Weaving）-可以在下面什么时间完成（）" class="headerlink" title="2、Spring AOP 中， 织入（Weaving） 可以在下面什么时间完成（）"></a>2、Spring AOP 中， 织入（Weaving） 可以在下面什么时间完成（）</h4><pre><code>A，全部选项B，Run timeC，Load timeD，Compile time正确答案：A</code></pre><h4 id="3、下面关于Spring-MVC-描述正确的是（）"><a href="#3、下面关于Spring-MVC-描述正确的是（）" class="headerlink" title="3、下面关于Spring MVC 描述正确的是（）"></a>3、下面关于Spring MVC 描述正确的是（）</h4><pre><code>A，DispatcherServlet在 Spring MVC 中是核心servlet , 它负责接收请求并将请求分发给适合的控制器B，在Spring MVC 中,可以配置多个DispatcherServletC，全部选项D，要使Spring MVC可用，DispatcherServlet需要在web.xml中配置正确答案：C</code></pre><h4 id="4、下面哪项是Spring自动装载模式（）"><a href="#4、下面哪项是Spring自动装载模式（）" class="headerlink" title="4、下面哪项是Spring自动装载模式（）"></a>4、下面哪项是Spring自动装载模式（）</h4><pre><code>A，autodetectB，全部选项C，constructorD，byname, byType正确答案：B</code></pre><h4 id="5、Spring-中，下面哪一项不是使用事务的方法（）"><a href="#5、Spring-中，下面哪一项不是使用事务的方法（）" class="headerlink" title="5、Spring 中，下面哪一项不是使用事务的方法（）"></a>5、Spring 中，下面哪一项不是使用事务的方法（）</h4><pre><code>A，proxiesB，declarativelyC，programmaticly正确答案：A</code></pre><h4 id="6、Spring提供了JMS层的抽象，正确吗（）"><a href="#6、Spring提供了JMS层的抽象，正确吗（）" class="headerlink" title="6、Spring提供了JMS层的抽象，正确吗（）"></a>6、Spring提供了JMS层的抽象，正确吗（）</h4><pre><code>A，正确B，错误正确答案：A</code></pre><h4 id="7、关于”-Order”注解，最正确的描述是（）"><a href="#7、关于”-Order”注解，最正确的描述是（）" class="headerlink" title="7、关于”@Order”注解，最正确的描述是（）"></a>7、关于”@Order”注解，最正确的描述是（）</h4><pre><code>A，实现org.springframework.core.Ordered接口B，指定一个bean的范围C，通常用于注入域对象的属性D，全不正确正确答案：A</code></pre><h4 id="8、如何在Spring应用中使用SLF4J（）"><a href="#8、如何在Spring应用中使用SLF4J（）" class="headerlink" title="8、如何在Spring应用中使用SLF4J（）"></a>8、如何在Spring应用中使用SLF4J（）</h4><pre><code>A，作为日志框架B，全不正确C，作为一个beanD，作为JDBC框架正确答案：A</code></pre><h4 id="9、Spring-bean-的默认作用范围是（）"><a href="#9、Spring-bean-的默认作用范围是（）" class="headerlink" title="9、Spring bean 的默认作用范围是（）"></a>9、Spring bean 的默认作用范围是（）</h4><pre><code>A，全不正确B，SingletonC，PrototypeD，SessionE， Abstract正确答案：B</code></pre><h4 id="10、Spring中，单例意味着每-只有一个实例（）"><a href="#10、Spring中，单例意味着每-只有一个实例（）" class="headerlink" title="10、Spring中，单例意味着每_只有一个实例（）"></a>10、Spring中，单例意味着每<strong>_</strong>只有一个实例（）</h4><pre><code>A，ContextB， JVMC，Thread正确答案：A</code></pre><h4 id="11、使用Spring-MVC-处理普通页面请求，-下面哪个排序是正确的（）"><a href="#11、使用Spring-MVC-处理普通页面请求，-下面哪个排序是正确的（）" class="headerlink" title="11、使用Spring MVC 处理普通页面请求， 下面哪个排序是正确的（）"></a>11、使用Spring MVC 处理普通页面请求， 下面哪个排序是正确的（）</h4><pre><code>1.请求：请求提交给服务器2.分发：分发器通过web 应用配置信息 ， 将请求分发至适当的控制器3.服务调用：控制器与业务层交互4.响应：控制器更新模型，将执行结果返回给客户端展现A，1-2-3-4B，1-4-3-2C，1-4-2-3D，1-3-2-4正确答案：A</code></pre><h4 id="12、以下哪个不是-Spring-AOP-的注解（）"><a href="#12、以下哪个不是-Spring-AOP-的注解（）" class="headerlink" title="12、以下哪个不是 Spring AOP 的注解（）"></a>12、以下哪个不是 Spring AOP 的注解（）</h4><pre><code>A，@BeforeB，@AroundC，@BeforeReturningD，@AfterThrowing正确答案：C</code></pre><h4 id="13、”-RequestMapping是Spring中的哪一部分（）"><a href="#13、”-RequestMapping是Spring中的哪一部分（）" class="headerlink" title="13、”@RequestMapping是Spring中的哪一部分（）"></a>13、”@RequestMapping是Spring中的哪一部分（）</h4><pre><code>A，DAOB，SecurityC，Web MVCD，Web正确答案：C</code></pre><h4 id="14、下面关于spring和struts2的描述，错误的是（）"><a href="#14、下面关于spring和struts2的描述，错误的是（）" class="headerlink" title="14、下面关于spring和struts2的描述，错误的是（）"></a>14、下面关于spring和struts2的描述，错误的是（）</h4><pre><code>A，spring mvc的入口是filter，而struts2是servletB，spring mvc是基于方法的设计，而struts2是基于类的设计C，struts2有以自己的interceptor机制，spring mvc用的是独立的AOP方式D， spring mvc的方法之间基本上独立的，独享request response数据，struts2所有Action变量是共享的正确答案：A</code></pre><h4 id="15、Spring中，下面哪个选项支持ORM（）"><a href="#15、Spring中，下面哪个选项支持ORM（）" class="headerlink" title="15、Spring中，下面哪个选项支持ORM（）"></a>15、Spring中，下面哪个选项支持ORM（）</h4><pre><code>A，OJBB，TopLinkC，全部选项D，Java Data Objects(JDO)E，iBatis正确答案：C</code></pre><h4 id="16、Spring和Hibernate的集成中，下面哪项是SessionFactory-正确的实现（）"><a href="#16、Spring和Hibernate的集成中，下面哪项是SessionFactory-正确的实现（）" class="headerlink" title="16、Spring和Hibernate的集成中，下面哪项是SessionFactory 正确的实现（）"></a>16、Spring和Hibernate的集成中，下面哪项是SessionFactory 正确的实现（）</h4><pre><code>A，LocalSessionFactoryBeanB，LocalFactoryBeanC，SessionFactoryD，SessionFactoryBean正确答案：A</code></pre><h4 id="17、下面哪个是Spring最核心的servlet（）"><a href="#17、下面哪个是Spring最核心的servlet（）" class="headerlink" title="17、下面哪个是Spring最核心的servlet（）"></a>17、下面哪个是Spring最核心的servlet（）</h4><pre><code>A，WebServletB，SpringServletC，DispatcherServletD，IoCServlet正确答案：C</code></pre><h4 id="18、Spring-test-用什么约定在测试中使用HTTP会话和HTTP-请求对象（）"><a href="#18、Spring-test-用什么约定在测试中使用HTTP会话和HTTP-请求对象（）" class="headerlink" title="18、Spring-test 用什么约定在测试中使用HTTP会话和HTTP 请求对象（）"></a>18、Spring-test 用什么约定在测试中使用HTTP会话和HTTP 请求对象（）</h4><pre><code>A，MVCB，Open-closed principleC，DAOsD，Mock objects正确答案：D</code></pre><h4 id="19、Spring-中，”-Cacheable”的key生成方式，以下哪个是正确的（）"><a href="#19、Spring-中，”-Cacheable”的key生成方式，以下哪个是正确的（）" class="headerlink" title="19、Spring 中，”@Cacheable”的key生成方式，以下哪个是正确的（）"></a>19、Spring 中，”@Cacheable”的key生成方式，以下哪个是正确的（）</h4><pre><code>A，可以是方法参数及其成员变量的任意表达式B，只能使用所有方法参数，但可以调整次序C，只能使用所有方法参数，且不能调整次序D，只能指定方法参数是否参与key的生成，不能控制参数的成员变量正确答案：A</code></pre><h4 id="20、使用-Required但不关联bean-来注解setter方法，将会发生（）"><a href="#20、使用-Required但不关联bean-来注解setter方法，将会发生（）" class="headerlink" title="20、使用@Required但不关联bean 来注解setter方法，将会发生（）"></a>20、使用@Required但不关联bean 来注解setter方法，将会发生（）</h4><pre><code>A，bean被设置为nullB，启动异常C，Spring 将创建beanD，什么也不发生正确答案：B</code></pre><h4 id="21，有关线程的哪些叙述是对的（-）"><a href="#21，有关线程的哪些叙述是对的（-）" class="headerlink" title="21，有关线程的哪些叙述是对的（ ）"></a>21，有关线程的哪些叙述是对的（ ）</h4><pre><code>A，一旦一个线程被创建，它就立即开始运行。B，使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。C，当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。D，一个线程可能因为不同的原因停止并进入就绪状态。答案：BCD在抢占式线程模型中，操作系统可以在任何时候打断线程。通常会在它运行了一段时间（就是所谓的一个时间片）后才打断它。这样的结果自然是没有线程能够不公平地长时间霸占处理器。</code></pre><hr><h4 id="22，哪个关键字可以对对象加互斥锁-（）"><a href="#22，哪个关键字可以对对象加互斥锁-（）" class="headerlink" title="22，哪个关键字可以对对象加互斥锁 （）"></a>22，哪个关键字可以对对象加互斥锁 （）</h4><pre><code>A，serializeB，synchronizedC，transientD，static答案：BA是对象串行化、C是关键字transient修饰的属性将不被串行化、D是静态的</code></pre><h4 id="23，下列关于线程优先级的说法中，正确的是（）"><a href="#23，下列关于线程优先级的说法中，正确的是（）" class="headerlink" title="23，下列关于线程优先级的说法中，正确的是（）"></a>23，下列关于线程优先级的说法中，正确的是（）</h4><pre><code>A、线程的优先级是不能改变的B、线程的优先级是在创建线程时设置的C、在创建线程后的任何时候都可以设置D、B和C答案：C    Java语言中线程的优先级是用一个介于MIN_PRIORITY和MAX_PRIORITY之间的整数来表示的。可以在创建线程后的任何时候修改线程的优先级。</code></pre><h4 id="24，为了使模块尽可能独立，要求"><a href="#24，为了使模块尽可能独立，要求" class="headerlink" title="24，为了使模块尽可能独立，要求( )"></a>24，为了使模块尽可能独立，要求( )</h4><pre><code>A．模块的内聚程度要尽量高，且耦合程度要尽量强B．模块的内聚程度要尽量高，且耦合程度要尽量弱C．模块的内聚程度要尽量低，且耦合程度要尽量弱D．模块的内聚程度要尽量低，且耦合程度要尽量强答案：B    系统设计的质量主要反映在模块的独立性上。评价模块独立性的主要标准有两个：一是模块之间的耦合，它表明两个模块之间互相独立的程度；二是模块内部之间的关系是否紧密，称为内聚。一般来说，要求模块之间的耦合尽可能地弱，即模块尽可能独立，而要求模块的内聚程度尽量高。</code></pre><h4 id="25，下列对于线性链表的描述中正确的是（）"><a href="#25，下列对于线性链表的描述中正确的是（）" class="headerlink" title="25，下列对于线性链表的描述中正确的是（）"></a>25，下列对于线性链表的描述中正确的是（）</h4><pre><code>A．存储空间不一定是连续，且各元素的存储顺序是任意的B．存储空间不一定是连续，且前件元素一定存储在后件元素的前面C．存储空间必须连续，且前件元素一定存储在后件元素的前面D．存储空间必须连续，且各元素的存储顺序是任意的答案：A在链式存储结构中，存储数据结构的存储空间可以不连续，各数据结点的存储顺序与数据元素之间 的逻辑关系可以不一致，而数据元素之间的逻辑关系是由指针域来确定的。</code></pre><h4 id="26，下列叙述中错误的是"><a href="#26，下列叙述中错误的是" class="headerlink" title="26，下列叙述中错误的是( )"></a>26，下列叙述中错误的是( )</h4><pre><code>A.线性表是由n个元素组成的一个有限序列B.线性表是一种线性结构C.线性表的所有结点有且仅有一个前件和后件D.线性表可以是空表答案：C线性表是一种线性结构，由n(n≥0)个元素组成，所以线性表可以是空表。但是在线性表中，第一个结点没有前驱，最后一个结点没有后继，其他结点有且只有一个前驱和后继，所以选项C是错误的。</code></pre><h4 id="27，已知一棵二叉树前序遍历和中序遍历分别为ABDEGCFH和DBGEACHF，则该二叉树的后序遍历为"><a href="#27，已知一棵二叉树前序遍历和中序遍历分别为ABDEGCFH和DBGEACHF，则该二叉树的后序遍历为" class="headerlink" title="27，已知一棵二叉树前序遍历和中序遍历分别为ABDEGCFH和DBGEACHF，则该二叉树的后序遍历为( )"></a>27，已知一棵二叉树前序遍历和中序遍历分别为ABDEGCFH和DBGEACHF，则该二叉树的后序遍历为( )</h4><pre><code>A.GEDHFBCAB.DGEBHFCAC.ABCDEFGHD.ACBFEDHG答案：B二叉树的遍历有3种：前序、中序和后序。先序：先访问根结点、左结点、右结点中序：先访问左结点、根结点、右结点后序：先访问左结点、右结点、根结点本题根据前序遍历和中序遍历的结果可以得出二叉树的结构，然后再对其进行后序遍历。</code></pre><h4 id="28，面向对象方法中，继承是指"><a href="#28，面向对象方法中，继承是指" class="headerlink" title="28，面向对象方法中，继承是指( )"></a>28，面向对象方法中，继承是指( )</h4><pre><code>A.一组对象所具有的相似性质B.一个对象具有另一个对象的性质C.各对象之间的共同性质D.类之间共享属性和操作的机制答案：D继承：在程序设计中，继承是指子类自动享用父类的属性和方法，并可以增加新的属性和方法的一种机制。它是实现代码共享的重要手段，可以使软件更具有开放性、可扩充性，这是信息组织与分类的行之有效的方法，也是面向对象的主要优点之一。继承又分为单重继承和多重继承，单重继承是指子类只能继承一个父类的属性和操作；而多重继承是指子类可以继承了多个父类的属性和操作。扩展：Java是一种单重继承语言，而C++是一种多重继承语言。</code></pre><h4 id="29，栈和队列的共同点是"><a href="#29，栈和队列的共同点是" class="headerlink" title="29，栈和队列的共同点是( )"></a>29，栈和队列的共同点是( )</h4><pre><code>A.都是先进先出B.都是先进后出C.只允许在端点处插入和删除元素D.没有共同特点答案：C栈是只允许在表的一端进行插入和删除的操作，队列是允许在表的一端进行插入，另一端进行删除的操作。</code></pre><h4 id="30，下列关于修饰符混用的说法，错误的是（）"><a href="#30，下列关于修饰符混用的说法，错误的是（）" class="headerlink" title="30，下列关于修饰符混用的说法，错误的是（）"></a>30，下列关于修饰符混用的说法，错误的是（）</h4><pre><code>A.abstract不能与final并列修饰同一个类B.abstract类中不可以有private的成员C.abstract方法必须在abstract类中D.static方法中能处理非static的数据答案：D静态方法是属于类的，而普通方法是属于对象的。属于类的静态方法可以在对象不存在的时候就能访问到，而普通方法必须先new一个对象才能用这个对象访问。当我们访问调用静态方法的时候（使用类名.静态方法名）这个时候就没有对象创建，所以普通方法是访问不到的。为了避免这种错误，所以java就不允许在静态方法中访问非静态方法。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySql中锁的理解</title>
      <link href="/2019/04/12/mysql-zhong-suo-de-li-jie/"/>
      <url>/2019/04/12/mysql-zhong-suo-de-li-jie/</url>
      
        <content type="html"><![CDATA[<p><img src="//zongmansheng.club/2019/04/12/mysql-zhong-suo-de-li-jie/001.png" alt="001"></p><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><pre><code>注：MySQL是一个支持插件式存储引擎的数据库系统。本文下面的所有介绍，都是基于InnoDB存储引擎，其他引擎的表现，会有较大的区别。</code></pre><h4 id="存储引擎查看"><a href="#存储引擎查看" class="headerlink" title="存储引擎查看"></a>存储引擎查看</h4><pre><code>MySQL给开发者提供了查询存储引擎的功能，我这里使用的是MySQL5.6.4，可以使用：SHOW ENGINES</code></pre><p><img src="//zongmansheng.club/2019/04/12/mysql-zhong-suo-de-li-jie/002.png" alt="002"></p><p><img src="//zongmansheng.club/2019/04/12/mysql-zhong-suo-de-li-jie/003.png" alt="003"></p><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><pre><code>    用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加1。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。</code></pre><h5 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h5><h6 id="1、数据库表设计"><a href="#1、数据库表设计" class="headerlink" title="1、数据库表设计"></a>1、数据库表设计</h6><pre><code>三个字段，分别是id,value、version</code></pre><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> id<span class="token punctuation">,</span><span class="token keyword">value</span><span class="token punctuation">,</span>version <span class="token keyword">from</span> <span class="token keyword">TABLE</span> <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token comment" spellcheck="true">#{id}</span></code></pre><h6 id="2、每次更新表中的value字段时，为了防止发生冲突，需要这样操作"><a href="#2、每次更新表中的value字段时，为了防止发生冲突，需要这样操作" class="headerlink" title="2、每次更新表中的value字段时，为了防止发生冲突，需要这样操作"></a>2、每次更新表中的value字段时，为了防止发生冲突，需要这样操作</h6><pre class=" language-sql"><code class="language-sql"><span class="token keyword">update</span> <span class="token keyword">TABLE</span> <span class="token keyword">set</span> <span class="token keyword">value</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span>version<span class="token operator">=</span>version<span class="token operator">+</span><span class="token number">1</span> <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token comment" spellcheck="true">#{id} and version=#{version};</span></code></pre><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><pre><code>    与乐观锁相对应的就是悲观锁了。悲观锁就是在操作数据时，认为此操作会出现数据冲突，所以在进行每次操作时都要通过获取锁才能进行对相同数据的操作，这点跟java中的synchronized很相似，所以悲观锁需要耗费较多的时间。另外与乐观锁相对应的，悲观锁是由数据库自己实现了的，要用的时候，我们直接调用数据库的相关语句就可以了。    说到这里，由悲观锁涉及到的另外两个锁概念就出来了，它们就是共享锁与排它锁。共享锁和排它锁是悲观锁的不同的实现，它俩都属于悲观锁的范畴。使用，排它锁 举例    要使用悲观锁，我们必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。我们可以使用命令设置MySQL为非autocommit模式：</code></pre><pre class=" language-sql"><code class="language-sql"><span class="token keyword">set</span> autocommit<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"># 设置完autocommit后，我们就可以执行我们的正常业务了。具体如下：</span><span class="token comment" spellcheck="true"># 1. 开始事务</span><span class="token keyword">begin</span><span class="token punctuation">;</span><span class="token operator">/</span><span class="token keyword">begin</span> <span class="token keyword">work</span><span class="token punctuation">;</span><span class="token operator">/</span><span class="token keyword">start</span> <span class="token keyword">transaction</span><span class="token punctuation">;</span> <span class="token punctuation">(</span>三者选一就可以<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 2. 查询表信息</span><span class="token keyword">select</span> <span class="token keyword">status</span> <span class="token keyword">from</span> <span class="token keyword">TABLE</span> <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token number">1</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"># 3. 插入一条数据</span><span class="token keyword">insert</span> <span class="token keyword">into</span> <span class="token keyword">TABLE</span> <span class="token punctuation">(</span>id<span class="token punctuation">,</span><span class="token keyword">value</span><span class="token punctuation">)</span> <span class="token keyword">values</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"># 4. 修改数据为</span><span class="token keyword">update</span> <span class="token keyword">TABLE</span> <span class="token keyword">set</span> <span class="token keyword">value</span><span class="token operator">=</span><span class="token number">2</span> <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"># 5. 提交事务</span><span class="token keyword">commit</span><span class="token punctuation">;</span><span class="token operator">/</span><span class="token keyword">commit</span> <span class="token keyword">work</span><span class="token punctuation">;</span></code></pre><h4 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h4><pre><code>共享锁又称读锁 read lock，是读取操作创建的锁。其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排他锁。获得共享锁的事务只能读数据，不能修改数据打开第一个查询窗口</code></pre><pre class=" language-sql"><code class="language-sql"><span class="token keyword">begin</span><span class="token punctuation">;</span><span class="token operator">/</span><span class="token keyword">begin</span> <span class="token keyword">work</span><span class="token punctuation">;</span><span class="token operator">/</span><span class="token keyword">start</span> <span class="token keyword">transaction</span><span class="token punctuation">;</span> <span class="token punctuation">(</span>三者选一就可以<span class="token punctuation">)</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">TABLE</span> <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span> <span class="token keyword">lock</span> <span class="token operator">in</span> <span class="token keyword">share mode</span><span class="token punctuation">;</span></code></pre><p>然后在另一个查询窗口中，对id为1的数据进行更新</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">update</span> <span class="token keyword">TABLE</span> <span class="token keyword">set</span> name<span class="token operator">=</span><span class="token string">"www.souyunku.com"</span> <span class="token keyword">where</span> id <span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span></code></pre><pre><code>此时，操作界面进入了卡顿状态，过了超时间，提示错误信息如果在超时前，执行 commit，此更新语句就会成功。</code></pre><pre class=" language-sql"><code class="language-sql"><span class="token punctuation">[</span>SQL<span class="token punctuation">]</span><span class="token keyword">update</span> test_one <span class="token keyword">set</span> name<span class="token operator">=</span><span class="token string">"www.souyunku.com"</span> <span class="token keyword">where</span> id <span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">[</span>Err<span class="token punctuation">]</span> <span class="token number">1205</span> <span class="token operator">-</span> <span class="token keyword">Lock</span> wait timeout exceeded<span class="token punctuation">;</span> try restarting <span class="token keyword">transaction</span></code></pre><p>加上共享锁后，也提示错误信息</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">update</span> test_one <span class="token keyword">set</span> name<span class="token operator">=</span><span class="token string">"www.souyunku.com"</span> <span class="token keyword">where</span> id <span class="token operator">=</span><span class="token number">1</span> <span class="token keyword">lock</span> <span class="token operator">in</span> <span class="token keyword">share mode</span><span class="token punctuation">;</span><span class="token punctuation">[</span>SQL<span class="token punctuation">]</span><span class="token keyword">update</span> test_one <span class="token keyword">set</span> name<span class="token operator">=</span><span class="token string">"www.souyunku.com"</span> <span class="token keyword">where</span> id <span class="token operator">=</span><span class="token number">1</span> <span class="token keyword">lock</span> <span class="token operator">in</span> <span class="token keyword">share mode</span><span class="token punctuation">;</span><span class="token punctuation">[</span>Err<span class="token punctuation">]</span> <span class="token number">1064</span> <span class="token operator">-</span> You have an error <span class="token operator">in</span> your SQL syntax<span class="token punctuation">;</span> <span class="token keyword">check</span> the manual that corresponds <span class="token keyword">to</span> your MySQL server version <span class="token keyword">for</span> the <span class="token keyword">right</span> syntax <span class="token keyword">to</span> <span class="token keyword">use</span> near <span class="token string">'lock in share mode'</span> at line <span class="token number">1</span></code></pre><pre><code>    在查询语句后面增加 LOCK IN SHARE MODE，Mysql会对查询结果中的每行都加共享锁，当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请共享锁，否则会被阻塞。其他线程也可以读取使用了共享锁的表，而且这些线程读取的是同一个版本的数据。加上共享锁后，对于update,insert,delete语句会自动加排它锁。</code></pre><h4 id="排它锁"><a href="#排它锁" class="headerlink" title="排它锁"></a>排它锁</h4><pre><code>排他锁 exclusive lock（也叫writer lock）又称写锁。排它锁是悲观锁的一种实现，在上面悲观锁也介绍过。若事务 1 对数据对象A加上X锁，事务 1 可以读A也可以修改A，其他事务不能再对A加任何锁，直到事物 1 释放A上的锁。这保证了其他事务在事物 1 释放A上的锁之前不能再读取和修改A。排它锁会阻塞所有的排它锁和共享锁读取为什么要加读锁呢：防止数据在被读取的时候被别的线程加上写锁，使用方式：在需要执行的语句后面加上for update就可以了</code></pre><h4 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h4><pre><code>行锁又分共享锁和排他锁,由字面意思理解，就是给某一行加上锁，也就是一条记录加上锁。注意：行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁。共享锁：名词解释：共享锁又叫做读锁，所有的事务只能对其进行读操作不能写操作，加上共享锁后在事务结束之前其他事务只能再加共享锁，除此之外其他任何类型的锁都不能再加了。</code></pre><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">TABLE</span> <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token string">"1"</span> <span class="token keyword">lock</span> <span class="token operator">in</span> <span class="token keyword">share mode</span><span class="token punctuation">;</span> 结果集的数据都会加共享锁</code></pre><h4 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h4><pre><code>如何加表锁innodb 的行锁是在有索引的情况下,没有索引的表是锁定全表的.</code></pre><h4 id="Innodb中的行锁与表锁"><a href="#Innodb中的行锁与表锁" class="headerlink" title="Innodb中的行锁与表锁"></a>Innodb中的行锁与表锁</h4><pre><code>前面提到过，在Innodb引擎中既支持行锁也支持表锁，那么什么时候会锁住整张表，什么时候或只锁住一行呢？只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！在实际应用中，要特别注意InnoDB行锁的这一特性，不然的话，可能导致大量的锁冲突，从而影响并发性能。行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁。行级锁的缺点是：由于需要请求大量的锁资源，所以速度慢，内存消耗大。</code></pre><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><pre><code>死锁（Deadlock） 所谓死锁：是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。由于资源占用是互斥的，当某个进程提出申请资源后，使得有关进程在无外力协助下，永远分配不到必需的资源而无法继续运行，这就产生了一种特殊现象死锁。解除正在死锁的状态有两种方法：</code></pre><p><strong>第一种</strong>：</p><p>1.查询是否锁表</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">show</span> <span class="token keyword">OPEN</span> <span class="token keyword">TABLES</span> <span class="token keyword">where</span> In_use <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span></code></pre><p>2.查询进程（如果您有SUPER权限，您可以看到所有线程。否则，您只能看到您自己的线程）</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">show</span> processlist</code></pre><p><img src="//zongmansheng.club/2019/04/12/mysql-zhong-suo-de-li-jie/004.png" alt="004"></p><p>3.杀死进程id（就是上面命令的id列）</p><pre><code>kill id</code></pre><p><strong>第二种</strong>：</p><p>1：查看当前的事务</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> INFORMATION_SCHEMA<span class="token punctuation">.</span>INNODB_TRX<span class="token punctuation">;</span></code></pre><p>2：查看当前锁定的事务</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> INFORMATION_SCHEMA<span class="token punctuation">.</span>INNODB_LOCKS<span class="token punctuation">;</span></code></pre><p>3：查看当前等锁的事务</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> INFORMATION_SCHEMA<span class="token punctuation">.</span>INNODB_LOCK_WAITS<span class="token punctuation">;</span></code></pre><p>杀死进程</p><pre><code>kill 进程ID</code></pre><pre><code>如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。其次，进程运行推进顺序与速度不同，也可能产生死锁。产生死锁的四个必要条件：（1） 互斥条件：一个资源每次只能被一个进程使用。（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。（3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。虽然不能完全避免死锁，但可以使死锁的数量减至最少。将死锁减至最少可以增加事务的吞吐量并减少系统开销，因为只有很少的事务回滚，而回滚会取消事务执行的所有工作。由于死锁时回滚而由应用程序重新提交。下列方法有助于最大限度地降低死锁：（1）按同一顺序访问对象。（2）避免事务中的用户交互。（3）保持事务简短并在一个批处理中。（4）使用低隔离级别。（5）使用绑定连接。</code></pre><p>原文：<a href="https://segmentfault.com/a/1190000015815061" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015815061</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 乐观锁，悲观锁，共享锁，排它锁，行锁，表锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swagger使用指南</title>
      <link href="/2019/04/11/swagger-shi-yong-zhi-nan/"/>
      <url>/2019/04/11/swagger-shi-yong-zhi-nan/</url>
      
        <content type="html"><![CDATA[<h1 id="Swagger"><a href="#Swagger" class="headerlink" title="Swagger"></a>Swagger</h1><h4 id="1：认识Swagger"><a href="#1：认识Swagger" class="headerlink" title="1：认识Swagger"></a>1：认识Swagger</h4><pre><code>    Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。总体目标是使客户端和文件系统作为服务器以同样的速度来更新。文件的方法，参数和模型紧密集成到服务器端的代码，允许API来始终保持同步。</code></pre><h4 id="2：Maven依赖"><a href="#2：Maven依赖" class="headerlink" title="2：Maven依赖"></a>2：Maven依赖</h4><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>io.springfox<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>springfox-swagger2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.7.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>io.springfox<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>springfox-swagger-ui<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.7.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><h4 id="3：创建Swagger2配置类（springboot搭建）"><a href="#3：创建Swagger2配置类（springboot搭建）" class="headerlink" title="3：创建Swagger2配置类（springboot搭建）"></a>3：创建Swagger2配置类（springboot搭建）</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>zms<span class="token punctuation">.</span>cmsdemo<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>SpringApplication<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>SpringBootApplication<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Bean<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>EnableMBeanExport<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>jmx<span class="token punctuation">.</span>support<span class="token punctuation">.</span>RegistrationPolicy<span class="token punctuation">;</span><span class="token keyword">import</span> springfox<span class="token punctuation">.</span>documentation<span class="token punctuation">.</span>builders<span class="token punctuation">.</span>ApiInfoBuilder<span class="token punctuation">;</span><span class="token keyword">import</span> springfox<span class="token punctuation">.</span>documentation<span class="token punctuation">.</span>builders<span class="token punctuation">.</span>PathSelectors<span class="token punctuation">;</span><span class="token keyword">import</span> springfox<span class="token punctuation">.</span>documentation<span class="token punctuation">.</span>builders<span class="token punctuation">.</span>RequestHandlerSelectors<span class="token punctuation">;</span><span class="token keyword">import</span> springfox<span class="token punctuation">.</span>documentation<span class="token punctuation">.</span>service<span class="token punctuation">.</span>ApiInfo<span class="token punctuation">;</span><span class="token keyword">import</span> springfox<span class="token punctuation">.</span>documentation<span class="token punctuation">.</span>spi<span class="token punctuation">.</span>DocumentationType<span class="token punctuation">;</span><span class="token keyword">import</span> springfox<span class="token punctuation">.</span>documentation<span class="token punctuation">.</span>spring<span class="token punctuation">.</span>web<span class="token punctuation">.</span>plugins<span class="token punctuation">.</span>Docket<span class="token punctuation">;</span><span class="token keyword">import</span> springfox<span class="token punctuation">.</span>documentation<span class="token punctuation">.</span>swagger2<span class="token punctuation">.</span>annotations<span class="token punctuation">.</span>EnableSwagger2<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author ZongMan */</span><span class="token annotation punctuation">@EnableSwagger2</span><span class="token annotation punctuation">@SpringBootApplication</span><span class="token annotation punctuation">@EnableMBeanExport</span><span class="token punctuation">(</span>registration <span class="token operator">=</span> RegistrationPolicy<span class="token punctuation">.</span>IGNORE_EXISTING<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CmsDemoApplication</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>CmsDemoApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> Docket <span class="token function">cmsApi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Docket</span><span class="token punctuation">(</span>DocumentationType<span class="token punctuation">.</span>SWAGGER_2<span class="token punctuation">)</span>               <span class="token punctuation">.</span><span class="token function">apiInfo</span><span class="token punctuation">(</span><span class="token function">testApiInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>               <span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span>               <span class="token punctuation">.</span><span class="token function">apis</span><span class="token punctuation">(</span>RequestHandlerSelectors<span class="token punctuation">.</span><span class="token function">basePackage</span><span class="token punctuation">(</span><span class="token string">"com.zms.cmsdemo.controller"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>               <span class="token punctuation">.</span><span class="token function">paths</span><span class="token punctuation">(</span>PathSelectors<span class="token punctuation">.</span><span class="token function">any</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>               <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> ApiInfo <span class="token function">testApiInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ApiInfoBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">title</span><span class="token punctuation">(</span><span class="token string">"咨询信息模块"</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">description</span><span class="token punctuation">(</span><span class="token string">"公共平台接口，主要用于测试."</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">termsOfServiceUrl</span><span class="token punctuation">(</span><span class="token string">"http:127.0.0.1:8080/cms"</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">version</span><span class="token punctuation">(</span><span class="token string">"1.0"</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="4：添加文档内容"><a href="#4：添加文档内容" class="headerlink" title="4：添加文档内容"></a>4：添加文档内容</h4><pre><code>Swagger使用的注解及其说明：@Api：用在类上，说明该类的作用。@ApiOperation：注解来给API增加方法说明。@ApiImplicitParams : 用在方法上包含一组参数说明。@ApiImplicitParam：用来注解来给方法入参增加说明。@ApiResponses：用于表示一组响应@ApiResponse：用在@ApiResponses中，一般用于表达一个错误的响应信息   code：数字，例如400   message：信息，例如&quot;请求参数没填好&quot;   response：抛出异常的类   @ApiModel：描述一个Model的信息（一般用在请求参数无法使用@ApiImplicitParam注解进行描述的时候）   @ApiModelProperty：描述一个model的属性</code></pre><p>注意：@ApiImplicitParam的参数说明：</p><p><img src="//zongmansheng.club/2019/04/11/swagger-shi-yong-zhi-nan/001.png" alt="001"></p><h5 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h5><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>zms<span class="token punctuation">.</span>cmsdemo<span class="token punctuation">.</span>controller<span class="token punctuation">;</span><span class="token keyword">import</span> io<span class="token punctuation">.</span>swagger<span class="token punctuation">.</span>annotations<span class="token punctuation">.</span>Api<span class="token punctuation">;</span><span class="token keyword">import</span> io<span class="token punctuation">.</span>swagger<span class="token punctuation">.</span>annotations<span class="token punctuation">.</span>ApiImplicitParam<span class="token punctuation">;</span><span class="token keyword">import</span> io<span class="token punctuation">.</span>swagger<span class="token punctuation">.</span>annotations<span class="token punctuation">.</span>ApiOperation<span class="token punctuation">;</span><span class="token keyword">import</span> io<span class="token punctuation">.</span>swagger<span class="token punctuation">.</span>annotations<span class="token punctuation">.</span>ApiResponse<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span>Logger<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span>LoggerFactory<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span>Controller<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>PathVariable<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>RequestMapping<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>RequestMethod<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>ResponseBody<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author ZongMan * @version 1.0 * @date 2019/4/12 0012 11:30 */</span><span class="token annotation punctuation">@Api</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/750p"</span><span class="token punctuation">,</span>description <span class="token operator">=</span> <span class="token string">"咨询信息的Controller"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Controller</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"750/p"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CmsController</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Logger LOGGER <span class="token operator">=</span> LoggerFactory<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span>CmsController<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 添加咨询信息     * @return     */</span>    <span class="token annotation punctuation">@ApiOperation</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"添加咨询信息"</span><span class="token punctuation">,</span>notes <span class="token operator">=</span> <span class="token string">"添加咨询信息"</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@ApiImplicitParam</span><span class="token punctuation">(</span>paramType<span class="token operator">=</span><span class="token string">"xxx"</span><span class="token punctuation">,</span>name <span class="token operator">=</span> <span class="token string">"咨询信息实体"</span><span class="token punctuation">,</span>value <span class="token operator">=</span> <span class="token string">"咨询信息实体"</span><span class="token punctuation">,</span>required <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">,</span>dataType <span class="token operator">=</span> <span class="token string">"实体类型"</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@ApiResponse</span><span class="token punctuation">(</span>code <span class="token operator">=</span> <span class="token number">001</span><span class="token operator">-</span><span class="token number">000</span><span class="token operator">-</span><span class="token number">001</span><span class="token punctuation">,</span>message <span class="token operator">=</span> <span class="token string">"添加咨询信息失败"</span><span class="token punctuation">,</span>response <span class="token operator">=</span> CmsController<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"addConOne"</span><span class="token punctuation">,</span>method <span class="token operator">=</span> RequestMethod<span class="token punctuation">.</span>POST<span class="token punctuation">)</span>    <span class="token annotation punctuation">@ResponseBody</span>    <span class="token keyword">public</span> String <span class="token function">addConOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"添加成功"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"deleteConOne/{id}"</span><span class="token punctuation">,</span>method <span class="token operator">=</span> RequestMethod<span class="token punctuation">.</span>DELETE<span class="token punctuation">)</span>    <span class="token annotation punctuation">@ResponseBody</span>    <span class="token keyword">public</span> String <span class="token function">deleteConOne</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span> String id<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token string">"删除成功"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>启动Spring Boot程序，访问：<a href="http://localhost:8080/swagger-ui.html" target="_blank" rel="noopener">http://localhost:8080/swagger-ui.html</a></p><p><img src="//zongmansheng.club/2019/04/11/swagger-shi-yong-zhi-nan/002.png" alt="002"></p>]]></content>
      
      
      <categories>
          
          <category> 日常学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swagger </tag>
            
            <tag> 在线文档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>装饰者设计模式</title>
      <link href="/2019/04/10/zhuang-shi-zhe-she-ji-mo-shi/"/>
      <url>/2019/04/10/zhuang-shi-zhe-she-ji-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="装饰者设计模式"><a href="#装饰者设计模式" class="headerlink" title="装饰者设计模式"></a>装饰者设计模式</h1><h4 id="一、装饰者模式的概念"><a href="#一、装饰者模式的概念" class="headerlink" title="一、装饰者模式的概念"></a>一、装饰者模式的概念</h4><p>​    装饰者模式又名包装(Wrapper)模式。装饰者模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案。</p><h4 id="二、装饰者模式的结构"><a href="#二、装饰者模式的结构" class="headerlink" title="二、装饰者模式的结构"></a>二、装饰者模式的结构</h4><p>​    装饰者模式以对客户透明的方式动态地给一个对象附加上更多的责任。换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。装饰者模式可以在不使用创造更多子类的情况下，将对象的功能加以扩展。<img src="//zongmansheng.club/2019/04/10/zhuang-shi-zhe-she-ji-mo-shi/个人学习文档\装饰者设计模式\Snipaste_2019-01-14_22-44-24.png" alt="Snipaste_2019-01-14_22-44-24"></p><p>在装饰模式中的角色有：</p><p>●　　抽象构件(Component)角色：给出一个抽象接口，以规范准备接收附加责任的对象。</p><p>●　　具体构件(ConcreteComponent)角色：定义一个将要接收附加责任的类。</p><p>●　　装饰(Decorator)角色：持有一个构件(Component)对象的实例，并定义一个与抽象构件接口一致的接口。</p><p>●　　具体装饰(ConcreteDecorator)角色：负责给构件对象“贴上”附加的责任。</p><h4 id="三、装饰者模式实例演示"><a href="#三、装饰者模式实例演示" class="headerlink" title="三、装饰者模式实例演示"></a>三、装饰者模式实例演示</h4><h5 id="齐天大圣的例子"><a href="#齐天大圣的例子" class="headerlink" title="齐天大圣的例子"></a>齐天大圣的例子</h5><p>​    孙悟空有七十二般变化，他的每一种变化都给他带来一种附加的本领。他变成鱼儿时，就可以到水里游泳；他变成鸟儿时，就可以在天上飞行。</p><p>​    本例中，Component的角色便由鼎鼎大名的齐天大圣扮演；ConcreteComponent的角色属于大圣的本尊，就是猢狲本人；Decorator的角色由大圣的七十二变扮演。而ConcreteDecorator的角色便是鱼儿、鸟儿等七十二般变化</p><p><img src="//zongmansheng.club/2019/04/10/zhuang-shi-zhe-she-ji-mo-shi/Snipaste_2019-01-14_22-47-58.png" alt="Snipaste_2019-01-14_22-47-58"></p><h4 id="四、装饰者模式的优缺点"><a href="#四、装饰者模式的优缺点" class="headerlink" title="四、装饰者模式的优缺点"></a>四、装饰者模式的优缺点</h4><h5 id="装饰模式的优点"><a href="#装饰模式的优点" class="headerlink" title="装饰模式的优点"></a>装饰模式的优点</h5><p>（1）装饰模式与继承关系的目的都是要扩展对象的功能，但是装饰模式可以提供比继承更多的灵活性。装    饰模式允许系统动态决定“贴上”一个需要的“装饰”，或者除掉一个不需要的“装饰”。继承关系则不同，继承关系是静态的，它在系统运行前就决定了。</p><p>（2）通过使用不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的组合。</p><h5 id="装饰模式的缺点"><a href="#装饰模式的缺点" class="headerlink" title="装饰模式的缺点"></a>装饰模式的缺点</h5><p>由于使用装饰模式，可以比使用继承关系需要较少数目的类。使用较少的类，当然使设计比较易于进行。但是，在另一方面，使用装饰模式会产生比使用继承关系更多的对象。更多的对象会使得查错变得困难，特别是这些对象看上去都很相像。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Wrapper，装饰者 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例设计模式</title>
      <link href="/2019/04/09/dan-li-she-ji-mo-shi/"/>
      <url>/2019/04/09/dan-li-she-ji-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="单例的几种写法"><a href="#单例的几种写法" class="headerlink" title="单例的几种写法"></a>单例的几种写法</h1><h4 id="第一种写法（饿汉式-可用）"><a href="#第一种写法（饿汉式-可用）" class="headerlink" title="第一种写法（饿汉式 可用）"></a>第一种写法（饿汉式 可用）</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019/1/23 0023 * @Time: 8:42 * @Vsersion: 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingletonDemo01</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 单例模式第一种写法：     * 饿汉式（静态常量）     */</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> SingletonDemo01 INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingletonDemo01</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">SingletonDemo01</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> SingletonDemo01 <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> INSTANCE<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>优点：写法比较简单，在类装载的时候就进行实例化，避免了线程同步的问题缺点：在类装载的时候就完成实例化，没有达到Lazy Loading的效果，如果从始至终都没有使用这个实例，就会造成内存的浪费。</code></pre><h4 id="第二种写法（饿汉式-可用）"><a href="#第二种写法（饿汉式-可用）" class="headerlink" title="第二种写法（饿汉式 可用）"></a>第二种写法（饿汉式 可用）</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019/1/23 0023 * @Time: 8:52 * @Vsersion: 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingletonDemo02</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 单例模式第二种写法：     * 静态代码块     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> SingletonDemo02 instance<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingletonDemo02</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">SingletonDemo02</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> SingletonDemo02 <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>优缺点同上</code></pre><h4 id="第三种写法（懒汉式-线程不安全、不可用）"><a href="#第三种写法（懒汉式-线程不安全、不可用）" class="headerlink" title="第三种写法（懒汉式 线程不安全、不可用）"></a>第三种写法（懒汉式 线程不安全、不可用）</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019/1/23 0023 * @Time: 8:56 * @Vsersion: 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingletonDemo03</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 单例模式的第三种写法     * 懒汉式（线程不安全）     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> SingletonDemo03 singleton<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">SingletonDemo03</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> SingletonDemo03 <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>            singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingletonDemo03</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>这种写法起到了Lazy Loading的效果，但是只能在单线程下使用。如果在多线程下，一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式。</code></pre><h4 id="第四种写法（懒汉式-线程安全、同步方法）"><a href="#第四种写法（懒汉式-线程安全、同步方法）" class="headerlink" title="第四种写法（懒汉式 线程安全、同步方法）"></a>第四种写法（懒汉式 线程安全、同步方法）</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019/1/23 0023 * @Time: 9:01 * @Vsersion: 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingletonDemo04</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 单例的第四种写法     * 线程安全 同步方法     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> SingletonDemo04 singleton<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">SingletonDemo04</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> SingletonDemo04 <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingletonDemo04</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>    解决上面第三种实现方式的线程不安全问题，做个线程同步就可以了，于是就对getInstance()方法进行了线程同步。缺点：效率太低了，每个线程在想获得类的实例时候，执行getInstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接return就行了。方法进行同步效率太低要改进。</code></pre><h4 id="第五种写法（懒汉式-线程安全、同步代码块）"><a href="#第五种写法（懒汉式-线程安全、同步代码块）" class="headerlink" title="第五种写法（懒汉式 线程安全、同步代码块）"></a>第五种写法（懒汉式 线程安全、同步代码块）</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019/1/23 0023 * @Time: 9:04 * @Vsersion: 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingletonDemo05</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 第五种：懒汉式     * 线程安全 同步代码块 不可用     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> SingletonDemo05 singleton<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">SingletonDemo05</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> SingletonDemo05 <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>SingletonDemo05<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingletonDemo05</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>    由于第四种实现方式同步效率太低，所以摒弃同步方法，改为同步产生实例化的的代码块。但是这种同步并不能起到线程同步的作用。跟第3种实现方式遇到的情形一致，假如一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。</code></pre><h4 id="第六种写法（双重检查-推荐使用）"><a href="#第六种写法（双重检查-推荐使用）" class="headerlink" title="第六种写法（双重检查  推荐使用）"></a>第六种写法（双重检查  推荐使用）</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019/1/23 0023 * @Time: 9:08 * @Vsersion: 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingletonDemo06</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 第六种：双重检查     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> SingletonDemo06 singleton<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">SingletonDemo06</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> SingletonDemo06 <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>SingletonDemo06<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingletonDemo06</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>    Double-Check概念对于多线程开发者来说不会陌生，如代码中所示，我们进行了两次if (singleton == null)检查，这样就可以保证线程安全了。这样，实例化代码只用执行一次，后面再次访问时，判断if (singleton == null)，直接return实例化对象。优点：线程安全；延迟加载；效率较高。</code></pre><h4 id="第七种写法（静态内部类-推荐使用）"><a href="#第七种写法（静态内部类-推荐使用）" class="headerlink" title="第七种写法（静态内部类    推荐使用）"></a>第七种写法（静态内部类    推荐使用）</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019/1/23 0023 * @Time: 9:11 * @Vsersion: 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingletonDemo07</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 静态内部类     */</span>    <span class="token keyword">private</span> <span class="token function">SingletonDemo07</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SingletonInstance</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> SingletonDemo07 INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingletonDemo07</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> SingletonDemo07 <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> SingletonInstance<span class="token punctuation">.</span>INSTANCE<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>    这种方式跟饿汉式方式采用的机制类似，但又有不同。两者都是采用了类装载的机制来保证初始化实例时只有一个线程。不同的地方在饿汉式方式是只要Singleton类被装载就会实例化，没有Lazy-Loading的作用，而静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化时，调用getInstance方法，才会装载SingletonInstance类，从而完成Singleton的实例化。    类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。优点：避免了线程不安全，延迟加载，效率高。</code></pre><h4 id="第八种写法（枚举-推荐用）"><a href="#第八种写法（枚举-推荐用）" class="headerlink" title="第八种写法（枚举 推荐用）"></a>第八种写法（枚举 推荐用）</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019/1/23 0023 * @Time: 9:14 * @Vsersion: 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingletonDemo08</span> <span class="token punctuation">{</span>    INSTANCE<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">whateverMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。可能是因为枚举在JDK1.5中才添加，所以在实际项目开发中，很少见人这么写过。优点系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能。缺点当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用new，可能会给其他开发人员造成困扰，特别是看不到源码的时候。适用场合需要频繁的进行创建和销毁的对象；创建对象时耗时过多或耗费资源过多，但又经常用到的对象；工具类对象；频繁访问数据库或文件的对象。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式，singleton </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http的各种状态</title>
      <link href="/2019/04/08/http-de-ge-chong-zhuang-tai/"/>
      <url>/2019/04/08/http-de-ge-chong-zhuang-tai/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h1><pre><code>HTTP状态码（HTTP Status Code）是用以表示网页服务器HTTP响应状态的3位数字代码。我们可以通过查看HTTP状态码来判断服务器状态，常见的有404 、502等；但是其他不是很常见的状态码都代表什么状态呢？下面有两张有趣的图片，让你瞬间都能理解了。</code></pre><p><img src="http的各种状态\Snipaste_2019-01-18_08-34-19.png" alt="Snipaste_2019-01-18_08-34-19"></p><pre><code>301—永久移动。被请求的资源已被永久移动位置；302—请求的资源现在临时从不同的 URI 响应请求；305—使用代理。被请求的资源必须通过指定的代理才能被访问；307—临时跳转。被请求的资源在临时从不同的URL响应请求；400—错误请求；402—需要付款。该状态码是为了将来可能的需求而预留的，用于一些数字货币或者是微支付；403—禁止访问。服务器已经理解请求，但是拒绝执行它；404—找不到对象。请求失败，资源不存在；406—不可接受的。请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体；</code></pre><p><img src="http的各种状态\Snipaste_2019-01-18_08-36-12.png" alt="Snipaste_2019-01-18_08-36-12"></p><pre><code>408—请求超时；409—冲突。由于和被请求的资源的当前状态之间存在冲突，请求无法完成；410—遗失的。被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址；413—响应实体太大。服务器拒绝处理当前请求，请求超过服务器所能处理和允许的最大值。417—期望失败。在请求头 Expect 中指定的预期内容无法被服务器满足；418—我是一个茶壶。超文本咖啡罐控制协议，但是并没有被实际的HTTP服务器实现；420—方法失效。422—不可处理的实体。请求格式正确，但是由于含有语义错误，无法响应；500—服务器内部错误。服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理；</code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> 状态码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty相关知识</title>
      <link href="/2019/04/08/netty-xiang-guan-zhi-shi/"/>
      <url>/2019/04/08/netty-xiang-guan-zhi-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="Netty相关知识"><a href="#Netty相关知识" class="headerlink" title="Netty相关知识"></a>Netty相关知识</h1><h4 id="1-Netty简介"><a href="#1-Netty简介" class="headerlink" title="1.Netty简介"></a>1.Netty简介</h4><pre><code>Netty是由JBOSS提供的一个java开源框架。    Netty是一个高性能、异步事件驱动的NIO框架，它提供了对TCP、UDP和文件传输的支持。作为当前最流行的NIO框架，Netty在互联网领域、大数据分布式计算领域、游戏行业、通信行业等获得了广泛的应用，一些业界著名的开源组件也基于Netty的NIO框架构建</code></pre><h4 id="2-Netty的特点"><a href="#2-Netty的特点" class="headerlink" title="2.Netty的特点"></a>2.Netty的特点</h4><h5 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h5><pre><code>Netty是一款基于NIO（Nonblocking I/O，非阻塞IO）开发的网络通信框架，对比于BIO（Blocking I/O，阻塞IO），他的并发性能得到了很大提高 。</code></pre><h5 id="传输快"><a href="#传输快" class="headerlink" title="传输快"></a>传输快</h5><pre><code>Netty的传输快其实也是依赖了NIO的一个特性——零拷贝。</code></pre><h5 id="封装好"><a href="#封装好" class="headerlink" title="封装好"></a>封装好</h5><pre><code>Netty封装了NIO操作的很多细节，提供易于使用的API。</code></pre><h4 id="3-为什么选择Netty"><a href="#3-为什么选择Netty" class="headerlink" title="3.为什么选择Netty"></a>3.为什么选择Netty</h4><pre><code>JDK 原生也有一套网络应用程序 API，但是存在一系列问题，主要如下：1）NIO 的类库和 API 繁杂，使用麻烦：你需要熟练掌握 Selector、ServerSocketChannel、SocketChannel、ByteBuffer 等。2）需要具备其他的额外技能做铺垫：例如熟悉 Java 多线程编程，因为 NIO 编程涉及到 Reactor 模式，你必须对多线程和网路编程非常熟悉，才能编写出高质量的 NIO 程序。3）可靠性能力补齐，开发工作量和难度都非常大：例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常码流的处理等等。NIO 编程的特点是功能开发相对容易，但是可靠性能力补齐工作量和难度都非常大。4）JDK NIO 的 Bug：例如臭名昭著的 Epoll Bug，它会导致 Selector 空轮询，最终导致 CPU 100%。官方声称在 JDK 1.6 版本的 update 18 修复了该问题，但是直到 JDK 1.7 版本该问题仍旧存在，只不过该 Bug 发生概率降低了一些而已，它并没有被根本解决。</code></pre><h4 id="4-Netty框架的优势"><a href="#4-Netty框架的优势" class="headerlink" title="4.Netty框架的优势"></a>4.Netty框架的优势</h4><pre><code>API使用简单，开发门槛低；功能强大，预置了多种编解码功能，支持多种主流协议；定制能力强，可以通过ChannelHandler对通信框架进行灵活地扩展；性能高，通过与其他业界主流的NIO框架对比，Netty的综合性能最优；成熟、稳定，Netty修复了已经发现的所有JDK NIO BUG，业务开发人员不需要再为NIO的BUG而烦恼；社区活跃，版本迭代周期短，发现的BUG可以被及时修复，同时，更多的新功能会加入；经历了大规模的商业应用考验，质量得到验证。在互联网、大数据、网络游戏、企业应用、电信软件等众多行业得到成功商用，证明了它已经完全能够满足不同行业的商业应用了。</code></pre><h4 id="5-Netty的架构设计"><a href="#5-Netty的架构设计" class="headerlink" title="5.Netty的架构设计"></a>5.Netty的架构设计</h4><h5 id="总体结构"><a href="#总体结构" class="headerlink" title="总体结构"></a>总体结构</h5><p>Netty 采用了比较典型的三层网络架构进行设计，逻辑架构图如下所示：</p><p><img src="//zongmansheng.club/2019/04/08/netty-xiang-guan-zhi-shi/002.png" alt="002"></p><pre><code>1）传输服务：支持 BIO 和 NIO；2）容器集成：支持 OSGI、JBossMC、Spring、Guice 容器；3）协议支持：HTTP、Protobuf、二进制、文本、WebSocket 等一系列常见协议都支持。还支持通过实行编码解码逻辑来实现自定义协议；4）Core 核心：可扩展事件模型、通用通信 API、支持零拷贝的 ByteBuf 缓冲对象。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 日常学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap</title>
      <link href="/2019/04/07/hashmap/"/>
      <url>/2019/04/07/hashmap/</url>
      
        <content type="html"><![CDATA[<h1 id="HashMap简介"><a href="#HashMap简介" class="headerlink" title="HashMap简介"></a>HashMap简介</h1><pre><code>HashMap 主要用来存放键值对，它基于哈希表的Map接口实现&lt;/font&gt;，是常用的Java集合之一。 JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树，以减少搜索时间。</code></pre><h2 id="底层数据结构分析"><a href="#底层数据结构分析" class="headerlink" title="底层数据结构分析"></a>底层数据结构分析</h2><h4 id="JDK1-8之前"><a href="#JDK1-8之前" class="headerlink" title="JDK1.8之前"></a>JDK1.8之前</h4><pre><code>JDK1.8 之前 HashMap 底层是 数组和链表 结合在一起使用也就是 链表散列。HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash  值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。JDK 1.8 HashMap 的 hash 方法源码:JDK 1.8 的 hash方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。</code></pre><pre class=" language-java"><code class="language-java">  <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> h<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// key.hashCode()：返回散列值也就是hashcode</span>        <span class="token comment" spellcheck="true">// ^ ：按位异或</span>        <span class="token comment" spellcheck="true">// >>>:无符号右移，忽略符号位，空位都以0补齐</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>对比一下 JDK1.7的 HashMap 的 hash 方法源码.</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// This function ensures that hashCodes that differ only by</span>    <span class="token comment" spellcheck="true">// constant multiples at each bit position have a bounded</span>    <span class="token comment" spellcheck="true">// number of collisions (approximately 8 at default load factor).</span>    h <span class="token operator">^=</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> h <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre><code>相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。所谓 “拉链法” 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</code></pre><p><img src="//zongmansheng.club/2019/04/07/hashmap/001.png" alt="001"></p><h4 id="JDK1-8之后"><a href="#JDK1-8之后" class="headerlink" title="JDK1.8之后"></a>JDK1.8之后</h4><pre><code>    相比于之前的版本，jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</code></pre><p><img src="//zongmansheng.club/2019/04/07/hashmap/002.png" alt="002"></p><p>类的属性：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractMap</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Map</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">,</span> Cloneable<span class="token punctuation">,</span> Serializable <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 序列号</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 362498820763181265L<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 默认的初始容量是16</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_INITIAL_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 最大容量</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAXIMUM_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 默认的填充因子</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">float</span> DEFAULT_LOAD_FACTOR <span class="token operator">=</span> <span class="token number">0.75f</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 当桶(bucket)上的结点数大于这个值时会转成红黑树</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 当桶(bucket)上的结点数小于这个值时树转链表</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> UNTREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 桶中结构转化为红黑树对应的table的最小大小</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MIN_TREEIFY_CAPACITY <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 存储元素的数组，总是2的幂次倍</span>    <span class="token keyword">transient</span> Node<span class="token operator">&lt;</span>k<span class="token punctuation">,</span>v<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 存放具体元素的集</span>    <span class="token keyword">transient</span> Set<span class="token operator">&lt;</span>map<span class="token punctuation">.</span>entry<span class="token operator">&lt;</span>k<span class="token punctuation">,</span>v<span class="token operator">>></span> entrySet<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 存放元素的个数，注意这个不等于数组的长度。</span>    <span class="token keyword">transient</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 每次扩容和更改map结构的计数器</span>    <span class="token keyword">transient</span> <span class="token keyword">int</span> modCount<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容</span>    <span class="token keyword">int</span> threshold<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 填充因子</span>    <span class="token keyword">final</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre><code>- loadFactor加载因子  loadFactor加载因子是控制数组存放数据的疏密程度，loadFactor越趋近于1，那么   数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，load   Factor越小，也就是趋近于0，  loadFactor太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor的默认值为0.75f是官方给出的一个比较好的临界值。   给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 = 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。- threshold  threshold = capacity * loadFactor，当Size&gt;=threshold的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是 衡量数组是否需要扩增的一个标准。</code></pre><p>Node节点类源码:</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 继承自 Map.Entry&lt;K,V></span><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token punctuation">{</span>       <span class="token keyword">final</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 哈希值，存放元素到hashmap中时用来与其他元素hash值比较</span>       <span class="token keyword">final</span> K key<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//键</span>       V value<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//值</span>       <span class="token comment" spellcheck="true">// 指向下一个节点</span>       Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">;</span>       <span class="token function">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>hash <span class="token operator">=</span> hash<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> K <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span> <span class="token keyword">return</span> key<span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> V <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span> <span class="token keyword">return</span> value<span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> key <span class="token operator">+</span> <span class="token string">"="</span> <span class="token operator">+</span> value<span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 重写hashCode()方法</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> Objects<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">^</span> Objects<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> V <span class="token function">setValue</span><span class="token punctuation">(</span>V newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>            V oldValue <span class="token operator">=</span> value<span class="token punctuation">;</span>            value <span class="token operator">=</span> newValue<span class="token punctuation">;</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 重写 equals() 方法</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token keyword">this</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token keyword">instanceof</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token operator">></span> e <span class="token operator">=</span> <span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">)</span>o<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>Objects<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                    Objects<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>树节点类源码:</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">TreeNode</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token punctuation">{</span>        TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> parent<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 父</span>        TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> left<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 左</span>        TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> right<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 右</span>        TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> prev<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// needed to unlink next upon deletion</span>        <span class="token keyword">boolean</span> red<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 判断颜色</span>        <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V val<span class="token punctuation">,</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">super</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 返回根节点</span>        <span class="token keyword">final</span> TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">root</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> r <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">,</span> p<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> r<span class="token punctuation">.</span>parent<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>                    <span class="token keyword">return</span> r<span class="token punctuation">;</span>                r <span class="token operator">=</span> p<span class="token punctuation">;</span>       <span class="token punctuation">}</span></code></pre><h2 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="HashMap源码分析"></a>HashMap源码分析</h2><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p><img src="//zongmansheng.club/2019/04/07/hashmap/003.png" alt="003"></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 默认构造函数。</span>    <span class="token keyword">public</span> More <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> DEFAULT_LOAD_FACTOR<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// all   other fields defaulted</span>     <span class="token punctuation">}</span>     <span class="token comment" spellcheck="true">// 包含另一个“Map”的构造函数</span>     <span class="token keyword">public</span> More <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">HashMap</span><span class="token punctuation">(</span>Map<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token operator">></span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> DEFAULT_LOAD_FACTOR<span class="token punctuation">;</span>         <span class="token function">putMapEntries</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//下面会分析到这个方法</span>     <span class="token punctuation">}</span>     <span class="token comment" spellcheck="true">// 指定“容量大小”的构造函数</span>     <span class="token keyword">public</span> More <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">this</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">,</span> DEFAULT_LOAD_FACTOR<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token comment" spellcheck="true">// 指定“容量大小”和“加载因子”的构造函数</span>     <span class="token keyword">public</span> More <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>             <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal initial capacity: "</span> <span class="token operator">+</span> initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">></span> MAXIMUM_CAPACITY<span class="token punctuation">)</span>             initialCapacity <span class="token operator">=</span> MAXIMUM_CAPACITY<span class="token punctuation">;</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>loadFactor <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> Float<span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span>loadFactor<span class="token punctuation">)</span><span class="token punctuation">)</span>             <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal load factor: "</span> <span class="token operator">+</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> loadFactor<span class="token punctuation">;</span>         <span class="token keyword">this</span><span class="token punctuation">.</span>threshold <span class="token operator">=</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span></code></pre><p>putMapEntries方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">putMapEntries</span><span class="token punctuation">(</span>Map<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token operator">></span> m<span class="token punctuation">,</span> <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> s <span class="token operator">=</span> m<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 判断table是否已经初始化</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>table <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// pre-size</span>            <span class="token comment" spellcheck="true">// 未初始化，s为m的实际元素个数</span>            <span class="token keyword">float</span> ft <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>s <span class="token operator">/</span> loadFactor<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1.0F</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ft <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token operator">?</span>                    <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>ft <span class="token operator">:</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 计算得到的t大于阈值，则初始化阈值</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">></span> threshold<span class="token punctuation">)</span>                threshold <span class="token operator">=</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 已初始化，并且m元素个数大于阈值，进行扩容处理</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">></span> threshold<span class="token punctuation">)</span>            <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 将m中的所有元素添加至HashMap中</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token operator">></span> e <span class="token operator">:</span> m<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            K key <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            V value <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> evict<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h4><pre><code>HashMap只提供了put用于添加元素，putVal方法只是给put方法调用的一个方法，并没有提供给用户使用。对putVal方法添加元素的分析如下：    - ①如果定位到的数组位置没有元素 就直接插入。    - ②如果定位到的数组位置有元素就和要插入的key比较，如果key相同就直接覆盖，如果key不相同，就判断p是否是一个树节点，如果是就调用e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)将元素添加进入。如果不是就遍历链表插入。</code></pre><p><img src="//zongmansheng.club/2019/04/07/hashmap/004.png" alt="004"></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">final</span> V <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span>                   <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// table未初始化或者长度为0，进行扩容</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>        tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 桶中已经存在元素</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span> K k<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">// 将第一个元素赋值给e，用e来记录</span>                e <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// hash值不相等，即key不相等；为红黑树结点</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// 放入树中</span>            e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 为链表结点</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 在链表最末插入结点</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 到达链表的尾部</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 在尾部插入新结点</span>                    p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 结点数量达到阈值，转化为红黑树</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">>=</span> TREEIFY_THRESHOLD <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// -1 for 1st</span>                        <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 跳出循环</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// 判断链表中结点的key值与插入的元素的key值是否相等</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token comment" spellcheck="true">// 相等，跳出循环</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span>                p <span class="token operator">=</span> e<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 表示在桶中找到key值、hash值与插入元素相等的结点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token comment" spellcheck="true">// 记录e的value</span>            V oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// onlyIfAbsent为false或者旧值为null</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> null<span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">//用新值替换旧值</span>                e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 访问后回调</span>            <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 返回旧值</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 结构性修改</span>    <span class="token operator">++</span>modCount<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 实际大小大于阈值则扩容</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">></span> threshold<span class="token punctuation">)</span>        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 插入后回调</span>    <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span> </code></pre><p><strong>我们再来对比一下 JDK1.7 put方法的代码</strong></p><p><strong>对于put方法的分析如下：</strong></p><ul><li>①如果定位到的数组位置没有元素 就直接插入。</li><li>②如果定位到的数组位置有元素，遍历以这个元素为头结点的链表，依次和插入的key比较，如果key相同就直接覆盖，不同就采用头插法插入元素。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>table <span class="token operator">==</span> EMPTY_TABLE<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token function">inflateTable</span><span class="token punctuation">(</span>threshold<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token function">putForNullKey</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> null<span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 先遍历</span>        Object k<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            V oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">recordAccess</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>         <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token function">addEntry</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 再插入</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">get</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">?</span> null <span class="token operator">:</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">final</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> first<span class="token punctuation">,</span> e<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span> K k<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>        <span class="token punctuation">(</span>first <span class="token operator">=</span> tab<span class="token punctuation">[</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 数组元素相等</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>first<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token comment" spellcheck="true">// always check first node</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> first<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> first<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 桶中不止一个节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> first<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 在树中get</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>first<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTreeNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 在链表中get</span>            <span class="token keyword">do</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> e<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="resize方法"><a href="#resize方法" class="headerlink" title="resize方法"></a>resize方法</h4><pre><code>    进行扩容，会伴随着一次重新hash分配，并且会遍历hash表中所有的元素，是非常耗时的。在编写程序中，要尽量避免resize。</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> oldTab <span class="token operator">=</span> table<span class="token punctuation">;</span>    <span class="token keyword">int</span> oldCap <span class="token operator">=</span> <span class="token punctuation">(</span>oldTab <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> oldTab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> oldThr <span class="token operator">=</span> threshold<span class="token punctuation">;</span>    <span class="token keyword">int</span> newCap<span class="token punctuation">,</span> newThr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">>=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token punctuation">{</span>            threshold <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>            <span class="token keyword">return</span> oldTab<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 没超过最大值，就扩充为原来的2倍</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newCap <span class="token operator">=</span> oldCap <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span> oldCap <span class="token operator">>=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span>            newThr <span class="token operator">=</span> oldThr <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// double threshold</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldThr <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// initial capacity was placed in threshold</span>        newCap <span class="token operator">=</span> oldThr<span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>         signifies using defaults        newCap <span class="token operator">=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">;</span>        newThr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>DEFAULT_LOAD_FACTOR <span class="token operator">*</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 计算新的resize上限</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newThr <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">float</span> ft <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>newCap <span class="token operator">*</span> loadFactor<span class="token punctuation">;</span>        newThr <span class="token operator">=</span> <span class="token punctuation">(</span>newCap <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span> ft <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>MAXIMUM_CAPACITY <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>ft <span class="token operator">:</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    threshold <span class="token operator">=</span> newThr<span class="token punctuation">;</span>    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"rawtypes"</span><span class="token punctuation">,</span><span class="token string">"unchecked"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTab <span class="token operator">=</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span>newCap<span class="token punctuation">]</span><span class="token punctuation">;</span>    table <span class="token operator">=</span> newTab<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldTab <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 把每个bucket都移动到新的buckets中</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> oldCap<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span>                    newTab<span class="token punctuation">[</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> <span class="token punctuation">(</span>newCap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>e<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> newTab<span class="token punctuation">,</span> j<span class="token punctuation">,</span> oldCap<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token punctuation">{</span>                     Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> loHead <span class="token operator">=</span> null<span class="token punctuation">,</span> loTail <span class="token operator">=</span> null<span class="token punctuation">;</span>                    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> hiHead <span class="token operator">=</span> null<span class="token punctuation">,</span> hiTail <span class="token operator">=</span> null<span class="token punctuation">;</span>                    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">;</span>                    <span class="token keyword">do</span> <span class="token punctuation">{</span>                        next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 原索引</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> oldCap<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">==</span> null<span class="token punctuation">)</span>                                loHead <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token keyword">else</span>                                loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>                            loTail <span class="token operator">=</span> e<span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        <span class="token comment" spellcheck="true">// 原索引+oldCap</span>                        <span class="token keyword">else</span> <span class="token punctuation">{</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">==</span> null<span class="token punctuation">)</span>                                hiHead <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token keyword">else</span>                                hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>                            hiTail <span class="token operator">=</span> e<span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 原索引放到bucket里</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>                        newTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> loHead<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token comment" spellcheck="true">// 原索引+oldCap放到bucket里</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>                        newTab<span class="token punctuation">[</span>j <span class="token operator">+</span> oldCap<span class="token punctuation">]</span> <span class="token operator">=</span> hiHead<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> newTab<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="HashMap常用方法测试"><a href="#HashMap常用方法测试" class="headerlink" title="HashMap常用方法测试"></a>HashMap常用方法测试</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> map<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Collection<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>HashMap<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Set<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashMapDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        HashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 键不能重复，值可以重复</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"san"</span><span class="token punctuation">,</span> <span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"si"</span><span class="token punctuation">,</span> <span class="token string">"李四"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"wu"</span><span class="token punctuation">,</span> <span class="token string">"王五"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"wang"</span><span class="token punctuation">,</span> <span class="token string">"老王"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"wang"</span><span class="token punctuation">,</span> <span class="token string">"老王2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 老王被覆盖</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"lao"</span><span class="token punctuation">,</span> <span class="token string">"老王"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"-------直接输出hashmap:-------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/**         * 遍历HashMap         */</span>        <span class="token comment" spellcheck="true">// 1.获取Map中的所有键</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"-------foreach获取Map中所有的键:------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Set<span class="token operator">&lt;</span>String<span class="token operator">></span> keys <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>String key <span class="token operator">:</span> keys<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>key<span class="token operator">+</span><span class="token string">"  "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//换行</span>        <span class="token comment" spellcheck="true">// 2.获取Map中所有值</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"-------foreach获取Map中所有的值:------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Collection<span class="token operator">&lt;</span>String<span class="token operator">></span> values <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>String value <span class="token operator">:</span> values<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>value<span class="token operator">+</span><span class="token string">"  "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//换行</span>        <span class="token comment" spellcheck="true">// 3.得到key的值的同时得到key所对应的值</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"-------得到key的值的同时得到key所对应的值:-------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Set<span class="token operator">&lt;</span>String<span class="token operator">></span> keys2 <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>String key <span class="token operator">:</span> keys2<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>key <span class="token operator">+</span> <span class="token string">"："</span> <span class="token operator">+</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"   "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">/**         * 另外一种不常用的遍历方式         */</span>        <span class="token comment" spellcheck="true">// 当我调用put(key,value)方法的时候，首先会把key和value封装到</span>        <span class="token comment" spellcheck="true">// Entry这个静态内部类对象中，把Entry对象再添加到数组中，所以我们想获取</span>        <span class="token comment" spellcheck="true">// map中的所有键值对，我们只要获取数组中的所有Entry对象，接下来</span>        <span class="token comment" spellcheck="true">// 调用Entry对象中的getKey()和getValue()方法就能获取键值对了</span>        Set<span class="token operator">&lt;</span>java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">>></span> entrys <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> entry <span class="token operator">:</span> entrys<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"--"</span> <span class="token operator">+</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">/**         * HashMap其他常用方法         */</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after map.size()："</span><span class="token operator">+</span>map<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after map.isEmpty()："</span><span class="token operator">+</span>map<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">"san"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after map.remove()："</span><span class="token operator">+</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after map.get(si)："</span><span class="token operator">+</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"si"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after map.containsKey(si)："</span><span class="token operator">+</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span><span class="token string">"si"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after containsValue(李四)："</span><span class="token operator">+</span>map<span class="token punctuation">.</span><span class="token function">containsValue</span><span class="token punctuation">(</span><span class="token string">"李四"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">"si"</span><span class="token punctuation">,</span> <span class="token string">"李四2"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after map.replace(si, 李四2):"</span><span class="token operator">+</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 日常学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆向工程</title>
      <link href="/2019/04/06/ni-xiang-gong-cheng/"/>
      <url>/2019/04/06/ni-xiang-gong-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="逆向工程"><a href="#逆向工程" class="headerlink" title="逆向工程"></a>逆向工程</h1><pre><code>日常开发中，逆向工程在我们的工作中用的非常普遍</code></pre><h4 id="generatorConfig-xml"><a href="#generatorConfig-xml" class="headerlink" title="generatorConfig.xml"></a>generatorConfig.xml</h4><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token doctype">&lt;!DOCTYPE generatorConfiguration        PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"        "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>generatorConfiguration</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>context</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>testTables<span class="token punctuation">"</span></span> <span class="token attr-name">targetRuntime</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>MyBatis3<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.mybatis.generator.plugins.SerializablePlugin<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>commentGenerator</span><span class="token punctuation">></span></span>            <span class="token comment" spellcheck="true">&lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>suppressAllComments<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>commentGenerator</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>jdbcConnection</span> <span class="token attr-name">driverClass</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.mysql.jdbc.Driver<span class="token punctuation">"</span></span>                        <span class="token attr-name">connectionURL</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jdbc:mysql://localhost:3306/shucangdb<span class="token punctuation">"</span></span> <span class="token attr-name">userId</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span>                        <span class="token attr-name">password</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>jdbcConnection</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- &lt;jdbcConnection driverClass="oracle.jdbc.OracleDriver"            connectionURL="jdbc:oracle:thin:@127.0.0.1:1521:yycg"            userId="yycg"            password="yycg">        &lt;/jdbcConnection> --></span>        <span class="token comment" spellcheck="true">&lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和            NUMERIC 类型解析为java.math.BigDecimal --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>javaTypeResolver</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>forceBigDecimals<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>javaTypeResolver</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- targetProject:生成PO类的位置 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>javaModelGenerator</span> <span class="token attr-name">targetPackage</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.xxxxxxxx<span class="token punctuation">"</span></span>                            <span class="token attr-name">targetProject</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>generator/src/main/java<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token comment" spellcheck="true">&lt;!-- enableSubPackages:是否让schema作为包的后缀 --></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>enableSubPackages<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>            <span class="token comment" spellcheck="true">&lt;!-- 从数据库返回的值被清理前后的空格 --></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>trimStrings<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>javaModelGenerator</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- targetProject:mapper映射文件生成的位置 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>sqlMapGenerator</span> <span class="token attr-name">targetPackage</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.xxxxxxxxxx<span class="token punctuation">"</span></span>                         <span class="token attr-name">targetProject</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>generator/src/main/java<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token comment" spellcheck="true">&lt;!-- enableSubPackages:是否让schema作为包的后缀 --></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>enableSubPackages<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>sqlMapGenerator</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- targetPackage：mapper接口生成的位置 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>javaClientGenerator</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>XMLMAPPER<span class="token punctuation">"</span></span>                             <span class="token attr-name">targetPackage</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.xxxxxxxx<span class="token punctuation">"</span></span>                             <span class="token attr-name">targetProject</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>generator/src/main/java<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token comment" spellcheck="true">&lt;!-- enableSubPackages:是否让schema作为包的后缀 --></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>enableSubPackages<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>javaClientGenerator</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 指定数据库表 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">tableName</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>xxxx<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>table</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">tableName</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>xxxx<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>table</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 有些表的字段需要指定java类型         &lt;table schema="" tableName="">            &lt;columnOverride column="" javaType="" />        &lt;/table> --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>context</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>generatorConfiguration</span><span class="token punctuation">></span></span></code></pre><h4 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h4><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0         http://maven.apache.org/xsd/maven-4.0.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modelVersion</span><span class="token punctuation">></span></span>4.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modelVersion</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.zms<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>generator<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.0-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span>                <span class="token comment" spellcheck="true">&lt;!-- 逆向工程--></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.mybatis.generator<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mybatis-generator-maven-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.3.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>mysql<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mysql-connector-java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>5.1.45<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>runtime<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.mybatis.generator<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mybatis-generator-core<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.3.7<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>                        <span class="token comment" spellcheck="true">&lt;!--配置文件的路径--></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configurationFile</span><span class="token punctuation">></span></span>${basedir}/src/main/resources/generatorConfig.xml<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configurationFile</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>overwrite</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>overwrite</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>verbose</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>verbose</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resources</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resource</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>directory</span><span class="token punctuation">></span></span>src/main/java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>directory</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--mapper--></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>includes</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span><span class="token punctuation">></span></span>**/*.properties<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>include</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span><span class="token punctuation">></span></span>**/*.xml<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>include</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>includes</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filtering</span><span class="token punctuation">></span></span>false<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filtering</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resource</span><span class="token punctuation">></span></span>                <span class="token comment" spellcheck="true">&lt;!-- 上面的配置导致src/main/resources的所有文件都不能被扫描，因此还要配多一个 --></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resource</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>directory</span><span class="token punctuation">></span></span>src/main/resources<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>directory</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>includes</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span><span class="token punctuation">></span></span>**/*.properties<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>include</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span><span class="token punctuation">></span></span>**/*.xml<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>include</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span><span class="token punctuation">></span></span>**/static/**<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>include</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span><span class="token punctuation">></span></span>**/*.js<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>include</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span><span class="token punctuation">></span></span>**/*.css<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>include</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span><span class="token punctuation">></span></span>**/*.json<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>include</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>includes</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filtering</span><span class="token punctuation">></span></span>false<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filtering</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resource</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resources</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>mysql<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mysql-connector-java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>5.1.46<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.mybatis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mybatis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.4.4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 日常学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis，mysql，generator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jdbc和mybatis的区别</title>
      <link href="/2019/04/05/jdbc-he-mybatis-de-qu-bie/"/>
      <url>/2019/04/05/jdbc-he-mybatis-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<h1 id="jdbc和mybatis的区别"><a href="#jdbc和mybatis的区别" class="headerlink" title="jdbc和mybatis的区别"></a>jdbc和mybatis的区别</h1><pre><code>mybatis也是基于JDBC的。Java与数据库操作仅能通过JDBC完成。 mybatis也要通过JDBC完成数据查询、更新这些动作。mybatis仅仅是在JDBC基础上做了，OO化、封装事务管理接口这些东西。</code></pre><p><img src="//zongmansheng.club/2019/04/05/jdbc-he-mybatis-de-qu-bie/001.png" alt="001"></p><pre><code>JDBC是地基,mybatis/Hibernate 是两栋外形各自有特点的楼房，楼房之间可以比较！地基就这一种。</code></pre><h4 id="传统JDBC操作数据"><a href="#传统JDBC操作数据" class="headerlink" title="传统JDBC操作数据"></a>传统JDBC操作数据</h4><pre><code>1.使用JDBC编程需要连接数据库，注册驱动和数据库信息2.操作Connection，打开 Statement 对象 。3.通过Statement执行SQL， 返回结果到ResultSet对象。4.使用ResultSet读取数据，然后通过代码转化为具体的POJO对象。5.关闭数据库的相关资源。</code></pre><h5 id="jdbc存在弊端："><a href="#jdbc存在弊端：" class="headerlink" title="jdbc存在弊端："></a>jdbc存在弊端：</h5><pre><code>1.工作量相对较大，每次都要去创建，关闭，获取2.JDBC编程可能产生的异常进行捕捉处理并正确关闭资源</code></pre><h4 id="对象关系映射（Object-Relational-Mapping）简称-ORM"><a href="#对象关系映射（Object-Relational-Mapping）简称-ORM" class="headerlink" title="对象关系映射（Object Relational Mapping）简称 ORM"></a>对象关系映射（Object Relational Mapping）简称 ORM</h4><pre><code>ORM模型就是数据库的表和简单Java对象（Plain Ordinary Java Object，简称POJO）的映射关系模型。</code></pre><pre><code>ORM模型提供了统一的规则使得数据库的数据通过配置便可轻易的映射到POJO上</code></pre><h4 id="常见的有两种"><a href="#常见的有两种" class="headerlink" title="常见的有两种"></a>常见的有两种</h4><h5 id="mybatis"><a href="#mybatis" class="headerlink" title="mybatis"></a>mybatis</h5><pre><code>1.易于上手和掌握。2.sql写在xml里，便于统一管理和优化。3.解除sql与程序代码的耦合。4.提供映射标签，支持对象与数据库的orm字段关系映射5.提供对象关系映射标签，支持对象关系组建维护6.提供xml标签，支持编写动态sql。</code></pre><h5 id="hibernate"><a href="#hibernate" class="headerlink" title="hibernate"></a>hibernate</h5><pre><code>1.消除了代码的映射规则，它全部被分离到XML或者注解里面去配置。2.无需再管理数据库连接，它也配置到XML里面。3.一个会话中，不要操作多个对象，只要操作Sesison即可。4.关闭资源只需要关闭一个Session即可。</code></pre><h4 id="Mybatis常见的面试题"><a href="#Mybatis常见的面试题" class="headerlink" title="Mybatis常见的面试题"></a>Mybatis常见的面试题</h4><h5 id="1-和-的区别是什么？"><a href="#1-和-的区别是什么？" class="headerlink" title="1. #{}和${}的区别是什么？"></a>1. #{}和${}的区别是什么？</h5><pre><code>#{}是预编译处理，${}是字符串替换。Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；Mybatis在处理${}时，就是把${}替换成变量的值。使用#{}可以有效的防止SQL注入，提高系统安全性。在我们日常开发中，能用#的地方都尽量用#。</code></pre><h5 id="2-通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？"><a href="#2-通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？" class="headerlink" title="2. 通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？"></a>2. 通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？</h5><p><img src="//zongmansheng.club/2019/04/05/jdbc-he-mybatis-de-qu-bie/002.png" alt="002"></p><p><img src="//zongmansheng.club/2019/04/05/jdbc-he-mybatis-de-qu-bie/003.png" alt="003"></p><pre><code>    Dao接口，就是人们常说的Mapper接口，接口的全限名，就是映射文件中的namespace的值，接口的方法名，就是映射文件中MappedStatement的id值，接口方法内的参数，就是传递给sql的参数。Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MappedStatement，举例：com.mybatis3.mappers.StudentDao.findStudentById，可以唯一找到namespace为com.mybatis3.mappers.StudentDao下面id = findStudentById的MappedStatement。在Mybatis中，每一个&lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;标签，都会被解析为一个MappedStatement对象。Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。    Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。</code></pre><h4 id="3-Mybatis是如何进行分页的？分页插件的原理是什么？"><a href="#3-Mybatis是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="3. Mybatis是如何进行分页的？分页插件的原理是什么？"></a>3. Mybatis是如何进行分页的？分页插件的原理是什么？</h4><pre><code>    Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页，可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。    分页插件(pagehelper)的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。</code></pre><h5 id="4-Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"><a href="#4-Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？" class="headerlink" title="4. Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"></a>4. Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？</h5><pre><code>    第一种是使用&lt;resultMap&gt;标签，逐一定义列名和对象属性名之间的映射关系。第二种是使用sql列的别名功能，将列别名书写为对象属性名，比如T_NAME AS NAME，对象属性名一般是name，小写，但是列名不区分大小写，Mybatis会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成T_NAME AS NaMe，Mybatis一样可以正常工作。    有了列名与属性名的映射关系后，Mybatis通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</code></pre><h5 id="5-Xml映射文件中，除了常见的select-insert-update-delete标签之外，还有哪些标签？"><a href="#5-Xml映射文件中，除了常见的select-insert-update-delete标签之外，还有哪些标签？" class="headerlink" title="5. Xml映射文件中，除了常见的select|insert|update|delete标签之外，还有哪些标签？"></a>5. Xml映射文件中，除了常见的select|insert|update|delete标签之外，还有哪些标签？</h5><pre><code>还有很多其他的标签，加上动态sql的9个标签，trim|where|set|foreach|if|choose|when|otherwise|bind等，其中为sql片段标签，通过标签引入sql片段，为不支持自增的主键生成策略标签。</code></pre><h5 id="6-简述Mybatis的插件运行原理，以及如何编写一个插件"><a href="#6-简述Mybatis的插件运行原理，以及如何编写一个插件" class="headerlink" title="6. 简述Mybatis的插件运行原理，以及如何编写一个插件"></a>6. 简述Mybatis的插件运行原理，以及如何编写一个插件</h5><pre><code>    Mybatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler、Executor这4种接口的插件，Mybatis使用JDK的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是InvocationHandler的invoke()方法，当然，只会拦截那些你指定需要拦截的方法。实现Mybatis的Interceptor接口并复写intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，还需要在配置文件中配置你编写的插件。</code></pre><h5 id="7-一级、二级缓存"><a href="#7-一级、二级缓存" class="headerlink" title="7. 一级、二级缓存"></a>7. 一级、二级缓存</h5><pre><code>1）一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空。2）二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。要开启二级缓存，你需要在你的 SQL 映射文件中添加一行：&lt;cache/&gt;3）对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</code></pre><h5 id="8-Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#8-Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="8. Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？"></a>8. Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？</h5><pre><code>    Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。    它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。</code></pre><h5 id="9-Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？"><a href="#9-Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？" class="headerlink" title="9. Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？"></a>9. Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？</h5><pre><code>    虽然Mybatis解析Xml映射文件是按照顺序解析的，但是，被引用的B标签依然可以定义在任何地方，Mybatis都可以正确识别。    原理是，Mybatis解析A标签，发现A标签引用了B标签，但是B标签尚未解析到，尚不存在，此时，Mybatis会将A标签标记为未解析状态，然后继续解析余下的标签，包含B标签，待所有标签解析完毕，Mybatis会重新解析那些被标记为未解析的标签，此时再解析A标签时，B标签已经存在，A标签也就可以正常解析完成了。</code></pre><h5 id="10-简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？"><a href="#10-简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？" class="headerlink" title="10. 简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？"></a>10. 简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？</h5><pre><code>    Mybatis将所有Xml配置信息都封装到All-In-One重量级对象Configuration内部。在Xml映射文件中，&lt;parameterMap&gt;标签会被解析为ParameterMap对象，其每个子元素会被解析为ParameterMapping对象。&lt;resultMap&gt;标签会被解析为ResultMap对象，其每个子元素会被解析为ResultMapping对象。每一个&lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;标签均会被解析为MappedStatement对象，标签内的sql会被解析为BoundSql对象。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 日常学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jdbc </tag>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解JDK、JRE、JVM</title>
      <link href="/2019/04/02/xiang-jie-jdk-jre-jvm/"/>
      <url>/2019/04/02/xiang-jie-jdk-jre-jvm/</url>
      
        <content type="html"><![CDATA[<h1 id="详解JDK-JRE-JVM之间的区别与联系"><a href="#详解JDK-JRE-JVM之间的区别与联系" class="headerlink" title="详解JDK JRE JVM之间的区别与联系"></a>详解JDK JRE JVM之间的区别与联系</h1><p><img src="//zongmansheng.club/2019/04/02/xiang-jie-jdk-jre-jvm/001.png" alt="001"></p><h4 id="一、JDK（Java-Development-ToolKit）Java开发工具"><a href="#一、JDK（Java-Development-ToolKit）Java开发工具" class="headerlink" title="一、JDK（Java Development ToolKit）Java开发工具"></a>一、JDK（Java Development ToolKit）Java开发工具</h4><pre><code>    JDK包含了jre，它除了包含jre之外还包含了一些javac的工具类，把java源文件编译成class文件，java文件是用来运行这个程序的。除此之外，里边还包含了java源生的API等。</code></pre><h5 id="JDK常用的包："><a href="#JDK常用的包：" class="headerlink" title="JDK常用的包："></a>JDK常用的包：</h5><pre><code>java.lang：这个是系统的基础类，比如：String，Math,Integer,system,thread提供常用的功能。Java.io这里面是所用输入输出有关的类，比如:文件操作。java.net:这里面是与网络有关的类，比如URL,URLVonnection等。Java.util：这个是系统辅助类，特别是集合类conllection,list,map等。Java.sql:这个是数据操作的类，connection，statememt,resultset等。JDK有以下三种版本：J2SE，standard edition，标准版；J2EE，enterpsise edtion，企业版；J2ME，micro edtion，主要用于移动设备上的java应用程序总之，JDK是整个JAVA的核心，包括了Java运行环境（Java Runtime Envirnment），一堆Java工具（javac/java/jdb等）和Java基础的类库（即Java API 包括rt.jar）。</code></pre><h4 id="二、JRE（Java-Runtime-Enviroment）Java运行环境"><a href="#二、JRE（Java-Runtime-Enviroment）Java运行环境" class="headerlink" title="二、JRE（Java Runtime Enviroment）Java运行环境"></a>二、JRE（Java Runtime Enviroment）Java运行环境</h4><pre><code>JRE包含JVMJRE，是为了保证java程序能够运行时，所必备的一基础环境，也就是它只是保证java程序运行的，不能用来开发，而jdk才是用来开发的，而想要开发Java，必须包含能够运行的环境，因此，JDK是包含JVM的。并且所有的Java程序都要在JRE下才能运行。</code></pre><pre><code>JDK包括JVM和JAVA核心类库和支持文件。与JDK相比，它不包含开发工具——编译器、调试器和其它工具。</code></pre><h4 id="三、JVM（Java-Virtual-Mechine）Java虚拟机"><a href="#三、JVM（Java-Virtual-Mechine）Java虚拟机" class="headerlink" title="三、JVM（Java Virtual Mechine）Java虚拟机"></a>三、JVM（Java Virtual Mechine）Java虚拟机</h4><pre><code>    JRE是Java运行时环境，Java运行靠的就是底层的依赖于JVM，即java虚拟机，Java虚拟机用来加载类文件，Java中之所以有跨平台的作用，JVM是按照不同的平台所写的，因此，Java具有跨平台性，但是JVM确实依赖于平台的。</code></pre><p><img src="//zongmansheng.club/2019/04/02/xiang-jie-jdk-jre-jvm/002.png" alt="002"></p><pre><code>    JVM是JRE的一部分，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。JVM 的主要工作是解释自己的指令集（即字节码）并映射到本地的 CPU 的指令集或 OS 的系统调用。Java语言是跨平台运行的，其实就是不同的操作系统，使用不同的JVM映射规则，让其与操作系统无关，完成了跨平台性。JVM 对上层的 Java 源文件是不关心的，它关注的只是由源文件生成的类文件（ class file）。类文件的组成包括 JVM 指令集，符号表以及一些补助信息。</code></pre><h4 id="JDK-JRE-JVM三者间的关系"><a href="#JDK-JRE-JVM三者间的关系" class="headerlink" title="JDK,JRE,JVM三者间的关系"></a>JDK,JRE,JVM三者间的关系</h4><pre><code>    其实在JDK的安装目录下有一个名为jre的目录，里面有两个文件夹bin和lib，在这里可以认为bin里的就是jvm，lib中则是jvm工作所需要的类库。</code></pre><p><img src="//zongmansheng.club/2019/04/02/xiang-jie-jdk-jre-jvm/003.png" alt="003"></p><pre><code>本文部分转载头条@波波说运维</code></pre><pre><code>有兴趣的小伙伴可以关注我的博客，只要有时间每天更新！ </code></pre><p><a href="http://www.zongmansheng.club" target="_blank" rel="noopener">www.zongmansheng.club</a></p><p><img src="//zongmansheng.club/2019/04/02/xiang-jie-jdk-jre-jvm/004.gif" alt="004"></p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDK </tag>
            
            <tag> JRK </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web.xml组件加载顺序</title>
      <link href="/2019/04/02/web-xml-zu-jian-jia-zai-shun-xu/"/>
      <url>/2019/04/02/web-xml-zu-jian-jia-zai-shun-xu/</url>
      
        <content type="html"><![CDATA[<h1 id="Java的web-xml组件加载顺序"><a href="#Java的web-xml组件加载顺序" class="headerlink" title="Java的web.xml组件加载顺序"></a>Java的web.xml组件加载顺序</h1><pre><code>在我们日常开发中，配置项目组件可以说是家常便饭，了解Tomcat加载组件顺序很有必要。例如：    Quartz的集群功能需要数据库的支持，数据库的加载肯定要在框架组件加载之前。</code></pre><pre><code>web.xm组件加载顺序为：context-param -&gt; listener -&gt; filter -&gt; servlet(同类则按编写顺序执行)。</code></pre><p><strong>web.xml常用组件解析：</strong> </p><pre><code>&lt;web-app&gt;&lt;display-name&gt;&lt;/display-name&gt;WEB应用的名字&lt;description&gt;&lt;/description&gt; WEB应用的描述&lt;context-param&gt;&lt;/context-param&gt; context-param元素声明应用范围内的初始化参数&lt;!– 指定spring配置文件位置 –&gt;&lt;context-param&gt;&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;&lt;param-value&gt;&lt;!–加载多个spring配置文件 –&gt;/WEB-INF/applicationContext.xml, /WEB-INF/action-servlet.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;filter&gt;&lt;/filter&gt; 过滤器将一个名字与一个实现javax.servlet.Filter接口的类相关联&lt;filter-mapping&gt;&lt;/filter-mapping&gt; 一旦命名了一个过滤器，就要利用filter-mapping元素把它与一个或多个servlet或JSP页面相关联&lt;listener&gt;&lt;/listener&gt; 事件监听程序在建立、修改和删除会话或servlet环境时得到通知。Listener元素指出事件监听程序类。如Log4j这个广泛使用的监听和&lt;!– 定义SPRING监听器，加载spring –&gt;&lt;listener&gt;&lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;servlet&gt;&lt;/servlet&gt; 在向servlet或JSP页面制定初始化参数或定制URL时，必须首先命名servlet或JSP页面。Servlet元素就是用来完成此项任务的。&lt;servlet-mapping&gt;&lt;/servlet-mapping&gt; 服务器一般为servlet提供一个缺省的URL：http://host/webAppPrefix/servlet/ServletName。但是，常常会更改这个URL，以便servlet可以访问初始化参数或更容易地处理相对URL。在更改缺省URL时，使用servlet-mapping元素&lt;session-config&gt;&lt;/session-config&gt; 如果某个会话在一定时间内未被访问，服务器可以抛弃它以节省内存。 可通过使用HttpSession的setMaxInactiveInterval方法明确设置单个会话对象的超时值，或者可利用session-config元素制定缺省超时值&lt;mime-mapping&gt;&lt;/mime-mapping&gt;如果Web应用具有想到特殊的文件，希望能保证给他们分配特定的MIME类型，则mime-mapping元素提供这种保证&lt;welcome-file-list&gt;&lt;/welcome-file-list&gt; 指示服务器在收到引用一个目录名而不是文件名的URL时，使用哪个文件(其实就是欢迎界面或者说入口界面一般为index.*)&lt;error-page&gt;&lt;/error-page&gt; 在返回特定HTTP状态代码时，或者特定类型的异常被抛出时，能够制定将要显示的页面。&lt;taglib&gt;&lt;/taglib&gt; 对标记库描述符文件（Tag Libraryu Descriptor file）指定别名。此功能使你能够更改TLD文件的位置， 而不用编辑使用这些文件的JSP页面。&lt;resource-env-ref&gt;&lt;/resource-env-ref&gt;声明与资源相关的一个管理对象。&lt;resource-ref&gt;&lt;/resource-ref&gt; 声明一个资源工厂使用的外部资源。&lt;security-constraint&gt;&lt;/security-constraint&gt; 制定应该保护的URL。它与login-config元素联合使用&lt;login-config&gt;&lt;/login-config&gt; 指定服务器应该怎样给试图访问受保护页面的用户授权。它与sercurity-constraint元素联合使用。&lt;security-role&gt;&lt;/security-role&gt;给出安全角色的一个列表，这些角色将出现在servlet元素内的security-role-ref元素的role-name子元素中。分别地声明角色可使高级IDE处理安全信息更为容易&lt;env-entry&gt;&lt;/env-entry&gt;声明Web应用的环境项&lt;/web-app&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> web基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xml </tag>
            
            <tag> 配置文件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库索引</title>
      <link href="/2019/04/01/shu-ju-ku-suo-yin/"/>
      <url>/2019/04/01/shu-ju-ku-suo-yin/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h1><h4 id="一、索引"><a href="#一、索引" class="headerlink" title="一、索引"></a>一、索引</h4><pre><code>    索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。如果想按特定职员的姓来查找他或她，则与在表中搜索所有的行相比，索引有助于更快地获取信息。    索引的一个主要目的就是加快检索表中数据，亦即能协助信息搜索者尽快的找到符合限制条件的记录ID的辅助数据结构。</code></pre><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><pre><code>搜索码。它表示的是记录各种字符段的一个集合，它可以是一个或者是多个字符段的任意序列组合，并不是惟一的一个标识记录。数据目录项。即为索引的相关元素，在建立索引的过程中，数据目录项一般具有各种不同的选择方式。记录ID。每一个/段索引在存储内容中惟一的一个标识符。</code></pre><h5 id="主要种类"><a href="#主要种类" class="headerlink" title="主要种类"></a>主要种类</h5><pre><code>数据库索引好比是一本书前面的目录，能加快数据库的查询速度。索引分为聚簇索引和非聚簇索引两种，聚簇索引 是按照数据存放的物理位置为顺序的，而非聚簇索引就不一样了；聚簇索引能提高多行检索的速度，而非聚簇索引对于单行的检索很快。根据数据库的功能，可以在数据库设计器中创建三种索引：唯一索引、主键索引和聚集索引。有关数据库所支持的索引功能的详细信息，请参见数据库文档。提示：尽管唯一索引有助于定位信息，但为获得最佳性能结果，建议改用主键或唯一约束。</code></pre><h5 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h5><pre><code>    唯一索引是不允许其中任何两行具有相同索引值的索引。当现有数据中存在重复的键值时，大多数数据库不允许将新创建的唯一索引与表一起保存。数据库还可能防止添加将在表中创建重复键值的新数据。例如，如果在employee表中职员的姓(lname)上创建了唯一索引，则任何两个员工都不能同姓。</code></pre><h5 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h5><pre><code>    数据库表经常有一列或多列组合，其值唯一标识表中的每一行。该列称为表的主键。在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。</code></pre><h5 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h5><pre><code>    在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。聚集索引和非聚集索引的区别，如字典默认按字母顺序排序，读者如知道某个字的读音可根据字母顺序快速定位。因此聚集索引和表的内容是在一起的。如读者需查询某个生僻字，则需按字典前面的索引，举例按偏旁进行定位，找到该字对应的页数，再打开对应页数找到该字。这种通过两个地方而查询到某个字的方式就如非聚集索引。</code></pre><h5 id="索引列"><a href="#索引列" class="headerlink" title="索引列"></a>索引列</h5><pre><code>    可以基于数据库表中的单列或多列创建索引。多列索引可以区分其中一列可能有相同值的行。如果经常同时搜索两列或多列或按两列或多列排序时，索引也很有帮助。例如，如果经常在同一查询中为姓和名两列设置判据，那么在这两列上创建多列索引将很有意义。    检查查询的WHERE和JOIN子句。在任一子句中包括的每一列都是索引可以选择的对象。对新索引进行试验以检查它对运行查询性能的影响。考虑已在表上创建的索引数量。最好避免在单个表上有很多索引。检查已在表上创建的索引的定义。最好避免包含共享列的重叠索引。    检查某列中唯一数据值的数量，并将该数量与表中的行数进行比较。比较的结果就是该列的可选择性，这有助于确定该列是否适合建立索引，如果适合，确定索引的类型。</code></pre><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><pre><code>通过建立索引可以极大地提高在数据库中获取所需信息的速度，同时还能提高服务器处理相关搜索请求的效率，从这个方面来看它具有以下优点 [1]  ：    在设计数据库时，通过创建一个惟一的索引，能够在索引和信息之间形成一对一的映射式的对应关系，增加数据的惟一性特点。    能提高数据的搜索及检索速度，符合数据库建立的初衷。    能够加快表与表之间的连接速度，这对于提高数据的参考完整性方面具有重要作用。    在信息检索过程中，若使用分组及排序子句进行时，通过建立索引能有效的减少检索过程中所需的分组及排序时间，提高检索效率。建立索引之后，在信息查询过程中可以使用优化隐藏器，这对于提高整个信息检索系统的性能具有重要意义。</code></pre><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点:"></a>缺点:</h5><pre><code>虽然索引的建立在提高检索效率方面具有诸多积极的作用，但还是存在下列缺点 [1]  ：在数据库建立过程中，需花费较多的时间去建立并维护索引，特别是随着数据总量的增加，所花费的时间将不断递增。在数据库中创建的索引需要占用一定的物理存储空间，这其中就包括数据表所占的数据空间以及所创建的每一个索引所占用的物理空间，如果有必要建立起聚簇索引，所占用的空间还将进一步的增加在对表中的数据进行修改时，例如对其进行增加、删除或者是修改操作时，索引还需要进行动态的维护，这给数据库的维护速度带来了一定的麻烦。</code></pre><h5 id="数据库索引的数据结构基础-B-tree"><a href="#数据库索引的数据结构基础-B-tree" class="headerlink" title="数据库索引的数据结构基础 B+tree"></a>数据库索引的数据结构基础 B+tree</h5><pre><code>B＋tree 是一个n叉树，每个节点有多个叶子节点，一颗B+树包含根节点，内部节点，叶子节点。根节点可能是一个叶子节点，也可能是一个包含两个或两个以上叶子节点的节点。</code></pre><pre><code>B＋tree的性质：1.n棵子tree的节点包含n个关键字，不用来保存数据而是保存数据的索引。2.所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。3.所有的非终端结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。B＋tree结构原型图大概如下（引用）：</code></pre><p><img src="//zongmansheng.club/2019/04/01/shu-ju-ku-suo-yin/001.png" alt="001"></p><pre><code>    由于B+tree的性质， 它通常被用于数据库和操作系统的文件系统中。NTFS, ReiserFS, NSS, XFS, JFS, ReFS 和BFS等文件系统都在使用B+树作为元数据索引，因为B+ 树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度（B+ 树元素自底向上插入）。</code></pre><p>（二）数据库索引</p><pre><code>数据库索引是用于提高数据库表的数据访问速度的。数据库索引的特点：a）避免进行数据库全表的扫描，大多数情况，只需要扫描较少的索引页和数据页，而不是查询所有数据页。而且对于非聚集索引，有时不需要访问数据页即可得到数据。b）聚集索引可以避免数据插入操作，集中于表的最后一个数据页面。c）在某些情况下，索引可以避免排序操作。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql，索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM虚拟机</title>
      <link href="/2019/03/31/jvm-xu-ni-ji/"/>
      <url>/2019/03/31/jvm-xu-ni-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM虚拟机"><a href="#JVM虚拟机" class="headerlink" title="JVM虚拟机"></a>JVM虚拟机</h1><h4 id="一、运行时数据区域"><a href="#一、运行时数据区域" class="headerlink" title="一、运行时数据区域"></a>一、运行时数据区域</h4><p><img src="//zongmansheng.club/2019/03/31/jvm-xu-ni-ji/001.png" alt="001"></p><p><img src="//zongmansheng.club/2019/03/31/jvm-xu-ni-ji/002.png" alt="002"></p><h5 id="1-1-程序计数器"><a href="#1-1-程序计数器" class="headerlink" title="1.1 程序计数器"></a>1.1 程序计数器</h5><pre><code>记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）。</code></pre><h5 id="1-2-java虚拟机栈"><a href="#1-2-java虚拟机栈" class="headerlink" title="1.2 java虚拟机栈"></a>1.2 java虚拟机栈</h5><pre><code>    每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</code></pre><p><img src="//zongmansheng.club/2019/03/31/jvm-xu-ni-ji/003.png" alt="003"></p><pre><code>可以通过 -Xss 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小：    java -Xss512M HackTheJava</code></pre><p>该区域可能抛出以下异常：</p><pre><code>◾当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；◾栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。</code></pre><h5 id="1-3-本地方法栈"><a href="#1-3-本地方法栈" class="headerlink" title="1.3 本地方法栈"></a>1.3 本地方法栈</h5><pre><code>    本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。    本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。</code></pre><p><img src="//zongmansheng.club/2019/03/31/jvm-xu-ni-ji/004.png" alt="004"></p><h5 id="1-4-堆"><a href="#1-4-堆" class="headerlink" title="1.4 堆"></a>1.4 堆</h5><pre><code>    所有对象都在这里分配内存，是垃圾收集的主要区域（&quot;GC 堆&quot;）。    现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。可以将堆分成两块：</code></pre><pre><code>◾新生代（Young Generation）◾老年代（Old Generation）</code></pre><pre><code>堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。可以通过 -Xms 和 -Xmx 这两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。</code></pre><pre><code>java -Xms1M -Xmx2M HackTheJava</code></pre><h5 id="1-5-方法区"><a href="#1-5-方法区" class="headerlink" title="1.5 方法区"></a>1.5 方法区</h5><pre><code>用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。HotSpot 虚拟机把它当成永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。</code></pre><h5 id="1-6-运行时常量池"><a href="#1-6-运行时常量池" class="headerlink" title="1.6 运行时常量池"></a>1.6 运行时常量池</h5><pre><code>运行时常量池是方法区的一部分。Class 文件中的常量池（编译器生成的字面量和符号引用）会在类加载后被放入这个区域。除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。</code></pre><h5 id="1-7-直接内存"><a href="#1-7-直接内存" class="headerlink" title="1.7 直接内存"></a>1.7 直接内存</h5><pre><code>    在 JDK 1.4 中新引入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在堆内存和堆外内存来回拷贝数据。</code></pre><h4 id="二、垃圾收集"><a href="#二、垃圾收集" class="headerlink" title="二、垃圾收集"></a>二、垃圾收集</h4><pre><code>    垃圾收集主要是针对堆和方法区进行。程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收。</code></pre><h5 id="判断一个对象是否可被回收"><a href="#判断一个对象是否可被回收" class="headerlink" title="判断一个对象是否可被回收"></a><strong>判断一个对象是否可被回收</strong></h5><h6 id="2-1-引用计数算法"><a href="#2-1-引用计数算法" class="headerlink" title="2.1 引用计数算法"></a>2.1 引用计数算法</h6><pre><code>    为对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。    在两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。正是因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。</code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019/3/31 0031 * @Time: 21:38 * @Vsersion: 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestJvm</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> Object instance <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        TestJvm xxx <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TestJvm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        TestJvm yyy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TestJvm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        xxx<span class="token punctuation">.</span>instance <span class="token operator">=</span> yyy<span class="token punctuation">;</span>        yyy<span class="token punctuation">.</span>instance <span class="token operator">=</span> xxx<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h6 id="2-2-可达性分析算法"><a href="#2-2-可达性分析算法" class="headerlink" title="2.2  可达性分析算法"></a>2.2  可达性分析算法</h6><pre><code>以 GC Roots 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。Java 虚拟机使用该算法来判断对象是否可被回收，GC Roots 一般包含以下内容：</code></pre><pre><code>◾虚拟机栈中局部变量表中引用的对象◾本地方法栈中 JNI 中引用的对象◾方法区中类静态属性引用的对象◾方法区中的常量引用的对象</code></pre><p><img src="//zongmansheng.club/2019/03/31/jvm-xu-ni-ji/005.png" alt="005"></p><h6 id="2-3-方法区的回收"><a href="#2-3-方法区的回收" class="headerlink" title="2.3 方法区的回收"></a>2.3 方法区的回收</h6><pre><code>因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。主要是对常量池的回收和对类的卸载。为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能。类的卸载条件很多，需要满足以下三个条件，并且满足了条件也不一定会被卸载：</code></pre><pre><code>◾该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。◾加载该类的 ClassLoader 已经被回收。◾该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。</code></pre><h6 id="2-4-finalize"><a href="#2-4-finalize" class="headerlink" title="2.4 finalize()"></a>2.4 finalize()</h6><pre><code>类似 C++ 的析构函数，用于关闭外部资源。但是 try-finally 等方式可以做得更好，并且该方法运行代价很高，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会再调用该方法。</code></pre><p><strong>引用类型</strong></p><pre><code>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。Java 提供了四种强度不同的引用类型。</code></pre><ol><li><p>强引用</p><pre><code>被强引用关联的对象不会被回收。使用 new 一个新对象的方式来创建强引用。</code></pre><pre class=" language-java"><code class="language-java">Object obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>软引用</p><pre><code>被软引用关联的对象只有在内存不够的情况下才会被回收。使用 SoftReference 类来创建软引用。</code></pre><pre class=" language-java"><code class="language-java">Object obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>SoftReference<span class="token operator">&lt;</span>Object<span class="token operator">></span> softReference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//使对象只被软引用关联</span>obj <span class="token operator">=</span> null<span class="token punctuation">;</span></code></pre></li><li><p>弱引用</p><pre><code>被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。使用 WeakReference 类来创建弱引用。</code></pre><pre class=" language-java"><code class="language-java">Object obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>WeakReference<span class="token operator">&lt;</span>Object<span class="token operator">></span> weakReference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakReference</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>obj <span class="token operator">=</span> null<span class="token punctuation">;</span></code></pre></li><li><p>虚引用</p></li></ol><pre><code>又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。使用 PhantomReference 来创建虚引用。</code></pre><pre class=" language-java"><code class="language-java">Object obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>PhantomReference<span class="token operator">&lt;</span>Object<span class="token operator">></span> phantomReference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PhantomReference</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>obj <span class="token operator">=</span> null<span class="token punctuation">;</span></code></pre><h5 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h5><h6 id="1-标记-清除"><a href="#1-标记-清除" class="headerlink" title="1. 标记 - 清除"></a>1. 标记 - 清除</h6><p><img src="//zongmansheng.club/2019/03/31/jvm-xu-ni-ji/006.png" alt="006"></p><pre><code>标记要回收的对象，然后清除。不足：◾标记和清除过程效率都不高；◾会产生大量不连续的内存碎片，导致无法给大对象分配内存。</code></pre><h6 id="2-标记-整理"><a href="#2-标记-整理" class="headerlink" title="2. 标记 - 整理"></a>2. 标记 - 整理</h6><p><img src="//zongmansheng.club/2019/03/31/jvm-xu-ni-ji/007.png" alt="007"></p><pre><code>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</code></pre><h6 id="3-复制"><a href="#3-复制" class="headerlink" title="3. 复制"></a>3. 复制</h6><p><img src="//zongmansheng.club/2019/03/31/jvm-xu-ni-ji/008.png" alt="008"></p><pre><code>将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。主要不足是只使用了内存的一半。现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 就不够用了，此时需要依赖于老年代进行空间分配担保，也就是借用老年代的空间存储放不下的对象。</code></pre><h6 id="4-分代收集"><a href="#4-分代收集" class="headerlink" title="4. 分代收集"></a>4. 分代收集</h6><pre><code>现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。一般将堆分为新生代和老年代。◾新生代使用：复制算法老年代使用：标记 - 清除 或者 标记 - 整理 算法</code></pre><p><img src="//zongmansheng.club/2019/03/31/jvm-xu-ni-ji/009.png" alt="009"></p><pre><code>◾单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程；◾串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。</code></pre><h5 id="1-Serial-收集器"><a href="#1-Serial-收集器" class="headerlink" title="1. Serial 收集器"></a>1. Serial 收集器</h5><p><img src="//zongmansheng.club/2019/03/31/jvm-xu-ni-ji/010.png" alt="010"></p><pre><code>Serial 翻译为串行，也就是说它以串行的方式执行。它是单线程的收集器，只会使用一个线程进行垃圾收集工作。它的优点是简单高效，在单个 CPU 环境下，由于没有线程交互的开销，因此拥有最高的单线程收集效率。它是 Client 场景下的默认新生代收集器，因为在该场景下内存一般来说不会很大。它收集一两百兆垃圾的停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿时间是可以接受的。</code></pre><h5 id="2-ParNew-收集器"><a href="#2-ParNew-收集器" class="headerlink" title="2. ParNew 收集器"></a>2. ParNew 收集器</h5><p><img src="//zongmansheng.club/2019/03/31/jvm-xu-ni-ji/011.png" alt="011"></p><pre><code>它是 Serial 收集器的多线程版本。它是 Server 场景下默认的新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合使用。</code></pre><h5 id="3-Parallel-Scavenge-收集器"><a href="#3-Parallel-Scavenge-收集器" class="headerlink" title="3. Parallel Scavenge 收集器"></a>3. Parallel Scavenge 收集器</h5><pre><code>与 ParNew 一样是多线程收集器。其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，因此它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户程序的时间占总时间的比值。停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。可以通过一个开关参数打开 GC 自适应的调节策略（GC Ergonomics），就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例、晋升老年代对象年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。</code></pre><h5 id="4-Serial-Old-收集器"><a href="#4-Serial-Old-收集器" class="headerlink" title="4. Serial Old 收集器"></a>4. Serial Old 收集器</h5><p><img src="//zongmansheng.club/2019/03/31/jvm-xu-ni-ji/012.png" alt="012"></p><pre><code>是 Serial 收集器的老年代版本，也是给 Client 场景下的虚拟机使用。如果用在 Server 场景下，它有两大用途：◾在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。◾作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。</code></pre><h5 id="5-Parallel-Old-收集器"><a href="#5-Parallel-Old-收集器" class="headerlink" title="5. Parallel Old 收集器"></a>5. Parallel Old 收集器</h5><p><img src="//zongmansheng.club/2019/03/31/jvm-xu-ni-ji/013.png" alt="013"></p><pre><code>是 Parallel Scavenge 收集器的老年代版本。在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。</code></pre><h5 id="6-CMS-收集器"><a href="#6-CMS-收集器" class="headerlink" title="6. CMS 收集器"></a>6. CMS 收集器</h5><p><img src="//zongmansheng.club/2019/03/31/jvm-xu-ni-ji/014.png" alt="014"></p><pre><code>CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法。分为以下四个流程：◾初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。◾并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。◾重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。◾并发清除：不需要停顿。在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。具有以下缺点：◾吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。◾无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。◾标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。</code></pre><h5 id="7-G1-收集器"><a href="#7-G1-收集器" class="headerlink" title="7. G1 收集器"></a>7. G1 收集器</h5><pre><code>G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。</code></pre><p><img src="//zongmansheng.club/2019/03/31/jvm-xu-ni-ji/015.png" alt="015"></p><p><img src="//zongmansheng.club/2019/03/31/jvm-xu-ni-ji/016.png" alt="016"></p><pre><code>通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。</code></pre><p><img src="//zongmansheng.club/2019/03/31/jvm-xu-ni-ji/017.png" alt="017"></p><pre><code>如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：◾初始标记◾并发标记◾最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。◾筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。具备如下特点：◾空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。◾可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。</code></pre><h4 id="三、内存分配与回收策略"><a href="#三、内存分配与回收策略" class="headerlink" title="三、内存分配与回收策略"></a>三、内存分配与回收策略</h4><h5 id="Minor-GC-和-Full-GC"><a href="#Minor-GC-和-Full-GC" class="headerlink" title="Minor GC 和 Full GC"></a>Minor GC 和 Full GC</h5><pre><code>◾Minor GC：回收新生代上，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会  比较快。◾Full GC：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。</code></pre><h5 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h5><pre><code>1. 对象优先在 Eden 分配大多数情况下，对象在新生代 Eden 区分配，当 Eden 区空间不够时，发起 Minor GC。2. 大对象直接进入老年代大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 区和 Survivor 区之间的大量内存复制。3. 长期存活的对象进入老年代为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。-XX:MaxTenuringThreshold 用来定义年龄的阈值。4. 动态对象年龄判定虚拟机并不是永远地要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。5. 空间分配担保在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。如果不成立的话虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 设置不允许冒险，那么就要进行一次 Full GC。</code></pre><h5 id="Full-GC-的触发条件"><a href="#Full-GC-的触发条件" class="headerlink" title="Full GC 的触发条件"></a>Full GC 的触发条件</h5><pre><code>对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件：1. 调用 System.gc()只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。2. 老年代空间不足老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。3. 空间分配担保失败使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。具体内容请参考上面的第五小节。4. JDK 1.7 及以前的永久代空间不足在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。5. Concurrent Mode Failure执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。</code></pre><h4 id="四、类加载机制"><a href="#四、类加载机制" class="headerlink" title="四、类加载机制"></a>四、类加载机制</h4><pre><code>类是在运行期间第一次使用时动态加载的，而不是一次性加载。因为如果一次性加载，那么会占用很多的内存。</code></pre><p><img src="//zongmansheng.club/2019/03/31/jvm-xu-ni-ji/018.png" alt="018"></p><pre><code>包括以下 7 个阶段：◾加载（Loading）◾验证（Verification）◾准备（Preparation）◾解析（Resolution）◾初始化（Initialization）◾使用（Using）◾卸载（Unloading）类加载过程包含了加载、验证、准备、解析和初始化这 5 个阶段。</code></pre><h5 id="1-加载"><a href="#1-加载" class="headerlink" title="1. 加载"></a>1. 加载</h5><pre><code>加载是类加载的一个阶段，注意不要混淆。加载过程完成以下三件事：◾通过类的完全限定名称获取定义该类的二进制字节流。◾将该字节流表示的静态存储结构转换为方法区的运行时存储结构。◾在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口。其中二进制字节流可以从以下方式中获取：◾从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础。◾从网络中获取，最典型的应用是 Applet。◾运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。◾由其他文件生成，例如由 JSP 文件生成对应的 Class 类。</code></pre><h5 id="2-验证"><a href="#2-验证" class="headerlink" title="2. 验证"></a>2. 验证</h5><pre><code>确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</code></pre><h5 id="3-准备"><a href="#3-准备" class="headerlink" title="3. 准备"></a>3. 准备</h5><pre><code>类变量是被 static 修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存。实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中。应该注意到，实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123。</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span></code></pre><pre><code>如果类变量是常量，那么它将初始化为表达式所定义的值而不是 0。例如下面的常量 value 被初始化为 123 而不是 0。</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span></code></pre><h5 id="4-解析"><a href="#4-解析" class="headerlink" title="4. 解析"></a>4. 解析</h5><pre><code>将常量池的符号引用替换为直接引用的过程。其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。</code></pre><h5 id="5-初始化"><a href="#5-初始化" class="headerlink" title="5. 初始化"></a>5. 初始化</h5><pre><code>初始化阶段才真正开始执行类中定义的 Java 程序代码。初始化阶段是虚拟机执行类构造器 &lt;clinit&gt;() 方法的过程。在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。在准备阶段，已经为类变量分配了系统所需的初始值，并且在初始化阶段，根据程序员通过程序进行的主观计划来初始化类变量和其他资源。&lt;clinit&gt;() 是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。例如以下代码：</code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019/3/31 0031 * @Time: 22:22 * @Vsersion: 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestJvm</span> <span class="token punctuation">{</span> <span class="token keyword">static</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">//给变量赋值可以正常编译通过</span>     i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//编译器会提示“非法向前指引”</span>     System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">static</span> <span class="token keyword">int</span> i <span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre><code>由于父类的 &lt;clinit&gt;() 方法先执行，也就意味着父类中定义的静态语句块的执行要优先于子类。例如以下代码：</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Parent</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> A <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        A <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Sub</span> <span class="token keyword">extends</span> <span class="token class-name">Parent</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> B <span class="token operator">=</span> A<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Sub<span class="token punctuation">.</span>B<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//2</span><span class="token punctuation">}</span></code></pre><pre><code>接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 &lt;clinit&gt;() 方法。但接口与类不同的是，执行接口的 &lt;clinit&gt;() 方法不需要先执行父接口的 &lt;clinit&gt;() 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 &lt;clinit&gt;() 方法。虚拟机会保证一个类的 &lt;clinit&gt;() 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 &lt;clinit&gt;() 方法，其它线程都会阻塞等待，直到活动线程执行 &lt;clinit&gt;() 方法完毕。如果在一个类的 &lt;clinit&gt;() 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽。</code></pre><h4 id="类初始化时机"><a href="#类初始化时机" class="headerlink" title="类初始化时机"></a><strong>类初始化时机</strong></h4><h5 id="1-主动引用"><a href="#1-主动引用" class="headerlink" title="1. 主动引用"></a><strong>1. 主动引用</strong></h5><pre><code>虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了有且只有下列五种情况必须对类进行初始化（加载、验证、准备都会随之发生）：◾◾遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这 4 条指令的场景是：使用 new 关键字实例化对象的时候；读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候；以及调用一个类的静态方法的时候。◾使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。◾当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。◾当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类；◾当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REFgetStatic, REFputStatic, REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化；</code></pre><h5 id="2-被动引用"><a href="#2-被动引用" class="headerlink" title="2. 被动引用"></a><strong>2. 被动引用</strong></h5><pre><code>以上 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用的常见例子包括：◾通过子类引用父类的静态字段，不会导致子类初始化。</code></pre><pre class=" language-java"><code class="language-java">System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>SubClass<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre><code>◾通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。</code></pre><pre class=" language-java"><code class="language-java">SuperClass<span class="token punctuation">[</span><span class="token punctuation">]</span> sca <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SuperClass</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><pre><code>◾常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</code></pre><pre><code>System.out.println(ConstClass.HELLOWORLD);</code></pre><h4 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a><strong>类与类加载器</strong></h4><pre><code>两个类相等，需要类本身相等，并且使用同一个类加载器进行加载。这是因为每一个类加载器都拥有一个独立的类名称空间。这里的相等，包括类的 Class 对象的 equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果为 true，也包括使用 instanceof 关键字做对象所属关系判定结果为 true。类加载器分类从 Java 虚拟机的角度来讲，只存在以下两种不同的类加载器：◾◾启动类加载器（Bootstrap ClassLoader），使用 C++ 实现，是虚拟机自身的一部分；◾所有其它类的加载器，使用 Java 实现，独立于虚拟机，继承自抽象类 java.lang.ClassLoader。从 Java 开发人员的角度看，类加载器可以划分得更细致一些：◾◾启动类加载器（Bootstrap ClassLoader）此类加载器负责将存放在 &lt;JRE_HOME&gt;lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可。◾扩展类加载器（Extension ClassLoader）这个类加载器是由 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将 &lt;JAVA_HOME&gt;/lib/ext 或者被 java.ext.dir 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。◾应用程序类加载器（Application ClassLoader）这个类加载器是由 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此一般称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</code></pre><p><strong>双亲委派模型</strong></p><pre><code>应用程序是由三种类加载器互相配合从而实现类加载，除此之外还可以加入自己定义的类加载器。下图展示了类加载器之间的层次关系，称为双亲委派模型（Parents Delegation Model）。该模型要求除了顶层的启动类加载器外，其它的类加载器都要有自己的父类加载器。类加载器之间的父子关系一般通过组合关系（Composition）来实现，而不是继承关系（Inheritance）。</code></pre><p><img src="//zongmansheng.club/2019/03/31/jvm-xu-ni-ji/019.png" alt="019"></p><p><strong>1. 工作过程</strong></p><pre><code>一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载。</code></pre><p><strong>2. 好处</strong></p><pre><code>使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。例如 java.lang.Object 存放在 rt.jar 中，如果编写另外一个 java.lang.Object 并放到 ClassPath 中，程序可以编译通过。由于双亲委派模型的存在，所以在 rt.jar 中的 Object 比在 ClassPath 中的 Object 优先级更高，这是因为 rt.jar 中的 Object 使用的是启动类加载器，而 ClassPath 中的 Object 使用的是应用程序类加载器。rt.jar 中的 Object 优先级更高，那么程序中所有的 Object 都是这个 Object。</code></pre><p><strong>3. 实现</strong></p><pre><code>以下是抽象类 java.lang.ClassLoader 的代码片段，其中的 loadClass() 方法运行过程如下：先检查类是否已经加载过，如果没有则让父类加载器去加载。当父类加载器加载失败时抛出 ClassNotFoundException，此时尝试自己去加载。</code></pre><p>自定义类加载器实现</p><pre><code>FileSystemClassLoader 是自定义类加载器，继承自 java.lang.ClassLoader，用于加载文件系统上的类。它首先根据类的全名在文件系统上查找类的字节代码文件（.class 文件），然后读取该文件内容，最后通过 defineClass() 方法来把这些字节代码转换成 java.lang.Class 类的实例。java.lang.ClassLoader 的 loadClass() 实现了双亲委派模型的逻辑，自定义类加载器一般不去重写它，但是需要重写 findClass() 方法。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java8新特性</title>
      <link href="/2019/03/30/java8-xin-te-xing/"/>
      <url>/2019/03/30/java8-xin-te-xing/</url>
      
        <content type="html"><![CDATA[<h1 id="java-8-新特性"><a href="#java-8-新特性" class="headerlink" title="java 8-新特性"></a>java 8-新特性</h1><h4 id="一、Java-8-Lambda-表达式"><a href="#一、Java-8-Lambda-表达式" class="headerlink" title="一、Java 8 Lambda 表达式"></a>一、Java 8 Lambda 表达式</h4><pre><code>Lambda 表达式，也可称为闭包，它是推动 Java 8 发布的最重要新特性。Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。使用Lambda 表达式可以使代码变的更加简洁紧凑。</code></pre><h5 id="1-1-语法"><a href="#1-1-语法" class="headerlink" title="1.1 语法"></a>1.1 语法</h5><pre><code>lambda 表达式的语法格式如下：(parameters) -&gt; expression或(parameters) -&gt;{statements; }</code></pre><pre><code>lambda表达式的重要特征:可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。可选的大括号：如果主体包含了一个语句，就不需要使用大括号。可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。</code></pre><h5 id="1-2-Lambda-表达式实例"><a href="#1-2-Lambda-表达式实例" class="headerlink" title="1.2  Lambda 表达式实例"></a>1.2  Lambda 表达式实例</h5><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> java8<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019/3/30 0030 * @Time: 19:16 * @Vsersion: 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test1</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Test1 test <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 类型声明</span>        MathOperation addition <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 不用类型声明</span>        MathOperation subtraction <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> a <span class="token operator">-</span> b<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 大括号中的返回语句</span>        MathOperation multiplication <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> a <span class="token operator">*</span> b<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 没有大括号及返回语句</span>        MathOperation division <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> a <span class="token operator">/</span> b<span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"10 + 5 = "</span> <span class="token operator">+</span> test<span class="token punctuation">.</span><span class="token function">operate</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> addition<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"10 - 5 = "</span> <span class="token operator">+</span> test<span class="token punctuation">.</span><span class="token function">operate</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> subtraction<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"10 x 5 = "</span> <span class="token operator">+</span> test<span class="token punctuation">.</span><span class="token function">operate</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> multiplication<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"10 / 5 = "</span> <span class="token operator">+</span> test<span class="token punctuation">.</span><span class="token function">operate</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> division<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 不用括号</span>        GreetingService greetService1 <span class="token operator">=</span> message <span class="token operator">-</span><span class="token operator">></span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ZongMan say: "</span> <span class="token operator">+</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 用括号</span>        GreetingService greetService2 <span class="token operator">=</span> <span class="token punctuation">(</span>message<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ZongMan say: "</span> <span class="token operator">+</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>        greetService1<span class="token punctuation">.</span><span class="token function">sayMessage</span><span class="token punctuation">(</span><span class="token string">"说什么王权富贵！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        greetService2<span class="token punctuation">.</span><span class="token function">sayMessage</span><span class="token punctuation">(</span><span class="token string">"怕什么戒律清规！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">interface</span> <span class="token class-name">MathOperation</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> <span class="token function">operation</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">interface</span> <span class="token class-name">GreetingService</span> <span class="token punctuation">{</span>        <span class="token keyword">void</span> <span class="token function">sayMessage</span><span class="token punctuation">(</span>String message<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">operate</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> MathOperation mathOperation<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> mathOperation<span class="token punctuation">.</span><span class="token function">operation</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>运行结果：</p><p><img src="//zongmansheng.club/2019/03/30/java8-xin-te-xing/test1.png" alt="test1"></p><h5 id="1-3-注意事项"><a href="#1-3-注意事项" class="headerlink" title="1.3 注意事项"></a>1.3 注意事项</h5><pre><code>      Lambda 表达式主要用来定义行内执行的方法类型接口，例如，一个简单方法接口。在上面例子中，我们使用各种类型的Lambda表达式来定义MathOperation接口的方法。然后我们定义了sayMessage的执行。Lambda 表达式免去了使用匿名方法的麻烦，并且给予Java简单但是强大的函数化的编程能力。</code></pre><h4 id="二、Java-8-方法引用"><a href="#二、Java-8-方法引用" class="headerlink" title="二、Java 8 方法引用"></a>二、Java 8 方法引用</h4><pre><code>方法引用通过方法的名字来指向一个方法。方法引用可以使语言的构造更紧凑简洁，减少冗余代码。方法引用使用一对冒号 :: </code></pre><h5 id="2-1方法引用"><a href="#2-1方法引用" class="headerlink" title="2.1方法引用"></a>2.1方法引用</h5><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> java8<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>List<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019/3/30 0030 * @Time: 19:30 * @Vsersion: 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test2</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Car</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@FunctionalInterface</span>        <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Supplier</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>            T <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//Supplier是jdk1.8的接口，这里和lamda一起使用了</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> Car <span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">final</span> Supplier<span class="token operator">&lt;</span>Car<span class="token operator">></span> supplier<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> supplier<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">collide</span><span class="token punctuation">(</span><span class="token keyword">final</span> Car car<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Collided "</span> <span class="token operator">+</span> car<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">follow</span><span class="token punctuation">(</span><span class="token keyword">final</span> Car another<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Following the "</span> <span class="token operator">+</span> another<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">repair</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Repaired "</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//构造器引用：它的语法是Class::new，或者更一般的Class&lt; T >::new实例如下：</span>            Car car  <span class="token operator">=</span> Car<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>Car<span class="token operator">:</span><span class="token operator">:</span><span class="token keyword">new</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Car car1 <span class="token operator">=</span> Car<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>Car<span class="token operator">:</span><span class="token operator">:</span><span class="token keyword">new</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Car car2 <span class="token operator">=</span> Car<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>Car<span class="token operator">:</span><span class="token operator">:</span><span class="token keyword">new</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Car car3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Car</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            List<span class="token operator">&lt;</span>Car<span class="token operator">></span> cars <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>car<span class="token punctuation">,</span>car1<span class="token punctuation">,</span>car2<span class="token punctuation">,</span>car3<span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"&lt;===================构造器引用========================>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//静态方法引用：它的语法是Class::static_method，实例如下：</span>            cars<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>Car<span class="token operator">:</span><span class="token operator">:</span>collide<span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"&lt;===================静态方法引用========================>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//特定类的任意对象的方法引用：它的语法是Class::method实例如下：</span>            cars<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>Car<span class="token operator">:</span><span class="token operator">:</span>repair<span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"&lt;==============特定类的任意对象的方法引用================>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//特定对象的方法引用：它的语法是instance::method实例如下：</span>            <span class="token keyword">final</span> Car police <span class="token operator">=</span> Car<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>Car<span class="token operator">:</span><span class="token operator">:</span><span class="token keyword">new</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            cars<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>police<span class="token operator">:</span><span class="token operator">:</span>follow<span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"&lt;===================特定对象的方法引===================>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="三、Java-8-函数式接口"><a href="#三、Java-8-函数式接口" class="headerlink" title="三、Java 8 函数式接口"></a>三、Java 8 函数式接口</h4><pre><code>函数式接口(FunctionalInterface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。函数式接口可以被隐式转换为lambda表达式。函数式接口可以现有的函数友好地支持 lambda。JDK 1.8之前已有的函数式接口:    java.lang.Runnable    java.util.concurrent.Callable    java.security.PrivilegedAction    java.util.Comparator    java.io.FileFilter    java.nio.file.PathMatcher    java.lang.reflect.InvocationHandler    java.beans.PropertyChangeListener    java.awt.event.ActionListener    javax.swing.event.ChangeListenerJDK 1.8 新增加的函数接口：    java.util.function    java.util.function 它包含了很多类，用来支持 Java的函数式编程，该包中的函数式接口有：</code></pre><p><img src="//zongmansheng.club/2019/03/30/java8-xin-te-xing/test3-1.png" alt="test3-1"></p><p><img src="//zongmansheng.club/2019/03/30/java8-xin-te-xing/test3-2.png" alt="test3-2"></p><p><img src="//zongmansheng.club/2019/03/30/java8-xin-te-xing/test3-3.png" alt="test3-3"></p><p><img src="//zongmansheng.club/2019/03/30/java8-xin-te-xing/test3-4.png" alt="test3-4"></p><h5 id="3-1-函数式接口实例"><a href="#3-1-函数式接口实例" class="headerlink" title="3.1 函数式接口实例"></a>3.1 函数式接口实例</h5><pre><code>Predicate &lt;T&gt; 接口是一个函数式接口，它接受一个输入参数 T，返回一个布尔值结果。该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）。该接口用于测试对象是 true 或 false。</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> java8<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>List<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>function<span class="token punctuation">.</span>Predicate<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019/3/30 0030 * @Time: 19:42 * @Vsersion: 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test4</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Predicate&lt;Integer> predicate = n -> true</span>        <span class="token comment" spellcheck="true">// n 是一个参数传递到 Predicate 接口的 test 方法</span>        <span class="token comment" spellcheck="true">// n 如果存在则 test 方法返回 true</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"输出所有数据:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 传递参数 n</span>        <span class="token function">eval</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> n<span class="token operator">-</span><span class="token operator">></span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Predicate&lt;Integer> predicate1 = n -> n%2 == 0</span>        <span class="token comment" spellcheck="true">// n 是一个参数传递到 Predicate 接口的 test 方法</span>        <span class="token comment" spellcheck="true">// 如果 n%2 为 0 test 方法返回 true</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"输出所有偶数:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">eval</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> n<span class="token operator">-</span><span class="token operator">></span> n<span class="token operator">%</span><span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Predicate&lt;Integer> predicate2 = n -> n > 3</span>        <span class="token comment" spellcheck="true">// n 是一个参数传递到 Predicate 接口的 test 方法</span>        <span class="token comment" spellcheck="true">// 如果 n 大于 3 test 方法返回 true</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"输出大于 3 的所有数字:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">eval</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> n<span class="token operator">-</span><span class="token operator">></span> n <span class="token operator">></span> <span class="token number">3</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">eval</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list<span class="token punctuation">,</span> Predicate<span class="token operator">&lt;</span>Integer<span class="token operator">></span> predicate<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>Integer n<span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>predicate<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>结果：</p><pre class=" language-txt"><code class="language-txt">输出所有数据:1 2 3 4 5 6 7 8 9 输出所有偶数:2 4 6 8 输出大于 3 的所有数字:4 5 6 7 8 9 Process finished with exit code 0</code></pre><h4 id="四、Java-8-默认方法"><a href="#四、Java-8-默认方法" class="headerlink" title="四、Java 8 默认方法"></a>四、Java 8 默认方法</h4><pre><code>Java 8 新增了接口的默认方法。简单说，默认方法就是接口可以有实现方法，而且不需要实现类去实现其方法。我们只需在方法名前面加个default关键字即可实现默认方法。为什么要有这个特性？首先，之前的接口是个双刃剑，好处是面向抽象而不是面向具体编程，缺陷是，当需要修改接口时候，需要修改全部实现该接口的类，目前的java 8之前的集合框架没有foreach方法，通常能想到的解决办法是在JDK里给相关的接口添加新的方法及实现。然而，对于已经发布的版本，是没法在给接口添加新方法的同时不影响已有的实现。所以引进的默认方法。他们的目的是为了解决接口的修改与现有的实现不兼容的问题。</code></pre><h5 id="4-1语法"><a href="#4-1语法" class="headerlink" title="4.1语法"></a>4.1语法</h5><p>默认方法语法格式如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">vehicle</span> <span class="token punctuation">{</span>    <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Java是世界上最好的编程语言!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="4-2多个默认方法"><a href="#4-2多个默认方法" class="headerlink" title="4.2多个默认方法"></a>4.2多个默认方法</h5><pre><code>一个接口有默认方法，考虑这样的情况，一个类实现了多个接口，且这些接口有相同的默认方法，以下实例说明了这种情况的解决方法：</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">vehicle</span> <span class="token punctuation">{</span>    <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">fourWheeler</span> <span class="token punctuation">{</span>    <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>第一个解决方案是创建自己的默认方法，来覆盖重写接口的默认方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Car</span> <span class="token keyword">implements</span> <span class="token class-name">vehicle</span><span class="token punctuation">,</span> fourWheeler <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="五、Java-8-Optional-类"><a href="#五、Java-8-Optional-类" class="headerlink" title="五、Java 8 Optional 类"></a>五、Java 8 Optional 类</h4><pre><code>Optional 类是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。Optional 是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。Optional 类的引入很好的解决空指针异常。</code></pre><h5 id="5-1-类声明"><a href="#5-1-类声明" class="headerlink" title="5.1 类声明"></a>5.1 类声明</h5><pre><code>以下是一个 java.util.Optional&lt;T&gt; 类的声明：publicfinalclassOptional&lt;T&gt; extendsObject</code></pre><h5 id="5-2-类方法"><a href="#5-2-类方法" class="headerlink" title="5.2 类方法"></a>5.2 类方法</h5><p><img src="//zongmansheng.club/2019/03/30/java8-xin-te-xing/5-1.png" alt="5-1"></p><p><img src="//zongmansheng.club/2019/03/30/java8-xin-te-xing/5-2.png" alt="5-2"></p><pre><code>注意： 这些方法是从 java.lang.Object 类继承来的。</code></pre><h5 id="5-3-Optional-实例"><a href="#5-3-Optional-实例" class="headerlink" title="5.3 Optional 实例"></a>5.3 Optional 实例</h5><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> java8<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Optional<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019/3/30 0030 * @Time: 20:09 * @Vsersion: 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test5</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Test5 test <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test5</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Integer value1 <span class="token operator">=</span> null<span class="token punctuation">;</span>        Integer value2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Optional.ofNullable - 允许传递为 null 参数</span>        Optional<span class="token operator">&lt;</span>Integer<span class="token operator">></span> a <span class="token operator">=</span> Optional<span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span>value1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Optional.of - 如果传递的参数是 null，抛出异常 NullPointerException</span>        Optional<span class="token operator">&lt;</span>Integer<span class="token operator">></span> b <span class="token operator">=</span> Optional<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>value2<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>test<span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> Integer <span class="token function">sum</span><span class="token punctuation">(</span>Optional<span class="token operator">&lt;</span>Integer<span class="token operator">></span> a<span class="token punctuation">,</span> Optional<span class="token operator">&lt;</span>Integer<span class="token operator">></span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Optional.isPresent - 判断值是否存在</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"第一个参数值存在: "</span> <span class="token operator">+</span> a<span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"第二个参数值存在: "</span> <span class="token operator">+</span> b<span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Optional.orElse - 如果值存在，返回它，否则返回默认值</span>        Integer value1 <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//Optional.get - 获取值，值需要存在</span>        Integer value2 <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> value1 <span class="token operator">+</span> value2<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="六、Java-8-Stream"><a href="#六、Java-8-Stream" class="headerlink" title="六、Java 8 Stream"></a>六、Java 8 Stream</h4><pre><code>Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。Stream使用一种类似用SQL语句从数据库查询数据的直观方式来提供一种对Java集合运算和表达的高阶抽象。Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。这种风格将要处理的元素集合看作一种流，流在管道中传输，并且可以在管道的节点上进行处理，比如筛选，排序，聚合等。元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作(terminal operation)得到前面处理的结果。</code></pre><h5 id="6-1-什么是-Stream？"><a href="#6-1-什么是-Stream？" class="headerlink" title="6.1 什么是 Stream？"></a>6.1 什么是 Stream？</h5><pre><code>Stream（流）是一个来自数据源的元素队列并支持聚合操作元素：是特定类型的对象，形成一个队列。Java中的Stream并不会存储元素，而是按需计算。数据源 ：流的来源。可以是集合，数组，I/O channel，产生器generator等。聚合操作： 类似SQL语句一样的操作，比如filter, map, reduce, find,match, sorted等。和以前的Collection操作不同，Stream操作还有两个基础的特征：Pipelining:：中间操作都会返回流对象本身。这样多个操作可以串联成一个管道，如同流式风格（fluent style）。这样做可以对操作进行优化，比如延迟执行(laziness)和短路( short-circuiting)。内部迭代：以前对集合遍历都是通过Iterator或者For-Each的方式,显式的在集合外部进行迭代，这叫做外部迭代。Stream提供了内部迭代的方式，通过访问者模式(Visitor)实现。</code></pre><h5 id="6-2-生成流"><a href="#6-2-生成流" class="headerlink" title="6.2 生成流"></a>6.2 生成流</h5><pre><code>在Java 8中,集合接口有两个方法来生成流：stream() −为集合创建串行流。parallelStream() − 为集合创建并行流。</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>String<span class="token operator">></span> strings <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"bc"</span><span class="token punctuation">,</span> <span class="token string">"efg"</span><span class="token punctuation">,</span> <span class="token string">"abcd"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"jkl"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>String<span class="token operator">></span> filtered <span class="token operator">=</span> strings<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>string <span class="token operator">-</span><span class="token operator">></span> <span class="token operator">!</span>string<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h5 id="6-3-forEach"><a href="#6-3-forEach" class="headerlink" title="6.3  forEach"></a>6.3  forEach</h5><pre><code>Stream 提供了新的方法 &#39;forEach&#39; 来迭代流中的每个数据。以下代码片段使用forEach 输出了10个随机数：</code></pre><pre class=" language-java"><code class="language-java">Random random <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>random<span class="token punctuation">.</span><span class="token function">ints</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="6-4-map"><a href="#6-4-map" class="headerlink" title="6.4  map"></a>6.4  map</h5><pre><code>map 方法用于映射每个元素到对应的结果，以下代码片段使用 map 输出了元素对应的平方数：</code></pre><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> numbers <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 获取对应的平方数</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> squaresList <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>i <span class="token operator">-</span><span class="token operator">></span> i <span class="token operator">*</span> i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">distinct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="6-5-filter"><a href="#6-5-filter" class="headerlink" title="6.5  filter"></a>6.5  filter</h5><pre><code>filter 方法用于通过设置条件过滤出元素。以下代码片段使用filter 方法过滤出空字符串：</code></pre><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>String<span class="token operator">></span>strings <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"bc"</span><span class="token punctuation">,</span> <span class="token string">"efg"</span><span class="token punctuation">,</span> <span class="token string">"abcd"</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"jkl"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 获取空字符串的数量</span><span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> strings<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>string <span class="token operator">-</span><span class="token operator">></span> string<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="6-6-limit"><a href="#6-6-limit" class="headerlink" title="6.6  limit"></a>6.6  limit</h5><pre><code>limit 方法用于获取指定数量的流。以下代码片段使用 limit 方法打印出 10 条数据：</code></pre><pre class=" language-java"><code class="language-java">Random random <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>random<span class="token punctuation">.</span><span class="token function">ints</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="6-7-sorted"><a href="#6-7-sorted" class="headerlink" title="6.7  sorted"></a>6.7  sorted</h5><pre><code>sorted 方法用于对流进行排序。以下代码片段使用 sorted 方法对输出的 10 个随机数进行排序：</code></pre><h5 id="6-8-并行（parallel）程序"><a href="#6-8-并行（parallel）程序" class="headerlink" title="6.8  并行（parallel）程序"></a>6.8  并行（parallel）程序</h5><pre><code>parallelStream 是流并行处理程序的代替方法。以下实例我们使用parallelStream 来输出空字符串的数量：</code></pre><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>String<span class="token operator">></span> strings <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"bc"</span><span class="token punctuation">,</span> <span class="token string">"efg"</span><span class="token punctuation">,</span> <span class="token string">"abcd"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"jkl"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 获取空字符串的数量</span><span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> strings<span class="token punctuation">.</span><span class="token function">parallelStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>string <span class="token operator">-</span><span class="token operator">></span> string<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="6-9-Collectors"><a href="#6-9-Collectors" class="headerlink" title="6.9  Collectors"></a>6.9  Collectors</h5><pre><code>Collectors 类实现了很多归约操作，例如将流转换成集合和聚合元素。Collectors可用于返回列表或字符串：</code></pre><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>String<span class="token operator">></span> strings <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"bc"</span><span class="token punctuation">,</span> <span class="token string">"efg"</span><span class="token punctuation">,</span> <span class="token string">"abcd"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"jkl"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>List<span class="token operator">&lt;</span>String<span class="token operator">></span> filtered <span class="token operator">=</span> strings<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>string <span class="token operator">-</span><span class="token operator">></span> <span class="token operator">!</span>string<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"筛选列表: "</span> <span class="token operator">+</span> filtered<span class="token punctuation">)</span><span class="token punctuation">;</span>String mergedString <span class="token operator">=</span> strings<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>string <span class="token operator">-</span><span class="token operator">></span> <span class="token operator">!</span>string<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">joining</span><span class="token punctuation">(</span><span class="token string">", "</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"合并字符串: "</span> <span class="token operator">+</span> mergedString<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="6-10-统计"><a href="#6-10-统计" class="headerlink" title="6.10  统计"></a>6.10  统计</h5><pre><code>    另外，一些产生统计结果的收集器也非常有用。它们主要用于int、double、long等基本类型上，它们可以用来产生类似如下的统计结果。</code></pre><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> numbers <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>IntSummaryStatistics stats <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">mapToInt</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> x<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">summaryStatistics</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"列表中最大的数 : "</span> <span class="token operator">+</span> stats<span class="token punctuation">.</span><span class="token function">getMax</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"列表中最小的数 : "</span> <span class="token operator">+</span> stats<span class="token punctuation">.</span><span class="token function">getMin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"所有数之和 : "</span> <span class="token operator">+</span> stats<span class="token punctuation">.</span><span class="token function">getSum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"平均数 : "</span> <span class="token operator">+</span> stats<span class="token punctuation">.</span><span class="token function">getAverage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="6-11-Stream-完整实例"><a href="#6-11-Stream-完整实例" class="headerlink" title="6.11  Stream 完整实例"></a>6.11  Stream 完整实例</h5><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> java8<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>stream<span class="token punctuation">.</span>Collectors<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019/3/30 0030 * @Time: 20:27 * @Vsersion: 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test6</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"使用 Java 7: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 计算空字符串</span>        List<span class="token operator">&lt;</span>String<span class="token operator">></span> strings <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"bc"</span><span class="token punctuation">,</span> <span class="token string">"efg"</span><span class="token punctuation">,</span> <span class="token string">"abcd"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"jkl"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"列表: "</span> <span class="token operator">+</span> strings<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> count <span class="token operator">=</span> <span class="token function">getCountEmptyStringUsingJava7</span><span class="token punctuation">(</span>strings<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"空字符数量为: "</span> <span class="token operator">+</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>        count <span class="token operator">=</span> <span class="token function">getCountLength3UsingJava7</span><span class="token punctuation">(</span>strings<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"字符串长度为 3 的数量为: "</span> <span class="token operator">+</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 删除空字符串</span>        List<span class="token operator">&lt;</span>String<span class="token operator">></span> filtered <span class="token operator">=</span> <span class="token function">deleteEmptyStringsUsingJava7</span><span class="token punctuation">(</span>strings<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"筛选后的列表: "</span> <span class="token operator">+</span> filtered<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 删除空字符串，并使用逗号把它们合并起来</span>        String mergedString <span class="token operator">=</span> <span class="token function">getMergedStringUsingJava7</span><span class="token punctuation">(</span>strings<span class="token punctuation">,</span> <span class="token string">", "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"合并字符串: "</span> <span class="token operator">+</span> mergedString<span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> numbers <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 获取列表元素平方数</span>        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> squaresList <span class="token operator">=</span> <span class="token function">getSquares</span><span class="token punctuation">(</span>numbers<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"平方数列表: "</span> <span class="token operator">+</span> squaresList<span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> integers <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">17</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"列表: "</span> <span class="token operator">+</span> integers<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"列表中最大的数 : "</span> <span class="token operator">+</span> <span class="token function">getMax</span><span class="token punctuation">(</span>integers<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"列表中最小的数 : "</span> <span class="token operator">+</span> <span class="token function">getMin</span><span class="token punctuation">(</span>integers<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"所有数之和 : "</span> <span class="token operator">+</span> <span class="token function">getSum</span><span class="token punctuation">(</span>integers<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"平均数 : "</span> <span class="token operator">+</span> <span class="token function">getAverage</span><span class="token punctuation">(</span>integers<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"随机数: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 输出10个随机数</span>        Random random <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>random<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"使用 Java 8: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"列表: "</span> <span class="token operator">+</span> strings<span class="token punctuation">)</span><span class="token punctuation">;</span>        count <span class="token operator">=</span> strings<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>string <span class="token operator">-</span><span class="token operator">></span> string<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"空字符串数量为: "</span> <span class="token operator">+</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>        count <span class="token operator">=</span> strings<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>string <span class="token operator">-</span><span class="token operator">></span> string<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"字符串长度为 3 的数量为: "</span> <span class="token operator">+</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>        filtered <span class="token operator">=</span> strings<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>string <span class="token operator">-</span><span class="token operator">></span> <span class="token operator">!</span>string<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"筛选后的列表: "</span> <span class="token operator">+</span> filtered<span class="token punctuation">)</span><span class="token punctuation">;</span>        mergedString <span class="token operator">=</span> strings<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>string <span class="token operator">-</span><span class="token operator">></span> <span class="token operator">!</span>string<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">joining</span><span class="token punctuation">(</span><span class="token string">", "</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"合并字符串: "</span> <span class="token operator">+</span> mergedString<span class="token punctuation">)</span><span class="token punctuation">;</span>        squaresList <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>i <span class="token operator">-</span><span class="token operator">></span> i <span class="token operator">*</span> i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">distinct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Squares List: "</span> <span class="token operator">+</span> squaresList<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"列表: "</span> <span class="token operator">+</span> integers<span class="token punctuation">)</span><span class="token punctuation">;</span>        IntSummaryStatistics stats <span class="token operator">=</span> integers<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">mapToInt</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> x<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">summaryStatistics</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"列表中最大的数 : "</span> <span class="token operator">+</span> stats<span class="token punctuation">.</span><span class="token function">getMax</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"列表中最小的数 : "</span> <span class="token operator">+</span> stats<span class="token punctuation">.</span><span class="token function">getMin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"所有数之和 : "</span> <span class="token operator">+</span> stats<span class="token punctuation">.</span><span class="token function">getSum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"平均数 : "</span> <span class="token operator">+</span> stats<span class="token punctuation">.</span><span class="token function">getAverage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"随机数: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        random<span class="token punctuation">.</span><span class="token function">ints</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 并行处理</span>        count <span class="token operator">=</span> strings<span class="token punctuation">.</span><span class="token function">parallelStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>string <span class="token operator">-</span><span class="token operator">></span> string<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"空字符串的数量为: "</span> <span class="token operator">+</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getCountEmptyStringUsingJava7</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>String<span class="token operator">></span> strings<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>String string <span class="token operator">:</span> strings<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>string<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                count<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> count<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getCountLength3UsingJava7</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>String<span class="token operator">></span> strings<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>String string <span class="token operator">:</span> strings<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>string<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                count<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> count<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">deleteEmptyStringsUsingJava7</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>String<span class="token operator">></span> strings<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>String<span class="token operator">></span> filteredList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>String string <span class="token operator">:</span> strings<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>string<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                filteredList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> filteredList<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> String <span class="token function">getMergedStringUsingJava7</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>String<span class="token operator">></span> strings<span class="token punctuation">,</span> String separator<span class="token punctuation">)</span> <span class="token punctuation">{</span>        StringBuilder stringBuilder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>String string <span class="token operator">:</span> strings<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>string<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                stringBuilder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token punctuation">;</span>                stringBuilder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>separator<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        String mergedString <span class="token operator">=</span> stringBuilder<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> mergedString<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> mergedString<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">getSquares</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> numbers<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> squaresList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Integer number <span class="token operator">:</span> numbers<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Integer square <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>number<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> number<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>squaresList<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>square<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                squaresList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>square<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> squaresList<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getMax</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> numbers<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> max <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numbers<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Integer number <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>number<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> max<span class="token punctuation">)</span> <span class="token punctuation">{</span>                max <span class="token operator">=</span> number<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> max<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getMin</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> numbers<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> min <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numbers<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Integer number <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>number<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> min<span class="token punctuation">)</span> <span class="token punctuation">{</span>                min <span class="token operator">=</span> number<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> min<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getSum</span><span class="token punctuation">(</span>List numbers<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>numbers<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numbers<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            sum <span class="token operator">+=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> numbers<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getAverage</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> numbers<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">getSum</span><span class="token punctuation">(</span>numbers<span class="token punctuation">)</span> <span class="token operator">/</span> numbers<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="七、Java-8-Nashorn-JavaScript"><a href="#七、Java-8-Nashorn-JavaScript" class="headerlink" title="七、Java 8 Nashorn JavaScript"></a>七、Java 8 Nashorn JavaScript</h4><pre><code>Nashorn 一个 javascript 引擎。从JDK1.8开始，Nashorn取代Rhino(JDK 1.6, JDK1.7)成为Java的嵌入式JavaScript引擎。Nashorn完全支持ECMAScript 5.1规范以及一些扩展。它使用基于JSR292的新语言特性，其中包含在JDK 7中引入的 invokedynamic，将JavaScript编译成Java字节码。与先前的Rhino实现相比，这带来了2到10倍的性能提升。</code></pre><h5 id="7-1-jjs"><a href="#7-1-jjs" class="headerlink" title="7.1 jjs"></a>7.1 jjs</h5><pre><code>jjs是个基于Nashorn引擎的命令行工具。它接受一些JavaScript源代码为参数，并且执行这些源代码。</code></pre><h5 id="7-2-jjs-交互式编程"><a href="#7-2-jjs-交互式编程" class="headerlink" title="7.2  jjs 交互式编程"></a>7.2  jjs 交互式编程</h5><pre class=" language-java"><code class="language-java">$ jjsjjs<span class="token operator">></span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Hello, World!"</span><span class="token punctuation">)</span>Hello<span class="token punctuation">,</span>World<span class="token operator">!</span>jjs<span class="token operator">></span> <span class="token function">quit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>></span> </code></pre><h5 id="7-3-传递参数"><a href="#7-3-传递参数" class="headerlink" title="7.3 传递参数"></a>7.3 传递参数</h5><pre class=" language-java"><code class="language-java">$ jjs <span class="token operator">--</span> a b cjjs<span class="token operator">></span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">'字母: '</span><span class="token operator">+</span>arguments<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">", "</span><span class="token punctuation">)</span><span class="token punctuation">)</span>字母<span class="token operator">:</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> cjjs<span class="token operator">></span></code></pre><h5 id="7-4-Java-中调用-JavaScript"><a href="#7-4-Java-中调用-JavaScript" class="headerlink" title="7.4  Java 中调用 JavaScript"></a>7.4  Java 中调用 JavaScript</h5><pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        ScriptEngineManager scriptEngineManager <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ScriptEngineManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ScriptEngine nashorn <span class="token operator">=</span> scriptEngineManager<span class="token punctuation">.</span><span class="token function">getEngineByName</span><span class="token punctuation">(</span><span class="token string">"nashorn"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String name <span class="token operator">=</span> <span class="token string">"Runoob"</span><span class="token punctuation">;</span>        Integer result <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            nashorn<span class="token punctuation">.</span><span class="token function">eval</span><span class="token punctuation">(</span><span class="token string">"print('"</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">"')"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            result <span class="token operator">=</span> <span class="token punctuation">(</span>Integer<span class="token punctuation">)</span> nashorn<span class="token punctuation">.</span><span class="token function">eval</span><span class="token punctuation">(</span><span class="token string">"10 + 2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ScriptException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行脚本错误: "</span> <span class="token operator">+</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h4 id="八、Java-8-日期时间-API"><a href="#八、Java-8-日期时间-API" class="headerlink" title="八、Java 8 日期时间 API"></a>八、Java 8 日期时间 API</h4><pre><code>Java 8通过发布新的Date-Time API (JSR 310)来进一步加强对日期与时间的处理。在旧版的Java 中，日期时间API 存在诸多问题，其中有：非线程安全 − java.util.Date 是非线程安全的，所有的日期类都是可变的，这是Java日期类最大的问题之一    设计很差 − Java的日期/时间类的定义并不一致，在java.util和java.sql的包中都有日期类，此外用于格式化和解析的类在java.text包中定义。java.util.Date同时包含日期和时间，而java.sql.Date仅包含日期，将其纳入java.sql包并不合理。另外这两个类都有相同的名字，这本身就是一个非常糟糕的设计。    时区处理麻烦 − 日期类并不提供国际化，没有时区支持，因此Java引入了java.util.Calendar和java.util.TimeZone类，但他们同样存在上述所有的问题。Java 8 在 java.time 包下提供了很多新的 API。以下为两个比较重要的 API：    Local(本地) − 简化了日期时间的处理，没有时区的问题。    Zoned(时区) − 通过制定的时区处理日期时间。新的java.time包涵盖了所有处理日期，时间，日期/时间，时区，时刻（instants），过程（during）与时钟（clock）的操作。</code></pre><h5 id="8-1-本地化日期时间-API"><a href="#8-1-本地化日期时间-API" class="headerlink" title="8.1 本地化日期时间 API"></a>8.1 本地化日期时间 API</h5><pre class=" language-java"><code class="language-java">  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Java8Tester java8tester <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Java8Tester</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        java8tester<span class="token punctuation">.</span><span class="token function">testLocalDateTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testLocalDateTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 获取当前的日期时间</span>        LocalDateTime currentTime <span class="token operator">=</span> LocalDateTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"当前时间: "</span> <span class="token operator">+</span> currentTime<span class="token punctuation">)</span><span class="token punctuation">;</span>        LocalDate date1 <span class="token operator">=</span> currentTime<span class="token punctuation">.</span><span class="token function">toLocalDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"date1: "</span> <span class="token operator">+</span> date1<span class="token punctuation">)</span><span class="token punctuation">;</span>        Month month <span class="token operator">=</span> currentTime<span class="token punctuation">.</span><span class="token function">getMonth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> day <span class="token operator">=</span> currentTime<span class="token punctuation">.</span><span class="token function">getDayOfMonth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> seconds <span class="token operator">=</span> currentTime<span class="token punctuation">.</span><span class="token function">getSecond</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"月: "</span> <span class="token operator">+</span> month <span class="token operator">+</span> <span class="token string">", 日: "</span> <span class="token operator">+</span> day <span class="token operator">+</span> <span class="token string">", 秒: "</span> <span class="token operator">+</span> seconds<span class="token punctuation">)</span><span class="token punctuation">;</span>        LocalDateTime date2 <span class="token operator">=</span> currentTime<span class="token punctuation">.</span><span class="token function">withDayOfMonth</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">withYear</span><span class="token punctuation">(</span><span class="token number">2012</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"date2: "</span> <span class="token operator">+</span> date2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 12 december 2014</span>        LocalDate date3 <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2014</span><span class="token punctuation">,</span> Month<span class="token punctuation">.</span>DECEMBER<span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"date3: "</span> <span class="token operator">+</span> date3<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 22 小时 15 分钟</span>        LocalTime date4 <span class="token operator">=</span> LocalTime<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"date4: "</span> <span class="token operator">+</span> date4<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 解析字符串</span>        LocalTime date5 <span class="token operator">=</span> LocalTime<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token string">"20:15:30"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"date5: "</span> <span class="token operator">+</span> date5<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h5 id="8-2-使用时区的日期时间API"><a href="#8-2-使用时区的日期时间API" class="headerlink" title="8.2 使用时区的日期时间API"></a>8.2 使用时区的日期时间API</h5><pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Java8Tester java8tester <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Java8Tester</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        java8tester<span class="token punctuation">.</span><span class="token function">testZonedDateTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testZonedDateTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 获取当前时间日期</span>        ZonedDateTime date1 <span class="token operator">=</span> ZonedDateTime<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token string">"2015-12-03T10:15:30+05:30[Asia/Shanghai]"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"date1: "</span> <span class="token operator">+</span> date1<span class="token punctuation">)</span><span class="token punctuation">;</span>        ZoneId id <span class="token operator">=</span> ZoneId<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"Europe/Paris"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ZoneId: "</span> <span class="token operator">+</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>        ZoneId currentZone <span class="token operator">=</span> ZoneId<span class="token punctuation">.</span><span class="token function">systemDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"当期时区: "</span> <span class="token operator">+</span> currentZone<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h4 id="九、Java8-Base64"><a href="#九、Java8-Base64" class="headerlink" title="九、Java8 Base64"></a>九、Java8 Base64</h4><pre><code>在Java8中，Base64编码已经成为Java类库的标准。Java 8 内置了 Base64 编码的编码器和解码器。Base64工具类提供了一套静态方法获取下面三种BASE64编解码器：    基本：输出被映射到一组字符A-Za-z0-9+/，编码不添加任何行标，输出的解码仅支持A-Za-z0-9+/。    URL：输出映射到一组字符A-Za-z0-9+_，输出是URL和文件。    MIME：输出隐射到MIME友好格式。输出每行不超过76字符，并且使用&#39;\r&#39;并跟随&#39;\n&#39;作为分割。编码输出最后没有行分割。</code></pre><h5 id="9-1-内嵌类"><a href="#9-1-内嵌类" class="headerlink" title="9.1 内嵌类"></a>9.1 内嵌类</h5><p><img src="//zongmansheng.club/2019/03/30/java8-xin-te-xing/9-1.png" alt="9-1"></p><h5 id="9-2-方法"><a href="#9-2-方法" class="headerlink" title="9.2 方法"></a>9.2 方法</h5><p><img src="//zongmansheng.club/2019/03/30/java8-xin-te-xing/9-2.png" alt="9-2"></p><pre><code>注意：Base64 类的很多方法从 java.lang.Object 类继承。</code></pre><h5 id="9-3-Base64-实例"><a href="#9-3-Base64-实例" class="headerlink" title="9.3  Base64 实例"></a>9.3  Base64 实例</h5><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 使用基本编码</span>            String base64encodedString <span class="token operator">=</span> Base64<span class="token punctuation">.</span><span class="token function">getEncoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">encodeToString</span><span class="token punctuation">(</span><span class="token string">"runoob?java8"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Base64 编码字符串 (基本) :"</span> <span class="token operator">+</span> base64encodedString<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 解码</span>            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> base64decodedBytes <span class="token operator">=</span> Base64<span class="token punctuation">.</span><span class="token function">getDecoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span>base64encodedString<span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"原始字符串: "</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>base64decodedBytes<span class="token punctuation">,</span> <span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            base64encodedString <span class="token operator">=</span> Base64<span class="token punctuation">.</span><span class="token function">getUrlEncoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">encodeToString</span><span class="token punctuation">(</span><span class="token string">"TutorialsPoint?java8"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Base64 编码字符串 (URL) :"</span> <span class="token operator">+</span> base64encodedString<span class="token punctuation">)</span><span class="token punctuation">;</span>            StringBuilder stringBuilder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                stringBuilder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>UUID<span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> mimeBytes <span class="token operator">=</span> stringBuilder<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            String mimeEncodedString <span class="token operator">=</span> Base64<span class="token punctuation">.</span><span class="token function">getMimeEncoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">encodeToString</span><span class="token punctuation">(</span>mimeBytes<span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Base64 编码字符串 (MIME) :"</span> <span class="token operator">+</span> mimeEncodedString<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">UnsupportedEncodingException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Error :"</span> <span class="token operator">+</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 日常学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal</title>
      <link href="/2019/03/29/threadlocal/"/>
      <url>/2019/03/29/threadlocal/</url>
      
        <content type="html"><![CDATA[<h2 id="ThreadLocal的简单使用及实现的原理"><a href="#ThreadLocal的简单使用及实现的原理" class="headerlink" title="ThreadLocal的简单使用及实现的原理"></a>ThreadLocal的简单使用及实现的原理</h2><h4 id="一、ThreadLocal简介"><a href="#一、ThreadLocal简介" class="headerlink" title="一、ThreadLocal简介"></a>一、ThreadLocal简介</h4><pre><code>    ThreadLocal的实例代表了一个线程局部的变量，每条线程都只能看到自己的值，并不会意识到其它的线程中也存在该变量。    它采用采用空间来换取时间的方式，解决多线程中相同变量的访问冲突问题。</code></pre><h4 id="二、ThreadLocal的简单使用"><a href="#二、ThreadLocal的简单使用" class="headerlink" title="二、ThreadLocal的简单使用"></a>二、ThreadLocal的简单使用</h4><pre><code>    下面的例子中，创建了两个线程，然后线程对各自的局部变量进行递增的操作。每个线程中的局部变量的初始值都是100。</code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @author ZongMan * @version 1.0 * @date 2019/3/22 0022 8:04 */</span><span class="token keyword">class</span> <span class="token class-name">ThreadLocalDemo</span> <span class="token punctuation">{</span>    ThreadLocal<span class="token operator">&lt;</span>Integer<span class="token operator">></span> threadLocal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">protected</span> Integer <span class="token function">initialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">100</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> threadLocal<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        threadLocal<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>threadLocal<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>定义对ThreadLocal的操作，也就是在原来的基础上进行加10的操作，然后打印出结果。</code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @author ZongMan * @version 1.0 * @date 2019/3/22 0022 8:08 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalDemo2</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>    ThreadLocalDemo localDemo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocalDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ThreadLocalDemo2</span><span class="token punctuation">(</span>ThreadLocalDemo localDemo<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>localDemo <span class="token operator">=</span> localDemo<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            localDemo<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//输出不同线程的ThreadLocal的值</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"=====>"</span> <span class="token operator">+</span> localDemo<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>    创建两个线程并启动，主线程等待这两个线程执行完成。最值得注意的就是主线程中输出的threadLocalDemo.get(),输出的初始值100</code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @author ZongMan * @version 1.0 * @date 2019/3/22 0022 8:14 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        ThreadLocalDemo threadLocalDemo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocalDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//多个线程操作同一个变量 但是不同线程的结果是互不影响的</span>        ThreadLocalDemo2 localDemo2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocalDemo2</span><span class="token punctuation">(</span>threadLocalDemo<span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>localDemo2<span class="token punctuation">)</span><span class="token punctuation">;</span>        t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>localDemo2<span class="token punctuation">)</span><span class="token punctuation">;</span>        t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//这个是main()线程中的变量，输出的是ThreadLocalDemo中的初始值 也是就100</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>threadLocalDemo<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="三、ThreadLocal的实现原理"><a href="#三、ThreadLocal的实现原理" class="headerlink" title="三、ThreadLocal的实现原理"></a>三、ThreadLocal的实现原理</h4><pre><code>    每个Thread的对象都有一个ThreadLocalMap，当创建一个ThreadLocal的时候，就会将该ThreadLocal对象添加到该Map中，其中键就是ThreadLocal，值可以是任意类型。    在该类中，我觉得最重要的方法就是两个：set()和get()方法。当调用ThreadLocal的get()方法的时候，会先找到当前线程的ThreadLocalMap，然后再找到对应的值。set()方法也是一样。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 日常学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
            <tag> ThreadLocal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试之集合</title>
      <link href="/2019/03/28/mian-shi-zhi-ji-he/"/>
      <url>/2019/03/28/mian-shi-zhi-ji-he/</url>
      
        <content type="html"><![CDATA[<h4 id="ArrayList简介"><a href="#ArrayList简介" class="headerlink" title="ArrayList简介"></a>ArrayList简介</h4><pre><code>    ArrayList 的底层是数组队列，相当于动态数组。与 Java 中的数组相比，它的容量能动态增长。在添加大量元素前，应用程序可以使用ensureCapacity操作来增加 ArrayList 实例的容量。这可以减少递增式再分配的数量。   它继承于 AbstractList，实现了 List, RandomAccess, Cloneable, java.io.Serializable 这些接口。   在我们学数据结构的时候就知道了线性表的顺序存储，插入删除元素的时间复杂度为O（n）,求表长以及增加元素，取第 i   元素的时间复杂度为O（1）　  ArrayList 继承了AbstractList，实现了List。它是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。　　ArrayList 实现了RandomAccess 接口，即提供了随机访问功能。RandomAccess 是 Java 中用来被 List 实现，为 List 提供快速访问功能的。在 ArrayList 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。　　ArrayList 实现了Cloneable 接口，即覆盖了函数 clone()，能被克隆。　　ArrayList 实现java.io.Serializable 接口，这意味着ArrayList支持序列化，能通过序列化去传输。　　和 Vector 不同，ArrayList 中的操作不是线程安全的！所以，建议在单线程中才使用 ArrayList，而在多线程中可以选择 Vector 或者  CopyOnWriteArrayList。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> List，ArrayList，LinkedList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>乐观锁与悲观锁的区别</title>
      <link href="/2019/03/25/le-guan-suo-yu-bei-guan-suo-de-qu-bie/"/>
      <url>/2019/03/25/le-guan-suo-yu-bei-guan-suo-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<h1 id="悲观锁和乐观锁的区别"><a href="#悲观锁和乐观锁的区别" class="headerlink" title="悲观锁和乐观锁的区别"></a>悲观锁和乐观锁的区别</h1><h4 id="一、悲观锁-Pessimistic-Lock"><a href="#一、悲观锁-Pessimistic-Lock" class="headerlink" title="一、悲观锁(Pessimistic Lock)"></a>一、悲观锁(Pessimistic Lock)</h4><pre><code>    总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。    它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。</code></pre><h4 id="二、乐观锁-Optimistic-Lock"><a href="#二、乐观锁-Optimistic-Lock" class="headerlink" title="二、乐观锁(Optimistic Lock)"></a>二、乐观锁(Optimistic Lock)</h4><pre><code>    总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。</code></pre><h4 id="三、乐观锁常见的两种实现方式"><a href="#三、乐观锁常见的两种实现方式" class="headerlink" title="三、乐观锁常见的两种实现方式"></a>三、乐观锁常见的两种实现方式</h4><pre><code>乐观锁一般会使用版本号机制或CAS算法实现。</code></pre><h5 id="1-版本号机制"><a href="#1-版本号机制" class="headerlink" title="1.版本号机制"></a>1.版本号机制</h5><pre><code>    一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。举一个简单的例子：     假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ balance ）为 $100 。    操作员 A 此时将其读出（ version=1 ），并从其帐户余额中扣除 50（50（100-$50 ）。在操作员 A 操作的过程中，操作员B 也读入此用户信息（ version=1 ），并从其帐户余额中扣除 20（20（100-$20 ）。操作员 A 完成了修改工作，将数据版本号加 1（ version=2 ），连同帐户扣除后余额（ balance=$50 ），提交至数据库更新，此时由于提交数据版本大于数据库记录当前版本，数据被更新，数据库记录 version 更新为 2 。    操作员 B 完成了操作，也将版本号加一（ version=2 ）试图向数据库提交数据（ balance=$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 2 ，数据库记录当前版本也为 2 ，不满足 “ 提交版本必须大于记录当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。这样，就避免了操作员 B 用基于 version=1 的旧数据修改的结果覆盖操作员A 的操作结果的可能。</code></pre><h5 id="2-CAS算法"><a href="#2-CAS算法" class="headerlink" title="2.CAS算法"></a>2.CAS算法</h5><pre><code>    即compare and swap（比较与交换），是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。CAS算法涉及到三个操作数    需要读写的内存值 V    进行比较的值 A    拟写入的新值 B    当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。</code></pre><h4 id="四、乐观锁的缺点"><a href="#四、乐观锁的缺点" class="headerlink" title="四、乐观锁的缺点"></a>四、乐观锁的缺点</h4><pre><code>ABA 问题是乐观锁一个常见的问题</code></pre><h5 id="1-ABA-问题"><a href="#1-ABA-问题" class="headerlink" title="1 ABA 问题"></a>1 ABA 问题</h5><pre><code>    如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 “ABA”问题。    JDK 1.5 以后的 AtomicStampedReference 类就提供了此种能力，其中的 compareAndSet 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</code></pre><h5 id="2-循环时间长开销大"><a href="#2-循环时间长开销大" class="headerlink" title="2 循环时间长开销大"></a>2 循环时间长开销大</h5><pre><code>    自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。 如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。</code></pre><h5 id="3-只能保证一个共享变量的原子操作"><a href="#3-只能保证一个共享变量的原子操作" class="headerlink" title="3 只能保证一个共享变量的原子操作"></a>3 只能保证一个共享变量的原子操作</h5><pre><code>    CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5开始，提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用AtomicReference类把多个共享变量合并成一个共享变量来操作。</code></pre><h4 id="五、CAS与synchronized的使用情景"><a href="#五、CAS与synchronized的使用情景" class="headerlink" title="五、CAS与synchronized的使用情景"></a>五、CAS与synchronized的使用情景</h4><pre><code>    简单的来说CAS适用于写比较少的情况下（多读场景，冲突一般较少），synchronized适用于写比较多的情况下（多写场景，冲突一般较多）</code></pre><pre><code>    对于资源竞争较少（线程冲突较轻）的情况，使用synchronized同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。</code></pre><pre><code>补充： Java并发编程这个领域中synchronized关键字一直都是元老级的角色，很久之前很多人都会称它为 “重量级锁” 。但是，在JavaSE 1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的 偏向锁 和 轻量级锁 以及其它各种优化之后变得在某些情况下并不是那么重了。synchronized的底层实现主要依靠 Lock-Free 的队列，基本思路是 自旋后阻塞，竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了高吞吐量。在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 日常学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库，乐观锁，悲观锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zookeeper的羊群效应</title>
      <link href="/2019/03/25/zookeeper-de-yang-qun-xiao-ying/"/>
      <url>/2019/03/25/zookeeper-de-yang-qun-xiao-ying/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis缓存介绍</title>
      <link href="/2019/03/24/mybatis-huan-cun-jie-shao/"/>
      <url>/2019/03/24/mybatis-huan-cun-jie-shao/</url>
      
        <content type="html"><![CDATA[<h1 id="Mybatis缓存的介绍"><a href="#Mybatis缓存的介绍" class="headerlink" title="Mybatis缓存的介绍"></a>Mybatis缓存的介绍</h1><pre><code>    缓存：合理使用缓存是优化中最常见的，将从数据库中查询出来的数据放入缓存中，下次使用时不必从数据库查询，而是直接从缓存中读取，避免频繁操作数据库，减轻数据库压力，同时提高系统性能。</code></pre><h4 id="一、一级缓存"><a href="#一、一级缓存" class="headerlink" title="一、一级缓存"></a>一、一级缓存</h4><pre><code>    一级缓存是SqlSession级别的缓存，在操作数据库的时候需要构造sqlsession对象，在对象中有一个数据结构用于存储缓存数据。不同的SqlSession之间的缓存数据区域是互相不影响的。也就是它只能作用在同一个sqlSession中，不同的SqlSession中的缓存是互相不能读取的</code></pre><h5 id="1、一级缓存的工作原理"><a href="#1、一级缓存的工作原理" class="headerlink" title="1、一级缓存的工作原理"></a>1、一级缓存的工作原理</h5><p><img src="//zongmansheng.club/2019/03/24/mybatis-huan-cun-jie-shao/Mybatis一级缓存原理.png" alt="Mybatis一级缓存原理"></p><pre><code>    用户发起查询请求，查找某条数据，sqlsession先去缓存中查找，是否有该数据，如果有，读取如果没有，从数据库查询，并将查询到的数据放入 一级缓存区域，供下次使用但sqlsession执行commit，即增删改操作时会清空缓存。目的是避免脏读如果commit不清空缓存，会有以下的场景：A查询了某个商品为10件，并将10件库存的数据存入缓存中，之后被客户买走了10件，数据被delete了，但是下次查询这件商品时，并不从数据库中查询，而是从缓存中查询，就会出现错误。二级缓存    二级缓存是mapper级别的缓存，多个SqlSession去操作同一个Mapper的sql语句，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的，二级缓存的作用范围更大。    实际开发中，Mybatis通常和Spring进行整合开发，Spring将事务放在Service中管理，对于每一个service中的sqlsession是不同的，这是通过mybatis-spring中的org.mybatis.spring.mapper.MapperScannerConfigurer创建sqlsession自动注入到service中的。 每次查询之后都要进行关闭sqlSession，关闭之后数据被清空。所以spring整合之后，如果没有事务，一级缓存是没有意义的。</code></pre><h5 id="2-二级缓存的工作原理"><a href="#2-二级缓存的工作原理" class="headerlink" title="2.二级缓存的工作原理"></a>2.二级缓存的工作原理</h5><p><img src="//zongmansheng.club/2019/03/24/mybatis-huan-cun-jie-shao/Mybatis二级缓存原理.png" alt="Mybatis二级缓存原理"></p><pre><code>    二级缓存是mapper级别的缓存，多个SqlSession去操作同一个Mapper的sql语句，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。    UserMapper有一个二级缓存区域（按namespace分），其它mapper也有自己的二级缓存区域（按namespace分）。每一个namespace的mapper都有一个二级缓存区域，两个mapper的namespace如果相同，这两个mapper执行sql查询到数据将存在相同的二级缓存区域中。</code></pre><h5 id="3-开启二级缓存"><a href="#3-开启二级缓存" class="headerlink" title="3.开启二级缓存"></a>3.开启二级缓存</h5><p>在MyBatis的配置文件中加入：</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">font-size</span><span class="token punctuation">:</span><span class="token number">18</span>px<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>settings</span><span class="token punctuation">></span></span>       <span class="token comment" spellcheck="true">&lt;!--开启二级缓存--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cacheEnabled<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>settings</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span></code></pre><p>在需要开启二级缓存的mapper.xml中加入caceh标签</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">font-size</span><span class="token punctuation">:</span><span class="token number">18</span>px<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cache</span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span></code></pre><h4 id="二、总结"><a href="#二、总结" class="headerlink" title="二、总结"></a>二、总结</h4><pre><code>    对于查询多commit少且用户对查询结果实时性要求不高，此时采用mybatis二级缓存技术降低数据库访问量，提高访问速度。</code></pre><pre><code>但不能滥用二级缓存，二级缓存也有很多弊端，从MyBatis默认二级缓存是关闭的就可以看出来。二级缓存是建立在同一个namespace下的，如果对表的操作查询可能有多个namespace，那么得到的数据就是错误的。举个简单的例子:   订单和订单详情，orderMapper、orderDetailMapper。在查询订单详情时我们需要把订单信息也查询出来，那么这个订单详情的信息被二级缓存在orderDetailMapper的namespace中，这个时候有人要修改订单的基本信息，那就是在orderMapper的namespace下修改，他是不会影响到orderDetailMapper的缓存的，那么你再次查找订单详情时，拿到的是缓存的数据，这个数据其实已经是过时的。</code></pre><pre><code>根据以上，想要使用二级缓存时需要想好两个问题：1）对该表的操作与查询都在同一个namespace下，其他的namespace如果有操作，就会发生数据的脏读。2）对关联表的查询，关联的所有表的操作都必须在同一个namespace。hexi</code></pre>]]></content>
      
      
      <categories>
          
          <category> 日常学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dubbo常见面试题总结</title>
      <link href="/2019/02/19/dubbo-chang-jian-mian-shi-ti-zong-jie/"/>
      <url>/2019/02/19/dubbo-chang-jian-mian-shi-ti-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="Dubbo面试题总结"><a href="#Dubbo面试题总结" class="headerlink" title="Dubbo面试题总结"></a>Dubbo面试题总结</h1><h4 id="一、Dubbo是什么？"><a href="#一、Dubbo是什么？" class="headerlink" title="一、Dubbo是什么？"></a>一、Dubbo是什么？</h4><pre><code>Dubbo是阿里巴巴开源的基于 Java 的高性能 RPC 分布式服务框架，现已成为 Apache 基金会孵化项目。</code></pre><h4 id="二、远程过程调用协议"><a href="#二、远程过程调用协议" class="headerlink" title="二、远程过程调用协议"></a>二、远程过程调用协议</h4><pre><code>RPC:(Remote Procedure Call)    它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。RPC采用客户机/服务器模式。请求程序就是一个客户机，而服务提供程序就是一个服务器。首先，客户机调用进程发送一个有进程参数的调用信息到服务进程，然后等待应答信息。在服务器端，进程保持睡眠状态直到调用信息到达为止。当一个调用信息到达，服务器获得进程参数，计算结果，发送答复信息，然后等待下一个调用信息，最后，客户端调用进程接收答复信息，获得进程结果，然后调用执行继续进行。有多种 RPC模式和执行。最初由 Sun 公司提出。IETF ONC 宪章重新修订了 Sun 版本，使得 ONC RPC 协议成为 IETF 标准协议。现在使用最普遍的模式和执行是开放式软件基础的分布式计算环境（DCE）。</code></pre><h4 id="三、为什么要用Dubbo"><a href="#三、为什么要用Dubbo" class="headerlink" title="三、为什么要用Dubbo?"></a>三、为什么要用Dubbo?</h4><pre><code>    因为是阿里开源项目，国内很多互联网公司都在用，已经经过很多线上考验。内部使用了 Netty、Zookeeper，保证了高性能高可用性。    使用 Dubbo 可以将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，可用于提高业务复用灵活扩展，使前端应用能更快速的响应多变的市场需求。下面这张图可以很清楚的诠释，最重要的一点是，分布式架构可以承受更大规模的并发流量。</code></pre><p><img src="//zongmansheng.club/2019/02/19/dubbo-chang-jian-mian-shi-ti-zong-jie/1550554002964.png" alt="1550554002964"></p><p>下面是 Dubbo 的服务治理图。</p><p><img src="//zongmansheng.club/2019/02/19/dubbo-chang-jian-mian-shi-ti-zong-jie/1550554034880.png" alt="1550554034880"></p><h4 id="四、Dubbo-和-Spring-Cloud-有什么区别？"><a href="#四、Dubbo-和-Spring-Cloud-有什么区别？" class="headerlink" title="四、Dubbo 和 Spring Cloud 有什么区别？"></a>四、Dubbo 和 Spring Cloud 有什么区别？</h4><pre><code>两个没关联，如果硬要说区别，有以下几点。1）通信方式不同Dubbo 使用的是 RPC 通信，而 Spring Cloud 使用的是 HTTP RESTFul 方式。2）组成部分不同</code></pre><p><img src="//zongmansheng.club/2019/02/19/dubbo-chang-jian-mian-shi-ti-zong-jie/1550554095559.png" alt="1550554095559"></p><h4 id="五、dubbo都支持什么协议，推荐用哪种？"><a href="#五、dubbo都支持什么协议，推荐用哪种？" class="headerlink" title="五、dubbo都支持什么协议，推荐用哪种？"></a>五、dubbo都支持什么协议，推荐用哪种？</h4><pre><code>dubbo://（推荐）rmi://hessian://http://webservice://thrift://memcached://redis://rest://</code></pre><h4 id="六、Dubbo需要-Web-容器吗？"><a href="#六、Dubbo需要-Web-容器吗？" class="headerlink" title="六、Dubbo需要 Web 容器吗？"></a>六、Dubbo需要 Web 容器吗？</h4><pre><code>不需要，如果硬要用 Web 容器，只会增加复杂性，也浪费资源。</code></pre><h4 id="七、Dubbo内置了哪几种服务容器？"><a href="#七、Dubbo内置了哪几种服务容器？" class="headerlink" title="七、Dubbo内置了哪几种服务容器？"></a>七、Dubbo内置了哪几种服务容器？</h4><pre><code>Spring ContainerJetty ContainerLog4j ContainerDubbo 的服务容器只是一个简单的 Main 方法，并加载一个简单的 Spring 容器，用于暴露服务。</code></pre><h4 id="八、Dubbo里面有哪几种节点角色？"><a href="#八、Dubbo里面有哪几种节点角色？" class="headerlink" title="八、Dubbo里面有哪几种节点角色？"></a>八、Dubbo里面有哪几种节点角色？</h4><p><img src="//zongmansheng.club/2019/02/19/dubbo-chang-jian-mian-shi-ti-zong-jie/1550554250039.png" alt="1550554250039"></p><h4 id="九、画一画服务注册与发现的流程图"><a href="#九、画一画服务注册与发现的流程图" class="headerlink" title="九、画一画服务注册与发现的流程图"></a>九、画一画服务注册与发现的流程图</h4><p><img src="//zongmansheng.club/2019/02/19/dubbo-chang-jian-mian-shi-ti-zong-jie/1550554288101.png" alt="1550554288101"></p><h4 id="十、Dubbo默认使用什么注册中心，还有别的选择吗？"><a href="#十、Dubbo默认使用什么注册中心，还有别的选择吗？" class="headerlink" title="十、Dubbo默认使用什么注册中心，还有别的选择吗？"></a>十、Dubbo默认使用什么注册中心，还有别的选择吗？</h4><pre><code>推荐使用 Zookeeper 作为注册中心，还有 Redis、Multicast、Simple 注册中心，但不推荐。</code></pre><h4 id="十一、Dubbo有哪几种配置方式？"><a href="#十一、Dubbo有哪几种配置方式？" class="headerlink" title="十一、Dubbo有哪几种配置方式？"></a>十一、Dubbo有哪几种配置方式？</h4><pre><code>1）Spring 配置方式2）Java API 配置方式</code></pre><h4 id="十二、Dubbo-核心的配置有哪些？"><a href="#十二、Dubbo-核心的配置有哪些？" class="headerlink" title="十二、Dubbo 核心的配置有哪些？"></a>十二、Dubbo 核心的配置有哪些？</h4><p><img src="//zongmansheng.club/2019/02/19/dubbo-chang-jian-mian-shi-ti-zong-jie/1550554406352.png" alt="1550554406352"></p><p>配置之间的关系见下图。</p><p><img src="//zongmansheng.club/2019/02/19/dubbo-chang-jian-mian-shi-ti-zong-jie/1550554429525.png" alt="1550554429525"></p><h4 id="十三、在-Provider-上可以配置的-Consumer-端的属性有哪些？"><a href="#十三、在-Provider-上可以配置的-Consumer-端的属性有哪些？" class="headerlink" title="十三、在 Provider 上可以配置的 Consumer 端的属性有哪些？"></a>十三、在 Provider 上可以配置的 Consumer 端的属性有哪些？</h4><pre><code>1）timeout：方法调用超时2）retries：失败重试次数，默认重试 2 次3）loadbalance：负载均衡算法，默认随机4）actives 消费者端，最大并发调用限制</code></pre><h4 id="十四、Dubbo启动时如果依赖的服务不可用会怎样？"><a href="#十四、Dubbo启动时如果依赖的服务不可用会怎样？" class="headerlink" title="十四、Dubbo启动时如果依赖的服务不可用会怎样？"></a>十四、Dubbo启动时如果依赖的服务不可用会怎样？</h4><pre><code>Dubbo 缺省会在启动时检查依赖的服务是否可用，不可用时会抛出异常，阻止 Spring 初始化完成，默认 check=&quot;true&quot;，可以通过 check=&quot;false&quot; 关闭检查。</code></pre><h4 id="十五、Dubbo默认使用的是什么通信框架，还有别的选择吗？"><a href="#十五、Dubbo默认使用的是什么通信框架，还有别的选择吗？" class="headerlink" title="十五、Dubbo默认使用的是什么通信框架，还有别的选择吗？"></a>十五、Dubbo默认使用的是什么通信框架，还有别的选择吗？</h4><pre><code>Dubbo 默认使用 Netty 框架，也是推荐的选择，另外内容还集成有Mina、Grizzly。</code></pre><h4 id="十六、Dubbo推荐使用什么序列化框架，你知道的还有哪些？"><a href="#十六、Dubbo推荐使用什么序列化框架，你知道的还有哪些？" class="headerlink" title="十六、Dubbo推荐使用什么序列化框架，你知道的还有哪些？"></a>十六、Dubbo推荐使用什么序列化框架，你知道的还有哪些？</h4><pre><code>推荐使用Hessian序列化，还有Duddo、FastJson、Java自带序列化。</code></pre><h4 id="十七、Dubbo有哪几种集群容错方案，默认是哪种？"><a href="#十七、Dubbo有哪几种集群容错方案，默认是哪种？" class="headerlink" title="十七、Dubbo有哪几种集群容错方案，默认是哪种？"></a>十七、Dubbo有哪几种集群容错方案，默认是哪种？</h4><p><img src="//zongmansheng.club/2019/02/19/dubbo-chang-jian-mian-shi-ti-zong-jie/1550554627446.png" alt="1550554627446"></p><h4 id="十八、Dubbo有哪几种负载均衡策略，默认是哪种？"><a href="#十八、Dubbo有哪几种负载均衡策略，默认是哪种？" class="headerlink" title="十八、Dubbo有哪几种负载均衡策略，默认是哪种？"></a>十八、Dubbo有哪几种负载均衡策略，默认是哪种？</h4><p><img src="//zongmansheng.club/2019/02/19/dubbo-chang-jian-mian-shi-ti-zong-jie/1550554672227.png" alt="1550554672227"></p><h4 id="十九、注册了多个同一样的服务，如果测试指定的某一个服务呢？"><a href="#十九、注册了多个同一样的服务，如果测试指定的某一个服务呢？" class="headerlink" title="十九、注册了多个同一样的服务，如果测试指定的某一个服务呢？"></a>十九、注册了多个同一样的服务，如果测试指定的某一个服务呢？</h4><pre><code>可以配置环境点对点直连，绕过注册中心，将以服务接口为单位，忽略注册中心的提供者列表。</code></pre><h4 id="二十、Dubbo支持服务多协议吗？"><a href="#二十、Dubbo支持服务多协议吗？" class="headerlink" title="二十、Dubbo支持服务多协议吗？"></a>二十、Dubbo支持服务多协议吗？</h4><pre><code>Dubbo 允许配置多协议，在不同服务上支持不同协议或者同一服务上同时支持多种协议。</code></pre><h4 id="二十一、当一个服务接口有多种实现时怎么做？"><a href="#二十一、当一个服务接口有多种实现时怎么做？" class="headerlink" title="二十一、当一个服务接口有多种实现时怎么做？"></a>二十一、当一个服务接口有多种实现时怎么做？</h4><pre><code>当一个接口有多种实现时，可以用 group 属性来分组，服务提供方和消费方都指定同一个 group 即可。</code></pre><h4 id="二十二、服务上线怎么兼容旧版本？"><a href="#二十二、服务上线怎么兼容旧版本？" class="headerlink" title="二十二、服务上线怎么兼容旧版本？"></a>二十二、服务上线怎么兼容旧版本？</h4><pre><code>可以用版本号（version）过渡，多个不同版本的服务注册到注册中心，版本号不同的服务相互间不引用。这个和服务分组的概念有一点类似。</code></pre><h4 id="二十三、Dubbo可以对结果进行缓存吗？"><a href="#二十三、Dubbo可以对结果进行缓存吗？" class="headerlink" title="二十三、Dubbo可以对结果进行缓存吗？"></a>二十三、Dubbo可以对结果进行缓存吗？</h4><pre><code>可以，Dubbo 提供了声明式缓存，用于加速热门数据的访问速度，以减少用户加缓存的工作量。</code></pre><h4 id="二十四、Dubbo服务之间的调用是阻塞的吗？"><a href="#二十四、Dubbo服务之间的调用是阻塞的吗？" class="headerlink" title="二十四、Dubbo服务之间的调用是阻塞的吗？"></a>二十四、Dubbo服务之间的调用是阻塞的吗？</h4><pre><code>默认是同步等待结果阻塞的，支持异步调用。Dubbo 是基于 NIO 的非阻塞实现并行调用，客户端不需要启动多线程即可完成并行调用多个远程服务，相对多线程开销较小，异步调用会返回一个 Future 对象。</code></pre><p><img src="//zongmansheng.club/2019/02/19/dubbo-chang-jian-mian-shi-ti-zong-jie/1550554946569.png" alt="1550554946569"></p><h4 id="二十五、Dubbo支持分布式事务吗？"><a href="#二十五、Dubbo支持分布式事务吗？" class="headerlink" title="二十五、Dubbo支持分布式事务吗？"></a>二十五、Dubbo支持分布式事务吗？</h4><p>目前暂时不支持，后续可能采用基于 JTA/XA 规范实现，如以图所示。</p><p><img src="//zongmansheng.club/2019/02/19/dubbo-chang-jian-mian-shi-ti-zong-jie/1550554990475.png" alt="1550554990475"></p><h4 id="二十六、Dubbo-telnet-命令能做什么？"><a href="#二十六、Dubbo-telnet-命令能做什么？" class="headerlink" title="二十六、Dubbo telnet 命令能做什么？"></a>二十六、Dubbo telnet 命令能做什么？</h4><pre><code>dubbo 通过 telnet 命令来进行服务治理，具体使用看这篇文章《dubbo服务调试管理实用命令》。telnet localhost 8090</code></pre><h4 id="二十七、Dubbo支持服务降级吗？"><a href="#二十七、Dubbo支持服务降级吗？" class="headerlink" title="二十七、Dubbo支持服务降级吗？"></a>二十七、Dubbo支持服务降级吗？</h4><pre><code>Dubbo 2.2.0 以上版本支持。</code></pre><h4 id="二十八、Dubbo如何优雅停机？"><a href="#二十八、Dubbo如何优雅停机？" class="headerlink" title="二十八、Dubbo如何优雅停机？"></a>二十八、Dubbo如何优雅停机？</h4><pre><code>Dubbo 是通过 JDK 的 ShutdownHook 来完成优雅停机的，所以如果使用 kill -9 PID 等强制关闭指令，是不会执行优雅停机的，只有通过 kill PID 时，才会执行。</code></pre><h4 id="二十九、服务提供者能实现失效踢出是什么原理？"><a href="#二十九、服务提供者能实现失效踢出是什么原理？" class="headerlink" title="二十九、服务提供者能实现失效踢出是什么原理？"></a>二十九、服务提供者能实现失效踢出是什么原理？</h4><pre><code>服务失效踢出基于 Zookeeper 的临时节点原理。</code></pre><h4 id="三十、如何解决服务调用链过长的问题？"><a href="#三十、如何解决服务调用链过长的问题？" class="headerlink" title="三十、如何解决服务调用链过长的问题？"></a>三十、如何解决服务调用链过长的问题？</h4><pre><code>Dubbo 可以使用 Pinpoint 和 Apache Skywalking(Incubator) 实现分布式服务追踪，当然还有其他很多方案。</code></pre><h4 id="三十一、服务读写推荐的容错策略是怎样的？"><a href="#三十一、服务读写推荐的容错策略是怎样的？" class="headerlink" title="三十一、服务读写推荐的容错策略是怎样的？"></a>三十一、服务读写推荐的容错策略是怎样的？</h4><pre><code>读操作建议使用 Failover 失败自动切换，默认重试两次其他服务器。写操作建议使用 Failfast 快速失败，发一次调用失败就立即报错。</code></pre><h4 id="三十二、Dubbo的管理控制台能做什么？"><a href="#三十二、Dubbo的管理控制台能做什么？" class="headerlink" title="三十二、Dubbo的管理控制台能做什么？"></a>三十二、Dubbo的管理控制台能做什么？</h4><pre><code>管理控制台主要包含：路由规则，动态配置，服务降级，访问控制，权重调整，负载均衡，等管理功能。</code></pre><h4 id="三十三、说说-Dubbo-服务暴露的过程。"><a href="#三十三、说说-Dubbo-服务暴露的过程。" class="headerlink" title="三十三、说说 Dubbo 服务暴露的过程。"></a>三十三、说说 Dubbo 服务暴露的过程。</h4><pre><code>Dubbo 会在 Spring 实例化完 bean 之后，在刷新容器最后一步发布 ContextRefreshEvent 事件的时候，通知实现了 ApplicationListener 的 ServiceBean 类进行回调 onApplicationEvent 事件方法，Dubbo 会在这个方法中调用 ServiceBean 父类 ServiceConfig 的 export 方法，而该方法真正实现了服务的（异步或者非异步）发布。    </code></pre><h4 id="三十四、Dubbo-停止维护了吗？"><a href="#三十四、Dubbo-停止维护了吗？" class="headerlink" title="三十四、Dubbo 停止维护了吗？"></a>三十四、Dubbo 停止维护了吗？</h4><pre><code>2014 年开始停止维护过几年，17 年开始重新维护，并进入了 Apache 项目。</code></pre><h4 id="三十五、Dubbo-和-Dubbox-有什么区别？"><a href="#三十五、Dubbo-和-Dubbox-有什么区别？" class="headerlink" title="三十五、Dubbo 和 Dubbox 有什么区别？"></a>三十五、Dubbo 和 Dubbox 有什么区别？</h4><pre><code>Dubbox 是继 Dubbo 停止维护后，当当网基于 Dubbo 做的一个扩展项目，如加了服务可 Restful 调用，更新了开源组件等。</code></pre><h4 id="三十六、你还了解别的分布式框架吗？"><a href="#三十六、你还了解别的分布式框架吗？" class="headerlink" title="三十六、你还了解别的分布式框架吗？"></a>三十六、你还了解别的分布式框架吗？</h4><pre><code>别的还有 Spring cloud、Facebook 的 Thrift、Twitter 的 Finagle 等。</code></pre><h4 id="三十七、Dubbo-能集成-Spring-Boot-吗？"><a href="#三十七、Dubbo-能集成-Spring-Boot-吗？" class="headerlink" title="三十七、Dubbo 能集成 Spring Boot 吗？"></a>三十七、Dubbo 能集成 Spring Boot 吗？</h4><pre><code>https://github.com/apache/incubator-dubbo-spring-boot-project</code></pre>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dubbo </tag>
            
            <tag> Zookeeper </tag>
            
            <tag> RPC </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
