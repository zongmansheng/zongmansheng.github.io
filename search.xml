<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>RabbitMQ个人总结</title>
      <link href="/2019/12/11/rabbitmq-ge-ren-zong-jie/"/>
      <url>/2019/12/11/rabbitmq-ge-ren-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><p>[TOC]</p><h3 id="一、RabbitMQ简介"><a href="#一、RabbitMQ简介" class="headerlink" title="一、RabbitMQ简介"></a>一、RabbitMQ简介</h3><blockquote><p>​        AMQP，即Advanced Message Queuing Protocol，高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，反之亦然。<br>​        AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。<br>RabbitMQ是一个开源的AMQP实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。</p><p>​        RabbitMQ是一个实现了AMQP（Advanced Message Queuing Protocol）高级消息队列协议的消息队列服务，采用Erlang语言开发。</p></blockquote><h3 id="二、RabbitMQ优势"><a href="#二、RabbitMQ优势" class="headerlink" title="二、RabbitMQ优势"></a>二、RabbitMQ优势</h3><blockquote><p>RabbitMQ是唯一一个实现了AMQP标准的消息服务器；</p><p>可靠性，RabbitMQ的持久化支持，保证了消息的稳定性；</p><p>高并发，RabbitMQ使用了Erlang开发语言，Erlang是为电话交换机开发的语言，天生自带高并发光环，和高可用特性；</p><p>集群部署简单，正是应为Erlang使得RabbitMQ集群部署变的超级简单；</p><p>社区活跃度高，根据网上资料来看，RabbitMQ也是首选；</p></blockquote><h3 id="三、RabbitMQ使用场景"><a href="#三、RabbitMQ使用场景" class="headerlink" title="三、RabbitMQ使用场景"></a>三、RabbitMQ使用场景</h3><h4 id="3-1、异步处理"><a href="#3-1、异步处理" class="headerlink" title="3.1、异步处理"></a>3.1、异步处理</h4><blockquote><p>场景说明：用户注册后，需要发注册邮件和注册短信,传统的做法有两种：</p></blockquote><h5 id="3-1-1、串行的方式"><a href="#3-1-1、串行的方式" class="headerlink" title="3.1.1、串行的方式"></a>3.1.1、串行的方式</h5><blockquote><p>串行方式:</p><p>将注册信息写入数据库后,发送注册邮件,再发送注册短信,以上三个任务全部完成后才返回给客户端。 这有一个问题是,邮件,短信并不是必须的,它只是一个通知,而这种做法让客户端等待没有必要等待的东西。</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/12/11/rabbitmq-ge-ren-zong-jie/001.png" alt></p><h5 id="3-1-2、并行的方式"><a href="#3-1-2、并行的方式" class="headerlink" title="3.1.2、并行的方式"></a>3.1.2、并行的方式</h5><blockquote><p>并行方式:</p><p>将注册信息写入数据库后,发送邮件的同时,发送短信,以上三个任务完成后,返回给客户端,并行的方式能提高处理的时间。 </p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/12/11/rabbitmq-ge-ren-zong-jie/002.png" alt></p><blockquote><p>假设三个业务节点分别使用50ms,串行方式使用时间150ms,并行使用时间100ms。虽然并性已经提高的处理时间,但是,前面说过,邮件和短信对我正常的使用网站没有任何影响，客户端没有必要等着其发送完成才显示注册成功,应该是写入数据库后就返回. </p></blockquote><h5 id="3-1-3、消息队列"><a href="#3-1-3、消息队列" class="headerlink" title="3.1.3、消息队列"></a>3.1.3、消息队列</h5><blockquote><p>引入消息队列后，把发送邮件,短信不是必须的业务逻辑异步处理 </p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/12/11/rabbitmq-ge-ren-zong-jie/003.png" alt></p><blockquote><p>由此可以看出,引入消息队列后，用户的响应时间就等于写入数据库的时间+写入消息队列的时间(可以忽略不计),引入消息队列后处理后,响应时间是串行的3倍,是并行的2倍。</p></blockquote><h4 id="3-2、应用解耦"><a href="#3-2、应用解耦" class="headerlink" title="3.2、应用解耦"></a>3.2、应用解耦</h4><blockquote><p>场景：双11是购物狂节,用户下单后,订单系统需要通知库存系统,传统的做法就是订单系统调用库存系统的接口。</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/12/11/rabbitmq-ge-ren-zong-jie/004.png" alt></p><blockquote><p>这种做法有一个缺点:</p><ul><li>当库存系统出现故障时,订单就会失败。</li><li>订单系统和库存系统高耦合。<br>引入消息队列 </li></ul></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/12/11/rabbitmq-ge-ren-zong-jie/005.png" alt></p><blockquote><ul><li>订单系统:用户下单后,订单系统完成持久化处理,将消息写入消息队列,返回用户订单下单成功。</li><li>库存系统:订阅下单的消息，获取下单消息，进行库操作。<br>就算库存系统出现故障，消息队列也能保证消息的可靠投递，不会导致消息丢失</li></ul></blockquote><h4 id="3-3、流量削峰"><a href="#3-3、流量削峰" class="headerlink" title="3.3、流量削峰"></a>3.3、流量削峰</h4><blockquote><p>流量削峰一般在秒杀活动中应用广泛<br>场景:秒杀活动，一般会因为流量过大，导致应用挂掉,为了解决这个问题，一般在应用前端加入消息队列。<br>作用:<br>1.可以控制活动人数，超过此一定阀值的订单直接丢弃<br>2.可以缓解短时间的高流量压垮应用(应用程序按自己的最大处理能力获取订单) </p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/12/11/rabbitmq-ge-ren-zong-jie/006.png" alt></p><blockquote><p>1.用户的请求,服务器收到之后,首先写入消息队列,加入消息队列长度超过最大值,则直接抛弃用户请求或跳转到错误页面.<br>2.秒杀业务根据消息队列中的请求信息，再做后续处理.</p></blockquote><h3 id="四、技术术语"><a href="#四、技术术语" class="headerlink" title="四、技术术语"></a>四、技术术语</h3><blockquote><p>AMQP模型（AMQP Model）：一个由关键实体和语义表示的逻辑框架，遵从AMQP规范的服务器必须提供这些实体和语义。为了实现本规范中定义的语义，客户端可以发送命令来控制AMQP服务器。<br>连接（Connection）：一个网络连接，比如TCP/IP套接字连接。<br>会话（Session）：端点之间的命名对话。在一个会话上下文中，保证“恰好传递一次”。<br>信道（Channel）：多路复用连接中的一条独立的双向数据流通道。为会话提供物理传输介质。<br>客户端（Client）：AMQP连接或者会话的发起者。AMQP是非对称的，客户端生产和消费消息，服务器存储和路由这些消息。<br>服务器（Server）：接受客户端连接，实现AMQP消息队列和路由功能的进程。也称为“消息代理”。<br>端点（Peer）：AMQP对话的任意一方。一个AMQP连接包括两个端点（一个是客户端，一个是服务器）。<br>搭档（Partner）：当描述两个端点之间的交互过程时，使用术语“搭档”来表示“另一个”端点的简记法。比如我们定义端点A和端点B，当它们进行通信时，端点B是端点A的搭档，端点A是端点B的搭档。<br>片段集（Assembly）：段的有序集合，形成一个逻辑工作单元。<br>段（Segment）：帧的有序集合，形成片段集中一个完整子单元。<br>帧（Frame）：AMQP传输的一个原子单元。一个帧是一个段中的任意分片。<br>控制（Control）：单向指令，AMQP规范假设这些指令的传输是不可靠的。<br>命令（Command）：需要确认的指令，AMQP规范规定这些指令的传输是可靠的。<br>异常（Exception）：在执行一个或者多个命令时可能发生的错误状态。<br>类（Class）：一批用来描述某种特定功能的AMQP命令或者控制。<br>消息头（Header）：描述消息数据属性的一种特殊段。<br>消息体（Body）：包含应用程序数据的一种特殊段。消息体段对于服务器来说完全透明——服务器不能查看或者修改消息体。<br>消息内容（Content）：包含在消息体段中的的消息数据。<br>交换器（Exchange）：服务器中的实体，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。<br>交换器类型（Exchange Type）：基于不同路由语义的交换器类。<br>消息队列（Message Queue）：一个命名实体，用来保存消息直到发送给消费者。<br>绑定器（Binding）：消息队列和交换器之间的关联。<br>绑定器关键字（Binding Key）：绑定的名称。一些交换器类型可能使用这个名称作为定义绑定器路由行为的模式。<br>路由关键字（Routing Key）：一个消息头，交换器可以用这个消息头决定如何路由某条消息。<br>持久存储（Durable）：一种服务器资源，当服务器重启时，保存的消息数据不会丢失。<br>临时存储（Transient）：一种服务器资源，当服务器重启时，保存的消息数据会丢失。<br>持久化（Persistent）：服务器将消息保存在可靠磁盘存储中，当服务器重启时，消息不会丢失。<br>非持久化（Non-Persistent）：服务器将消息保存在内存中，当服务器重启时，消息可能丢失。<br>消费者（Consumer）：一个从消息队列中请求消息的客户端应用程序。<br>生产者（Producer）：一个向交换器发布消息的客户端应用程序。<br>虚拟主机（Virtual Host）：一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。客户端应用程序在登录到服务器之后，可以选择一个虚拟主机。</p></blockquote><h3 id="五、系统架构"><a href="#五、系统架构" class="headerlink" title="五、系统架构"></a>五、系统架构</h3><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/12/11/rabbitmq-ge-ren-zong-jie/007.png" alt></p><blockquote><p>1.Channel（信道）：多路复用连接中的一条独立的双向数据流通道。信道是建立在真实的TCP连接内的虚拟连接，复用TCP连接的通道。<br>2.Producer（消息的生产者）：向消息队列发布消息的客户端应用程序。<br>3.Consumer（消息的消费者）：从消息队列取得消息的客户端应用程序。<br>4.Message（消息）：消息由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）、priority（消息优先权）、delivery-mode（是否持久性存储）等。<br>5.Routing Key（路由键）：消息头的一个属性，用于标记消息的路由规则，决定了交换机的转发路径。最大长度255 字节。<br>6.Queue（消息队列）：存储消息的一种数据结构，用来保存消息，直到消息发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将消息取走。需要注意，当多个消费者订阅同一个Queue，这时Queue中的消息会被平均分摊给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理，每一条消息只能被一个订阅者接收。<br>7.Exchange（交换器|路由器）：提供Producer到Queue之间的匹配，接收生产者发送的消息并将这些消息按照路由规则转发到消息队列。交换器用于转发消息，它不会存储消息 ，如果没有 Queue绑定到 Exchange 的话，它会直接丢弃掉 Producer 发送过来的消息。交换器有四种消息调度策略（下面会介绍），分别是fanout, direct, topic, headers。<br>8.Binding（绑定）：用于建立Exchange和Queue之间的关联。一个绑定就是基于Binding Key将Exchange和Queue连接起来的路由规则，所以可以将交换器理解成一个由Binding构成的路由表。<br>6.Binding Key（绑定键）：Exchange与Queue的绑定关系，用于匹配Routing Key。最大长度255 字节。<br>7.Broker：RabbitMQ Server，服务器实体。它提供一种传输服务,它的角色就是维护一条从生产者到消费者的路线，保证数据能按照指定的方式进行传输。</p></blockquote><h4 id="5-1、Exchange消息调度策略"><a href="#5-1、Exchange消息调度策略" class="headerlink" title="5.1、Exchange消息调度策略"></a>5.1、Exchange消息调度策略</h4><blockquote><p>​        调度策略是指Exchange在收到生产者发送的消息后依据什么规则把消息转发到一个或多个队列中保存。调度策略与三个因素相关：</p><p>Exchange Type（Exchange的类型）</p><p>Binding Key（Exchange和Queue的绑定关系）</p><p>消息的标记信息（Routing Key和headers）。<br>Exchange根据消息的Routing Key和Exchange绑定Queue的Binding Key分配消息。生产者在将消息发送给Exchange的时候，一般会指定一个Routing Key，来指定这个消息的路由规则，而这个Routing Key需要与Exchange Type及Binding Key联合使用才能最终生效。<br>在Exchange Type与Binding Key固定的情况下（一般这些内容都是固定配置好的），我们的生产者就可以在发送消息给Exchange时，通过指定Routing Key来决定消息流向哪里。</p></blockquote><h4 id="5-2、交换器有四种类型：Direct-topic-Headers-and-Fanout"><a href="#5-2、交换器有四种类型：Direct-topic-Headers-and-Fanout" class="headerlink" title="5.2、交换器有四种类型：Direct, topic, Headers and Fanout"></a>5.2、交换器有四种类型：Direct, topic, Headers and Fanout</h4><blockquote><ul><li>Direct：direct 类型的行为是”先匹配, 再投送”. 即在绑定时设定一个 routing_key, 消息的routing_key匹配时, 才会被交换器投送到绑定的队列中去.</li><li>Topic：按规则转发消息（最灵活）</li><li>Headers：设置header attribute参数类型的交换器</li><li>Fanout：转发消息到所有绑定队列</li></ul></blockquote><h5 id="5-2-1、Fanout-（订阅模式-广播模式）"><a href="#5-2-1、Fanout-（订阅模式-广播模式）" class="headerlink" title="5.2.1、Fanout （订阅模式|广播模式）"></a>5.2.1、Fanout （订阅模式|广播模式）</h5><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/12/11/rabbitmq-ge-ren-zong-jie/008.png" alt></p><blockquote><p>交换器会把所有发送到该交换器的消息路由到所有与该交换器绑定的消息队列中。订阅模式<br>与Binding Key和Routing Key无关，交换器将接受到的消息分发给有绑定关系的所有消息队列队列（不论Binding Key和Routing Key是什么）。类似于子网广播，子网内的每台主机都获得了一份复制的消息。Fanout交换机转发消息是最快的。</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/12/11/rabbitmq-ge-ren-zong-jie/009.png" alt></p><h5 id="5-2-2、Direct（路由模式）"><a href="#5-2-2、Direct（路由模式）" class="headerlink" title="5.2.2、Direct（路由模式）"></a>5.2.2、Direct（路由模式）</h5><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/12/11/rabbitmq-ge-ren-zong-jie/010.png" alt></p><blockquote><p>精确匹配：当消息的Routing Key与 Exchange和Queue 之间的Binding Key完全匹配，如果匹配成功，将消息分发到该Queue。只有当Routing Key和Binding Key完全匹配的时候，消息队列才可以获取消息。Direct是Exchange的默认模式。<br>RabbitMQ默认提供了一个Exchange，名字是空字符串，类型是Direct，绑定到所有的Queue（每一个Queue和这个无名Exchange之间的Binding Key是Queue的名字）。所以，有时候我们感觉不需要交换器也可以发送和接收消息，但是实际上是使用了RabbitMQ默认提供的Exchange。</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/12/11/rabbitmq-ge-ren-zong-jie/011.png" alt></p><h5 id="5-2-3、Topic-（通配符模式）"><a href="#5-2-3、Topic-（通配符模式）" class="headerlink" title="5.2.3、Topic （通配符模式）"></a>5.2.3、Topic （通配符模式）</h5><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/12/11/rabbitmq-ge-ren-zong-jie/012.png" alt></p><blockquote><p>按照正则表达式模糊匹配：用消息的Routing Key与 Exchange和Queue 之间的Binding Key进行模糊匹配，如果匹配成功，将消息分发到该Queue。<br>Routing Key是一个句点号“. ”分隔的字符串（我们将被句点号“. ”分隔开的每一段独立的字符串称为一个单词）。Binding Key与Routing Key一样也是句点号“. ”分隔的字符串。Binding Key中可以存在两种特殊字符“ <em> ”与“#”，用于做模糊匹配，其中“</em>”用于匹配一个单词，“#”用于匹配多个单词（可以是零个）。</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/12/11/rabbitmq-ge-ren-zong-jie/013.png" alt></p><h5 id="5-2-4、Headers（键值对模式）"><a href="#5-2-4、Headers（键值对模式）" class="headerlink" title="5.2.4、Headers（键值对模式）"></a>5.2.4、Headers（键值对模式）</h5><blockquote><p>Headers不依赖于Routing Key与Binding Key的匹配规则来转发消息，交换器的路由规则是通过消息头的Headers属性来进行匹配转发的，类似HTTP请求的Headers。<br>在绑定Queue与Exchange时指定一组键值对，键值对的Hash结构中要求携带一个键“x-match”，这个键的Value可以是any或all，代表消息携带的Hash是需要全部匹配(all)，还是仅匹配一个键(any)。<br>当消息发送到Exchange时，交换器会取到该消息的headers，对比其中的键值对是否完全匹配Queue与Exchange绑定时指定的键值对；如果完全匹配则消息会路由到该Queue，否则不会路由到该Queue。Headers交换机的优势是匹配的规则不被限定为字符串(String)，而是Object类型。</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/12/11/rabbitmq-ge-ren-zong-jie/014.png" alt></p><h4 id="5-3、RPC"><a href="#5-3、RPC" class="headerlink" title="5.3、RPC"></a>5.3、RPC</h4><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/12/11/rabbitmq-ge-ren-zong-jie/015.png" alt></p><blockquote><p>MQ本身是基于异步的消息处理，前面的示例中所有的生产者（P）将消息发送到RabbitMQ后不会知道消费者（C）处理成功或者失败，甚至连有没有消费者来处理这条消息都不知道。但实际的应用场景中，我们很可能需要一些同步处理，需要同步等待服务端将我的消息处理完成后再进行下一步处理。这相当于RPC（Remote Procedure Call，远程过程调用）。</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/12/11/rabbitmq-ge-ren-zong-jie/016.png" alt></p><blockquote><p>RabbitMQ中实现RPC的机制是：<br>一. 生产者发送请求（消息）时，在消息的属性（MessageProperties，在AMQP协议中定义了14个属性，这些属性会随着消息一起发送）中设置两个属性值replyTo（一个Queue名称，用于告诉消费者处理完成后将通知我的消息发送到这个Queue中）和correlationId（此次请求的标识号，消费者处理完成后需要将此属性返还，生产者将根据这个id了解哪条请求被成功执行了或执行失败）。<br>二. 消费者收到消息并处理。<br>三. 消费者处理完消息后，将生成一条应答消息到replyTo指定的Queue，同时带上correlationId属性。<br>四. 生产者之前已订阅replyTo指定的Queue，从中收到服务器的应答消息后，根据其中的correlationId属性分析哪条请求被执行了，根据执行结果进行后续业务处理。</p></blockquote><h4 id="5-4、消息确认-Message-acknowledgment"><a href="#5-4、消息确认-Message-acknowledgment" class="headerlink" title="5.4、消息确认:Message acknowledgment"></a>5.4、消息确认:Message acknowledgment</h4><blockquote><p>在实际应用中，可能会发生消费者收到Queue中的消息，但没有处理完成就宕机（或出现其他意外）的情况，这种情况下就可能会导致消息丢失。为了避免这种情况发生，我们可以要求消费者在消费完消息后发送一个回执给RabbitMQ，RabbitMQ收到消息回执（Message acknowledgment）后才将该消息从Queue中移除；如果RabbitMQ没有收到回执并检测到消费者的RabbitMQ连接断开，则RabbitMQ会将该消息发送给其他消费者（如果存在多个消费者）进行处理。这里不存在Timeout概念，一个消费者处理消息时间再长也不会导致该消息被发送给其他消费者，除非它的RabbitMQ连接断开。<br>这里会产生另外一个问题，如果我们的开发人员在处理完业务逻辑后，忘记发送回执给RabbitMQ，这将会导致严重的问题，Queue中堆积的消息会越来越多，消费者重启后会重复消费这些消息并重复执行业务逻辑。<br>如果我们采用no-ack的方式进行确认，也就是说，每次Consumer接到数据后，而不管是否处理完成，RabbitMQ会立即把这个Message标记为完成，然后从queue中删除了。</p></blockquote><h4 id="5-5、消息持久化-Message-durability"><a href="#5-5、消息持久化-Message-durability" class="headerlink" title="5.5、消息持久化:Message durability"></a>5.5、消息持久化:Message durability</h4><blockquote><p>如果我们希望即使在RabbitMQ服务重启的情况下，也不会丢失消息，我们可以将Queue与Message都设置为可持久化的（durable），这样可以保证绝大部分情况下我们的RabbitMQ消息不会丢失。但依然解决不了小概率丢失事件的发生（比如RabbitMQ服务器已经接收到生产者的消息，但还没来得及持久化该消息时RabbitMQ服务器就断电了），如果我们需要对这种小概率事件也要管理起来，那么我们要用到事务(下面再讲)。</p></blockquote><h4 id="5-6、分发机制"><a href="#5-6、分发机制" class="headerlink" title="5.6、分发机制"></a>5.6、分发机制</h4><blockquote><p>我们在应用程序使用消息系统时，一般情况下生产者往队列里插入数据时速度是比较快的，但是消费者消费数据往往涉及到一些业务逻辑处理导致速度跟不上生产者生产数据。因此如果一个生产者对应一个消费者的话，很容易导致很多消息堆积在队列里。这时，就得使用工作队列了。一个队列有多个消费者同时消费数据。<br>工作队列有两种分发数据的方式：轮询分发（Round-robin）和 公平分发（Fair dispatch）。轮询分发：队列给每一个消费者发送数量一样的数据。公平分发：消费者设置每次从队列中取一条数据，并且消费完后手动应答，继续从队列取下一个数据。</p></blockquote><h5 id="5-6-1、轮询分发：Round-robin-dispatching"><a href="#5-6-1、轮询分发：Round-robin-dispatching" class="headerlink" title="5.6.1、轮询分发：Round-robin dispatching"></a>5.6.1、轮询分发：Round-robin dispatching</h5><blockquote><p>如果工作队列中有两个消费者，两个消费者得到的数据量一样的，并不会因为两个消费者处理数据速度不一样使得两个消费者取得不一样数量的数据。但是这种分发方式存在着一些隐患，消费者虽然得到了消息，但是如果消费者没能成功处理业务逻辑，在RabbitMQ中也不存在这条消息。就会出现消息丢失并且业务逻辑没能成功处理的情况。</p></blockquote><h5 id="5-6-2、公平分发：Fair-dispatch"><a href="#5-6-2、公平分发：Fair-dispatch" class="headerlink" title="5.6.2、公平分发：Fair dispatch"></a>5.6.2、公平分发：Fair dispatch</h5><blockquote><p>消费者设置每次从队列里取一条数据，并且关闭自动回复机制，每次取完一条数据后，手动回复并继续取下一条数据。与轮询分发不同的是，当每个消费都设置了每次只会从队列取一条数据时，并且关闭自动应答，在每次处理完数据后手动给队列发送确认收到数据。这样队列就会公平给每个消息费者发送数据，消费一条再发第二条，而且可以在管理界面中看到数据是一条条随着消费者消费完从而减少的，并不是一下子全部分发完了。采用公平分发方式就不会出现消息丢失并且业务逻辑没能成功处理的情况。</p></blockquote><h4 id="5-7、事务"><a href="#5-7、事务" class="headerlink" title="5.7、事务"></a>5.7、事务</h4><blockquote><p>对事务的支持是AMQP协议的一个重要特性。假设当生产者将一个持久化消息发送给服务器时，因为consume命令本身没有任何Response返回，所以即使服务器崩溃，没有持久化该消息，生产者也无法获知该消息已经丢失。如果此时使用事务，即通过txSelect()开启一个事务，然后发送消息给服务器，然后通过txCommit()提交该事务，即可以保证，如果txCommit()提交了，则该消息一定会持久化，如果txCommit()还未提交即服务器崩溃，则该消息不会服务器接收。当然Rabbit MQ也提供了txRollback()命令用于回滚某一个事务。</p></blockquote><h4 id="5-8、Confirm机制"><a href="#5-8、Confirm机制" class="headerlink" title="5.8、Confirm机制"></a>5.8、Confirm机制</h4><blockquote><p>使用事务固然可以保证只有提交的事务，才会被服务器执行。但是这样同时也将客户端与消息服务器同步起来，这背离了消息队列解耦的本质。Rabbit MQ提供了一个更加轻量级的机制来保证生产者可以感知服务器消息是否已被路由到正确的队列中——Confirm。如果设置channel为confirm状态，则通过该channel发送的消息都会被分配一个唯一的ID，然后一旦该消息被正确的路由到匹配的队列中后，服务器会返回给生产者一个Confirm，该Confirm包含该消息的ID，这样生产者就会知道该消息已被正确分发。对于持久化消息，只有该消息被持久化后，才会返回Confirm。Confirm机制的最大优点在于异步，生产者在发送消息以后，即可继续执行其他任务。而服务器返回Confirm后，会触发生产者的回调函数，生产者在回调函数中处理Confirm信息。如果消息服务器发生异常，导致该消息丢失，会返回给生产者一个nack，表示消息已经丢失，这样生产者就可以通过重发消息，保证消息不丢失。Confirm机制在性能上要比事务优越很多。但是Confirm机制，无法进行回滚，就是一旦服务器崩溃，生产者无法得到Confirm信息，生产者其实本身也不知道该消息是否已经被持久化，只有继续重发来保证消息不丢失，但是如果原先已经持久化的消息，并不会被回滚，这样队列中就会存在两条相同的消息，系统需要支持去重。</p></blockquote><h4 id="5-9、Alternate-Exchange（代替交换器）"><a href="#5-9、Alternate-Exchange（代替交换器）" class="headerlink" title="5.9、Alternate Exchange（代替交换器）"></a>5.9、Alternate Exchange（代替交换器）</h4><blockquote><p>Alternate Exchange是Rabbitmq自己扩展的功能，不是AMQP协议定义的。<br>创建Exchange指定该Exchange的Alternate Exchange，发送消息的时候如果Exchange没有成功把消息路由到队列中去，这就会将此消息路由到Alternate Exchange属性指定的Exchange上了。需要在创建Exchange时添加alternate-exchange属性。如果Alternate Exchange也没能成功把消息路由到队列中去，这个消息就会丢失。可以触发publish confirm机制，表示这个消息没有确认。<br>创建交换器时需要指定如下属性</p></blockquote><pre class=" language-java"><code class="language-java">Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>Object<span class="token operator">></span> argsMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>argsMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>“alternate<span class="token operator">-</span>exchange”<span class="token punctuation">,</span>“Alternate Exchange Name”<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="5-10、TTL（生存时间）"><a href="#5-10、TTL（生存时间）" class="headerlink" title="5.10、TTL（生存时间）"></a>5.10、TTL（生存时间）</h4><blockquote><p>RabbitMQ允许您为消息和队列设置TTL（生存时间）。 可以使用可选的队列参数或策略完成（推荐使用后一个选项）。 可以为单个队列，一组队列或单个消息应用消息TTL。</p><p>设置消息的过期时间</p></blockquote><pre class=" language-java"><code class="language-java">MessageProperties messageProperties <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MessageProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>messageProperties<span class="token punctuation">.</span><span class="token function">setExpiration</span><span class="token punctuation">(</span>“<span class="token number">30000</span>”<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>设置队列中消息的过期时间<br>在声明一个队列时，可以指定队列中消息的过期时间，需要添加x-message-ttl属性。</p></blockquote><pre class=" language-java"><code class="language-java">Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> arguments <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>arguments<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>“x<span class="token operator">-</span>message<span class="token operator">-</span>ttl”<span class="token punctuation">,</span><span class="token number">30000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>如果同时制定了Message TTL，Queue TTL，则时间短的生效。</p></blockquote><h4 id="5-11、Queue-Length-Limit（队列长度限制）"><a href="#5-11、Queue-Length-Limit（队列长度限制）" class="headerlink" title="5.11、Queue Length Limit（队列长度限制）"></a>5.11、Queue Length Limit（队列长度限制）</h4><blockquote><p>可以设置队列中消息数量的限制，如果测试队列中最多只有5个消息，当第六条消息发送过来的时候，会删除最早的那条消息。队列中永远只有5条消息。<br>使用代码声明含有x-max-length和x-max-length-bytes属性的队列<br>Max length(x-max-length) 用来控制队列中消息的数量。<br>如果超出数量，则先到达的消息将会被删除掉。</p><p>Max length bytes(x-max-length-bytes) 用来控制队列中消息总的大小。<br>如果超过总大小，则最先到达的消息将会被删除，直到总大小不超过x-max-length-byte为止。</p><p>Map&lt;String, Object&gt; arguments = new HashMap&lt;&gt;();<br>//表示队列中最多存放三条消息<br>arguments.put(“x-max-length”,3);<br>Map&lt;String, Object&gt; arguments = new HashMap&lt;&gt;();<br>//队列中消息总的空间大小<br>arguments.put(“x-max-length-bytes”,10);</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 消息中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rabbitmq </tag>
            
            <tag> 消息中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JMeter性能测试入门</title>
      <link href="/2019/12/10/jmeter-xing-neng-ce-shi-ru-men/"/>
      <url>/2019/12/10/jmeter-xing-neng-ce-shi-ru-men/</url>
      
        <content type="html"><![CDATA[<h1 id="JMeter性能测试入门"><a href="#JMeter性能测试入门" class="headerlink" title="JMeter性能测试入门"></a>JMeter性能测试入门</h1><p>[TOC]</p><h3 id="一、JMeter简介"><a href="#一、JMeter简介" class="headerlink" title="一、JMeter简介"></a>一、JMeter简介</h3><blockquote><p>​        Apache JMeter是一款纯java编写负载功能测试和性能测试开源工具软件。相比Loadrunner而言，JMeter小巧轻便且免费，逐渐成为了主流的性能测试工具，是每个测试人员都必须要掌握的工具之一。</p></blockquote><h4 id="1-1、JMeter的作用"><a href="#1-1、JMeter的作用" class="headerlink" title="1.1、JMeter的作用"></a>1.1、<strong>JMeter的作用</strong></h4><blockquote><p>1.能够对HTTP和FTP服务器进行压力和<a href="https://baike.baidu.com/item/性能测试" target="_blank" rel="noopener">性能测试</a>， 也可以对任何数据库进行同样的测试（通过JDBC）。</p><p>2.完全的可移植性和100% 纯java。</p><p>3.完全 Swing 和轻量组件支持（<a href="https://baike.baidu.com/item/预编译" target="_blank" rel="noopener">预编译</a>的JAR使用 javax.swing.*)包。</p><p>4.完全多线程 框架允许通过多个线程并发取样和 通过单独的<a href="https://baike.baidu.com/item/线程组" target="_blank" rel="noopener">线程组</a>对不同的功能同时取样。</p><p>5.精心的GUI设计允许快速操作和更精确的计时。</p><p>6.缓存和离线分析/回放测试结果。</p></blockquote><h4 id="1-2、JMeter的高可扩展性"><a href="#1-2、JMeter的高可扩展性" class="headerlink" title="1.2、JMeter的高可扩展性"></a>1.2、<strong>JMeter的高可扩展性</strong></h4><blockquote><p>1.可链接的取样器允许无限制的测试能力。</p><p>2.各种负载统计表和可链接的<a href="https://baike.baidu.com/item/计时器" target="_blank" rel="noopener">计时器</a>可供选择。</p><p>3.数据分析和可视化<a href="https://baike.baidu.com/item/插件" target="_blank" rel="noopener">插件</a>提供了很好的可扩展性以及个性化。</p><p>4.具有提供动态输入到测试的功能（包括Javascript）。</p><p>5.支持脚本编程的取样器（在1.9.2及以上版本支持BeanShell）。</p></blockquote><h4 id="1-3、意义"><a href="#1-3、意义" class="headerlink" title="1.3、意义"></a>1.3、意义</h4><blockquote><p>1、Label： 定义的HTTP请求名称</p><p>2、Samples： 表示这次测试中一共发出了多少个请求</p><p>3、Average： 访问页面的平均响应时间</p><p>4、Min: 访问页面的最小响应时间</p><p>5、Max: 访问页面的最大响应时间</p><p>6、Error%： 错误的请求的数量/请求的总数</p><p>7、Throughput：每秒完成的请求数</p><p>8、KB/Sec： 每秒从服务器端接收到的数据量</p></blockquote><h4 id="1-4、环境"><a href="#1-4、环境" class="headerlink" title="1.4、环境"></a>1.4、环境</h4><blockquote><p>系统Mac os 、JDK版本1.8、Jmeter版本5.2.1</p></blockquote><h3 id="二、测试接口"><a href="#二、测试接口" class="headerlink" title="二、测试接口"></a>二、测试接口</h3><h4 id="2-1、自定义接口"><a href="#2-1、自定义接口" class="headerlink" title="2.1、自定义接口"></a>2.1、自定义接口</h4><blockquote><p><a href="http://127.0.0.1:8080/zms/student/list" target="_blank" rel="noopener">http://127.0.0.1:8080/zms/student/list</a></p><p><a href="http://127.0.0.1:8080/zms/student/delete/{id}" target="_blank" rel="noopener">http://127.0.0.1:8080/zms/student/delete/{id}</a></p></blockquote><h4 id="2-2、请求参数"><a href="#2-2、请求参数" class="headerlink" title="2.2、请求参数"></a>2.2、请求参数</h4><blockquote><p>学生id</p></blockquote><h3 id="三、JMeter脚本编写"><a href="#三、JMeter脚本编写" class="headerlink" title="三、JMeter脚本编写"></a>三、JMeter脚本编写</h3><h4 id="3-1、添加线程组"><a href="#3-1、添加线程组" class="headerlink" title="3.1、添加线程组"></a>3.1、添加线程组</h4><blockquote><p>右键点击—&gt;测试计划—&gt;添加—&gt;线程（用户）—&gt;线程组</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/12/10/jmeter-xing-neng-ce-shi-ru-men/001.png" alt></p><blockquote><p>这里可以配置线程组名称，线程数，准备时长（Ramp-Up Period(in seconds)）循环次数，调度器等参数： </p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/12/10/jmeter-xing-neng-ce-shi-ru-men/002.png" alt></p><blockquote><p>线程组参数详解：</p><p>1、 线程数：虚拟用户数。一个虚拟用户占用一个进程或线程。设置多少虚拟用户数在这里也就是设置多少个        线程数。<br>2、 Ramp-Up 时间(秒)准备时长：设置的虚拟用户数需要多长时间全部启动。如果线程数为10，准备时长为        2，那么需要2秒钟启动10个线程，也就是每秒钟启动5个线程。<br>3、 循环次数：每个线程发送请求的次数。如果线程数为10，循环次数为100，那么每个线程发送100次请        求。总请求数为10*100=1000 。如果勾选了“永远”，那么所有线程会一直发送请求，一到选择停止运行        脚本。<br>4、 Delay Thread creation until needed：直到需要时延迟线程的创建。<br>5、 调度器：设置线程组启动的开始时间和结束时间(配置调度器时，需要勾选循环次数为永远)<br>持续时间（秒）：测试持续时间，会覆盖结束时间<br>启动延迟（秒）：测试延迟启动时间，会覆盖启动时间<br>启动时间：测试启动时间，启动延迟会覆盖它。当启动时间已过，手动只需测试时当前时间也会覆盖它。<br>结束时间：测试结束时间，持续时间会覆盖它。</p></blockquote><h4 id="3-2、添加HTTP请求"><a href="#3-2、添加HTTP请求" class="headerlink" title="3.2、添加HTTP请求"></a>3.2、添加HTTP请求</h4><blockquote><p>右键点击—&gt;线程组– -&gt; 添加—&gt;取样器(Sampler) —&gt; HTTP请求</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/12/10/jmeter-xing-neng-ce-shi-ru-men/003.png" alt></p><p>接口测试：</p><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/12/10/jmeter-xing-neng-ce-shi-ru-men/004.png" alt></p><blockquote><p>Http请求主要参数详解：</p><p>1、Web服务器<br>协议：向目标服务器发送HTTP请求协议，可以是HTTP或HTTPS，默认为HTTP<br>服务器名称或IP ：HTTP请求发送的目标服务器名称或IP<br>端口号：目标服务器的端口号，默认值为80<br>2、Http请求<br>方法：发送HTTP请求的方法，可用方法包括GET、POST、HEAD、PUT、OPTIONS、TRACE、DELETE等。<br>路径：目标URL路径（URL中去掉服务器地址、端口及参数后剩余部分）<br>Content encoding ：编码方式，默认为ISO-8859-1编码，这里配置为utf-8<br>同请求一起发送参数<br>在请求中发送的URL参数，用户可以将URL中所有参数设置在本表中，表中每行为一个参数（对应URL中的 name=value），注意参数传入中文时需要勾选“编码”</p></blockquote><h4 id="3-3、添加察看结果树"><a href="#3-3、添加察看结果树" class="headerlink" title="3.3、添加察看结果树"></a>3.3、添加察看结果树</h4><p>右键—&gt;添加—&gt;监听器—&gt;察看结果树</p><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/12/10/jmeter-xing-neng-ce-shi-ru-men/005.png" alt></p><p>结果：</p><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/12/10/jmeter-xing-neng-ce-shi-ru-men/006.png" alt></p><h3 id="3-4、用户自定义变量"><a href="#3-4、用户自定义变量" class="headerlink" title="3.4、用户自定义变量"></a>3.4、用户自定义变量</h3>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jmeter、性能测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工厂方法设计模式</title>
      <link href="/2019/11/26/gong-han-fang-fa-she-ji-mo-shi/"/>
      <url>/2019/11/26/gong-han-fang-fa-she-ji-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><p>[TOC]</p><h3 id="一、模式的定义与特点"><a href="#一、模式的定义与特点" class="headerlink" title="一、模式的定义与特点"></a>一、模式的定义与特点</h3><blockquote><p>工厂方法（FactoryMethod）模式的定义：定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。这满足创建型模式中所要求的“创建与使用相分离”的特点。 如果要创建的产品不多，只要一个工厂类就可以完成，这种模式叫“简单工厂模式”，它不属于 GoF 的 23 种经典<a href="http://c.biancheng.net/design_pattern/" target="_blank" rel="noopener">设计模式</a>，它的缺点是增加新产品时会违背“开闭原则”。</p><p>工厂方法模式的主要优点有：</p><ul><li><p>用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程；</p></li><li><p>在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则；</p><p>其缺点是：每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。</p></li></ul></blockquote><h3 id="二、模式的结构与实现"><a href="#二、模式的结构与实现" class="headerlink" title="二、模式的结构与实现"></a>二、模式的结构与实现</h3><blockquote><p>工厂方法模式由抽象工厂、具体工厂、抽象产品和具体产品等4个要素构成。本节来分析其基本结构和实现方法。</p></blockquote><h4 id="2-1、模式的结构"><a href="#2-1、模式的结构" class="headerlink" title="2.1、模式的结构"></a>2.1、模式的结构</h4><blockquote><p>工厂方法模式的主要角色如下。</p><ol><li>抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 newProduct() 来创建产品。</li><li>具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。</li><li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。</li><li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</li></ol></blockquote><blockquote><p>其结构图如图 1 所示。</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/11/26/gong-han-fang-fa-she-ji-mo-shi/图一.png" alt></p><h4 id="2-2、模式的实现"><a href="#2-2、模式的实现" class="headerlink" title="2.2、模式的实现"></a>2.2、模式的实现</h4><blockquote><p>根据图 1 写出该模式的代码如下：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AbstractFactoryTest</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">try</span>        <span class="token punctuation">{</span>            Product a<span class="token punctuation">;</span>            AbstractFactory af<span class="token punctuation">;</span>            af<span class="token operator">=</span><span class="token punctuation">(</span>AbstractFactory<span class="token punctuation">)</span> ReadXML1<span class="token punctuation">.</span><span class="token function">getObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            a<span class="token operator">=</span>af<span class="token punctuation">.</span><span class="token function">newProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            a<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">catch</span><span class="token punctuation">(</span>Exception e<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//抽象产品：提供了产品的接口</span><span class="token keyword">interface</span> <span class="token class-name">Product</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//具体产品1：实现抽象产品中的抽象方法</span><span class="token keyword">class</span> <span class="token class-name">ConcreteProduct1</span> <span class="token keyword">implements</span> <span class="token class-name">Product</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"具体产品1显示..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//具体产品2：实现抽象产品中的抽象方法</span><span class="token keyword">class</span> <span class="token class-name">ConcreteProduct2</span> <span class="token keyword">implements</span> <span class="token class-name">Product</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"具体产品2显示..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//抽象工厂：提供了厂品的生成方法</span><span class="token keyword">interface</span> <span class="token class-name">AbstractFactory</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> Product <span class="token function">newProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//具体工厂1：实现了厂品的生成方法</span><span class="token keyword">class</span> <span class="token class-name">ConcreteFactory1</span> <span class="token keyword">implements</span> <span class="token class-name">AbstractFactory</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> Product <span class="token function">newProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"具体工厂1生成-->具体产品1..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProduct1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//具体工厂2：实现了厂品的生成方法</span><span class="token keyword">class</span> <span class="token class-name">ConcreteFactory2</span> <span class="token keyword">implements</span> <span class="token class-name">AbstractFactory</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> Product <span class="token function">newProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"具体工厂2生成-->具体产品2..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProduct2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">ReadXML1</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//该方法用于从XML配置文件中提取具体类类名，并返回一个实例对象</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Object <span class="token function">getObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">try</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//创建文档对象</span>            DocumentBuilderFactory dFactory<span class="token operator">=</span>DocumentBuilderFactory<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            DocumentBuilder builder<span class="token operator">=</span>dFactory<span class="token punctuation">.</span><span class="token function">newDocumentBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Document doc<span class="token punctuation">;</span>                                       doc<span class="token operator">=</span>builder<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"src/FactoryMethod/config1.xml"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//获取包含类名的文本节点</span>            NodeList nl<span class="token operator">=</span>doc<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">"className"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Node classNode<span class="token operator">=</span>nl<span class="token punctuation">.</span><span class="token function">item</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getFirstChild</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            String cName<span class="token operator">=</span><span class="token string">"FactoryMethod."</span><span class="token operator">+</span>classNode<span class="token punctuation">.</span><span class="token function">getNodeValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//System.out.println("新类名："+cName);</span>            <span class="token comment" spellcheck="true">//通过类名生成实例对象并将其返回</span>            Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c<span class="token operator">=</span>Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>cName<span class="token punctuation">)</span><span class="token punctuation">;</span>              Object obj<span class="token operator">=</span>c<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> obj<span class="token punctuation">;</span>         <span class="token punctuation">}</span>           <span class="token keyword">catch</span><span class="token punctuation">(</span>Exception e<span class="token punctuation">)</span>         <span class="token punctuation">{</span>                   e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token keyword">return</span> null<span class="token punctuation">;</span>         <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="三、模式的应用实例"><a href="#三、模式的应用实例" class="headerlink" title="三、模式的应用实例"></a>三、模式的应用实例</h3><blockquote><p>【例1】用工厂方法模式设计畜牧场。</p><p>分析：有很多种类的畜牧场，如养马场用于养马，养牛场用于养牛，所以该实例用工厂方法模式比较适合。</p><p>对养马场和养牛场等具体工厂类，只要定义一个生成动物的方法 newAnimal() 即可。由于要显示马类和牛类等具体产品类的图像，所以它们的构造函数中用到了 JPanel、JLabd 和 ImageIcon 等组件，并定义一个 show() 方法来显示它们。</p><p>客户端程序通过对象生成器类 ReadXML2 读取 XML 配置文件中的数据来决定养马还是养牛。其结构图如图 2 所示。</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/11/26/gong-han-fang-fa-she-ji-mo-shi/图2.png" alt></p><h3 id="四、模式的应用场景"><a href="#四、模式的应用场景" class="headerlink" title="四、模式的应用场景"></a>四、模式的应用场景</h3><blockquote><p>工厂方法模式通常适用于以下场景。</p><ul><li>客户只知道创建产品的工厂名，而不知道具体的产品名。如 TCL 电视工厂、海信电视工厂等。</li><li>创建对象的任务由多个具体子工厂中的某一个完成，而抽象工厂只提供创建产品的接口。</li><li>客户不关心创建产品的细节，只关心产品的品牌。</li></ul></blockquote><h3 id="五、模式的扩展"><a href="#五、模式的扩展" class="headerlink" title="五、模式的扩展"></a>五、模式的扩展</h3><blockquote><p>当需要生成的产品不多且不会增加，一个具体工厂类就可以完成任务时，可删除抽象工厂类。这时工厂方法模式将退化到简单工厂模式，其结构图如图 4 所示。</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/11/26/gong-han-fang-fa-she-ji-mo-shi/图4.png" alt></p><h3 id="六、转载"><a href="#六、转载" class="headerlink" title="六、转载"></a>六、转载</h3><blockquote><p>地址：<a href="http://c.biancheng.net/view/1348.html" target="_blank" rel="noopener">http://c.biancheng.net/view/1348.html</a></p></blockquote><h3 id="七、源码地址"><a href="#七、源码地址" class="headerlink" title="七、源码地址"></a>七、源码地址</h3><blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> factory method </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解Java内存模型（一）——基础</title>
      <link href="/2019/10/17/shen-ru-li-jie-java-nei-cun-mo-xing-yi-ji-chu/"/>
      <url>/2019/10/17/shen-ru-li-jie-java-nei-cun-mo-xing-yi-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="深入理解Java内存模型（一）——基础"><a href="#深入理解Java内存模型（一）——基础" class="headerlink" title="深入理解Java内存模型（一）——基础"></a>深入理解Java内存模型（一）——基础</h1><p>[TOC]</p><h2 id="一、并发编程模型的分类"><a href="#一、并发编程模型的分类" class="headerlink" title="一、并发编程模型的分类"></a>一、并发编程模型的分类</h2><blockquote><p>在并发编程中，我们需要处理两个关键问题：线程之间如何通信及线程之间如何同步（这里的线程是指并发执行的活动实体）。通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种：共享内存和消息传递。</p><p>在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写 - 读内存中的公共状态来隐式进行通信。在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。</p><p>同步是指程序用于控制不同线程之间操作发生相对顺序的机制。在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。</p><p>Java 的并发采用的是共享内存模型，Java 线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。如果编写多线程程序的 Java 程序员不理解隐式进行的线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题。</p></blockquote><h2 id="二、Java-内存模型的抽象"><a href="#二、Java-内存模型的抽象" class="headerlink" title="二、Java 内存模型的抽象"></a>二、Java 内存模型的抽象</h2><blockquote><p>在 java 中，所有实例域、静态域和数组元素存储在堆内存中，堆内存在线程之间共享（本文使用“共享变量”这个术语代指实例域，静态域和数组元素）。局部变量（Local variables），方法定义参数（java 语言规范称之为 formal method parameters）和异常处理器参数（exception handler parameters）不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。</p><p>Java 线程之间的通信由 Java 内存模型（本文简称为 JMM）控制，JMM 决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM 定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读 / 写共享变量的副本。本地内存是 JMM 的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。Java 内存模型的抽象示意图如下：</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/10/17/shen-ru-li-jie-java-nei-cun-mo-xing-yi-ji-chu/001.png" alt></p><blockquote><p>从上图来看，线程 A 与线程 B 之间如要通信的话，必须要经历下面 2 个步骤：</p><ol><li>首先，线程 A 把本地内存 A 中更新过的共享变量刷新到主内存中去。</li><li>然后，线程 B 到主内存中去读取线程 A 之前已更新过的共享变量。</li></ol><p>下面通过示意图来说明这两个步骤：</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/10/17/shen-ru-li-jie-java-nei-cun-mo-xing-yi-ji-chu/002.png" alt></p><blockquote><p>如上图所示，本地内存 A 和 B 有主内存中共享变量 x 的副本。假设初始时，这三个内存中的 x 值都为 0。线程 A 在执行时，把更新后的 x 值（假设值为 1）临时存放在自己的本地内存 A 中。当线程 A 和线程 B 需要通信时，线程 A 首先会把自己本地内存中修改后的 x 值刷新到主内存中，此时主内存中的 x 值变为了 1。随后，线程 B 到主内存中去读取线程 A 更新后的 x 值，此时线程 B 的本地内存的 x 值也变为了 1。</p><p>从整体来看，这两个步骤实质上是线程 A 在向线程 B 发送消息，而且这个通信过程必须要经过主内存。JMM 通过控制主内存与每个线程的本地内存之间的交互，来为 java 程序员提供内存可见性保证。</p></blockquote><h2 id="三、重排序"><a href="#三、重排序" class="headerlink" title="三、重排序"></a>三、重排序</h2><blockquote><p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：</p><ol><li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li><li>指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li><li>内存系统的重排序。由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li></ol><p>从 java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序：</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/10/17/shen-ru-li-jie-java-nei-cun-mo-xing-yi-ji-chu/003.png" alt></p><blockquote><p>上述的 1 属于编译器重排序，2 和 3 属于处理器重排序。这些重排序都可能会导致多线程程序出现内存可见性问题。对于编译器，JMM 的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM 的处理器重排序规则会要求 java 编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel 称之为 memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。</p><p>JMM 属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</p></blockquote><h2 id="四、处理器重排序与内存屏障指令"><a href="#四、处理器重排序与内存屏障指令" class="headerlink" title="四、处理器重排序与内存屏障指令"></a>四、处理器重排序与内存屏障指令</h2><blockquote><p>现代的处理器使用写缓冲区来临时保存向内存写入的数据。写缓冲区可以保证指令流水线持续运行，它可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟。同时，通过以批处理的方式刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写，可以减少对内存总线的占用。虽然写缓冲区有这么多好处，但每个处理器上的写缓冲区，仅仅对它所在的处理器可见。这个特性会对内存操作的执行顺序产生重要的影响：处理器对内存的读 / 写操作的执行顺序，不一定与内存实际发生的读 / 写操作顺序一致！为了具体说明，请看下面示例：</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/10/17/shen-ru-li-jie-java-nei-cun-mo-xing-yi-ji-chu/004.png" alt></p><blockquote><p>假设处理器 A 和处理器 B 按程序的顺序并行执行内存访问，最终却可能得到 x = y = 0 的结果。具体的原因如下图所示：</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/10/17/shen-ru-li-jie-java-nei-cun-mo-xing-yi-ji-chu/005.png" alt></p><blockquote><p>这里处理器 A 和处理器 B 可以同时把共享变量写入自己的写缓冲区（A1，B1），然后从内存中读取另一个共享变量（A2，B2），最后才把自己写缓存区中保存的脏数据刷新到内存中（A3，B3）。当以这种时序执行时，程序就可以得到 x = y = 0 的结果。</p><p>从内存操作实际发生的顺序来看，直到处理器 A 执行 A3 来刷新自己的写缓存区，写操作 A1 才算真正执行了。虽然处理器 A 执行内存操作的顺序为：A1-&gt;A2，但内存操作实际发生的顺序却是：A2-&gt;A1。此时，处理器 A 的内存操作顺序被重排序了（处理器 B 的情况和处理器 A 一样，这里就不赘述了）。</p><p>这里的关键是，由于写缓冲区仅对自己的处理器可见，它会导致处理器执行内存操作的顺序可能会与内存实际的操作执行顺序不一致。由于现代的处理器都会使用写缓冲区，因此现代的处理器都会允许对写 - 读操做重排序。</p><p>下面是常见处理器允许的重排序类型的列表：</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/10/17/shen-ru-li-jie-java-nei-cun-mo-xing-yi-ji-chu/006.png" alt></p><blockquote><p>上表单元格中的“N”表示处理器不允许两个操作重排序，“Y”表示允许重排序。</p><p>从上表我们可以看出：常见的处理器都允许 Store-Load 重排序；常见的处理器都不允许对存在数据依赖的操作做重排序。sparc-TSO 和 x86 拥有相对较强的处理器内存模型，它们仅允许对写 - 读操作做重排序（因为它们都使用了写缓冲区）。</p><p>※注 1：sparc-TSO 是指以 TSO(Total Store Order) 内存模型运行时，sparc 处理器的特性。</p><p>※注 2：上表中的 x86 包括 x64 及 AMD64。</p><p>※注 3：由于 ARM 处理器的内存模型与 PowerPC 处理器的内存模型非常类似，本文将忽略它。</p><p>※注 4：数据依赖性后文会专门说明。</p><p>为了保证内存可见性，java 编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。JMM 把内存屏障指令分为下列四类：</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/10/17/shen-ru-li-jie-java-nei-cun-mo-xing-yi-ji-chu/007.png" alt></p><blockquote><p>StoreLoad Barriers 是一个“全能型”的屏障，它同时具有其他三个屏障的效果。现代的多处理器大都支持该屏障（其他类型的屏障不一定被所有处理器支持）。执行该屏障开销会很昂贵，因为当前处理器通常要把写缓冲区中的数据全部刷新到内存中（buffer fully flush）。</p></blockquote><h2 id="五、happens-before"><a href="#五、happens-before" class="headerlink" title="五、happens-before"></a>五、happens-before</h2><blockquote><p>从 JDK5 开始，java 使用新的 JSR -133 内存模型（本文除非特别说明，针对的都是 JSR- 133 内存模型）。JSR-133 提出了 happens-before 的概念，通过这个概念来阐述操作之间的内存可见性。如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在 happens-before 关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。 与程序员密切相关的 happens-before 规则如下：</p><ul><li>程序顺序规则：一个线程中的每个操作，happens- before 于该线程中的任意后续操作。</li><li>监视器锁规则：对一个监视器锁的解锁，happens- before 于随后对这个监视器锁的加锁。</li><li>volatile 变量规则：对一个 volatile 域的写，happens- before 于任意后续对这个 volatile 域的读。</li><li>传递性：如果 A happens- before B，且 B happens- before C，那么 A happens- before C。</li></ul><p>注意，两个操作之间具有 happens-before 关系，并不意味着前一个操作必须要在后一个操作之前执行！happens-before 仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前（the first is visible to and ordered before the second）。happens- before 的定义很微妙，后文会具体说明 happens-before 为什么要这么定义。</p></blockquote><blockquote><p>happens-before 与 JMM 的关系如下图所示：</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/10/17/shen-ru-li-jie-java-nei-cun-mo-xing-yi-ji-chu/008.png" alt></p><blockquote><p>如上图所示，一个 happens-before 规则通常对应于多个编译器重排序规则和处理器重排序规则。对于 java 程序员来说，happens-before 规则简单易懂，它避免程序员为了理解 JMM 提供的内存可见性保证而去学习复杂的重排序规则以及这些规则的具体实现。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/10/14/cong-shu-ru-url-dao-ye-mian-jia-zai-fa-sheng-liao-shi-me/"/>
      <url>/2019/10/14/cong-shu-ru-url-dao-ye-mian-jia-zai-fa-sheng-liao-shi-me/</url>
      
        <content type="html"><![CDATA[<pre><code>title: 从输入URL到页面加载发生了什么date: 2019-10-14 08:30:28tags: [前端经典面试题]categories: 面试题</code></pre><h1 id="从输入URL到页面加载发生了什么"><a href="#从输入URL到页面加载发生了什么" class="headerlink" title="从输入URL到页面加载发生了什么"></a>从输入URL到页面加载发生了什么</h1><p>[TOC]</p><h3 id="一、总体来说分为以下几个过程"><a href="#一、总体来说分为以下几个过程" class="headerlink" title="一、总体来说分为以下几个过程:"></a>一、总体来说分为以下几个过程:</h3><blockquote><ol><li>DNS解析</li><li>TCP连接</li><li>发送HTTP请求</li><li>服务器处理请求并返回HTTP报文</li><li>浏览器解析渲染页面</li><li>连接结束</li></ol></blockquote><h3 id="二、具体过程"><a href="#二、具体过程" class="headerlink" title="二、具体过程"></a>二、具体过程</h3><h4 id="2-1、DNS解析"><a href="#2-1、DNS解析" class="headerlink" title="2.1、DNS解析"></a>2.1、DNS解析</h4><blockquote><p>​        DNS解析的过程就是寻找哪台机器上有你需要资源的过程。当你在浏览器中输入一个地址时，例如<a href="http://www.baidu.com，其实不是百度网站真正意义上的地址。互联网上每一台计算机的唯一标识是它的IP地址，但是IP地址并不方便记忆。用户更喜欢用方便记忆的网址去寻找互联网上的其它计算机，也就是上面提到的百度的网址。所以互联网设计者需要在用户的方便性与可用性方面做一个权衡，这个权衡就是一个网址到IP地址的转换，这个过程就是DNS解析。它实际上充当了一个翻译的角色，实现了网址到IP地址的转换。网址到IP地址转换的过程是如何进行的" target="_blank" rel="noopener">www.baidu.com，其实不是百度网站真正意义上的地址。互联网上每一台计算机的唯一标识是它的IP地址，但是IP地址并不方便记忆。用户更喜欢用方便记忆的网址去寻找互联网上的其它计算机，也就是上面提到的百度的网址。所以互联网设计者需要在用户的方便性与可用性方面做一个权衡，这个权衡就是一个网址到IP地址的转换，这个过程就是DNS解析。它实际上充当了一个翻译的角色，实现了网址到IP地址的转换。网址到IP地址转换的过程是如何进行的</a>?</p></blockquote><h5 id="2-1-1、解析过程"><a href="#2-1-1、解析过程" class="headerlink" title="2.1.1、解析过程"></a>2.1.1、解析过程</h5><blockquote><p>DNS解析是一个递归查询的过程。</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/10/14/cong-shu-ru-url-dao-ye-mian-jia-zai-fa-sheng-liao-shi-me/001.png" alt></p><blockquote><p>上述图片是查找<a href="http://www.google.com的IP地址过程。首先在本地域名服务器中查询IP地址，如果没有找到的情况下，本地域名服务器会向根域名服务器发送一个请求，如果根域名服务器也不存在该域名时，本地域名会向com顶级域名服务器发送一个请求，依次类推下去。直到最后本地域名服务器得到google的IP地址并把它缓存到本地，供下次查询使用。从上述过程中，可以看出网址的解析是一个从右向左的过程" target="_blank" rel="noopener">www.google.com的IP地址过程。首先在本地域名服务器中查询IP地址，如果没有找到的情况下，本地域名服务器会向根域名服务器发送一个请求，如果根域名服务器也不存在该域名时，本地域名会向com顶级域名服务器发送一个请求，依次类推下去。直到最后本地域名服务器得到google的IP地址并把它缓存到本地，供下次查询使用。从上述过程中，可以看出网址的解析是一个从右向左的过程</a>: com -&gt; google.com -&gt; <a href="http://www.google.com。但是你是否发现少了点什么，根域名服务器的解析过程呢？事实上，真正的网址是www.google.com.，并不是我多打了一个.，这个.对应的就是根域名服务器，默认情况下所有的网址的最后一位都是.，既然是默认情况下，为了方便用户，通常都会省略，浏览器在请求DNS的时候会自动加上，所有网址真正的解析过程为" target="_blank" rel="noopener">www.google.com。但是你是否发现少了点什么，根域名服务器的解析过程呢？事实上，真正的网址是www.google.com.，并不是我多打了一个.，这个.对应的就是根域名服务器，默认情况下所有的网址的最后一位都是.，既然是默认情况下，为了方便用户，通常都会省略，浏览器在请求DNS的时候会自动加上，所有网址真正的解析过程为</a>: . -&gt; .com -&gt; google.com. -&gt; <a href="http://www.google.com.。" target="_blank" rel="noopener">www.google.com.。</a></p></blockquote><h5 id="2-1-2、DNS优化"><a href="#2-1-2、DNS优化" class="headerlink" title="2.1.2、DNS优化"></a>2.1.2、DNS优化</h5><blockquote><p>了解了DNS的过程，可以为我们带来哪些？上文中请求到google的IP地址时，经历了8个步骤，这个过程中存在多个请求(同时存在UDP和TCP请求，为什么有两种请求方式，请自行查找)。如果每次都经过这么多步骤，是否太耗时间？如何减少该过程的步骤呢？那就是DNS缓存。</p></blockquote><h5 id="2-1-3、DNS缓存"><a href="#2-1-3、DNS缓存" class="headerlink" title="2.1.3、DNS缓存"></a>2.1.3、DNS缓存</h5><blockquote><p>DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。</p><ul><li>在你的chrome浏览器中输入:chrome://dns/，你可以看到chrome浏览器的DNS缓存。</li><li>系统缓存主要存在/etc/hosts(Linux系统)中:</li></ul></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/10/14/cong-shu-ru-url-dao-ye-mian-jia-zai-fa-sheng-liao-shi-me/002.png" alt></p><h5 id="2-1-4、DNS负载均衡"><a href="#2-1-4、DNS负载均衡" class="headerlink" title="2.1.4、DNS负载均衡"></a>2.1.4、DNS负载均衡</h5><blockquote><p>不知道大家有没有思考过一个问题: DNS返回的IP地址是否每次都一样？如果每次都一样是否说明你请求的资源都位于同一台机器上面，那么这台机器需要多高的性能和储存才能满足亿万请求呢？其实真实的互联网世界背后存在成千上百台服务器，大型的网站甚至更多。但是在用户的眼中，它需要的只是处理他的请求，哪台机器处理请求并不重要。DNS可以返回一个合适的机器的IP给用户，例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等，这种过程就是DNS负载均衡，又叫做DNS重定向。大家耳熟能详的CDN(Content Delivery Network)就是利用DNS的重定向技术，DNS服务器会返回一个跟用户最接近的点的IP地址给用户，CDN节点的服务器负责响应用户的请求，提供所需的内容。</p></blockquote><h4 id="2-2、TCP连接"><a href="#2-2、TCP连接" class="headerlink" title="2.2、TCP连接"></a>2.2、TCP连接</h4><blockquote><p>HTTP协议是使用TCP作为其传输层协议的，当TCP出现瓶颈时，HTTP也会受到影响。但由于TCP优化这一块我平常接触的并不是很多，再加上大学时的计算机网络的基础基本上忘完，所以这一部分我也就不在这里分析了。</p></blockquote><h5 id="2-2-1、HTTPS协议"><a href="#2-2-1、HTTPS协议" class="headerlink" title="2.2.1、HTTPS协议"></a>2.2.1、HTTPS协议</h5><blockquote><p>HTTP报文是包裹在TCP报文中发送的，服务器端收到TCP报文时会解包提取出HTTP报文。但是这个过程中存在一定的风险，HTTP报文是明文，如果中间被截取的话会存在一些信息泄露的风险。那么在进入TCP报文之前对HTTP做一次加密就可以解决这个问题了。HTTPS协议的本质就是HTTP + SSL(or TLS)。在HTTP报文进入TCP报文之前，先使用SSL对HTTP报文进行加密。从网络的层级结构看它位于HTTP协议与TCP协议之间。</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/10/14/cong-shu-ru-url-dao-ye-mian-jia-zai-fa-sheng-liao-shi-me/003.png" alt></p><h4 id="2-2-2、HTTPS过程"><a href="#2-2-2、HTTPS过程" class="headerlink" title="2.2.2、HTTPS过程"></a>2.2.2、HTTPS过程</h4><blockquote><p>HTTPS在传输数据之前需要客户端与服务器进行一个握手(TLS/SSL握手)，在握手过程中将确立双方加密传输数据的密码信息。TLS/SSL使用了非对称加密，对称加密以及hash等。具体过程请参考经典的阮一峰先生的博客<a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html" target="_blank" rel="noopener">TLS/SSL握手过程</a>。<br>HTTPS相比于HTTP，虽然提供了安全保证，但是势必会带来一些时间上的损耗，如握手和加密等过程，是否使用HTTPS需要根据具体情况在安全和性能方面做出权衡。</p></blockquote><h4 id="2-3、HTTP请求"><a href="#2-3、HTTP请求" class="headerlink" title="2.3、HTTP请求"></a>2.3、HTTP请求</h4><blockquote><p>其实这部分又可以称为前端工程师眼中的HTTP，它主要发生在客户端。发送HTTP请求的过程就是构建HTTP请求报文并通过TCP协议中发送到服务器指定端口(HTTP协议80/8080, HTTPS协议443)。HTTP请求报文是由三部分组成: <strong>请求行</strong>, <strong>请求报头</strong>和<strong>请求正文</strong>。</p><h4 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h4><p>格式如下:<br><code>Method Request-URL HTTP-Version CRLF</code></p><pre><code>eg: GET index.html HTTP/1.1</code></pre><p>常用的方法有: GET, POST, PUT, DELETE, OPTIONS, HEAD。</p><p>TODO：</p><ul><li>GET和POST有什么区别？</li></ul></blockquote><h5 id="2-3-1、请求报头"><a href="#2-3-1、请求报头" class="headerlink" title="2.3.1、请求报头"></a>2.3.1、请求报头</h5><blockquote><p>请求报头允许客户端向服务器传递请求的附加信息和客户端自身的信息。<br>PS: 客户端不一定特指浏览器，有时候也可使用Linux下的CURL命令以及HTTP客户端测试工具等。<br>常见的请求报头有: Accept, Accept-Charset, Accept-Encoding, Accept-Language, Content-Type, Authorization, Cookie, User-Agent等。</p></blockquote><h5 id="2-3-2-、请求正文"><a href="#2-3-2-、请求正文" class="headerlink" title="2.3.2.、请求正文"></a>2.3.2.、请求正文</h5><blockquote><p>当使用POST, PUT等方法时，通常需要客户端向服务器传递数据。这些数据就储存在请求正文中。在请求包头中有一些与请求正文相关的信息，例如: 现在的Web应用通常采用Rest架构，请求的数据格式一般为json。这时就需要设置Content-Type: application/json。</p></blockquote><h4 id="2-4、服务器处理请求并返回HTTP报文"><a href="#2-4、服务器处理请求并返回HTTP报文" class="headerlink" title="2.4、服务器处理请求并返回HTTP报文"></a>2.4、服务器处理请求并返回HTTP报文</h4><blockquote><p>自然而然这部分对应的就是后端工程师眼中的HTTP。后端从在固定的端口接收到TCP报文开始，这一部分对应于编程语言中的socket。它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。这一部分工作一般是由Web服务器去进行，我使用过的Web服务器有Tomcat, Jetty和Netty等等。</p><p>HTTP响应报文也是由三部分组成: <strong>状态码</strong>, <strong>响应报头</strong>和<strong>响应报文</strong>。</p></blockquote><h5 id="2-4-1、状态码"><a href="#2-4-1、状态码" class="headerlink" title="2.4.1、状态码"></a>2.4.1、状态码</h5><blockquote><p>状态码是由3位数组成，第一个数字定义了响应的类别，且有五种可能取值:</p><ul><li>1xx：指示信息–表示请求已接收，继续处理。</li><li>2xx：成功–表示请求已被成功接收、理解、接受。</li><li>3xx：重定向–要完成请求必须进行更进一步的操作。</li><li>4xx：客户端错误–请求有语法错误或请求无法实现。</li><li>5xx：服务器端错误–服务器未能实现合法的请求。<br>平时遇到比较常见的状态码有:200, 204, 301, 302, 304, 400, 401, 403, 404, 422, 500(分别表示什么请自行查找)。</li></ul><p>TODO:</p><ul><li>301和302有什么区别？</li><li>HTTP缓存</li></ul></blockquote><h5 id="2-4-2、响应报头"><a href="#2-4-2、响应报头" class="headerlink" title="2.4.2、响应报头"></a>2.4.2、响应报头</h5><blockquote><p>常见的响应报头字段有: Server, Connection…。</p></blockquote><h5 id="2-4-3、响应报文"><a href="#2-4-3、响应报文" class="headerlink" title="2.4.3、响应报文"></a>2.4.3、响应报文</h5><blockquote><p>服务器返回给浏览器的文本信息，通常HTML, CSS, JS, 图片等文件就放在这一部分。</p></blockquote><h4 id="2-5、浏览器解析渲染页面"><a href="#2-5、浏览器解析渲染页面" class="headerlink" title="2.5、浏览器解析渲染页面"></a>2.5、浏览器解析渲染页面</h4><blockquote><p>浏览器在收到HTML,CSS,JS文件后，它是如何把页面呈现到屏幕上的？下图对应的就是WebKit渲染的过程。</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/10/14/cong-shu-ru-url-dao-ye-mian-jia-zai-fa-sheng-liao-shi-me/004.png" alt></p><blockquote><p>浏览器是一个边解析边渲染的过程。首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。这个过程比较复杂，涉及到两个概念: reflow(回流)和repain(重绘)。DOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为relow;当盒模型的位置,大小以及其他属性，如颜色,字体,等确定下来之后，浏览器便开始绘制内容，这个过程称为repain。页面在首次加载时必然会经历reflow和repain。reflow和repain过程是非常消耗性能的，尤其是在移动设备上，它会破坏用户体验，有时会造成页面卡顿。所以我们应该尽可能少的减少reflow和repain。</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/10/14/cong-shu-ru-url-dao-ye-mian-jia-zai-fa-sheng-liao-shi-me/005.png" alt></p><blockquote><p>JS的解析是由浏览器中的JS解析引擎完成的。JS是单线程运行，也就是说，在同一个时间内只能做一件事，所有的任务都需要排队，前一个任务结束，后一个任务才能开始。但是又存在某些任务比较耗时，如IO读写等，所以需要一种机制可以先执行排在后面的任务，这就是：同步任务(synchronous)和异步任务(asynchronous)。JS的执行机制就可以看做是一个主线程加上一个任务队列(task queue)。同步任务就是放在主线程上执行的任务，异步任务是放在任务队列中的任务。所有的同步任务在主线程上执行，形成一个执行栈;异步任务有了运行结果就会在任务队列中放置一个事件；脚本运行时先依次运行执行栈，然后会从任务队列里提取事件，运行任务队列中的任务，这个过程是不断重复的，所以又叫做事件循环(Event loop)。</p><p>浏览器在解析过程中，如果遇到请求外部资源时，如图像,iconfont,JS等。浏览器将重复1-6过程下载该资源。请求过程是异步的，并不会影响HTML文档进行加载，但是当文档加载过程中遇到JS文件，HTML文档会挂起渲染过程，不仅要等到文档中JS文件加载完毕还要等待解析执行完毕，才会继续HTML的渲染过程。原因是因为JS有可能修改DOM结构，这就意味着JS执行完成前，后续所有资源的下载是没有必要的，这就是JS阻塞后续资源下载的根本原因。CSS文件的加载不影响JS文件的加载，但是却影响JS文件的执行。JS代码执行前浏览器必须保证CSS文件已经下载并加载完毕。</p></blockquote><h4 id="2-6、Web优化"><a href="#2-6、Web优化" class="headerlink" title="2.6、Web优化"></a>2.6、Web优化</h4><blockquote><p>上面部分主要介绍了一次完整的请求对应的过程，了解该过程的目的无非就是为了Web优化。在谈到Web优化之前，我们回到一个更原始的问题，Web前端的本质是什么。我的理解是: 将信息快速并友好的展示给用户并能够与用户进行交互。快速的意思就是在尽可能短的时间内完成页面的加载，试想一下当你在淘宝购买东西的时候，淘宝页面加载了10几秒才显示出物品，这个时候你还有心情去购买吗？怎么快速的完成页面的加载呢？优雅的学院派雅虎给出了常用的一些手段，也就是我们熟悉的<a href="https://developer.yahoo.com/performance/" target="_blank" rel="noopener">雅虎34条军规</a>。这34军规实际上就是围绕请求过程进行的一些优化方式。</p><p>如何尽快的加载资源？答案就是能不从网络中加载的资源就不从网络中加载，当我们合理使用缓存，将资源放在浏览器端，这是最快的方式。如果资源必须从网络中加载，则要考虑缩短连接时间，即DNS优化部分;减少响应内容大小，即对内容进行压缩。另一方面，如果加载的资源数比较少的话，也可以快速的响应用户。当资源到达浏览器之后，浏览器开始进行解析渲染，浏览器中最耗时的部分就是reflow，所以围绕这一部分就是考虑如何减少reflow的次数。</p></blockquote><h3 id="三、转载"><a href="#三、转载" class="headerlink" title="三、转载"></a>三、转载</h3><p>转自：<a href="https://segmentfault.com/a/1190000006879700" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006879700</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Mysql面试集锦</title>
      <link href="/2019/10/11/mysql-mian-shi-ji-jin/"/>
      <url>/2019/10/11/mysql-mian-shi-ji-jin/</url>
      
        <content type="html"><![CDATA[<h1 id="Mysql面试集锦"><a href="#Mysql面试集锦" class="headerlink" title="Mysql面试集锦"></a>Mysql面试集锦</h1><p>[TOC]</p><h3 id="1-索引是什么？有什么作用以及缺点"><a href="#1-索引是什么？有什么作用以及缺点" class="headerlink" title="1.索引是什么？有什么作用以及缺点"></a>1.索引是什么？有什么作用以及缺点</h3><blockquote><p>​        索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。也可以理解为索引就是一本书的目录，创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。 索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚集索引那么需要的空间就会更大。</p></blockquote><h3 id="2-索引的目的是什么"><a href="#2-索引的目的是什么" class="headerlink" title="2.索引的目的是什么"></a>2.索引的目的是什么</h3><blockquote><p>为了高效的查找得到我们所需要的数据，减少分组和排序时间，提高我们的mysql的性能</p></blockquote><h3 id="3-索引对数据库系统的负面影响"><a href="#3-索引对数据库系统的负面影响" class="headerlink" title="3.索引对数据库系统的负面影响"></a>3.索引对数据库系统的负面影响</h3><blockquote><p>虽然索引对于数据库的查询提高了效率，但一定程度上增加了空间的占用，同时写入的速度降低了不少，和原有写入数据相比较，多了一步去维护索引的操作。</p></blockquote><h3 id="4-建立索引的原则"><a href="#4-建立索引的原则" class="headerlink" title="4.建立索引的原则"></a>4.建立索引的原则</h3><blockquote><p>选择唯一性索引，为经常需要查询、排序、分组和联合操作的字段建立索引，限制索引的数目，最左前缀匹配原则（非常重要的原则），尽量选择区分度高的列作为索引，字段尽力设置不为null，索引列上不计算。</p></blockquote><h3 id="5-主键、外键和唯一索引的区别"><a href="#5-主键、外键和唯一索引的区别" class="headerlink" title="5.主键、外键和唯一索引的区别"></a>5.主键、外键和唯一索引的区别</h3><blockquote><p>定义：</p><p>主键：唯一标识一条记录，不能有重复的，不允许为空</p><p>外键：表的外键是另一表的主键, 外键可以有重复的, 可以是空值</p><p>索引：该字段没有重复值，但可以有一个空值</p><p>作用：</p><p>主键：用来保证数据完整性</p><p>外键：用来和其他表建立联系用的</p><p>索引：是提高查询排序的速度</p><p>个数：</p><p>主键：主键只能有一个</p><p>外键：一个表可以有多个外键</p><p>索引：一个表可以有多个唯一索引</p></blockquote><h3 id="6-MySQL底层实现，MySQL有什么引擎"><a href="#6-MySQL底层实现，MySQL有什么引擎" class="headerlink" title="6.MySQL底层实现，MySQL有什么引擎"></a>6.MySQL底层实现，MySQL有什么引擎</h3><blockquote><p>mysql底层采用B+tree的存储结构，也就是只有叶子节点携带真实数据，每个节点大小为16Kb，大致三层的B+tree就可以存2000W左右的数据，大大的减少了磁盘的IO。我们常见的存储引擎有InnoDB和MyISAM。</p></blockquote><h3 id="7-InnoDB和MyISAM区别，InnoDB替代了MyISAM，那么MyISAM是否一无是处。"><a href="#7-InnoDB和MyISAM区别，InnoDB替代了MyISAM，那么MyISAM是否一无是处。" class="headerlink" title="7.InnoDB和MyISAM区别，InnoDB替代了MyISAM，那么MyISAM是否一无是处。"></a>7.InnoDB和MyISAM区别，InnoDB替代了MyISAM，那么MyISAM是否一无是处。</h3><blockquote><ol><li>事务支持 &gt; <em>MyISAM：强调的是性能，每次查询具有原子性,其执行速度比 InnoDB 类型更快，但是不提供事务支持。&gt;</em> InnoDB：提供事务支持事务，外部键等高级数据库功能。具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。</li><li>InnoDB 支持行级锁，而 MyISAM 支持表级锁. &gt;&gt; 用户在操作myisam 表时，select，update，delete，insert 语句都会给表自动加锁，如果加锁以后的表满足insert 并发的情况下，可以在表的尾部插入新的数据。</li><li>InnoDB 支持 MVCC, 而 MyISAM 不支持</li><li>InnoDB 支持外键，而 MyISAM 不支持</li><li>表主键 &gt; <em>MyISAM：允许没有任何索引和主键的表存在，索引都是保存行的地址。&gt;</em> InnoDB：如果没有设定主键或者非空唯一索引，就会自动生成一个6 字节的主键(用户不可见)，数据是主索引的一部分，附加索引保存的是主索引的值。</li><li>InnoDB 不支持全文索引，而 MyISAM 支持。</li><li>可移植性、备份及恢复 &gt; <em>MyISAM：数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作。&gt;</em> InnoDB：免费的方案可以是拷贝数据文件、备份binlog，或者用 mysqldump，在数据量达到几十 G 的时候就相对痛苦了</li><li>存储结构 &gt; <em>MyISAM：每个 MyISAM 在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。.frm 文件存储表定义。数据文件的扩展名为.MYD (MYData)。索引文件的扩展名是.MYI (MYIndex)。&gt;</em> InnoDB：所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为 2GB。</li></ol></blockquote><h3 id="8-什么是事务，事务特性"><a href="#8-什么是事务，事务特性" class="headerlink" title="8.什么是事务，事务特性"></a>8.什么是事务，事务特性</h3><blockquote><p>事务是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。在我们的mysql里也是如此，</p><p>也就是我们的ACID原则。</p><p>A原子性，把一系列的动作视为一个最小的操作（原子操作）</p><p>C一致性，从一个状态到另一个状态是一致的，</p><p>I隔离性：事务与事务之间是不可见相互隔离的，</p><p>D持久性：一旦事务提交，则所做修改就会被永久保存到数据库中。</p><p>可以简单说一下可重复读的MVCC机制，面试官也懵圈</p><ol><li>Read Uncommitted（读取未提交内容） &gt;&gt; 在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。</li><li>Read Committed（读取提交内容） &gt;&gt; 这是大多数数据库系统的默认隔离级别（但不是 MySQL 默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的 commit，所以同一 select 可能返回不同结果。</li><li>Repeatable Read（可重读） &gt;&gt; 这是 MySQL 的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读（PhantomRead）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB 和 Falcon 存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control 间隙锁）机制解决了该问题。注：其实多版本只是解决不可重复读问题，而加上间隙锁（也就是它这里所谓的并发控制）才解决了幻读问题。</li><li>Serializable（可串行化） &gt;&gt; 这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。</li></ol></blockquote><h3 id="9-如何设计一个高并发的系统（对于mysql来讲）"><a href="#9-如何设计一个高并发的系统（对于mysql来讲）" class="headerlink" title="9.如何设计一个高并发的系统（对于mysql来讲）"></a>9.如何设计一个高并发的系统（对于mysql来讲）</h3><blockquote><p>大致就是我们首先应该考虑到的是读写分离操作，再就是我们常见的分库分表操作，水平切分垂直切分。还可以加入缓存redis操作。合理使用索引，explain进行sql优化。</p></blockquote><h3 id="10-锁的优化策略"><a href="#10-锁的优化策略" class="headerlink" title="10.锁的优化策略"></a>10.锁的优化策略</h3><blockquote><p>优化，也就是最小力度的锁我们的数据，也就是行锁，InnoDB的行锁其实是加在索引字段的，避免行锁的升级为表锁，再就是我们尽量避免间隙锁，尽量避免我们的范围修改，如果真的必须范围修改，那么我应该尽可能的缩小到最小的范围。</p></blockquote><h3 id="11-优化SQL的方法"><a href="#11-优化SQL的方法" class="headerlink" title="11.优化SQL的方法"></a>11.优化SQL的方法</h3><blockquote><p>设置一个主键索引，需主要主键索引一般没有真正业务含义，使用int类型自动增长的，而且不能为null，非主键索引字段优先考虑区分度高的业务情况和最左前缀原则，设置为null。如果真的数据量不大，不建议加索引，反而会影响效率的。选取最适用的字段属性，尽可能减少定义字段宽度，尽量把字段设置NOTNULL， 使用连接(JOIN)来代替子查询，适用联合(UNION)来代替手动创建的临时表。学会使用explain进行SQL分析，实在不行可以打开trace进行分析SQL情况，用完记得关闭。</p></blockquote><h3 id="12-谈谈三大范式，什么时候使用反范式设计"><a href="#12-谈谈三大范式，什么时候使用反范式设计" class="headerlink" title="12.谈谈三大范式，什么时候使用反范式设计"></a>12.谈谈三大范式，什么时候使用反范式设计</h3><blockquote><p>第一范式（1NF）：确保每列保持原子性即列不可分</p><p>第二范式（2NF）：属性完全依赖于主键，也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。</p><p>第三范式（3NF）：属性和主键不能间接相关（减少数据冗余，这样就可以通过主外键进行表之间连接）</p><p>比如我们表比较多，需要关联时，但我们的A表只需要关联B表的一个字段，而且每次都需要关联查询你，这时我们可以采用A表放置一个冗余字段来存B表的那个字段。这个操作其实就是一个反范式的。</p></blockquote><h3 id="13-说几个mysql中你常用的函数"><a href="#13-说几个mysql中你常用的函数" class="headerlink" title="13.说几个mysql中你常用的函数"></a>13.说几个mysql中你常用的函数</h3><blockquote><p>sum、count 、avg、min、max</p></blockquote><h3 id="14-varchar-100-和varchar-200-的区别"><a href="#14-varchar-100-和varchar-200-的区别" class="headerlink" title="14.varchar(100)和varchar(200)的区别"></a>14.varchar(100)和varchar(200)的区别</h3><blockquote><p>占用内存空间大小肯定是不一致的，但是占用我们磁盘的大小是一致的，我们存储字符串”abc”，完全是一样的磁盘空间，但是对于varchar(100)来说，接收到的字符串长度太长了就会报错的。后面的数字代表可存储的字节数。</p></blockquote><h3 id="15-varchar-20-和int-20-中的20含义一样吗"><a href="#15-varchar-20-和int-20-中的20含义一样吗" class="headerlink" title="15.varchar(20)和int(20)中的20含义一样吗"></a>15.varchar(20)和int(20)中的20含义一样吗</h3><blockquote><p>显然不一致， int(M) M表示的不是数据的最大长度，只是数据宽度，并不影响存储多少位长度的数据；varchar(M) M表示的是varchar类型数据在数据库中存储的最大长度，超过则不存；</p></blockquote><h3 id="16-如何开启慢日志查询？"><a href="#16-如何开启慢日志查询？" class="headerlink" title="16.如何开启慢日志查询？"></a>16.如何开启慢日志查询？</h3><blockquote><p>有2种方式，一是修改mysql的配置文件，二是通过set global语句来实现。slow_query_log = ON，打开日志，long_query_time = 2，设置时间，2秒就算是慢查询，然后重启mysql服务即可，进入mysql控制台，输入SET GLOBAL slow_query_log = ‘ON’;SET GLOBAL long_query_time = X;不需要重启服务就可以得到慢查询日志。</p></blockquote><h3 id="17-有哪些数据库优化方面的经验"><a href="#17-有哪些数据库优化方面的经验" class="headerlink" title="17.有哪些数据库优化方面的经验?"></a>17.有哪些数据库优化方面的经验?</h3><blockquote><ol><li>用 PreparedStatement， 一般来说比 Statement 性能高：一个 sql发给服务器去执行，涉及步骤：语法检查、语义分析， 编译，缓存。</li><li>有外键约束会影响插入和删除性能，如果程序能够保证数据的完整性，那在设计数据库时就去掉外键。</li><li>表中允许适当冗余，譬如，主题帖的回复数量和最后回复时间等4. UNION ALL 要比UNION 快很多，所以，如果可以确认合并的两个结果集中不包含重复数据且不需要排序时的话，那么就使用 UNIONALL。&gt;&gt;UNION 和 UNION ALL 关键字都是将两个结果集合并为一个，但这两者从使用和效率上来说都有所不同。&gt;1. 对重复结果的处理：UNION 在进行表链接后会筛选掉重复的记录，Union All 不会去除重复记录。&gt;2. 对排序的处理：Union 将会按照字段的顺序进行排序；UNION ALL 只是简单的将两个结果合并后就返回。</li></ol></blockquote><h3 id="18-请简述常用的索引有哪些种类"><a href="#18-请简述常用的索引有哪些种类" class="headerlink" title="18.请简述常用的索引有哪些种类?"></a>18.请简述常用的索引有哪些种类?</h3><blockquote><ol><li>普通索引: 即针对数据库表创建索引</li><li>唯一索引: 与普通索引类似，不同的就是：MySQL 数据库索引列的值必须唯一，但允许有空值</li><li>主键索引: 它是一种特殊的唯一索引，不允许有空值。一般是在建表的时候同时创建主键索引</li><li>组合索引: 为了进一步榨取 MySQL 的效率，就要考虑建立组合索引。即将数据库表中的多个字段联合起来作为一个组合索引。</li></ol></blockquote><h3 id="19-mysql-的复制原理以及流程。"><a href="#19-mysql-的复制原理以及流程。" class="headerlink" title="19.mysql 的复制原理以及流程。"></a>19.mysql 的复制原理以及流程。</h3><blockquote><p>Mysql 内建的复制功能是构建大型，高性能应用程序的基础。将 Mysql 的数据分布到多个系统上去，这种分布的机制，是通过将 Mysql 的某一台主机的数据复制到其它主机（slaves）上，并重新执行一遍来实现的。* 复制过程中一个服务器充当主服务器，而一个或多个其它服务器充当从服务器。</p><p>主服务器将更新写入二进制日志文件，并维护文件的一个索引以跟踪日志循环。这些日志可以记录发送到从服务器的更新。当一个从服务器连接主服务器时，它通知主服务器在日志中读取的最后一次成功更新的位置。</p><p>从服务器接收从那时起发生的任何更新，然后封锁并等待主服务器通知新的更新。过程如下</p><p>\1. 主服务器把更新记录到二进制日志文件中。</p><p>\2. 从服务器把主服务器的二进制日志拷贝到自己的中继日志（replay log）中。3. 从服务器重做中继日志中的时间，把更新应用到自己的数据库上。</p></blockquote><h3 id="20-表中有大字段-X（例如：text-类型），且字段-X-不会经常更新，以读为为主，将该字段拆成子表好处是什么？"><a href="#20-表中有大字段-X（例如：text-类型），且字段-X-不会经常更新，以读为为主，将该字段拆成子表好处是什么？" class="headerlink" title="20.表中有大字段 X（例如：text 类型），且字段 X 不会经常更新，以读为为主，将该字段拆成子表好处是什么？"></a>20.表中有大字段 X（例如：text 类型），且字段 X 不会经常更新，以读为为主，将该字段拆成子表好处是什么？</h3><blockquote><p>如果字段里面有大字段（text,blob)类型的，而且这些字段的访问并不多，这时候放在一起就变成缺点了。MYSQL 数据库的记录存储是按行存储的，数据块大小又是固定的（16K），每条记录越小，相同的块存储的记录就越多。此时应该把大字段拆走，这样应付大部分小字段的查询时，就能提高效率。当需要查询大字段时，此时的关联查询是不可避免的，但也是值得的。拆分开后，对字段的 UPDAE 就要 UPDATE 多个表了</p></blockquote><h3 id="21-MySQL-中-InnoDB-引擎的行锁是通过加在什么上完成（或称实现）的？"><a href="#21-MySQL-中-InnoDB-引擎的行锁是通过加在什么上完成（或称实现）的？" class="headerlink" title="21.MySQL 中 InnoDB 引擎的行锁是通过加在什么上完成（或称实现）的？"></a>21.MySQL 中 InnoDB 引擎的行锁是通过加在什么上完成（或称实现）的？</h3><blockquote><p>InnoDB 行锁是通过给索引上的索引项加锁来实现的，这一点 MySQL 与Oracle 不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB 这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB 才使用行级锁，否则，InnoDB 将使用表锁！</p></blockquote><h3 id="可重复读的MVCC机制"><a href="#可重复读的MVCC机制" class="headerlink" title="可重复读的MVCC机制"></a>可重复读的MVCC机制</h3>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot2整合FastDFS中间件,实现文件分布式管理</title>
      <link href="/2019/09/22/springboot2-zheng-he-fastdfs-zhong-jian-jian-shi-xian-wen-jian-fen-bu-shi-guan-li/"/>
      <url>/2019/09/22/springboot2-zheng-he-fastdfs-zhong-jian-jian-shi-xian-wen-jian-fen-bu-shi-guan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot2整合FastDFS中间件-实现文件分布式管理"><a href="#SpringBoot2整合FastDFS中间件-实现文件分布式管理" class="headerlink" title="SpringBoot2整合FastDFS中间件,实现文件分布式管理"></a>SpringBoot2整合FastDFS中间件,实现文件分布式管理</h1><h3 id="一、FastDFS"><a href="#一、FastDFS" class="headerlink" title="一、FastDFS"></a>一、FastDFS</h3><blockquote><p>​        FastDFS是由淘宝的余庆先⽣生所开发，是⼀一个轻量量级、⾼高性能的开源分布式⽂文件系统，⽤用纯C语⾔言开 发，包括⽂文件存储、⽂文件同步、⽂文件访问(上传、下载)、存取负载均衡、在线扩容、相同内容只存储 ⼀一份等功能，适合有⼤大容量量存储需求的应⽤用或系统。做分布式系统开发时，其中要解决的⼀一个问题就是 图⽚片、⾳音视频、⽂文件共享的问题，分布式⽂文件系统正好可以解决这个需求。同类的分布式⽂文件系统有⾕谷 歌的GFS、HDFS(Hadoop)、TFS(淘宝)等。 </p></blockquote><h3 id="二、FastDFS系统架构"><a href="#二、FastDFS系统架构" class="headerlink" title="二、FastDFS系统架构:"></a>二、FastDFS系统架构:</h3><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/09/22/springboot2-zheng-he-fastdfs-zhong-jian-jian-shi-xian-wen-jian-fen-bu-shi-guan-li/001.png" alt></p><h3 id="三、FastDFS⽂文件上传流程"><a href="#三、FastDFS⽂文件上传流程" class="headerlink" title="三、FastDFS⽂文件上传流程"></a>三、FastDFS⽂文件上传流程</h3><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/09/22/springboot2-zheng-he-fastdfs-zhong-jian-jian-shi-xian-wen-jian-fen-bu-shi-guan-li/002.png" alt></p><blockquote><ol><li>client询问tracker上传到的storage，不需要附加参数;</li><li>tracker返回⼀台可用的storage;</li><li>client直接和storage通讯完成文件上传。</li></ol></blockquote><h3 id="四、FastDFS文件下载流程"><a href="#四、FastDFS文件下载流程" class="headerlink" title="四、FastDFS文件下载流程"></a>四、FastDFS文件下载流程</h3><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/09/22/springboot2-zheng-he-fastdfs-zhong-jian-jian-shi-xian-wen-jian-fen-bu-shi-guan-li/003.png" alt></p><blockquote><ol><li>client询问tracker下载文件的storage，参数为⽂文件标识(组名和⽂文件名);</li><li>tracker返回⼀台可⽤用的storage;</li><li>client直接和storage通讯完成⽂文件下载。</li></ol></blockquote><h3 id="五、核心角色"><a href="#五、核心角色" class="headerlink" title="五、核心角色"></a>五、核心角色</h3><blockquote><p>FastDFS是由跟踪服务器（trackerserver）、存储服务器（storageserver）和客户端（client）三个部分组成。</p><p>1）跟踪服务器</p><p>FastDFS的协调者，负责管理所有的storage server和group，每个storage在启动后会连接Tracker，告知自己所属的group等信息，并保持周期性的心跳，tracker根据storage的心跳信息，建立group到[storage server list]的映射表。</p><p>2）存储服务器</p><p>以组（group）为单位，一个group内包含多台storage机器，数据互为备份，存储空间以group内容量最小的storage为准，所以建议group内的多个storage尽量配置相同，以免造成存储空间的浪费。</p><p>3）客户端</p><p>业务请求的发起方，通过专有接口，使用TCP/IP协议与跟踪器服务器或存储节点进行数据交互。</p></blockquote><h3 id="六、创建SpringBoot工程"><a href="#六、创建SpringBoot工程" class="headerlink" title="六、创建SpringBoot工程"></a>六、创建SpringBoot工程</h3><h4 id="6-1、pom文件"><a href="#6-1、pom文件" class="headerlink" title="6.1、pom文件"></a>6.1、pom文件</h4><pre class=" language-xml"><code class="language-xml"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- FastDFS依赖 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.github.tobato<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>fastdfs-client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.26.5<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- Swagger2 核心依赖 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>io.springfox<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>springfox-swagger2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.6.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>io.springfox<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>springfox-swagger-ui<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.6.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-devtools<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>runtime<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>optional</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>optional</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.projectlombok<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>lombok<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span></code></pre><h4 id="6-2、application-yml"><a href="#6-2、application-yml" class="headerlink" title="6.2、application.yml"></a>6.2、application.yml</h4><pre class=" language-yml"><code class="language-yml">spring:  application:    name: zms-fast-dfs  servlet:    multipart:      enabled: true      max-file-size: 10MB      max-request-size: 20MBserver:  port: 8122fdfs:  # 链接超时  connect-timeout: 300  # 读取时间  so-timeout: 300  # 生成缩略图参数  thumb-image:    width: 150    height: 150  tracker-list: 118.24.39.10:22122</code></pre><h4 id="6-3、配置"><a href="#6-3、配置" class="headerlink" title="6.3、配置"></a>6.3、配置</h4><h5 id="6-3-1、FastDfsConfiguration"><a href="#6-3-1、FastDfsConfiguration" class="headerlink" title="6.3.1、FastDfsConfiguration"></a>6.3.1、FastDfsConfiguration</h5><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span>FdfsClientConfig<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@EnableMBeanExport</span><span class="token punctuation">(</span>registration<span class="token operator">=</span> RegistrationPolicy<span class="token punctuation">.</span>IGNORE_EXISTING<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FastDfsConfiguration</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><h5 id="6-3-2、SwaggerConfig"><a href="#6-3-2、SwaggerConfig" class="headerlink" title="6.3.2、SwaggerConfig"></a>6.3.2、SwaggerConfig</h5><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SwaggerConfig</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> Docket <span class="token function">createRestApi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Docket</span><span class="token punctuation">(</span>DocumentationType<span class="token punctuation">.</span>SWAGGER_2<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">apiInfo</span><span class="token punctuation">(</span><span class="token function">apiInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">apis</span><span class="token punctuation">(</span>RequestHandlerSelectors<span class="token punctuation">.</span><span class="token function">basePackage</span><span class="token punctuation">(</span><span class="token string">"com.springboot.fastdfs"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">paths</span><span class="token punctuation">(</span>PathSelectors<span class="token punctuation">.</span><span class="token function">any</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> ApiInfo <span class="token function">apiInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ApiInfoBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">title</span><span class="token punctuation">(</span><span class="token string">"SpringBoot整合fastDF接口测试"</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">description</span><span class="token punctuation">(</span><span class="token string">"作者：ZongMan"</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">termsOfServiceUrl</span><span class="token punctuation">(</span><span class="token string">"http://zongmansheng.gitee.io/"</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">version</span><span class="token punctuation">(</span><span class="token string">"version 1.0"</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="6-4、工具类"><a href="#6-4、工具类" class="headerlink" title="6.4、工具类"></a>6.4、工具类</h4><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FileDfsUtil</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Logger LOGGER <span class="token operator">=</span> LoggerFactory<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span>FileDfsUtil<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Resource</span>    <span class="token keyword">private</span> FastFileStorageClient storageClient <span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 上传文件     */</span>    <span class="token keyword">public</span> String <span class="token function">upload</span><span class="token punctuation">(</span>MultipartFile multipartFile<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>        String originalFilename <span class="token operator">=</span> multipartFile<span class="token punctuation">.</span><span class="token function">getOriginalFilename</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>                <span class="token function">substring</span><span class="token punctuation">(</span>multipartFile<span class="token punctuation">.</span><span class="token function">getOriginalFilename</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>                        <span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        StorePath storePath <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>storageClient<span class="token punctuation">.</span><span class="token function">uploadImageAndCrtThumbImage</span><span class="token punctuation">(</span>                multipartFile<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                multipartFile<span class="token punctuation">.</span><span class="token function">getSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>originalFilename <span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> storePath<span class="token punctuation">.</span><span class="token function">getFullPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 删除文件     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">deleteFile</span><span class="token punctuation">(</span>String fileUrl<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>fileUrl<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            LOGGER<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"fileUrl ------> 文件路径为空"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            StorePath storePath <span class="token operator">=</span> StorePath<span class="token punctuation">.</span><span class="token function">parseFromUrl</span><span class="token punctuation">(</span>fileUrl<span class="token punctuation">)</span><span class="token punctuation">;</span>            storageClient<span class="token punctuation">.</span><span class="token function">deleteFile</span><span class="token punctuation">(</span>storePath<span class="token punctuation">.</span><span class="token function">getGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> storePath<span class="token punctuation">.</span><span class="token function">getPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            LOGGER<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="6-5、controller"><a href="#6-5、controller" class="headerlink" title="6.5、controller"></a>6.5、controller</h4><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RestController</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FileController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Resource</span>    <span class="token keyword">private</span> FileDfsUtil fileDfsUtil <span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 文件上传     */</span>    <span class="token annotation punctuation">@ApiOperation</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">"上传文件"</span><span class="token punctuation">,</span> notes<span class="token operator">=</span><span class="token string">"测试FastDFS文件上传"</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/uploadFile"</span><span class="token punctuation">,</span>headers<span class="token operator">=</span><span class="token string">"content-type=multipart/form-data"</span><span class="token punctuation">,</span> method <span class="token operator">=</span> RequestMethod<span class="token punctuation">.</span>POST<span class="token punctuation">)</span>    <span class="token keyword">public</span> ResponseEntity<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">uploadFile</span> <span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span><span class="token string">"file"</span><span class="token punctuation">)</span> MultipartFile file<span class="token punctuation">)</span><span class="token punctuation">{</span>        String result <span class="token punctuation">;</span>        <span class="token keyword">try</span><span class="token punctuation">{</span>            String path <span class="token operator">=</span> fileDfsUtil<span class="token punctuation">.</span><span class="token function">upload</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span> <span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>StringUtils<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                result <span class="token operator">=</span> path <span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                result <span class="token operator">=</span> <span class="token string">"上传失败"</span> <span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>            result <span class="token operator">=</span> <span class="token string">"服务异常"</span> <span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ResponseEntity<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 文件删除     */</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/deleteByPath"</span><span class="token punctuation">,</span> method <span class="token operator">=</span> RequestMethod<span class="token punctuation">.</span>GET<span class="token punctuation">)</span>    <span class="token keyword">public</span> ResponseEntity<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">deleteByPath</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           String filePathName <span class="token operator">=</span> <span class="token string">"group1/M00/00/00/rBAAB12HNaeAdfRXAAA4ubrcS4o415_150x150.jpg"</span><span class="token punctuation">;</span>        fileDfsUtil<span class="token punctuation">.</span><span class="token function">deleteFile</span><span class="token punctuation">(</span>filePathName<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ResponseEntity<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token string">"看到这个你就删除成功啦！报仇啦！！！"</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="七、启动并访问Swagger"><a href="#七、启动并访问Swagger" class="headerlink" title="七、启动并访问Swagger"></a>七、启动并访问Swagger</h3><blockquote><p>访问地址：<a href="http://127.0.0.1:8122/swagger-ui.html#/" target="_blank" rel="noopener">http://127.0.0.1:8122/swagger-ui.html#/</a></p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/09/22/springboot2-zheng-he-fastdfs-zhong-jian-jian-shi-xian-wen-jian-fen-bu-shi-guan-li/004.png" alt></p><h3 id="八、源码地址"><a href="#八、源码地址" class="headerlink" title="八、源码地址"></a>八、源码地址</h3><blockquote><p><a href="https://gitee.com/zongmansheng/springboot-zms" target="_blank" rel="noopener">https://gitee.com/zongmansheng/springboot-zms</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> fastDFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7安装软件</title>
      <link href="/2019/09/20/centos7-an-zhuang-java-huan-jing/"/>
      <url>/2019/09/20/centos7-an-zhuang-java-huan-jing/</url>
      
        <content type="html"><![CDATA[<h1 id="CentOS7安装软件"><a href="#CentOS7安装软件" class="headerlink" title="CentOS7安装软件"></a>CentOS7安装软件</h1><h3 id="一、工具"><a href="#一、工具" class="headerlink" title="一、工具"></a>一、工具</h3><blockquote><p>云服务器：安装CentOS 7</p><p>远程连接工具：FinalShell</p></blockquote><h3 id="二、安装java环境"><a href="#二、安装java环境" class="headerlink" title="二、安装java环境"></a>二、安装java环境</h3><h4 id="下载jdk1-8"><a href="#下载jdk1-8" class="headerlink" title="下载jdk1.8"></a>下载jdk1.8</h4><blockquote><p>wget –no-cookies –no-check-certificate –header “Cookie: gpw_e24=http%3A%2F%2F<a href="http://www.oracle.com%2F" target="_blank" rel="noopener">www.oracle.com%2F</a>; oraclelicense=accept-securebackup-cookie” “<a href="http://download.oracle.com/otn-pub/java/jdk/8u141-b15/336fa29ff2bb4ef291e347e091f7f4a7/jdk-8u141-linux-x64.tar.gz&quot;" target="_blank" rel="noopener">http://download.oracle.com/otn-pub/java/jdk/8u141-b15/336fa29ff2bb4ef291e347e091f7f4a7/jdk-8u141-linux-x64.tar.gz&quot;</a></p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/09/20/centos7-an-zhuang-java-huan-jing/001.png" alt></p><h4 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h4><pre><code>tar -zxvf jdk-8u131-linux-x64.tar.gz</code></pre><p>重命名</p><pre><code>mv jdk-8u131-linux-x64.tar.gz /jdk8</code></pre><h3 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h3><pre><code>vi /etc/profile</code></pre><pre><code>export JAVA_HOME=/usr/local/java8/jdk8export JRE_HOME=$JAVA_HOME/jreexport CLASSPATH=$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATHexport PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH</code></pre><p>环境生效</p><pre><code>source /etc/profile</code></pre><h3 id="安装FastDFS"><a href="#安装FastDFS" class="headerlink" title="安装FastDFS"></a>安装FastDFS</h3><h4 id="安装gcc（编译时需要）"><a href="#安装gcc（编译时需要）" class="headerlink" title="安装gcc（编译时需要）"></a>安装gcc（编译时需要）</h4><blockquote><p>FastDFS是C语言开发，安装FastDFS需要先将官网下载的源码进行编译，编译依赖gcc环境，如果没有gcc环境，需要安装gcc</p></blockquote><pre><code>yum install -y gcc gcc-c++</code></pre><h4 id="安装libevent（运行时需求）"><a href="#安装libevent（运行时需求）" class="headerlink" title="安装libevent（运行时需求）"></a>安装libevent（运行时需求）</h4><blockquote><p>若安装了桌面图形界面，就不需要安装；FastDFS依赖libevent库；</p></blockquote><pre><code>yum -y install libevent</code></pre><h4 id="安装libfastcommon"><a href="#安装libfastcommon" class="headerlink" title="安装libfastcommon"></a>安装libfastcommon</h4><pre><code>wget https://github.com/happyfish100/libfastcommon/archive/V1.0.7.tar.gz</code></pre><h4 id="修改名字"><a href="#修改名字" class="headerlink" title="修改名字"></a>修改名字</h4><pre><code> mv V1.0.7.tar.gz libfastcommon-1.0.7.tar.gz</code></pre><h4 id="解压并进入"><a href="#解压并进入" class="headerlink" title="解压并进入"></a>解压并进入</h4><pre><code>tar -zxvf libfastcommon-1.0.7.tar.gzcd libfastcommon-1.0.7/</code></pre><h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><pre><code>./make.sh</code></pre><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/09/20/centos7-an-zhuang-java-huan-jing/002.png" alt></p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><pre><code>./make.sh install</code></pre><h4 id="设置几个软连接"><a href="#设置几个软连接" class="headerlink" title="设置几个软连接"></a>设置几个软连接</h4><pre><code>ln -s /usr/lib64/libfastcommon.so /usr/local/lib/libfastcommon.soln -s /usr/lib64/libfastcommon.so /usr/lib/libfastcommon.soln -s /usr/lib64/libfdfsclient.so /usr/local/lib/libfdfsclient.soln -s /usr/lib64/libfdfsclient.so /usr/lib/libfdfsclient.so</code></pre><h4 id="安装-tracker-（跟踪器）服务-FastDFS-v5-05-tar-gz"><a href="#安装-tracker-（跟踪器）服务-FastDFS-v5-05-tar-gz" class="headerlink" title="安装 tracker （跟踪器）服务 FastDFS_v5.05.tar.gz"></a>安装 tracker （跟踪器）服务 FastDFS_v5.05.tar.gz</h4><pre><code>wget https://github.com/happyfish100/fastdfs/archive/V5.05.tar.gz</code></pre><h4 id="修改名字-1"><a href="#修改名字-1" class="headerlink" title="修改名字"></a>修改名字</h4><pre><code>mv V5.05.tar.gz FastDFS_v5.05.tar.gz</code></pre><p>解压进入编译安装</p><pre><code>tar -zxvf FastDFS_v5.05.tar.gzcd fastdfs-5.05/./make.sh ./make.sh install</code></pre><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/09/20/centos7-an-zhuang-java-huan-jing/003.png" alt></p><h4 id="配置和启动tracker"><a href="#配置和启动tracker" class="headerlink" title="配置和启动tracker"></a>配置和启动tracker</h4><blockquote><p>切换目录到： /etc/fdfs/ 目录下；</p><p>拷贝一份新的tracker配置文件</p></blockquote><pre><code>cp tracker.conf.sample tracker.conf</code></pre><blockquote><p>修改tracker.conf ; </p></blockquote><pre><code>vim tracker.confbase_path=/home/yuqing/fastdfs  改为:  base_path=/home/fastdfshttp.server_port  改为： 80</code></pre><h4 id="创建-home-fastdfs-目录"><a href="#创建-home-fastdfs-目录" class="headerlink" title="创建 /home/fastdfs 目录"></a>创建 /home/fastdfs 目录</h4><pre><code>mkdir /home/fastdfs</code></pre><h4 id="启动tracker，运行如下命令："><a href="#启动tracker，运行如下命令：" class="headerlink" title="启动tracker，运行如下命令："></a>启动tracker，运行如下命令：</h4><pre><code>/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf restart</code></pre><blockquote><p>注意：在/home/fastdfs/ 目录下生成两个目录， 一个是数据，一个是日志</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/09/20/centos7-an-zhuang-java-huan-jing/004.png" alt></p><h4 id="配置和启动storage"><a href="#配置和启动storage" class="headerlink" title="配置和启动storage"></a>配置和启动storage</h4><blockquote><p>由于上面已经安装过FastDFS，这里只需要配置storage就好了；</p><p>（1）切换目录到： /etc/fdfs/ 目录下；</p><p>（2）拷贝一份新的storage配置文件</p></blockquote><blockquote><pre><code>cp storage.conf.sample storage.conf</code></pre></blockquote><blockquote><p>修改storage.conf ; </p></blockquote><pre><code>vim storage.conf</code></pre><blockquote><pre><code>group_name=group1 #配置组名base_path=/home/yuqing/fastdfs    改为:  base_path=/home/fastdfs#store存放文件的位置(store_path)store_path0=/home/yuqing/fastdfs  改为： store_path0=/home/fdfs_storage #如果有多个挂载磁盘则定义多个store_path，如下#store_path1=.....#store_path2=......#配置tracker服务器:IPtracker_server=192.168.172.20:22122#如果有多个则配置多个tracker#tracker_server=192.168.101.4:22122#配置http端口http.server_port=88</code></pre></blockquote><h4 id="创建-home-fdfs-storage-目录"><a href="#创建-home-fdfs-storage-目录" class="headerlink" title="创建 /home/fdfs_storage 目录"></a>创建 /home/fdfs_storage 目录</h4><pre><code>mkdir /home/fdfs_storage</code></pre><h4 id="启动storage，-运行命令如下："><a href="#启动storage，-运行命令如下：" class="headerlink" title="启动storage， 运行命令如下："></a>启动storage， 运行命令如下：</h4><pre><code>/usr/bin/fdfs_storaged /etc/fdfs/storage.conf restart</code></pre><blockquote><p>启动完成后进入 /home/fdfs_storage/data 目录下，显示目录如下：</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/09/20/centos7-an-zhuang-java-huan-jing/005.png" alt></p><h4 id="使用FastDFS自带工具测试"><a href="#使用FastDFS自带工具测试" class="headerlink" title="使用FastDFS自带工具测试"></a>使用FastDFS自带工具测试</h4><blockquote><p>（1）切换目录到 /etc/fdfs/ 目录下；</p><p>（2）拷贝一份新的client配置文件</p></blockquote><pre><code>cp client.conf.sample client.conf</code></pre><blockquote><p>（3）修改client.conf ;   <strong>vim client.conf，</strong>修改基本路径和tracker_server如下：</p></blockquote><pre><code>base_path = /home/fastdfstracker_server = 118.24.39.10:22122</code></pre><p>上传一张图片到新建的pic目录下</p><blockquote><p>进行测试，运行如下：（运行测试程序，读取/etc/fdfs/client.conf 文件，上传/pic目录下的timg.jpg文件）</p></blockquote><pre><code>/usr/bin/fdfs_test /etc/fdfs/client.conf upload /pic/timg.jpg</code></pre><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/09/20/centos7-an-zhuang-java-huan-jing/006.png" alt></p><h3 id="FastDFS-和nginx整合"><a href="#FastDFS-和nginx整合" class="headerlink" title="FastDFS 和nginx整合"></a>FastDFS 和nginx整合</h3><h4 id="下载nginx插件"><a href="#下载nginx插件" class="headerlink" title="下载nginx插件"></a>下载nginx插件</h4><pre><code>wget http://jaist.dl.sourceforge.NET/project/fastdfs/FastDFS%20Nginx%20Module%20Source%20Code/fastdfs-nginx-module_v1.16.tar.gz</code></pre><p>编辑Nginx模块的配置文件：</p><blockquote><p>找到下面一行包含有 local 字眼去掉，因为这三个路径根本不是在 local 目录下的</p><pre>CORE_INCS="$CORE_INCS /usr/local/include/fastdfs /usr/local/include/fastcommon/"</pre>改为如下：<pre>CORE_INCS="$CORE_INCS /usr/include/fastdfs /usr/include/fastcommon/"</pre><p>复制文件：cp /usr/local/fastDFS/fastdfs-5.05/conf/http.conf /etc/fdfs<br>复制文件：cp /usr/local/fastDFS/fastdfs-5.05/conf/mime.types /etc/fdfs</p></blockquote><h4 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h4><pre><code>tar -zxvf nginx-1.11.8.tar.gz cd nginx-1.11.8./configure --add-module=/usr/local/fastDFS/fastdfs-nginx-module/srcmakemake install</code></pre><blockquote><p>复制 Nginx 模块的配置文件：cp /opt/setups/FastDFS/fastdfs-nginx-module/src/mod_fastdfs.conf /etc/fdfs</p></blockquote><pre><code>cp /usr/local/fastDFS/fastdfs-nginx-module/src/mod_fastdfs.conf /etc/fdfs/</code></pre><blockquote><p>编辑 Nginx 模块的配置文件：vim /etc/fdfs/mod_fastdfs.conf，编辑内容看下面中文注释<br>如果在已经启动 Nginx 的情况下修改下面内容记得要重启 Nginx。</p></blockquote><pre><code>vi mod_fastdfs.conf</code></pre><pre><code>base_path=/home/fastdfstracker_server=118.24.39.10:22122 #tracker_server=118.24.39.10:22122 #(多个tracker配置多行)url_have_group_name=true        #url中包含group名称store_path0=/home/fdfs_storage  #指定文件存储路径（上面配置的store路径）</code></pre><h4 id="将libfdfsclient-so拷贝至-usr-lib下"><a href="#将libfdfsclient-so拷贝至-usr-lib下" class="headerlink" title="将libfdfsclient.so拷贝至/usr/lib下"></a>将libfdfsclient.so拷贝至/usr/lib下</h4><pre><code>cp /usr/lib64/libfdfsclient.so /usr/lib/</code></pre><h4 id="创建nginx-client目录"><a href="#创建nginx-client目录" class="headerlink" title="创建nginx/client目录"></a>创建nginx/client目录</h4><pre><code>mkdir -p /var/temp/nginx/client</code></pre><h4 id="修改nginx配置文件"><a href="#修改nginx配置文件" class="headerlink" title="修改nginx配置文件"></a>修改nginx配置文件</h4><pre><code>vi nginx.conf</code></pre><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/09/20/centos7-an-zhuang-java-huan-jing/007.png" alt></p><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/09/20/centos7-an-zhuang-java-huan-jing/008.png" alt></p><blockquote><p><strong>说明</strong>：</p><p>　　(a.) server_name指定本机ip；</p><p>　　(b.) location /group1/M00/：group1为nginx 服务FastDFS的分组名称，M00是FastDFS自动生成编号，对应store_path0=/home/fdfs_storage，如果FastDFS定义store_path1，这里就是M01</p></blockquote><h4 id="Nginx启动"><a href="#Nginx启动" class="headerlink" title="Nginx启动"></a>Nginx启动</h4><pre><code>cd /usr/local/nginx/sbin/./nginx </code></pre><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/09/20/centos7-an-zhuang-java-huan-jing/009.png" alt></p><h3 id="在浏览器中访问上传到fastDFS的图片"><a href="#在浏览器中访问上传到fastDFS的图片" class="headerlink" title="在浏览器中访问上传到fastDFS的图片"></a>在浏览器中访问上传到fastDFS的图片</h3><p><a href="http://118.24.39.10/group1/M00/00/00/rBAAB12E7iyABm0TAACu49zL7nc697_big.jpg" target="_blank" rel="noopener">http://118.24.39.10/group1/M00/00/00/rBAAB12E7iyABm0TAACu49zL7nc697_big.jpg</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql优化专题</title>
      <link href="/2019/09/20/mysql-you-hua-zhuan-ti/"/>
      <url>/2019/09/20/mysql-you-hua-zhuan-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="Mysql优化专题"><a href="#Mysql优化专题" class="headerlink" title="Mysql优化专题"></a>Mysql优化专题</h1><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/09/20/mysql-you-hua-zhuan-ti/001.png" alt></p><h3 id="一、索引的概述"><a href="#一、索引的概述" class="headerlink" title="一、索引的概述"></a>一、索引的概述</h3><h4 id="1）什么是索引？"><a href="#1）什么是索引？" class="headerlink" title="1）什么是索引？"></a>1）什么是索引？</h4><blockquote><p>​        索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。更通俗的说，索引就相当于目录。当你在用新华字典时，帮你把目录撕掉了，你查询某个字开头的成语只能从第一页翻到第一千页。累！把目录还给你，则能快速定位！</p></blockquote><h4 id="2）索引的优缺点："><a href="#2）索引的优缺点：" class="headerlink" title="2）索引的优缺点："></a>2）索引的优缺点：</h4><blockquote><p>​        可以大大加快数据的检索速度，这也是创建索引的最主要的原因。，且通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。但是，索引也是有缺点的：索引需要额外的维护成本；因为索引文件是单独存在的文件,对数据的增加,修改,删除,都会产生额外的对索引文件的操作,这些操作需要消耗额外的IO,会降低增/改/删的执行效率。</p></blockquote><h3 id="二、索引的基本使用"><a href="#二、索引的基本使用" class="headerlink" title="二、索引的基本使用"></a>二、索引的基本使用</h3><h4 id="1）创建索引：（三种方式）"><a href="#1）创建索引：（三种方式）" class="headerlink" title="1）创建索引：（三种方式）"></a>1）创建索引：（三种方式）</h4><h5 id="第一种方式："><a href="#第一种方式：" class="headerlink" title="第一种方式："></a>第一种方式：</h5><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/09/20/mysql-you-hua-zhuan-ti/002.png" alt></p><h5 id="第二种方式：使用ALTER-TABLE命令去增加索引："><a href="#第二种方式：使用ALTER-TABLE命令去增加索引：" class="headerlink" title="第二种方式：使用ALTER TABLE命令去增加索引："></a>第二种方式：使用ALTER TABLE命令去增加索引：</h5><blockquote><p>ALTER TABLE用来创建普通索引、UNIQUE索引或PRIMARY KEY索引。</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/09/20/mysql-you-hua-zhuan-ti/003.png" alt></p><blockquote><p>其中table_name是要增加索引的表名，column_list指出对哪些列进行索引，多列时各列之间用逗号分隔。</p><p>索引名index_name可自己命名，缺省时，MySQL将根据第一个索引列赋一个名称。另外，ALTER TABLE允许在单个语句中更改多个表，因此可以在同时创建多个索引。</p></blockquote><h5 id="第三种方式：使用CREATE-INDEX命令创建"><a href="#第三种方式：使用CREATE-INDEX命令创建" class="headerlink" title="第三种方式：使用CREATE INDEX命令创建"></a>第三种方式：使用CREATE INDEX命令创建</h5><blockquote><p>CREATE INDEX可对表增加普通索引或UNIQUE索引。（但是，不能创建PRIMARY KEY索引）</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/09/20/mysql-you-hua-zhuan-ti/004.png" alt></p><h3 id="三、索引的基本原理"><a href="#三、索引的基本原理" class="headerlink" title="三、索引的基本原理"></a>三、索引的基本原理</h3><blockquote><p>​        索引用来快速地寻找那些具有特定值的记录。如果没有索引，一般来说执行查询时遍历整张表。</p><p>索引的原理很简单，就是把无序的数据变成有序的查询</p><p>1、把创建了索引的列的内容进行排序</p><p>2、对排序结果生成倒排表</p><p>3、在倒排表内容上拼上数据地址链</p><p>4、在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据</p></blockquote><h3 id="四、索引的数据结构（b树，hash）"><a href="#四、索引的数据结构（b树，hash）" class="headerlink" title="四、索引的数据结构（b树，hash）"></a>四、索引的数据结构（b树，hash）</h3><h4 id="1）B树索引"><a href="#1）B树索引" class="headerlink" title="1）B树索引"></a>1）B树索引</h4><blockquote><p>​        mysql通过存储引擎取数据，基本上90%的人用的就是InnoDB了，按照实现方式分，InnoDB的索引类型目前只有两种：BTREE（B树）索引和HASH索引。B树索引是Mysql数据库中使用最频繁的索引类型，基本所有存储引擎都支持BTree索引。通常我们说的索引不出意外指的就是（B树）索引（实际是用B+树实现的，因为在查看表索引时，mysql一律打印BTREE，所以简称为B树索引）</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/09/20/mysql-you-hua-zhuan-ti/005.png" alt></p><blockquote><p>查询方式：</p><p>主键索引区:PI(关联保存的时数据的地址)按主键查询,</p><p>普通索引区:si(关联的id的地址,然后再到达上面的地址)。所以按主键查询,速度最快</p><p>B+tree性质：</p><p>1.）n棵子tree的节点包含n个关键字，不用来保存数据而是保存数据的索引。</p><p>2.）所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</p><p>3.）所有的非终端结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。</p><p>4.）B+ 树中，数据对象的插入和删除仅在叶节点上进行。</p><p>5.）B+树有2个头指针，一个是树的根节点，一个是最小关键码的叶节点。</p></blockquote><h4 id="2）哈希索引"><a href="#2）哈希索引" class="headerlink" title="2）哈希索引"></a>2）哈希索引</h4><blockquote><p>​        简要说下，类似于数据结构中简单实现的HASH表（散列表）一样，当我们在mysql中用哈希索引时，主要就是通过Hash算法（常见的Hash算法有直接定址法、平方取中法、折叠法、除数取余法、随机数法），将数据库字段数据转换成定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置；如果发生Hash碰撞（两个不同关键字的Hash值相同），则在对应Hash键下以链表形式存储。当然这只是简略模拟图。</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/09/20/mysql-you-hua-zhuan-ti/006.png" alt></p><h3 id="五、创建索引的原则（重中之重）"><a href="#五、创建索引的原则（重中之重）" class="headerlink" title="五、创建索引的原则（重中之重）"></a>五、创建索引的原则（重中之重）</h3><blockquote><p>索引虽好，但也不是无限制的使用，最好符合一下几个原则</p><p>1） 最左前缀匹配原则，组合索引非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</p><p>2）较频繁作为查询条件的字段才去创建索引</p><p>3）更新频繁字段不适合创建索引</p><p>4）若是不能有效区分数据的列不适合做索引列(如性别，男女未知，最多也就三种，区分度实在太低)</p><p>5）尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</p><p>6）定义有外键的数据列一定要建立索引。</p><p>7）对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。</p><p>8）对于定义为text、image和bit的数据类型的列不要建立索引。</p></blockquote><h3 id="六、百万级别或以上的数据如何删除"><a href="#六、百万级别或以上的数据如何删除" class="headerlink" title="六、百万级别或以上的数据如何删除"></a>六、百万级别或以上的数据如何删除</h3><blockquote><p>关于索引：由于索引需要额外的维护成本，因为索引文件是单独存在的文件,所以当我们对数据的增加,修改,删除,都会产生额外的对索引文件的操作,这些操作需要消耗额外的IO,会降低增/改/删的执行效率。所以，在我们删除数据库百万级别数据的时候，查询MySQL官方手册得知删除数据的速度和创建的索引数量是成正比的。</p><p>所以我们想要删除百万数据的时候可以先删除索引（此时大概耗时三分多钟）</p><p>然后删除其中无用数据（此过程需要不到两分钟）</p><p>删除完成后重新创建索引(此时数据较少了)创建索引也非常快，约十分钟左右。</p><p>与之前的直接删除绝对是要快速很多，更别说万一删除中断,一切删除会回滚。那更是坑了。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程（一）</title>
      <link href="/2019/09/17/java-duo-xian-cheng-yi/"/>
      <url>/2019/09/17/java-duo-xian-cheng-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="Java多线程（一）"><a href="#Java多线程（一）" class="headerlink" title="Java多线程（一）"></a>Java多线程（一）</h1><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/09/17/java-duo-xian-cheng-yi/001.png" alt></p><h3 id="一-进程和多线程简介"><a href="#一-进程和多线程简介" class="headerlink" title="一 进程和多线程简介"></a>一 进程和多线程简介</h3><h4 id="1-1-相关概念"><a href="#1-1-相关概念" class="headerlink" title="1.1 相关概念"></a>1.1 相关概念</h4><h5 id="何为线程？"><a href="#何为线程？" class="headerlink" title="何为线程？"></a><strong>何为线程？</strong></h5><blockquote><p>​        线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p></blockquote><h5 id="何为进程？"><a href="#何为进程？" class="headerlink" title="何为进程？"></a><strong>何为进程？</strong></h5><blockquote><p>​        进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如CPU时间，内存空间，文件，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。</p></blockquote><h5 id="线程和进程有何不同？"><a href="#线程和进程有何不同？" class="headerlink" title="线程和进程有何不同？"></a><strong>线程和进程有何不同？</strong></h5><blockquote><p>​        线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。</p></blockquote><h4 id="1-2-多线程"><a href="#1-2-多线程" class="headerlink" title="1.2 多线程"></a>1.2 多线程</h4><h5 id="何为多线程？"><a href="#何为多线程？" class="headerlink" title="何为多线程？"></a><strong>何为多线程？</strong></h5><blockquote><p>​        多线程就是几乎同时执行多个线程（一个处理器在某一个时间点上永远都只能是一个线程！即使这个处理器是多核的，除非有多个处理器才能实现多个线程同时运行。）。几乎同时是因为实际上多线程程序中的多个线程实际上是一个线程执行一会然后其他的线程再执行，并不是很多书籍所谓的同时执行。</p></blockquote><h5 id="为什么多线程是必要的？"><a href="#为什么多线程是必要的？" class="headerlink" title="为什么多线程是必要的？"></a><strong>为什么多线程是必要的？</strong></h5><blockquote><ol><li>使用线程可以把占据长时间的程序中的任务放到后台去处理</li><li>用户界面可以更加吸引人，这样比如用户点击了一个按钮去触发某些事件的处理，可以弹出一个进度条来显示处理的进度</li><li>程序的运行速度可能加快</li></ol></blockquote><h3 id="二-使用多线程"><a href="#二-使用多线程" class="headerlink" title="二 使用多线程"></a>二 使用多线程</h3><h4 id="2-1继承Thread类"><a href="#2-1继承Thread类" class="headerlink" title="2.1继承Thread类"></a>2.1继承Thread类</h4><p>MyThread.java</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"简单线程运行！！！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Run.java</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Run</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        MyThread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程结束"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>运行结果：</p><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/09/17/java-duo-xian-cheng-yi/002.png" alt></p><blockquote><p>从上面的运行结果可以看出：线程是一个子任务，CPU以不确定的方式，或者说是以随机的时间来调用线程中的run方法。</p></blockquote><h4 id="2-2实现Runnable接口"><a href="#2-2实现Runnable接口" class="headerlink" title="2.2实现Runnable接口"></a>2.2实现Runnable接口</h4><p>MyRunnable.java</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyRunnable</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Runnable实现多线程"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Run.java</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Run</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Runnable runnable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyRunnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>runnable<span class="token punctuation">)</span><span class="token punctuation">;</span>        thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程结束"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>运行结果：</p><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/09/17/java-duo-xian-cheng-yi/003.png" alt></p><h3 id="三-实例变量和线程安全"><a href="#三-实例变量和线程安全" class="headerlink" title="三 实例变量和线程安全"></a>三 实例变量和线程安全</h3><blockquote><p>定义线程类中的实例变量针对其他线程可以有共享和不共享之分</p></blockquote><h4 id="3-1-不共享数据的情况"><a href="#3-1-不共享数据的情况" class="headerlink" title="3.1 不共享数据的情况"></a>3.1 不共享数据的情况</h4><p>MyThread.java</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">MyThread</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            count<span class="token operator">--</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"由 "</span> <span class="token operator">+</span> MyThread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                    <span class="token operator">+</span> <span class="token string">" 计算，count="</span> <span class="token operator">+</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Run.java</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Run</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        MyThread a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        MyThread b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        MyThread c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token string">"C"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        a<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        b<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        c<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>运行结果：</p><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/09/17/java-duo-xian-cheng-yi/004.png" alt></p><blockquote><p>可以看出每个线程都有一个属于自己的实例变量count，它们之间互不影响。我们再来看看另一种情况</p></blockquote><h4 id="3-2-共享数据的情况"><a href="#3-2-共享数据的情况" class="headerlink" title="3.2 共享数据的情况"></a>3.2 共享数据的情况</h4><p>MyThread.java</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        count<span class="token operator">--</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"由 "</span> <span class="token operator">+</span> MyThread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" 计算，count="</span> <span class="token operator">+</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Run.java</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Run</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        MyThread mythread<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/**         * 下列线程都是通过mythread对象创建的         */</span>        Thread a<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>mythread<span class="token punctuation">,</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread b<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>mythread<span class="token punctuation">,</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread c<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>mythread<span class="token punctuation">,</span><span class="token string">"C"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread d<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>mythread<span class="token punctuation">,</span><span class="token string">"D"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread e<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>mythread<span class="token punctuation">,</span><span class="token string">"E"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        a<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        b<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        c<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        d<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        e<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>运行结果：</p><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/09/17/java-duo-xian-cheng-yi/005.png" alt></p><blockquote><p>可以看出这里已经出现了错误，我们想要的是依次递减的结果。为什么呢？？</p><p>因为在大多数jvm中，count–的操作分为如下下三步：</p><ol><li>取得原有count值</li><li>计算i -1</li><li>对i进行赋值</li></ol><p>所以多个线程同时访问时出现问题就是难以避免的了。</p><p>那么有没有什么解决办法呢？</p><p>答案是：当然有，而且很简单。</p><p>在run方法前加上synchronized关键字即可得到正确答案。</p></blockquote><p>加上关键字后的运行结果：</p><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/09/17/java-duo-xian-cheng-yi/006.png" alt></p><h3 id="四-一些常用方法"><a href="#四-一些常用方法" class="headerlink" title="四 一些常用方法"></a>四 一些常用方法</h3><h4 id="4-1-currentThread"><a href="#4-1-currentThread" class="headerlink" title="4.1 currentThread()"></a>4.1 currentThread()</h4><blockquote><p>返回对当前正在执行的线程对象的引用。</p></blockquote><h4 id="4-2-getId"><a href="#4-2-getId" class="headerlink" title="4.2 getId()"></a>4.2 getId()</h4><blockquote><p>返回此线程的标识符</p></blockquote><h4 id="4-3-getName"><a href="#4-3-getName" class="headerlink" title="4.3 getName()"></a>4.3 getName()</h4><blockquote><p>返回此线程的名称</p></blockquote><h4 id="4-4-getPriority"><a href="#4-4-getPriority" class="headerlink" title="4.4 getPriority()"></a>4.4 getPriority()</h4><blockquote><p>返回此线程的优先级</p></blockquote><h4 id="4-5-isAlive"><a href="#4-5-isAlive" class="headerlink" title="4.5 isAlive()"></a>4.5 isAlive()</h4><blockquote><p>测试这个线程是否还处于活动状态。</p></blockquote><blockquote><p>什么是活动状态呢？</p></blockquote><blockquote><p>活动状态就是线程已经启动且尚未终止。线程处于正在运行或准备运行的状态。</p></blockquote><h4 id="4-6-sleep-long-millis"><a href="#4-6-sleep-long-millis" class="headerlink" title="4.6 sleep(long millis)"></a>4.6 sleep(long millis)</h4><blockquote><p>使当前正在执行的线程以指定的毫秒数“休眠”（暂时停止执行），具体取决于系统定时器和调度程序的精度和准确性。</p></blockquote><h4 id="4-7-interrupt"><a href="#4-7-interrupt" class="headerlink" title="4.7 interrupt()"></a>4.7 interrupt()</h4><blockquote><p>中断这个线程。</p></blockquote><h4 id="4-8-interrupted-和isInterrupted"><a href="#4-8-interrupted-和isInterrupted" class="headerlink" title="4.8 interrupted() 和isInterrupted()"></a>4.8 interrupted() 和isInterrupted()</h4><blockquote><p>interrupted()：测试当前线程是否已经是中断状态，执行后具有将状态标志清除为false的功能</p></blockquote><blockquote><p>isInterrupted()： 测试线程Thread对相关是否已经是中断状态，但部清楚状态标志</p></blockquote><h4 id="4-9-setName-String-name"><a href="#4-9-setName-String-name" class="headerlink" title="4.9 setName(String name)"></a>4.9 setName(String name)</h4><blockquote><p>将此线程的名称更改为等于参数 name 。</p></blockquote><h4 id="4-10-isDaemon"><a href="#4-10-isDaemon" class="headerlink" title="4.10 isDaemon()"></a>4.10 isDaemon()</h4><blockquote><p>测试这个线程是否是守护线程。</p></blockquote><h3 id="4-11-setDaemon-boolean-on"><a href="#4-11-setDaemon-boolean-on" class="headerlink" title="4.11 setDaemon(boolean on)"></a>4.11 setDaemon(boolean on)</h3><blockquote><p>将此线程标记为 daemon线程或用户线程。</p></blockquote><h3 id="4-12-join"><a href="#4-12-join" class="headerlink" title="4.12 join()"></a>4.12 join()</h3><blockquote><p>在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再结束，这个时候就要用到join()方法了。</p></blockquote><blockquote><p>join()的作用是：“等待该线程终止”，这里需要理解的就是该线程是指的主线程等待子线程的终止。也就是在子线程调用了join()方法后面的代码，只有等到子线程结束了才能执行</p></blockquote><h3 id="4-13-yield"><a href="#4-13-yield" class="headerlink" title="4.13 yield()"></a>4.13 yield()</h3><blockquote><p>yield()方法的作用是放弃当前的CPU资源，将它让给其他的任务去占用CPU时间。注意：放弃的时间不确定，可能一会就会重新获得CPU时间片。</p></blockquote><h3 id="4-14-setPriority-int-newPriority"><a href="#4-14-setPriority-int-newPriority" class="headerlink" title="4.14 setPriority(int newPriority)"></a>4.14 setPriority(int newPriority)</h3><blockquote><p>更改此线程的优先级</p></blockquote><h3 id="五-如何停止一个线程呢？"><a href="#五-如何停止一个线程呢？" class="headerlink" title="五 如何停止一个线程呢？"></a>五 如何停止一个线程呢？</h3><h4 id="5-1-使用interrupt-方法"><a href="#5-1-使用interrupt-方法" class="headerlink" title="5.1 使用interrupt()方法"></a>5.1 使用interrupt()方法</h4><blockquote><p>我们上面提到了interrupt()方法，先来试一下interrupt()方法能不能停止线程 </p></blockquote><p>MyThread.java</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5000000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"i="</span> <span class="token operator">+</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Run.java</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Run</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            MyThread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            thread<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"main catch"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>运行上诉代码你会发现，线程并不会终止。</p><p>针对上面代码的一个改进：</p><p>interrupted()方法判断线程是否停止，如果是停止状态则break</p></blockquote><p>MyThread.java</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">500000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"已经是停止状态了!我要退出了!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"i="</span> <span class="token operator">+</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"看到这句话说明线程并未终止------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Run.java</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Run</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            MyThread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            thread<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"main catch"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"end!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/09/17/java-duo-xian-cheng-yi/007.png" alt></p><blockquote><p>for循环虽然停止执行了，但是for循环下面的语句还是会执行，说明线程并未被停止。</p></blockquote><h4 id="5-2-使用return停止线程"><a href="#5-2-使用return停止线程" class="headerlink" title="5.2 使用return停止线程"></a>5.2 使用return停止线程</h4><p>MyThread.java</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ֹͣ停止了!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"timer="</span> <span class="token operator">+</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Run.java</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Run</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        MyThread t<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="六-线程的优先级"><a href="#六-线程的优先级" class="headerlink" title="六 线程的优先级"></a>六 线程的优先级</h3><blockquote><p>每个线程都具有各自的优先级，线程的优先级可以在程序中表明该线程的重要性，如果有很多线程处于就绪状态，系统会根据优先级来决定首先使哪个线程进入运行状态。但这个并不意味着低 优先级的线程得不到运行，而只是它运行的几率比较小，如垃圾回收机制线程的优先级就比较低。所以很多垃圾得不到及时的回收处理。</p><p>线程优先级具有继承特性比如A线程启动B线程，则B线程的优先级和A是一样的。</p><p>线程优先级具有随机性也就是说线程优先级高的不一定每一次都先执行完。</p><p>Thread类中包含的成员变量代表了线程的某些优先级。如<strong>Thread.MIN_PRIORITY（常数1）</strong>，<strong>Thread.NORM_PRIORITY（常数5）</strong>,<strong>Thread.MAX_PRIORITY（常数10）</strong>。其中每个线程的优先级都在<strong>Thread.MIN_PRIORITY（常数1）</strong>到<strong>Thread.MAX_PRIORITY（常数10）</strong>之间，在默认情况下优先级都是<strong>Thread.NORM_PRIORITY（常数5）</strong>。</p><p>学过操作系统这门课程的话，我们可以发现多线程优先级或多或少借鉴了操作系统对进程的管理。</p><p><strong>线程优先级具有继承特性测试代码：</strong></p></blockquote><p>MyThread01.java</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyThread01</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"MyThread1 run priority="</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getPriority</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        MyThread02 thread2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread02</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>MyThread02.java</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyThread02</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"MyThread2 run priority="</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getPriority</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Run.java</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Run</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"main thread begin priority="</span>                <span class="token operator">+</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getPriority</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setPriority</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"main thread end   priority="</span>                <span class="token operator">+</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getPriority</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        MyThread01 thread1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread01</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/09/17/java-duo-xian-cheng-yi/008.png" alt></p><h3 id="七-Java多线程分类"><a href="#七-Java多线程分类" class="headerlink" title="七 Java多线程分类"></a>七 Java多线程分类</h3><h4 id="7-1-多线程分类"><a href="#7-1-多线程分类" class="headerlink" title="7.1 多线程分类"></a>7.1 多线程分类</h4><blockquote><p>用户线程：运行在前台，执行具体的任务，如程序的主线程、连接网络的子线程等都是用户线程</p><p>守护线程：运行在后台，为其他前台线程服务.也可以说守护线程是JVM中非守护线程的 <strong>“佣人”</strong>。</p><p>特点：一旦所有用户线程都结束运行，守护线程会随JVM一起结束工作</p><p>应用：数据库连接池中的检测线程，JVM虚拟机启动后的检测线程</p><p>最常见的守护线程：垃圾回收线程</p></blockquote><h4 id="7-2-如何设置守护线程？"><a href="#7-2-如何设置守护线程？" class="headerlink" title="7.2 如何设置守护线程？"></a>7.2 如何设置守护线程？</h4><blockquote><p>可以通过调用Thead类的setDaemon(true)方法设置当前的线程为守护线程</p><p>注意事项：</p><pre><code>1.  setDaemon(true)必须在start（）方法前执行，否则会抛出IllegalThreadStateException异常2. 在守护线程中产生的新线程也是守护线程3. 不是所有的任务都可以分配给守护线程来执行，比如读写操作或者计算逻辑</code></pre></blockquote><p>MyThread.java</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>         <span class="token keyword">private</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"i="</span> <span class="token operator">+</span> <span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// TODO Auto-generated catch block</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Run.java</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Run</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            MyThread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            thread<span class="token punctuation">.</span><span class="token function">setDaemon</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"我离开thread对象也不再打印了，也就是停止了！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// TODO Auto-generated catch block</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/09/17/java-duo-xian-cheng-yi/009.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> Thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot整合activemq</title>
      <link href="/2019/09/09/springboot-zheng-he-activemq/"/>
      <url>/2019/09/09/springboot-zheng-he-activemq/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot整合activemq"><a href="#SpringBoot整合activemq" class="headerlink" title="SpringBoot整合activemq"></a>SpringBoot整合activemq</h1>]]></content>
      
      
      <categories>
          
          <category> 消息中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> activemq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot整合七牛云实现图片上传</title>
      <link href="/2019/09/08/springboot-zheng-he-qi-niu-yun-shi-xian-tu-pian-shang-chuan/"/>
      <url>/2019/09/08/springboot-zheng-he-qi-niu-yun-shi-xian-tu-pian-shang-chuan/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot整合七牛云实现图片上传"><a href="#SpringBoot整合七牛云实现图片上传" class="headerlink" title="SpringBoot整合七牛云实现图片上传"></a>SpringBoot整合七牛云实现图片上传</h1><h3 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h3>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 七牛云 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下常用命令</title>
      <link href="/2019/09/07/linux-xia-chang-yong-ming-ling/"/>
      <url>/2019/09/07/linux-xia-chang-yong-ming-ling/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux下常用命令"><a href="#Linux下常用命令" class="headerlink" title="Linux下常用命令"></a>Linux下常用命令</h1><h3 id="一、Linux防火墙查看状态firewall、iptable"><a href="#一、Linux防火墙查看状态firewall、iptable" class="headerlink" title="一、Linux防火墙查看状态firewall、iptable"></a>一、Linux防火墙查看状态firewall、iptable</h3><blockquote><p>一、iptables防火墙<br>1、基本操作</p><p># 查看防火墙状态</p><p>service iptables status  </p><p># 停止防火墙</p><p>service iptables stop  </p><p># 启动防火墙</p><p>service iptables start  </p><p># 重启防火墙</p><p>service iptables restart  </p><p># 永久关闭防火墙</p><p>chkconfig iptables off  </p><p># 永久关闭后重启</p><p>chkconfig iptables on　　</p><p>2、开启80端口</p><p>vim /etc/sysconfig/iptables<br># 加入如下代码<br>-A INPUT -m state –state NEW -m tcp -p tcp –dport 80 -j ACCEPT<br>保存退出后重启防火墙</p><p>service iptables restart<br>二、firewall防火墙<br>1、查看firewall服务状态</p><p>systemctl status firewalld</p><p>出现Active: active (running)切高亮显示则表示是启动状态。</p><p>出现 Active: inactive (dead)灰色表示停止，看单词也行。<br>2、查看firewall的状态</p><p>firewall-cmd –state<br>3、开启、重启、关闭、firewalld.service服务</p><p># 开启<br>service firewalld start<br># 重启<br>service firewalld restart<br># 关闭<br>service firewalld stop<br>4、查看防火墙规则</p><p>firewall-cmd –list-all<br>5、查询、开放、关闭端口</p><h1 id="查询端口是否开放"><a href="#查询端口是否开放" class="headerlink" title="查询端口是否开放"></a>查询端口是否开放</h1><p>firewall-cmd –query-port=8080/tcp</p><h1 id="开放80端口"><a href="#开放80端口" class="headerlink" title="开放80端口"></a>开放80端口</h1><p>firewall-cmd –permanent –add-port=80/tcp</p><h1 id="移除端口"><a href="#移除端口" class="headerlink" title="移除端口"></a>移除端口</h1><p>firewall-cmd –permanent –remove-port=8080/tcp</p><p>#重启防火墙(修改配置后要重启防火墙)<br>firewall-cmd –reload</p><h1 id="参数解释"><a href="#参数解释" class="headerlink" title="参数解释"></a>参数解释</h1><p>1、firwall-cmd：是Linux提供的操作firewall的一个工具；<br>2、–permanent：表示设置为持久；<br>3、–add-port：标识添加的端口；</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac下docker环境安装Redis</title>
      <link href="/2019/08/21/mac-xia-docker-huan-jing-an-zhuang-redis/"/>
      <url>/2019/08/21/mac-xia-docker-huan-jing-an-zhuang-redis/</url>
      
        <content type="html"><![CDATA[<h1 id="Mac下docker环境安装Redis"><a href="#Mac下docker环境安装Redis" class="headerlink" title="Mac下docker环境安装Redis"></a>Mac下docker环境安装Redis</h1><blockquote><p>说明下，以下内容中：<br><code>本地</code>是指，主机，即安装<code>docker</code>的机器环境，一般是物理机<br><code>容器</code>是指，运行<code>docker</code>容器后的内部环境</p></blockquote><h4 id="一、下载镜像"><a href="#一、下载镜像" class="headerlink" title="一、下载镜像"></a>一、下载镜像</h4><pre><code>docker pull redis</code></pre><blockquote><p>不指定版本默认下载就是最新版本</p></blockquote><h4 id="二、在本地某个位置创建以下内容"><a href="#二、在本地某个位置创建以下内容" class="headerlink" title="二、在本地某个位置创建以下内容"></a>二、在本地某个位置创建以下内容</h4><blockquote><p>建议将以下内容放在一起，方便以后管理和查看</p><p>mac切换用户权限    sudo su</p></blockquote><pre><code># 以/docker/redis为例mkdir /docker/redismkdir /docker/redis/datatouch /docker/redis/redis.conftouch /docker/redis/redis.bash</code></pre><h4 id="三、编辑配置文件"><a href="#三、编辑配置文件" class="headerlink" title="三、编辑配置文件"></a>三、编辑配置文件</h4><pre><code>vim /docker/redis/reoedis.conf</code></pre><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/08/21/mac-xia-docker-huan-jing-an-zhuang-redis/001.png" alt></p><h4 id="四、编辑启动脚本"><a href="#四、编辑启动脚本" class="headerlink" title="四、编辑启动脚本"></a>四、编辑启动脚本</h4><pre><code>vi /docker/redis/redis.bash</code></pre><pre><code>docker run -p 6379:6379 --name redis -v /docker/redis/redis.conf:/etc/redis/redis.conf -v /docker/redis/data:/data -d redis redis-server /etc/redis/redis.conf </code></pre><pre><code>docker run redis # 从redis镜像运行容器-p 6379:6379 # 映射本地6379端口到容器6379端口，前为本地端口--name redis # 设置容器名称为redis，方便以后使用docker ps进行管理-v /docker/redis/redis.conf:/etc/redis/redis.conf # 关联本地/docker/redis/redis.conf文件到容器中/etc/redis/redis.conf，同样，前为本地-v /docker/redis/data:/data # 关联本地/docker/redis/data到容器内/data目录，此为存放redis数据的目录，为方便以后升级redis，而数据可以留存-d # 后台启动，使用此方式启动，则redis.conf中daemonize必须设置为no，否则会无法启动redis-server /etc/redis/redis.conf # 在容器内启动redis-server的命令，主要是为了加载配置</code></pre><h4 id="五、给与执行权限"><a href="#五、给与执行权限" class="headerlink" title="五、给与执行权限"></a>五、给与执行权限</h4><pre><code>sudo chmod 777 /docker/redis/redis.bash</code></pre><h4 id="六、启动"><a href="#六、启动" class="headerlink" title="六、启动"></a>六、启动</h4><pre><code>/docker/redis/redis.bash# 查看是否已启动docker ps# 如果无法启动或者docker ps中无对应内容，将bash中命令复制出来，删除-d参数启动，查看报错信息# 使用redis-cli或者rdm访问 localhost:6379# 如需访问容器，可使用docker exec -it redis bash# 或直接使用redis-cli访问容器内redisdocker exec -it redis redis-cli</code></pre>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac下docker环境安装ElasticSearch</title>
      <link href="/2019/08/20/mac-xia-docker-huan-jing-an-zhuang-elasticsearch/"/>
      <url>/2019/08/20/mac-xia-docker-huan-jing-an-zhuang-elasticsearch/</url>
      
        <content type="html"><![CDATA[<h1 id="Mac下docker环境安装ElasticSearch"><a href="#Mac下docker环境安装ElasticSearch" class="headerlink" title="Mac下docker环境安装ElasticSearch"></a>Mac下docker环境安装ElasticSearch</h1><h4 id="一、Mac上需要装有docker环境"><a href="#一、Mac上需要装有docker环境" class="headerlink" title="一、Mac上需要装有docker环境"></a>一、Mac上需要装有docker环境</h4><h5 id="1、下载镜像"><a href="#1、下载镜像" class="headerlink" title="1、下载镜像"></a>1、下载镜像</h5><pre><code>docker pull elasticsearch:6.5.3</code></pre><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/08/20/mac-xia-docker-huan-jing-an-zhuang-elasticsearch/001.png" alt></p><h5 id="2、运行容器"><a href="#2、运行容器" class="headerlink" title="2、运行容器"></a>2、运行容器</h5><pre><code>docker run -d -p 9200:9200 -p 9300:9300 --name elasticsearch-6.5.3</code></pre><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/08/20/mac-xia-docker-huan-jing-an-zhuang-elasticsearch/002.png" alt></p><h5 id="3、进入容器"><a href="#3、进入容器" class="headerlink" title="3、进入容器"></a>3、进入容器</h5><pre><code>docker exec -it elasticsearch-6.5.3 /bin/bash</code></pre><h5 id="4、安装ik分词器"><a href="#4、安装ik分词器" class="headerlink" title="4、安装ik分词器"></a>4、安装ik分词器</h5><pre><code>./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.5.3/elasticsearch-analysis-ik-6.5.3.zip</code></pre><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/08/20/mac-xia-docker-huan-jing-an-zhuang-elasticsearch/003.png" alt></p><h5 id="5、修改es配置文件"><a href="#5、修改es配置文件" class="headerlink" title="5、修改es配置文件"></a>5、修改es配置文件</h5><pre><code>vi ./config/elasticsearch.yml</code></pre><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">cluster.name</span><span class="token punctuation">:</span> <span class="token string">"docker-cluster"</span><span class="token key atrule">network.host</span><span class="token punctuation">:</span> 0.0.0.0<span class="token comment" spellcheck="true"># minimum_master_nodes need to be explicitly set when bound on a public IP</span><span class="token comment" spellcheck="true"># set to 1 to allow single node clusters</span><span class="token comment" spellcheck="true"># Details: https://github.com/elastic/elasticsearch/pull/17288</span><span class="token key atrule">discovery.zen.minimum_master_nodes</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token comment" spellcheck="true"># just for elasticsearch-head plugin</span><span class="token key atrule">http.cors.enabled</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token key atrule">http.cors.allow-origin</span><span class="token punctuation">:</span> <span class="token string">"*"</span></code></pre><p>6、退出容器</p><pre><code>exit</code></pre><p>7、停止容器</p><pre><code>docker stop elasticsearch-6.5.3</code></pre><p>8、启动容器</p><pre><code>docker start elasticsearch-6.5.3</code></pre>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot（七）</title>
      <link href="/2019/08/19/springboot-qi/"/>
      <url>/2019/08/19/springboot-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Boot-集成ElasticSearch"><a href="#Spring-Boot-集成ElasticSearch" class="headerlink" title="Spring Boot 集成ElasticSearch"></a>Spring Boot 集成ElasticSearch</h1><h3 id="一、ElasticSearch"><a href="#一、ElasticSearch" class="headerlink" title="一、ElasticSearch"></a>一、ElasticSearch</h3><blockquote><p>ElasticSearch 是一个分布式、高扩展、高实时的搜索与<a href="https://baike.baidu.com/item/数据分析/6577123" target="_blank" rel="noopener">数据分析</a>引擎。它能很方便的使大量数据具有搜索、分析和探索的能力。充分利用ElasticSearch的水平伸缩性，能使数据在生产环境变得更有价值。ElasticSearch 的实现原理主要分为以下几个步骤，首先用户将数据提交到Elastic Search 数据库中，再通过分词控制器去将对应的语句分词，将其权重和分词结果一并存入数据，当用户搜索数据时候，再根据权重将结果排名，打分，再将返回结果呈现给用户。</p><p>Elasticsearch是与名为Logstash的数据收集和日志解析引擎以及名为Kibana的分析和可视化平台一起开发的。这三个产品被设计成一个集成解决方案，称为“Elastic Stack”（以前称为“ELK stack”）。</p><p>Elasticsearch可以用于搜索各种文档。它提供可扩展的搜索，具有接近实时的搜索，并支持多租户。”Elasticsearch是分布式的，这意味着索引可以被分成分片，每个分片可以有0个或多个副本。每个节点托管一个或多个分片，并充当协调器将操作委托给正确的分片。再平衡和路由是自动完成的。“相关数据通常存储在同一个索引中，该索引由一个或多个主分片和零个或多个复制分片组成。一旦创建了索引，就不能更改主分片的数量。</p><p>Elasticsearch使用Lucene，并试图通过JSON和Java API提供其所有特性。它支持facetting和percolating，如果新文档与注册查询匹配，这对于通知非常有用。另一个特性称为“网关”，处理索引的长期持久性；例如，在服务器崩溃的情况下，可以从网关恢复索引。Elasticsearch支持实时GET请求，适合作为NoSQL数据存储，但缺少<a href="https://baike.baidu.com/item/分布式/7316617" target="_blank" rel="noopener">分布式</a>事务。</p></blockquote><h3 id="二、创建SpringBoot工程（2-1-7）"><a href="#二、创建SpringBoot工程（2-1-7）" class="headerlink" title="二、创建SpringBoot工程（2.1.7）"></a>二、创建SpringBoot工程（2.1.7）</h3><h4 id="2-1、pom依赖"><a href="#2-1、pom依赖" class="headerlink" title="2.1、pom依赖"></a>2.1、pom依赖</h4><pre class=" language-xml"><code class="language-xml">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>cn.hutool<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>hutool-all<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>4.6.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.google.guava<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>guava<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>27.0.1-jre<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-data-elasticsearch<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.1.7.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.1.7.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-devtools<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>runtime<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>optional</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>optional</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.projectlombok<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>lombok<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>optional</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>optional</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-maven-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">></span></span></code></pre><h4 id="2-2、application-yml"><a href="#2-2、application-yml" class="headerlink" title="2.2、application.yml"></a>2.2、application.yml</h4><pre class=" language-yml"><code class="language-yml">spring:  data:    elasticsearch:      cluster-name: docker-cluster      cluster-nodes: localhost:9300</code></pre><h4 id="2-3、创建一个实体"><a href="#2-3、创建一个实体" class="headerlink" title="2.3、创建一个实体"></a>2.3、创建一个实体</h4><blockquote><p>@Document 注解主要声明索引名、类型名、分片数量和备份数量</p><p>@Field 注解主要声明字段对应ES的类型</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>springboot<span class="token punctuation">.</span>elasticsearch<span class="token punctuation">.</span>entity<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>springboot<span class="token punctuation">.</span>elasticsearch<span class="token punctuation">.</span>constants<span class="token punctuation">.</span>EsConsts<span class="token punctuation">;</span><span class="token keyword">import</span> lombok<span class="token punctuation">.</span>AllArgsConstructor<span class="token punctuation">;</span><span class="token keyword">import</span> lombok<span class="token punctuation">.</span>Data<span class="token punctuation">;</span><span class="token keyword">import</span> lombok<span class="token punctuation">.</span>NoArgsConstructor<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Id<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>elasticsearch<span class="token punctuation">.</span>annotations<span class="token punctuation">.</span>Document<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>elasticsearch<span class="token punctuation">.</span>annotations<span class="token punctuation">.</span>Field<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>elasticsearch<span class="token punctuation">.</span>annotations<span class="token punctuation">.</span>FieldType<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Date<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019-08-20 * @Time: 08:35 * @Vsersion: 1.0 **/</span><span class="token annotation punctuation">@Document</span><span class="token punctuation">(</span>indexName <span class="token operator">=</span> EsConsts<span class="token punctuation">.</span>INDEX_NAME<span class="token punctuation">,</span> type <span class="token operator">=</span> EsConsts<span class="token punctuation">.</span>TYPE_NAME<span class="token punctuation">,</span> shards <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> replicas <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Data</span><span class="token annotation punctuation">@NoArgsConstructor</span><span class="token annotation punctuation">@AllArgsConstructor</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 主键     */</span>    <span class="token annotation punctuation">@Id</span>    <span class="token keyword">private</span> Long id<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 名字     */</span>    <span class="token annotation punctuation">@Field</span><span class="token punctuation">(</span>type <span class="token operator">=</span> FieldType<span class="token punctuation">.</span>Keyword<span class="token punctuation">)</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 国家     */</span>    <span class="token annotation punctuation">@Field</span><span class="token punctuation">(</span>type <span class="token operator">=</span> FieldType<span class="token punctuation">.</span>Keyword<span class="token punctuation">)</span>    <span class="token keyword">private</span> String country<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 年龄     */</span>    <span class="token annotation punctuation">@Field</span><span class="token punctuation">(</span>type <span class="token operator">=</span> FieldType<span class="token punctuation">.</span>Integer<span class="token punctuation">)</span>    <span class="token keyword">private</span> Integer age<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 生日     */</span>    <span class="token annotation punctuation">@Field</span><span class="token punctuation">(</span>type <span class="token operator">=</span> FieldType<span class="token punctuation">.</span>Date<span class="token punctuation">)</span>    <span class="token keyword">private</span> Date birthday<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 介绍     */</span>    <span class="token annotation punctuation">@Field</span><span class="token punctuation">(</span>type <span class="token operator">=</span> FieldType<span class="token punctuation">.</span>Text<span class="token punctuation">,</span> analyzer <span class="token operator">=</span> <span class="token string">"ik_smart"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String remark<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="2-4、用户持久层"><a href="#2-4、用户持久层" class="headerlink" title="2.4、用户持久层"></a>2.4、用户持久层</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>springboot<span class="token punctuation">.</span>elasticsearch<span class="token punctuation">.</span>repository<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>springboot<span class="token punctuation">.</span>elasticsearch<span class="token punctuation">.</span>entity<span class="token punctuation">.</span>Person<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>elasticsearch<span class="token punctuation">.</span>repository<span class="token punctuation">.</span>ElasticsearchRepository<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>List<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019-08-20 * @Time: 08:37 * @Vsersion: 1.0 * @description: 用户持久层 **/</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">PersonRepository</span> <span class="token keyword">extends</span> <span class="token class-name">ElasticsearchRepository</span><span class="token operator">&lt;</span>Person<span class="token punctuation">,</span> Long<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 根据年龄区间查询     *     * @param min 最小值     * @param max 最大值     * @return 满足条件的用户列表     */</span>    List<span class="token operator">&lt;</span>Person<span class="token operator">></span> <span class="token function">findByAgeBetween</span><span class="token punctuation">(</span>Integer min<span class="token punctuation">,</span> Integer max<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="2-5、ES常量池"><a href="#2-5、ES常量池" class="headerlink" title="2.5、ES常量池"></a>2.5、ES常量池</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>springboot<span class="token punctuation">.</span>elasticsearch<span class="token punctuation">.</span>constants<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019-08-20 * @Time: 08:36 * @Vsersion: 1.0 * @description:  **/</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">EsConsts</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 索引名称     */</span>    String INDEX_NAME <span class="token operator">=</span> <span class="token string">"person"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 类型名称     */</span>    String TYPE_NAME <span class="token operator">=</span> <span class="token string">"person"</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="2-6、TemplateTest-java"><a href="#2-6、TemplateTest-java" class="headerlink" title="2.6、TemplateTest.java"></a>2.6、TemplateTest.java</h4><blockquote><p>主要测试创建索引、映射配置、删除索引</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>springboot<span class="token punctuation">.</span>elasticsearch<span class="token punctuation">.</span>template<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>springboot<span class="token punctuation">.</span>elasticsearch<span class="token punctuation">.</span>SpringbootElasticsearchApplicationTests<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>springboot<span class="token punctuation">.</span>elasticsearch<span class="token punctuation">.</span>entity<span class="token punctuation">.</span>Person<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>Test<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Autowired<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>elasticsearch<span class="token punctuation">.</span>core<span class="token punctuation">.</span>ElasticsearchTemplate<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019-08-20 * @Time: 08:41 * @Vsersion: 1.0 * @description: 测试 ElasticTemplate 的创建/删除 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TemplateTest</span> <span class="token keyword">extends</span> <span class="token class-name">SpringbootElasticsearchApplicationTests</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> ElasticsearchTemplate esTemplate<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 测试 ElasticTemplate 创建 index     */</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testCreateIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 创建索引，会根据Item类的@Document注解信息来创建</span>        esTemplate<span class="token punctuation">.</span><span class="token function">createIndex</span><span class="token punctuation">(</span>Person<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 配置映射，会根据Item类中的id、Field等字段来自动完成映射</span>        esTemplate<span class="token punctuation">.</span><span class="token function">putMapping</span><span class="token punctuation">(</span>Person<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 测试 ElasticTemplate 删除 index     */</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testDeleteIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        esTemplate<span class="token punctuation">.</span><span class="token function">deleteIndex</span><span class="token punctuation">(</span>Person<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="2-7、PersonRepositoryTest-java"><a href="#2-7、PersonRepositoryTest-java" class="headerlink" title="2.7、PersonRepositoryTest.java"></a>2.7、PersonRepositoryTest.java</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>springboot<span class="token punctuation">.</span>elasticsearch<span class="token punctuation">.</span>respository<span class="token punctuation">;</span><span class="token keyword">import</span> cn<span class="token punctuation">.</span>hutool<span class="token punctuation">.</span>core<span class="token punctuation">.</span>date<span class="token punctuation">.</span>DateUtil<span class="token punctuation">;</span><span class="token keyword">import</span> cn<span class="token punctuation">.</span>hutool<span class="token punctuation">.</span>json<span class="token punctuation">.</span>JSONUtil<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>google<span class="token punctuation">.</span>common<span class="token punctuation">.</span>collect<span class="token punctuation">.</span>Lists<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>springboot<span class="token punctuation">.</span>elasticsearch<span class="token punctuation">.</span>SpringbootElasticsearchApplicationTests<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>springboot<span class="token punctuation">.</span>elasticsearch<span class="token punctuation">.</span>entity<span class="token punctuation">.</span>Person<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>springboot<span class="token punctuation">.</span>elasticsearch<span class="token punctuation">.</span>repository<span class="token punctuation">.</span>PersonRepository<span class="token punctuation">;</span><span class="token keyword">import</span> lombok<span class="token punctuation">.</span>extern<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span>Slf4j<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>elasticsearch<span class="token punctuation">.</span>index<span class="token punctuation">.</span>query<span class="token punctuation">.</span>MatchQueryBuilder<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>elasticsearch<span class="token punctuation">.</span>index<span class="token punctuation">.</span>query<span class="token punctuation">.</span>QueryBuilders<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>elasticsearch<span class="token punctuation">.</span>search<span class="token punctuation">.</span>aggregations<span class="token punctuation">.</span>AggregationBuilders<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>elasticsearch<span class="token punctuation">.</span>search<span class="token punctuation">.</span>aggregations<span class="token punctuation">.</span>bucket<span class="token punctuation">.</span>terms<span class="token punctuation">.</span>StringTerms<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>elasticsearch<span class="token punctuation">.</span>search<span class="token punctuation">.</span>aggregations<span class="token punctuation">.</span>metrics<span class="token punctuation">.</span>avg<span class="token punctuation">.</span>InternalAvg<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>elasticsearch<span class="token punctuation">.</span>search<span class="token punctuation">.</span>sort<span class="token punctuation">.</span>SortBuilders<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>elasticsearch<span class="token punctuation">.</span>search<span class="token punctuation">.</span>sort<span class="token punctuation">.</span>SortOrder<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>Test<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Autowired<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>domain<span class="token punctuation">.</span>Page<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>domain<span class="token punctuation">.</span>PageRequest<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>domain<span class="token punctuation">.</span>Sort<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>elasticsearch<span class="token punctuation">.</span>core<span class="token punctuation">.</span>aggregation<span class="token punctuation">.</span>AggregatedPage<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>elasticsearch<span class="token punctuation">.</span>core<span class="token punctuation">.</span>query<span class="token punctuation">.</span>FetchSourceFilter<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>elasticsearch<span class="token punctuation">.</span>core<span class="token punctuation">.</span>query<span class="token punctuation">.</span>NativeSearchQueryBuilder<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>List<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019-08-20 * @Time: 08:39 * @Vsersion: 1.0 * @description: 测试 Repository 操作ES **/</span><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PersonRepositoryTest</span> <span class="token keyword">extends</span> <span class="token class-name">SpringbootElasticsearchApplicationTests</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> PersonRepository repo<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 测试新增     */</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Person person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span>1L<span class="token punctuation">,</span> <span class="token string">"刘备"</span><span class="token punctuation">,</span> <span class="token string">"蜀国"</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">,</span> DateUtil<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token string">"1990-01-02 03:04:05"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"刘备（161年－223年6月10日），即汉昭烈帝（221年－223年在位），又称先主，字玄德，东汉末年幽州涿郡涿县（今河北省涿州市）人，西汉中山靖王刘胜之后，三国时期蜀汉开国皇帝、政治家。\n刘备少年时拜卢植为师；早年颠沛流离，备尝艰辛，投靠过多个诸侯，曾参与镇压黄巾起义。先后率军救援北海相孔融、徐州牧陶谦等。陶谦病亡后，将徐州让与刘备。赤壁之战时，刘备与孙权联盟击败曹操，趁势夺取荆州。而后进取益州。于章武元年（221年）在成都称帝，国号汉，史称蜀或蜀汉。《三国志》评刘备的机权干略不及曹操，但其弘毅宽厚，知人待士，百折不挠，终成帝业。刘备也称自己做事“每与操反，事乃成尔”。\n章武三年（223年），刘备病逝于白帝城，终年六十三岁，谥号昭烈皇帝，庙号烈祖，葬惠陵。后世有众多文艺作品以其为主角，在成都武侯祠有昭烈庙为纪念。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Person save <span class="token operator">=</span> repo<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"【save】= {}"</span><span class="token punctuation">,</span> save<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 测试批量新增     */</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">saveList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>Person<span class="token operator">></span> personList <span class="token operator">=</span> Lists<span class="token punctuation">.</span><span class="token function">newArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        personList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span>2L<span class="token punctuation">,</span> <span class="token string">"曹操"</span><span class="token punctuation">,</span> <span class="token string">"魏国"</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> DateUtil<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token string">"1988-01-02 03:04:05"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"曹操（155年－220年3月15日），字孟德，一名吉利，小字阿瞒，沛国谯县（今安徽亳州）人。东汉末年杰出的政治家、军事家、文学家、书法家，三国中曹魏政权的奠基人。\n曹操曾担任东汉丞相，后加封魏王，奠定了曹魏立国的基础。去世后谥号为武王。其子曹丕称帝后，追尊为武皇帝，庙号太祖。\n东汉末年，天下大乱，曹操以汉天子的名义征讨四方，对内消灭二袁、吕布、刘表、马超、韩遂等割据势力，对外降服南匈奴、乌桓、鲜卑等，统一了中国北方，并实行一系列政策恢复经济生产和社会秩序，扩大屯田、兴修水利、奖励农桑、重视手工业、安置流亡人口、实行“租调制”，从而使中原社会渐趋稳定、经济出现转机。黄河流域在曹操统治下，政治渐见清明，经济逐步恢复，阶级压迫稍有减轻，社会风气有所好转。曹操在汉朝的名义下所采取的一些措施具有积极作用。\n曹操军事上精通兵法，重贤爱才，为此不惜一切代价将看中的潜能分子收于麾下；生活上善诗歌，抒发自己的政治抱负，并反映汉末人民的苦难生活，气魄雄伟，慷慨悲凉；散文亦清峻整洁，开启并繁荣了建安文学，给后人留下了宝贵的精神财富，鲁迅评价其为“改造文章的祖师”。同时曹操也擅长书法，唐朝张怀瓘在《书断》将曹操的章草评为“妙品”。"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        personList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span>3L<span class="token punctuation">,</span> <span class="token string">"孙权"</span><span class="token punctuation">,</span> <span class="token string">"吴国"</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">,</span> DateUtil<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token string">"1989-01-02 03:04:05"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"孙权（182年－252年5月21日），字仲谋，吴郡富春（今浙江杭州富阳区）人。三国时代孙吴的建立者（229年－252年在位）。\n孙权的父亲孙坚和兄长孙策，在东汉末年群雄割据中打下了江东基业。建安五年（200年），孙策遇刺身亡，孙权继之掌事，成为一方诸侯。建安十三年（208年），与刘备建立孙刘联盟，并于赤壁之战中击败曹操，奠定三国鼎立的基础。建安二十四年（219年），孙权派吕蒙成功袭取刘备的荆州，使领土面积大大增加。\n黄武元年（222年），孙权被魏文帝曹丕册封为吴王，建立吴国。同年，在夷陵之战中大败刘备。黄龙元年（229年），在武昌正式称帝，国号吴，不久后迁都建业。孙权称帝后，设置农官，实行屯田，设置郡县，并继续剿抚山越，促进了江南经济的发展。在此基础上，他又多次派人出海。黄龙二年（230年），孙权派卫温、诸葛直抵达夷州。\n孙权晚年在继承人问题上反复无常，引致群下党争，朝局不稳。太元元年（252年）病逝，享年七十一岁，在位二十四年，谥号大皇帝，庙号太祖，葬于蒋陵。\n孙权亦善书，唐代张怀瓘在《书估》中将其书法列为第三等。"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        personList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span>4L<span class="token punctuation">,</span> <span class="token string">"诸葛亮"</span><span class="token punctuation">,</span> <span class="token string">"蜀国"</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> DateUtil<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token string">"1992-01-02 03:04:05"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"诸葛亮（181年-234年10月8日），字孔明，号卧龙，徐州琅琊阳都（今山东临沂市沂南县）人，三国时期蜀国丞相，杰出的政治家、军事家、外交家、文学家、书法家、发明家。\n早年随叔父诸葛玄到荆州，诸葛玄死后，诸葛亮就在襄阳隆中隐居。后刘备三顾茅庐请出诸葛亮，联孙抗曹，于赤壁之战大败曹军。形成三国鼎足之势，又夺占荆州。建安十六年（211年），攻取益州。继又击败曹军，夺得汉中。蜀章武元年（221年），刘备在成都建立蜀汉政权，诸葛亮被任命为丞相，主持朝政。蜀后主刘禅继位，诸葛亮被封为武乡侯，领益州牧。勤勉谨慎，大小政事必亲自处理，赏罚严明；与东吴联盟，改善和西南各族的关系；实行屯田政策，加强战备。前后六次北伐中原，多以粮尽无功。终因积劳成疾，于蜀建兴十二年（234年）病逝于五丈原（今陕西宝鸡岐山境内），享年54岁。刘禅追封其为忠武侯，后世常以武侯尊称诸葛亮。东晋政权因其军事才能特追封他为武兴王。\n诸葛亮散文代表作有《出师表》《诫子书》等。曾发明木牛流马、孔明灯等，并改造连弩，叫做诸葛连弩，可一弩十矢俱发。诸葛亮一生“鞠躬尽瘁、死而后已”，是中国传统文化中忠臣与智者的代表人物。"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Iterable<span class="token operator">&lt;</span>Person<span class="token operator">></span> people <span class="token operator">=</span> repo<span class="token punctuation">.</span><span class="token function">saveAll</span><span class="token punctuation">(</span>personList<span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"【people】= {}"</span><span class="token punctuation">,</span> people<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 测试更新     */</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        repo<span class="token punctuation">.</span><span class="token function">findById</span><span class="token punctuation">(</span>1L<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ifPresent</span><span class="token punctuation">(</span>person <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            person<span class="token punctuation">.</span><span class="token function">setRemark</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span><span class="token function">getRemark</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\n更新更新更新更新更新"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Person save <span class="token operator">=</span> repo<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"【save】= {}"</span><span class="token punctuation">,</span> save<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 测试删除     */</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">delete</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 主键删除</span>        repo<span class="token punctuation">.</span><span class="token function">deleteById</span><span class="token punctuation">(</span>1L<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 对象删除</span>        repo<span class="token punctuation">.</span><span class="token function">findById</span><span class="token punctuation">(</span>2L<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ifPresent</span><span class="token punctuation">(</span>person <span class="token operator">-</span><span class="token operator">></span> repo<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 批量删除</span>        repo<span class="token punctuation">.</span><span class="token function">deleteAll</span><span class="token punctuation">(</span>repo<span class="token punctuation">.</span><span class="token function">findAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 测试普通查询，按生日倒序     */</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        repo<span class="token punctuation">.</span><span class="token function">findAll</span><span class="token punctuation">(</span>Sort<span class="token punctuation">.</span><span class="token function">by</span><span class="token punctuation">(</span>Sort<span class="token punctuation">.</span>Direction<span class="token punctuation">.</span>DESC<span class="token punctuation">,</span> <span class="token string">"birthday"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>person <span class="token operator">-</span><span class="token operator">></span> log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"{} 生日: {}"</span><span class="token punctuation">,</span> person<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> DateUtil<span class="token punctuation">.</span><span class="token function">formatDateTime</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span><span class="token function">getBirthday</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 自定义查询，根据年龄范围查询     */</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">customSelectRangeOfAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        repo<span class="token punctuation">.</span><span class="token function">findByAgeBetween</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>person <span class="token operator">-</span><span class="token operator">></span> log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"{} 年龄: {}"</span><span class="token punctuation">,</span> person<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> person<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 高级查询     */</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">advanceSelect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// QueryBuilders 提供了很多静态方法，可以实现大部分查询条件的封装</span>        MatchQueryBuilder queryBuilder <span class="token operator">=</span> QueryBuilders<span class="token punctuation">.</span><span class="token function">matchQuery</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"孙权"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"【queryBuilder】= {}"</span><span class="token punctuation">,</span> queryBuilder<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        repo<span class="token punctuation">.</span><span class="token function">search</span><span class="token punctuation">(</span>queryBuilder<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>person <span class="token operator">-</span><span class="token operator">></span> log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"【person】= {}"</span><span class="token punctuation">,</span> person<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 自定义高级查询     */</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">customAdvanceSelect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 构造查询条件</span>        NativeSearchQueryBuilder queryBuilder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NativeSearchQueryBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 添加基本的分词条件</span>        queryBuilder<span class="token punctuation">.</span><span class="token function">withQuery</span><span class="token punctuation">(</span>QueryBuilders<span class="token punctuation">.</span><span class="token function">matchQuery</span><span class="token punctuation">(</span><span class="token string">"remark"</span><span class="token punctuation">,</span> <span class="token string">"东汉"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 排序条件</span>        queryBuilder<span class="token punctuation">.</span><span class="token function">withSort</span><span class="token punctuation">(</span>SortBuilders<span class="token punctuation">.</span><span class="token function">fieldSort</span><span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">order</span><span class="token punctuation">(</span>SortOrder<span class="token punctuation">.</span>DESC<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 分页条件</span>        queryBuilder<span class="token punctuation">.</span><span class="token function">withPageable</span><span class="token punctuation">(</span>PageRequest<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Page<span class="token operator">&lt;</span>Person<span class="token operator">></span> people <span class="token operator">=</span> repo<span class="token punctuation">.</span><span class="token function">search</span><span class="token punctuation">(</span>queryBuilder<span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"【people】总条数 = {}"</span><span class="token punctuation">,</span> people<span class="token punctuation">.</span><span class="token function">getTotalElements</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"【people】总页数 = {}"</span><span class="token punctuation">,</span> people<span class="token punctuation">.</span><span class="token function">getTotalPages</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        people<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>person <span class="token operator">-</span><span class="token operator">></span> log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"【person】= {}，年龄 = {}"</span><span class="token punctuation">,</span> person<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> person<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 测试聚合，测试平均年龄     */</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">agg</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 构造查询条件</span>        NativeSearchQueryBuilder queryBuilder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NativeSearchQueryBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 不查询任何结果</span>        queryBuilder<span class="token punctuation">.</span><span class="token function">withSourceFilter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FetchSourceFilter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token string">""</span><span class="token punctuation">}</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 平均年龄</span>        queryBuilder<span class="token punctuation">.</span><span class="token function">addAggregation</span><span class="token punctuation">(</span>AggregationBuilders<span class="token punctuation">.</span><span class="token function">avg</span><span class="token punctuation">(</span><span class="token string">"avg"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">field</span><span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"【queryBuilder】= {}"</span><span class="token punctuation">,</span> JSONUtil<span class="token punctuation">.</span><span class="token function">toJsonStr</span><span class="token punctuation">(</span>queryBuilder<span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        AggregatedPage<span class="token operator">&lt;</span>Person<span class="token operator">></span> people <span class="token operator">=</span> <span class="token punctuation">(</span>AggregatedPage<span class="token operator">&lt;</span>Person<span class="token operator">></span><span class="token punctuation">)</span> repo<span class="token punctuation">.</span><span class="token function">search</span><span class="token punctuation">(</span>queryBuilder<span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">double</span> avgAge <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>InternalAvg<span class="token punctuation">)</span> people<span class="token punctuation">.</span><span class="token function">getAggregation</span><span class="token punctuation">(</span><span class="token string">"avg"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"【avgAge】= {}"</span><span class="token punctuation">,</span> avgAge<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 测试高级聚合查询，每个国家的人有几个，每个国家的平均年龄是多少     */</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">advanceAgg</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 构造查询条件</span>        NativeSearchQueryBuilder queryBuilder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NativeSearchQueryBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 不查询任何结果</span>        queryBuilder<span class="token punctuation">.</span><span class="token function">withSourceFilter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FetchSourceFilter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token string">""</span><span class="token punctuation">}</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 1. 添加一个新的聚合，聚合类型为terms，聚合名称为country，聚合字段为age</span>        queryBuilder<span class="token punctuation">.</span><span class="token function">addAggregation</span><span class="token punctuation">(</span>AggregationBuilders<span class="token punctuation">.</span><span class="token function">terms</span><span class="token punctuation">(</span><span class="token string">"country"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">field</span><span class="token punctuation">(</span><span class="token string">"country"</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">// 2. 在国家聚合桶内进行嵌套聚合，求平均年龄</span>                <span class="token punctuation">.</span><span class="token function">subAggregation</span><span class="token punctuation">(</span>AggregationBuilders<span class="token punctuation">.</span><span class="token function">avg</span><span class="token punctuation">(</span><span class="token string">"avg"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">field</span><span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"【queryBuilder】= {}"</span><span class="token punctuation">,</span> JSONUtil<span class="token punctuation">.</span><span class="token function">toJsonStr</span><span class="token punctuation">(</span>queryBuilder<span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 3. 查询</span>        AggregatedPage<span class="token operator">&lt;</span>Person<span class="token operator">></span> people <span class="token operator">=</span> <span class="token punctuation">(</span>AggregatedPage<span class="token operator">&lt;</span>Person<span class="token operator">></span><span class="token punctuation">)</span> repo<span class="token punctuation">.</span><span class="token function">search</span><span class="token punctuation">(</span>queryBuilder<span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 4. 解析</span>        <span class="token comment" spellcheck="true">// 4.1. 从结果中取出名为 country 的那个聚合，因为是利用String类型字段来进行的term聚合，所以结果要强转为StringTerm类型</span>        StringTerms country <span class="token operator">=</span> <span class="token punctuation">(</span>StringTerms<span class="token punctuation">)</span> people<span class="token punctuation">.</span><span class="token function">getAggregation</span><span class="token punctuation">(</span><span class="token string">"country"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 4.2. 获取桶</span>        List<span class="token operator">&lt;</span>StringTerms<span class="token punctuation">.</span>Bucket<span class="token operator">></span> buckets <span class="token operator">=</span> country<span class="token punctuation">.</span><span class="token function">getBuckets</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>StringTerms<span class="token punctuation">.</span>Bucket bucket <span class="token operator">:</span> buckets<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 4.3. 获取桶中的key，即国家名称  4.4. 获取桶中的文档数量</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"{} 总共有 {} 人"</span><span class="token punctuation">,</span> bucket<span class="token punctuation">.</span><span class="token function">getKeyAsString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> bucket<span class="token punctuation">.</span><span class="token function">getDocCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 4.5. 获取子聚合结果：</span>            InternalAvg avg <span class="token operator">=</span> <span class="token punctuation">(</span>InternalAvg<span class="token punctuation">)</span> bucket<span class="token punctuation">.</span><span class="token function">getAggregations</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">asMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"avg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"平均年龄：{}"</span><span class="token punctuation">,</span> avg<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="三、参考"><a href="#三、参考" class="headerlink" title="三、参考"></a>三、参考</h3><blockquote><p>3.1、ElasticSearch 官方文档：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.x/getting-started.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/6.x/getting-started.html</a></p><p>3.2、spring-data-elasticsearch 官方文档：<a href="https://docs.spring.io/spring-data/elasticsearch/docs/3.1.2.RELEASE/reference/html/" target="_blank" rel="noopener">https://docs.spring.io/spring-data/elasticsearch/docs/3.1.2.RELEASE/reference/html/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
            <tag> docker </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud（七）</title>
      <link href="/2019/08/19/springcloud-qi/"/>
      <url>/2019/08/19/springcloud-qi/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot（六）</title>
      <link href="/2019/08/12/springboot-liu/"/>
      <url>/2019/08/12/springboot-liu/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot事物Transaction"><a href="#SpringBoot事物Transaction" class="headerlink" title="SpringBoot事物Transaction"></a>SpringBoot事物Transaction</h1>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot2.0 </tag>
            
            <tag> 事物 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatis-plus实现多数据动态切换</title>
      <link href="/2019/08/09/mybatis-plus-shi-xian-duo-shu-ju-dong-tai-qie-huan/"/>
      <url>/2019/08/09/mybatis-plus-shi-xian-duo-shu-ju-dong-tai-qie-huan/</url>
      
        <content type="html"><![CDATA[<h1 id="Mybatis-Plus实现多数据动态切换"><a href="#Mybatis-Plus实现多数据动态切换" class="headerlink" title="Mybatis-Plus实现多数据动态切换"></a>Mybatis-Plus实现多数据动态切换</h1><h3 id="一、搭建springboot项目"><a href="#一、搭建springboot项目" class="headerlink" title="一、搭建springboot项目"></a>一、搭建springboot项目</h3><h4 id="1-1、pom-xml依赖"><a href="#1-1、pom-xml依赖" class="headerlink" title="1.1、pom.xml依赖"></a>1.1、pom.xml依赖</h4><p>​        </p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Springboot2.0 </tag>
            
            <tag> Mybatis-plus 3.0 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MYSQL数据库设计规范与原则</title>
      <link href="/2019/08/08/mysql-shu-ju-ku-she-ji-gui-fan-yu-yuan-ze/"/>
      <url>/2019/08/08/mysql-shu-ju-ku-she-ji-gui-fan-yu-yuan-ze/</url>
      
        <content type="html"><![CDATA[<h1 id="MYSQL数据库设计规范与原则"><a href="#MYSQL数据库设计规范与原则" class="headerlink" title="MYSQL数据库设计规范与原则"></a>MYSQL数据库设计规范与原则</h1><p>[TOC]</p><h3 id="一、MYSQL数据库设计规范"><a href="#一、MYSQL数据库设计规范" class="headerlink" title="一、MYSQL数据库设计规范"></a>一、MYSQL数据库设计规范</h3><pre><code>1、数据库命名规范    采用26个英文字母(区分大小写)和0-9的自然数(经常不需要)加上下划线&#39;_&#39;组成;    命名简洁明确(长度不能超过30个字符);    例如：user, stat, log, 也可以wifi_user, wifi_stat, wifi_log给数据库加个前缀;    除非是备份数据库可以加0-9的自然数：user_db_20151210;2、数据库表名命名规范    采用26个英文字母(区分大小写)和0-9的自然数(经常不需要)加上下划线&#39;_&#39;组成;    命名简洁明确,多个单词用下划线&#39;_&#39;分隔;    例如：user_login, user_profile, user_detail, user_role, user_role_relation,        user_role_right, user_role_right_relation    表前缀&#39;user_&#39;可以有效的把相同关系的表显示在一起;3、数据库表字段名命名规范    采用26个英文字母(区分大小写)和0-9的自然数(经常不需要)加上下划线&#39;_&#39;组成;    命名简洁明确,多个单词用下划线&#39;_&#39;分隔;    例如：user_login表字段 user_id, user_name, pass_word, eamil, tickit, status, mobile, add_time;    每个表中必须有自增主键,add_time(默认系统时间)    表与表之间的相关联字段名称要求尽可能的相同;4、数据库表字段类型规范    用尽量少的存储空间来存数一个字段的数据;    例如：能使用int就不要使用varchar、char,能用varchar(16)就不要使用varchar(256);    IP地址最好使用int类型;    固定长度的类型最好使用char,例如：邮编;    能使用tinyint就不要使用smallint,int;    最好给每个字段一个默认值,最好不能为null;5、数据库表索引规范    命名简洁明确,例如：user_login表user_name字段的索引应为user_name_index唯一索引;    为每个表创建一个主键索引;    为每个表创建合理的索引;    建立复合索引请慎重;6、简单熟悉数据库范式    第一范式(1NF)：字段值具有原子性,不能再分(所有关系型数据库系统都满足第一范式);        例如：姓名字段,其中姓和名是一个整体,如果区分姓和名那么必须设立两个独立字段;    第二范式(2NF)：一个表必须有主键,即每行数据都能被唯一的区分;        备注：必须先满足第一范式;    第三范式(3NF)：一个表中不能包涵其他相关表中非关键字段的信息,即数据表不能有沉余字段;        备注：必须先满足第二范式;</code></pre><p>数据库的三范式：<br>①字段不可分。<br>②有主键，非主键字段依赖主键。<br>③非主键字段不能互相依赖。</p><pre><code>    备注：往往我们在设计表中不能遵守第三范式,因为合理的沉余字段将会给我们减少join的查询;          例如：相册表中会添加图片的点击数字段,在相册图片表中也会添加图片的点击数字段;</code></pre><h3 id="二、MYSQL数据库设计原则"><a href="#二、MYSQL数据库设计原则" class="headerlink" title="二、MYSQL数据库设计原则"></a>二、MYSQL数据库设计原则</h3><pre><code>1、核心原则    不在数据库做运算;    cpu计算务必移至业务层;    控制列数量(字段少而精,字段数建议在20以内);    平衡范式与冗余(效率优先；往往牺牲范式)    拒绝3B(拒绝大sql语句：big sql、拒绝大事物：big transaction、拒绝大批量：big batch);2、字段类原则    用好数值类型(用合适的字段类型节约空间);    字符转化为数字(能转化的最好转化,同样节约空间、提高查询性能);    避免使用NULL字段(NULL字段很难查询优化、NULL字段的索引需要额外空间、NULL字段的复合索引无效);    少用text类型(尽量使用varchar代替text字段);3、索引类原则    合理使用索引(改善查询,减慢更新,索引一定不是越多越好);    字符字段必须建前缀索引;    不在索引做列运算;    innodb主键推荐使用自增列(主键建立聚簇索引,主键不应该被修改,字符串不应该做主键)(理解Innodb的索引保存结构就知道了);    不用外键(由程序保证约束);4、sql类原则    sql语句尽可能简单(一条sql只能在一个cpu运算,大语句拆小语句,减少锁时间,一条大sql可以堵死整个库);    简单的事务;    避免使用trig/func(触发器、函数不用客户端程序取而代之);    不用select *(消耗cpu,io,内存,带宽,这种程序不具有扩展性);    OR改写为IN(or的效率是n级别);    OR改写为UNION(mysql的索引合并很弱智);        select id from t where phone = ’159′ or name = ‘john’;        =&gt;        select id from t where phone=’159′        union        select id from t where name=’jonh’    避免负向%;    慎用count(*);    limit高效分页(limit越大，效率越低);    使用union all替代union(union有去重开销);    少用连接join;    使用group by;    请使用同类型比较;    打散批量更新;5、性能分析工具    show profile;    mysqlsla;    mysqldumpslow;    explain;    show slow log;    show processlist;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql-存储过程</title>
      <link href="/2019/07/31/mysql-cun-chu-guo-cheng/"/>
      <url>/2019/07/31/mysql-cun-chu-guo-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL-数据库之存储过程的创建和调用"><a href="#MySQL-数据库之存储过程的创建和调用" class="headerlink" title="MySQL 数据库之存储过程的创建和调用"></a>MySQL 数据库之存储过程的创建和调用</h1><h3 id="MySQL-5-0-版本开始支持存储过程。"><a href="#MySQL-5-0-版本开始支持存储过程。" class="headerlink" title="MySQL 5.0 版本开始支持存储过程。"></a>MySQL 5.0 版本开始支持存储过程。</h3><blockquote><p>存储过程（Stored Procedure）是一种在数据库中存储复杂程序，以便外部程序调用的一种数据库对象。</p><p>存储过程是为了完成特定功能的SQL语句集，经编译创建并保存在数据库中，用户可通过指定存储过程的名字并给定参数(需要时)来调用执行。</p><p>存储过程思想上很简单，就是数据库 SQL 语言层面的代码封装与重用。</p></blockquote><h4 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h4><blockquote><ul><li>存储过程可封装，并隐藏复杂的商业逻辑。</li><li>存储过程可以回传值，并可以接受参数。</li><li>存储过程无法使用 SELECT 指令来运行，因为它是子程序，与查看表，数据表或用户定义函数不同。</li><li>存储过程可以用在数据检验，强制实行商业逻辑等。</li></ul></blockquote><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点:"></a>缺点:</h4><blockquote><ul><li>存储过程，往往定制化于特定的数据库上，因为支持的编程语言不同。当切换到其他厂商的数据库系统时，需要重写原有的存储过程。</li><li>存储过程的性能调校与撰写，受限于各种数据库系统。</li></ul></blockquote><h3 id="存储过程的创建和调用"><a href="#存储过程的创建和调用" class="headerlink" title="存储过程的创建和调用"></a>存储过程的创建和调用</h3><h4 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h4>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池</title>
      <link href="/2019/07/30/xian-cheng-chi/"/>
      <url>/2019/07/30/xian-cheng-chi/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h1><blockquote><p>​        我们有两种常见的创建线程的方法，一种是继承Thread类，一种是实现Runnable的接口，Thread类其实也是实现了Runnable接口。但是我们创建这两种线程在运行结束后都会被虚拟机销毁，如果线程数量多的话，频繁的创建和销毁线程会大大浪费时间和效率，更重要的是浪费内存，因为正常来说线程执行完毕后死亡，线程对象变成垃圾！那么有没有一种方法能让线程运行完后不立即销毁，而是让线程重复使用，继续执行其他的任务哪？我们使用线程池就能很好地解决这个问题。</p></blockquote><h3 id="一、Java中的ThreadPoolExecutor类"><a href="#一、Java中的ThreadPoolExecutor类" class="headerlink" title="一、Java中的ThreadPoolExecutor类"></a>一、Java中的ThreadPoolExecutor类</h3><blockquote><p>java.uitl.concurrent.ThreadPoolExecutor类是线程池中最核心的一个类，因此如果要透彻地了解Java中的线程池，必须先了解这个类。下面我们来看一下ThreadPoolExecutor类的具体实现源码。</p><p>在ThreadPoolExecutor类中提供了四个构造方法：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadPoolExecutor</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractExecutorService</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">public</span> <span class="token function">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span><span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span><span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>TimeUnit unit<span class="token punctuation">,</span>            BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span><span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span><span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>TimeUnit unit<span class="token punctuation">,</span>            BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue<span class="token punctuation">,</span>ThreadFactory threadFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span><span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span><span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>TimeUnit unit<span class="token punctuation">,</span>            BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue<span class="token punctuation">,</span>RejectedExecutionHandler handler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span><span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span><span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>TimeUnit unit<span class="token punctuation">,</span>        BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue<span class="token punctuation">,</span>ThreadFactory threadFactory<span class="token punctuation">,</span>RejectedExecutionHandler handler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><blockquote><p>从上面的代码可以得知，ThreadPoolExecutor继承了AbstractExecutorService类，并提供了四个构造器，事实上，通过观察每个构造器的源码具体实现，发现前面三个构造器都是调用的第四个构造器进行的初始化工作。</p><p>　　下面解释下一下构造器中各个参数的含义：</p><ul><li>corePoolSize：核心池的大小，这个参数跟后面讲述的线程池的实现原理有非常大的关系。在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了prestartAllCoreThreads()或者prestartCoreThread()方法，从这2个方法的名字就可以看出，是预创建线程的意思，即在没有任务到来之前就创建corePoolSize个线程或者一个线程。默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中；</li><li>maximumPoolSize：线程池最大线程数，这个参数也是一个非常重要的参数，它表示在线程池中最多能创建多少个线程；</li><li>keepAliveTime：表示线程没有任务执行时最多保持多久时间会终止。默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用，直到线程池中的线程数不大于corePoolSize，即当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize。但是如果调用了allowCoreThreadTimeOut(boolean)方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0；</li><li>unit：参数keepAliveTime的时间单位，有7种取值，在TimeUnit类中有7种静态属性：</li></ul></blockquote><pre class=" language-java"><code class="language-java">TimeUnit<span class="token punctuation">.</span>DAYS<span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">//天</span>TimeUnit<span class="token punctuation">.</span>HOURS<span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//小时</span>TimeUnit<span class="token punctuation">.</span>MINUTES<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//分钟</span>TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//秒</span>TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//毫秒</span>TimeUnit<span class="token punctuation">.</span>MICROSECONDS<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//微妙</span>TimeUnit<span class="token punctuation">.</span>NANOSECONDS<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//纳秒</span></code></pre><blockquote><p>workQueue：一个阻塞队列，用来存储等待执行的任务，这个参数的选择也很重要，会对线程池的运行过程产生重大影响，一般来说，这里的阻塞队列有以下几种选择：</p></blockquote><blockquote><pre class=" language-java"><code class="language-java">ArrayBlockingQueue<span class="token punctuation">;</span>LinkedBlockingQueue<span class="token punctuation">;</span>SynchronousQueue<span class="token punctuation">;</span></code></pre></blockquote><blockquote><p>ArrayBlockingQueue和PriorityBlockingQueue使用较少，一般使用LinkedBlockingQueue和Synchronous。线程池的排队策略与BlockingQueue有关。</p><ul><li>threadFactory：线程工厂，主要用来创建线程；</li><li>handler：表示当拒绝处理任务时的策略，有以下四种取值：</li></ul></blockquote><pre class=" language-java"><code class="language-java">ThreadPoolExecutor<span class="token punctuation">.</span>AbortPolicy<span class="token operator">:</span>丢弃任务并抛出RejectedExecutionException异常。 ThreadPoolExecutor<span class="token punctuation">.</span>DiscardPolicy：也是丢弃任务，但是不抛出异常。 ThreadPoolExecutor<span class="token punctuation">.</span>DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）ThreadPoolExecutor<span class="token punctuation">.</span>CallerRunsPolicy：由调用线程处理该任务 </code></pre><blockquote><p>从上面给出的ThreadPoolExecutor类的代码可以知道，ThreadPoolExecutor继承了AbstractExecutorService，我们来看一下AbstractExecutorService的实现：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @since 1.5 * @author Doug Lea */</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractExecutorService</span> <span class="token keyword">implements</span> <span class="token class-name">ExecutorService</span> <span class="token punctuation">{</span>    <span class="token keyword">protected</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> RunnableFuture<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">newTaskFor</span><span class="token punctuation">(</span>Runnable runnable<span class="token punctuation">,</span> T value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>runnable<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">protected</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> RunnableFuture<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">newTaskFor</span><span class="token punctuation">(</span>Callable<span class="token operator">&lt;</span>T<span class="token operator">></span> callable<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>callable<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * @throws RejectedExecutionException {@inheritDoc}     * @throws NullPointerException       {@inheritDoc}     */</span>    <span class="token keyword">public</span> Future<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">submit</span><span class="token punctuation">(</span>Runnable task<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>task <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        RunnableFuture<span class="token operator">&lt;</span>Void<span class="token operator">></span> ftask <span class="token operator">=</span> <span class="token function">newTaskFor</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">execute</span><span class="token punctuation">(</span>ftask<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ftask<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * @throws RejectedExecutionException {@inheritDoc}     * @throws NullPointerException       {@inheritDoc}     */</span>    <span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> Future<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">submit</span><span class="token punctuation">(</span>Runnable task<span class="token punctuation">,</span> T result<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>task <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        RunnableFuture<span class="token operator">&lt;</span>T<span class="token operator">></span> ftask <span class="token operator">=</span> <span class="token function">newTaskFor</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">execute</span><span class="token punctuation">(</span>ftask<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ftask<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * @throws RejectedExecutionException {@inheritDoc}     * @throws NullPointerException       {@inheritDoc}     */</span>    <span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> Future<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">submit</span><span class="token punctuation">(</span>Callable<span class="token operator">&lt;</span>T<span class="token operator">></span> task<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>task <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        RunnableFuture<span class="token operator">&lt;</span>T<span class="token operator">></span> ftask <span class="token operator">=</span> <span class="token function">newTaskFor</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">execute</span><span class="token punctuation">(</span>ftask<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ftask<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * the main mechanics of invokeAny.     */</span>    <span class="token keyword">private</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> T <span class="token function">doInvokeAny</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>T<span class="token operator">>></span> tasks<span class="token punctuation">,</span>                              <span class="token keyword">boolean</span> timed<span class="token punctuation">,</span> <span class="token keyword">long</span> nanos<span class="token punctuation">)</span>        <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">,</span> ExecutionException<span class="token punctuation">,</span> TimeoutException <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>tasks <span class="token operator">==</span> null<span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> ntasks <span class="token operator">=</span> tasks<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ntasks <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ArrayList<span class="token operator">&lt;</span>Future<span class="token operator">&lt;</span>T<span class="token operator">>></span> futures <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Future<span class="token operator">&lt;</span>T<span class="token operator">>></span><span class="token punctuation">(</span>ntasks<span class="token punctuation">)</span><span class="token punctuation">;</span>        ExecutorCompletionService<span class="token operator">&lt;</span>T<span class="token operator">></span> ecs <span class="token operator">=</span>            <span class="token keyword">new</span> <span class="token class-name">ExecutorCompletionService</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// For efficiency, especially in executors with limited</span>        <span class="token comment" spellcheck="true">// parallelism, check to see if previously submitted tasks are</span>        <span class="token comment" spellcheck="true">// done before submitting more of them. This interleaving</span>        <span class="token comment" spellcheck="true">// plus the exception mechanics account for messiness of main</span>        <span class="token comment" spellcheck="true">// loop.</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// Record exceptions so that if we fail to obtain any</span>            <span class="token comment" spellcheck="true">// result, we can throw the last exception we got.</span>            ExecutionException ee <span class="token operator">=</span> null<span class="token punctuation">;</span>            <span class="token keyword">final</span> <span class="token keyword">long</span> deadline <span class="token operator">=</span> timed <span class="token operator">?</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> nanos <span class="token operator">:</span> 0L<span class="token punctuation">;</span>            Iterator<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>T<span class="token operator">>></span> it <span class="token operator">=</span> tasks<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// Start one task for sure; the rest incrementally</span>            futures<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>ecs<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">--</span>ntasks<span class="token punctuation">;</span>            <span class="token keyword">int</span> active <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                Future<span class="token operator">&lt;</span>T<span class="token operator">></span> f <span class="token operator">=</span> ecs<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>ntasks <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token operator">--</span>ntasks<span class="token punctuation">;</span>                        futures<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>ecs<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token operator">++</span>active<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>active <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>timed<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        f <span class="token operator">=</span> ecs<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span>nanos<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>NANOSECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token operator">==</span> null<span class="token punctuation">)</span>                            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TimeoutException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        nanos <span class="token operator">=</span> deadline <span class="token operator">-</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">else</span>                        f <span class="token operator">=</span> ecs<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token operator">--</span>active<span class="token punctuation">;</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        <span class="token keyword">return</span> f<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ExecutionException</span> eex<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        ee <span class="token operator">=</span> eex<span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RuntimeException</span> rex<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        ee <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ExecutionException</span><span class="token punctuation">(</span>rex<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ee <span class="token operator">==</span> null<span class="token punctuation">)</span>                ee <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ExecutionException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">throw</span> ee<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> size <span class="token operator">=</span> futures<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>                futures<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> T <span class="token function">invokeAny</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>T<span class="token operator">>></span> tasks<span class="token punctuation">)</span>        <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">,</span> ExecutionException <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token function">doInvokeAny</span><span class="token punctuation">(</span>tasks<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">TimeoutException</span> cannotHappen<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">assert</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> T <span class="token function">invokeAny</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>T<span class="token operator">>></span> tasks<span class="token punctuation">,</span>                           <span class="token keyword">long</span> timeout<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">)</span>        <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">,</span> ExecutionException<span class="token punctuation">,</span> TimeoutException <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">doInvokeAny</span><span class="token punctuation">(</span>tasks<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> List<span class="token operator">&lt;</span>Future<span class="token operator">&lt;</span>T<span class="token operator">>></span> <span class="token function">invokeAll</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>T<span class="token operator">>></span> tasks<span class="token punctuation">)</span>        <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>tasks <span class="token operator">==</span> null<span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ArrayList<span class="token operator">&lt;</span>Future<span class="token operator">&lt;</span>T<span class="token operator">>></span> futures <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Future<span class="token operator">&lt;</span>T<span class="token operator">>></span><span class="token punctuation">(</span>tasks<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> done <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Callable<span class="token operator">&lt;</span>T<span class="token operator">></span> t <span class="token operator">:</span> tasks<span class="token punctuation">)</span> <span class="token punctuation">{</span>                RunnableFuture<span class="token operator">&lt;</span>T<span class="token operator">></span> f <span class="token operator">=</span> <span class="token function">newTaskFor</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>                futures<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">execute</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> size <span class="token operator">=</span> futures<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                Future<span class="token operator">&lt;</span>T<span class="token operator">></span> f <span class="token operator">=</span> futures<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>f<span class="token punctuation">.</span><span class="token function">isDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        f<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">CancellationException</span> ignore<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ExecutionException</span> ignore<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            done <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> futures<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>done<span class="token punctuation">)</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> size <span class="token operator">=</span> futures<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>                    futures<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> List<span class="token operator">&lt;</span>Future<span class="token operator">&lt;</span>T<span class="token operator">>></span> <span class="token function">invokeAll</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>T<span class="token operator">>></span> tasks<span class="token punctuation">,</span>                                         <span class="token keyword">long</span> timeout<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">)</span>        <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>tasks <span class="token operator">==</span> null<span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> nanos <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>        ArrayList<span class="token operator">&lt;</span>Future<span class="token operator">&lt;</span>T<span class="token operator">>></span> futures <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Future<span class="token operator">&lt;</span>T<span class="token operator">>></span><span class="token punctuation">(</span>tasks<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> done <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Callable<span class="token operator">&lt;</span>T<span class="token operator">></span> t <span class="token operator">:</span> tasks<span class="token punctuation">)</span>                futures<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token function">newTaskFor</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">final</span> <span class="token keyword">long</span> deadline <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> nanos<span class="token punctuation">;</span>            <span class="token keyword">final</span> <span class="token keyword">int</span> size <span class="token operator">=</span> futures<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// Interleave time checks and calls to execute in case</span>            <span class="token comment" spellcheck="true">// executor doesn't have any/much parallelism.</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Runnable<span class="token punctuation">)</span>futures<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                nanos <span class="token operator">=</span> deadline <span class="token operator">-</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nanos <span class="token operator">&lt;=</span> 0L<span class="token punctuation">)</span>                    <span class="token keyword">return</span> futures<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                Future<span class="token operator">&lt;</span>T<span class="token operator">></span> f <span class="token operator">=</span> futures<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>f<span class="token punctuation">.</span><span class="token function">isDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>nanos <span class="token operator">&lt;=</span> 0L<span class="token punctuation">)</span>                        <span class="token keyword">return</span> futures<span class="token punctuation">;</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        f<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>nanos<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>NANOSECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">CancellationException</span> ignore<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ExecutionException</span> ignore<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">TimeoutException</span> toe<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">return</span> futures<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    nanos <span class="token operator">=</span> deadline <span class="token operator">-</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            done <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> futures<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>done<span class="token punctuation">)</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> size <span class="token operator">=</span> futures<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>                    futures<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>AbstractExecutorService是一个抽象类，它实现了ExecutorService接口。</p><p>我们接着看ExecutorService接口的实现：</p></blockquote><pre><code>package java.util.concurrent;import java.util.List;import java.util.Collection;public interface ExecutorService extends Executor {    void shutdown();    List&lt;Runnable&gt; shutdownNow();    boolean isShutdown();    boolean isTerminated();    boolean awaitTermination(long timeout, TimeUnit unit)        throws InterruptedException;    &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);    &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);    Future&lt;?&gt; submit(Runnable task);    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)        throws InterruptedException;    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,                                  long timeout, TimeUnit unit)        throws InterruptedException;    &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)        throws InterruptedException, ExecutionException;    &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,                    long timeout, TimeUnit unit)        throws InterruptedException, ExecutionException, TimeoutException;}</code></pre><blockquote><p>而ExecutorService又是继承了Executor接口，我们看一下Executor接口的实现：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Executor</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span>Runnable command<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>到这里，大家应该明白了ThreadPoolExecutor、AbstractExecutorService、ExecutorService和Executor几个之间的关系了。</p><p>　　Executor是一个顶层接口，在它里面只声明了一个方法execute(Runnable)，返回值为void，参数为Runnable类型，从字面意思可以理解，就是用来执行传进去的任务的；</p><p>　　然后ExecutorService接口继承了Executor接口，并声明了一些方法：submit、invokeAll、invokeAny以及shutDown等；</p><p>　　抽象类AbstractExecutorService实现了ExecutorService接口，基本实现了ExecutorService中声明的所有方法；</p><p>　　然后ThreadPoolExecutor继承了类AbstractExecutorService。</p><p>　　在ThreadPoolExecutor类中有几个非常重要的方法：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">shutdownNow</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><blockquote><p>execute()方法实际上是Executor中声明的方法，在ThreadPoolExecutor进行了具体的实现，这个方法是ThreadPoolExecutor的核心方法，通过这个方法可以向线程池提交一个任务，交由线程池去执行。</p><p>　　submit()方法是在ExecutorService中声明的方法，在AbstractExecutorService就已经有了具体的实现，在ThreadPoolExecutor中并没有对其进行重写，这个方法也是用来向线程池提交任务的，但是它和execute()方法不同，它能够返回任务执行的结果，去看submit()方法的实现，会发现它实际上还是调用的execute()方法，只不过它利用了Future来获取任务执行结果（Future相关内容将在下一篇讲述）。</p><p>　　shutdown()和shutdownNow()是用来关闭线程池的。</p><p>　　还有很多其他的方法：</p><p>　　比如：getQueue() 、getPoolSize() 、getActiveCount()、getCompletedTaskCount()等获取与线程池相关属性的方法</p></blockquote><h3 id="二-深入剖析线程池实现原理"><a href="#二-深入剖析线程池实现原理" class="headerlink" title="二.深入剖析线程池实现原理"></a>二.深入剖析线程池实现原理</h3><blockquote><p>在上一节我们从宏观上介绍了ThreadPoolExecutor，下面我们来深入解析一下线程池的具体实现原理，将从下面几个方面讲解：</p><p>　　<strong>1.线程池状态</strong></p><p>　　<strong>2.任务的执行</strong></p><p>　　<strong>3.线程池中的线程初始化</strong></p><p>　　<strong>4.任务缓存队列及排队策略</strong></p><p>　　<strong>5.任务拒绝策略</strong></p><p>　　<strong>6.线程池的关闭</strong></p><p>　　<strong>7.线程池容量的动态调整</strong></p></blockquote><h4 id="1-线程池状态"><a href="#1-线程池状态" class="headerlink" title="1.线程池状态"></a><strong>1.线程池状态</strong></h4><blockquote><p>在ThreadPoolExecutor中定义了一个volatile变量，另外定义了几个static final变量表示线程池的各个状态：</p></blockquote><pre><code>        private static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;    private static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;    private static final int STOP       =  1 &lt;&lt; COUNT_BITS;    private static final int TIDYING    =  2 &lt;&lt; COUNT_BITS;    private static final int TERMINATED =  3 &lt;&lt; COUNT_BITS;</code></pre><blockquote><p>runState表示当前线程池的状态，它是一个volatile变量用来保证线程之间的可见性；</p><p>　　下面的几个static final变量表示runState可能的几个取值。</p><p>　　当创建线程池后，初始时，线程池处于RUNNING状态；</p><p>　　如果调用了shutdown()方法，则线程池处于SHUTDOWN状态，此时线程池不能够接受新的任务，它会等待所有任务执行完毕；</p><p>　　如果调用了shutdownNow()方法，则线程池处于STOP状态，此时线程池不能接受新的任务，并且会去尝试终止正在执行的任务；</p><p>　　当线程池处于SHUTDOWN或STOP状态，并且所有工作线程已经销毁，任务缓存队列已经清空或执行结束后，线程池被设置为TERMINATED状态。</p></blockquote><h4 id="2-任务的执行"><a href="#2-任务的执行" class="headerlink" title="2.任务的执行"></a><strong>2.任务的执行</strong></h4><blockquote><p>在了解将任务提交给线程池到任务执行完毕整个过程之前，我们先来看一下ThreadPoolExecutor类中其他的一些比较重要成员变量：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue<span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">//任务缓存队列，用来存放等待执行的任务</span><span class="token keyword">private</span> <span class="token keyword">final</span> ReentrantLock mainLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//线程池的主要状态锁，对线程池状态（比如线程池大小</span>                                                              <span class="token comment" spellcheck="true">//、runState等）的改变都要使用这个锁</span><span class="token keyword">private</span> <span class="token keyword">final</span> HashSet<span class="token operator">&lt;</span>Worker<span class="token operator">></span> workers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span>Worker<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//用来存放工作集</span><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">long</span>  keepAliveTime<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//线程存货时间   </span><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> allowCoreThreadTimeOut<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//是否允许为核心线程设置存活时间</span><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span>   corePoolSize<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//核心池的大小（即线程池中的线程数目大于这个参数时，提交的任务会被放进任务缓存队列）</span><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span>   maximumPoolSize<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//线程池最大能容忍的线程数</span><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span>   poolSize<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//线程池中当前的线程数</span><span class="token keyword">private</span> <span class="token keyword">volatile</span> RejectedExecutionHandler handler<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//任务拒绝策略</span><span class="token keyword">private</span> <span class="token keyword">volatile</span> ThreadFactory threadFactory<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//线程工厂，用来创建线程</span><span class="token keyword">private</span> <span class="token keyword">int</span> largestPoolSize<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//用来记录线程池中曾经出现过的最大线程数</span><span class="token keyword">private</span> <span class="token keyword">long</span> completedTaskCount<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//用来记录已经执行完毕的任务个数</span></code></pre><blockquote><p>每个变量的作用都已经标明出来了，这里要重点解释一下corePoolSize、maximumPoolSize、largestPoolSize三个变量。</p><p>　　corePoolSize在很多地方被翻译成核心池大小，其实我的理解这个就是线程池的大小。举个简单的例子：</p><p>　　假如有一个工厂，工厂里面有10个工人，每个工人同时只能做一件任务。</p><p>　　因此只要当10个工人中有工人是空闲的，来了任务就分配给空闲的工人做；</p><p>　　当10个工人都有任务在做时，如果还来了任务，就把任务进行排队等待；</p><p>　　如果说新任务数目增长的速度远远大于工人做任务的速度，那么此时工厂主管可能会想补救措施，比如重新招4个临时工人进来；</p><p>　　然后就将任务也分配给这4个临时工人做；</p><p>　　如果说着14个工人做任务的速度还是不够，此时工厂主管可能就要考虑不再接收新的任务或者抛弃前面的一些任务了。</p><p>　　当这14个工人当中有人空闲时，而新任务增长的速度又比较缓慢，工厂主管可能就考虑辞掉4个临时工了，只保持原来的10个工人，毕竟请额外的工人是要花钱的。</p><p>　　这个例子中的corePoolSize就是10，而maximumPoolSize就是14（10+4）。</p><p>　　也就是说corePoolSize就是线程池大小，maximumPoolSize在我看来是线程池的一种补救措施，即任务量突然过大时的一种补救措施。</p><p>　　不过为了方便理解，在本文后面还是将corePoolSize翻译成核心池大小。</p><p>　　largestPoolSize只是一个用来起记录作用的变量，用来记录线程池中曾经有过的最大线程数目，跟线程池的容量没有任何关系。</p><p>　　下面我们进入正题，看一下任务从提交到最终执行完毕经历了哪些过程。</p><p>　　在ThreadPoolExecutor类中，最核心的任务提交方法是execute()方法，虽然通过submit也可以提交任务，但是实际上submit方法里面最终调用的还是execute()方法，所以我们只需要研究execute()方法的实现原理即可：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span>Runnable command<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>command <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>poolSize <span class="token operator">>=</span> corePoolSize <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">addIfUnderCorePoolSize</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>runState <span class="token operator">==</span> RUNNING <span class="token operator">&amp;&amp;</span> workQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>runState <span class="token operator">!=</span> RUNNING <span class="token operator">||</span> poolSize <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token function">ensureQueuedTaskHandled</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">addIfUnderMaximumPoolSize</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// is shutdown or saturated</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>上面的代码可能看起来不是那么容易理解，下面我们一句一句解释：</p><p>　　首先，判断提交的任务command是否为null，若是null，则抛出空指针异常；</p><p>　　接着是这句，这句要好好理解一下：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>poolSize <span class="token operator">>=</span> corePoolSize <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">addIfUnderCorePoolSize</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><blockquote><p>由于是或条件运算符，所以先计算前半部分的值，如果线程池中当前线程数不小于核心池大小，那么就会直接进入下面的if语句块了。</p><p>　　如果线程池中当前线程数小于核心池大小，则接着执行后半部分，也就是执行</p></blockquote><pre><code>addIfUnderCorePoolSize(command)</code></pre><blockquote><p>如果执行完addIfUnderCorePoolSize这个方法返回false，则继续执行下面的if语句块，否则整个方法就直接执行完毕了。</p><p>　　如果执行完addIfUnderCorePoolSize这个方法返回false，然后接着判断：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>runState <span class="token operator">==</span> RUNNING <span class="token operator">&amp;&amp;</span> workQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><blockquote><p>如果当前线程池处于RUNNING状态，则将任务放入任务缓存队列；如果当前线程池不处于RUNNING状态或者任务放入缓存队列失败，则执行：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token function">addIfUnderMaximumPoolSize</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span></code></pre><blockquote><p>如果执行addIfUnderMaximumPoolSize方法失败，则执行reject()方法进行任务拒绝处理。</p><p>　　回到前面：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>runState <span class="token operator">==</span> RUNNING <span class="token operator">&amp;&amp;</span> workQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><blockquote><p>这句的执行，如果说当前线程池处于RUNNING状态且将任务放入任务缓存队列成功，则继续进行判断：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>runState <span class="token operator">!=</span> RUNNING <span class="token operator">||</span> poolSize <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span></code></pre><blockquote><p>这句判断是为了防止在将此任务添加进任务缓存队列的同时其他线程突然调用shutdown或者shutdownNow方法关闭了线程池的一种应急措施。如果是这样就执行：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token function">ensureQueuedTaskHandled</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span></code></pre><blockquote><p>进行应急处理，从名字可以看出是保证 添加到任务缓存队列中的任务得到处理。</p><p>　　我们接着看2个关键方法的实现：addIfUnderCorePoolSize和addIfUnderMaximumPoolSize：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">addIfUnderCorePoolSize</span><span class="token punctuation">(</span>Runnable firstTask<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Thread t <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">final</span> ReentrantLock mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>    mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>poolSize <span class="token operator">&lt;</span> corePoolSize <span class="token operator">&amp;&amp;</span> runState <span class="token operator">==</span> RUNNING<span class="token punctuation">)</span>            t <span class="token operator">=</span> <span class="token function">addThread</span><span class="token punctuation">(</span>firstTask<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//创建线程去执行firstTask任务   </span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>这个是addIfUnderCorePoolSize方法的具体实现，从名字可以看出它的意图就是当低于核心吃大小时执行的方法。下面看其具体实现，首先获取到锁，因为这地方涉及到线程池状态的变化，先通过if语句判断当前线程池中的线程数目是否小于核心池大小，有朋友也许会有疑问：前面在execute()方法中不是已经判断过了吗，只有线程池当前线程数目小于核心池大小才会执行addIfUnderCorePoolSize方法的，为何这地方还要继续判断？原因很简单，前面的判断过程中并没有加锁，因此可能在execute方法判断的时候poolSize小于corePoolSize，而判断完之后，在其他线程中又向线程池提交了任务，就可能导致poolSize不小于corePoolSize了，所以需要在这个地方继续判断。然后接着判断线程池的状态是否为RUNNING，原因也很简单，因为有可能在其他线程中调用了shutdown或者shutdownNow方法。然后就是执行</p></blockquote><pre class=" language-java"><code class="language-java">t <span class="token operator">=</span> <span class="token function">addThread</span><span class="token punctuation">(</span>firstTask<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>这个方法也非常关键，传进去的参数为提交的任务，返回值为Thread类型。然后接着在下面判断t是否为空，为空则表明创建线程失败（即poolSize&gt;=corePoolSize或者runState不等于RUNNING），否则调用t.start()方法启动线程。</p><p>　　我们来看一下addThread方法的实现：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> Thread <span class="token function">addThread</span><span class="token punctuation">(</span>Runnable firstTask<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Worker w <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span>firstTask<span class="token punctuation">)</span><span class="token punctuation">;</span>    Thread t <span class="token operator">=</span> threadFactory<span class="token punctuation">.</span><span class="token function">newThread</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//创建一个线程，执行任务   </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        w<span class="token punctuation">.</span>thread <span class="token operator">=</span> t<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//将创建的线程的引用赋值为w的成员变量       </span>        workers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> nt <span class="token operator">=</span> <span class="token operator">++</span>poolSize<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//当前线程数加1       </span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nt <span class="token operator">></span> largestPoolSize<span class="token punctuation">)</span>            largestPoolSize <span class="token operator">=</span> nt<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> t<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>在addThread方法中，首先用提交的任务创建了一个Worker对象，然后调用线程工厂threadFactory创建了一个新的线程t，然后将线程t的引用赋值给了Worker对象的成员变量thread，接着通过workers.add(w)将Worker对象添加到工作集当中。</p><p>　　下面我们看一下Worker类的实现：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Worker</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> ReentrantLock runLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> Runnable firstTask<span class="token punctuation">;</span>    <span class="token keyword">volatile</span> <span class="token keyword">long</span> completedTasks<span class="token punctuation">;</span>    Thread thread<span class="token punctuation">;</span>    <span class="token function">Worker</span><span class="token punctuation">(</span>Runnable firstTask<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>firstTask <span class="token operator">=</span> firstTask<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">boolean</span> <span class="token function">isActive</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> runLock<span class="token punctuation">.</span><span class="token function">isLocked</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">interruptIfIdle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> ReentrantLock runLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>runLock<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>runLock<span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>thread <span class="token operator">!=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        thread<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                runLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">interruptNow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        thread<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">runTask</span><span class="token punctuation">(</span>Runnable task<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> ReentrantLock runLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>runLock<span class="token punctuation">;</span>        runLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>runState <span class="token operator">&lt;</span> STOP <span class="token operator">&amp;&amp;</span>                Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                runState <span class="token operator">>=</span> STOP<span class="token punctuation">)</span>            <span class="token keyword">boolean</span> ran <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token function">beforeExecute</span><span class="token punctuation">(</span>thread<span class="token punctuation">,</span> task<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//beforeExecute方法是ThreadPoolExecutor类的一个方法，没有具体实现，用户可以根据</span>            <span class="token comment" spellcheck="true">//自己需要重载这个方法和后面的afterExecute方法来进行一些统计信息，比如某个任务的执行时间等           </span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                task<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                ran <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token function">afterExecute</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">++</span>completedTasks<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RuntimeException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ran<span class="token punctuation">)</span>                    <span class="token function">afterExecute</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">throw</span> ex<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            runLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Runnable task <span class="token operator">=</span> firstTask<span class="token punctuation">;</span>            firstTask <span class="token operator">=</span> null<span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>task <span class="token operator">!=</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>task <span class="token operator">=</span> <span class="token function">getTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">runTask</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>                task <span class="token operator">=</span> null<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            <span class="token function">workerDone</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//当任务队列中没有任务时，进行清理工作       </span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>它实际上实现了Runnable接口，因此上面的Thread t = threadFactory.newThread(w);效果跟下面这句的效果基本一样：</p></blockquote><pre class=" language-java"><code class="language-java">Thread t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>相当于传进去了一个Runnable任务，在线程t中执行这个Runnable。</p><p>　　既然Worker实现了Runnable接口，那么自然最核心的方法便是run()方法了：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        Runnable task <span class="token operator">=</span> firstTask<span class="token punctuation">;</span>        firstTask <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>task <span class="token operator">!=</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>task <span class="token operator">=</span> <span class="token function">getTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">runTask</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>            task <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token function">workerDone</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>从run方法的实现可以看出，它首先执行的是通过构造器传进来的任务firstTask，在调用runTask()执行完firstTask之后，在while循环里面不断通过getTask()去取新的任务来执行，那么去哪里取呢？自然是从任务缓存队列里面去取，getTask是ThreadPoolExecutor类中的方法，并不是Worker类中的方法，下面是getTask方法的实现：</p></blockquote><pre class=" language-java"><code class="language-java">Runnable <span class="token function">getTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> state <span class="token operator">=</span> runState<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>state <span class="token operator">></span> SHUTDOWN<span class="token punctuation">)</span>                <span class="token keyword">return</span> null<span class="token punctuation">;</span>            Runnable r<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>state <span class="token operator">==</span> SHUTDOWN<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// Help drain queue</span>                r <span class="token operator">=</span> workQueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>poolSize <span class="token operator">></span> corePoolSize <span class="token operator">||</span> allowCoreThreadTimeOut<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//如果线程数大于核心池大小或者允许为核心池线程设置空闲时间，</span>                <span class="token comment" spellcheck="true">//则通过poll取任务，若等待一定的时间取不到任务，则返回null</span>                r <span class="token operator">=</span> workQueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span>keepAliveTime<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>NANOSECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span>                r <span class="token operator">=</span> workQueue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">!=</span> null<span class="token punctuation">)</span>                <span class="token keyword">return</span> r<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCanExit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//如果没取到任务，即r为null，则判断当前的worker是否可以退出</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>runState <span class="token operator">>=</span> SHUTDOWN<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// Wake up others</span>                    <span class="token function">interruptIdleWorkers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//中断处于空闲状态的worker</span>                <span class="token keyword">return</span> null<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// Else retry</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> ie<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// On interruption, re-check runState</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>在getTask中，先判断当前线程池状态，如果runState大于SHUTDOWN（即为STOP或者TERMINATED），则直接返回null。</p><p>　　如果runState为SHUTDOWN或者RUNNING，则从任务缓存队列取任务。</p><p>　　如果当前线程池的线程数大于核心池大小corePoolSize或者允许为核心池中的线程设置空闲存活时间，则调用poll(time,timeUnit)来取任务，这个方法会等待一定的时间，如果取不到任务就返回null。</p><p>　　然后判断取到的任务r是否为null，为null则通过调用workerCanExit()方法来判断当前worker是否可以退出，我们看一下workerCanExit()的实现：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">workerCanExit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> ReentrantLock mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>    mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> canExit<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//如果runState大于等于STOP，或者任务缓存队列为空了</span>    <span class="token comment" spellcheck="true">//或者  允许为核心池线程设置空闲存活时间并且线程池中的线程数目大于1</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        canExit <span class="token operator">=</span> runState <span class="token operator">>=</span> STOP <span class="token operator">||</span>            workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span>            <span class="token punctuation">(</span>allowCoreThreadTimeOut <span class="token operator">&amp;&amp;</span>             poolSize <span class="token operator">></span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> corePoolSize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> canExit<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>也就是说如果线程池处于STOP状态、或者任务队列已为空或者允许为核心池线程设置空闲存活时间并且线程数大于1时，允许worker退出。如果允许worker退出，则调用interruptIdleWorkers()中断处于空闲状态的worker，我们看一下interruptIdleWorkers()的实现：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">interruptIdleWorkers</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> ReentrantLock mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>    mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Worker w <span class="token operator">:</span> workers<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//实际上调用的是worker的interruptIfIdle()方法</span>            w<span class="token punctuation">.</span><span class="token function">interruptIfIdle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>从实现可以看出，它实际上调用的是worker的interruptIfIdle()方法，在worker的interruptIfIdle()方法中：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">interruptIfIdle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> ReentrantLock runLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>runLock<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>runLock<span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//注意这里，是调用tryLock()来获取锁的，因为如果当前worker正在执行任务，锁已经被获取了，是无法获取到锁的</span>                                <span class="token comment" spellcheck="true">//如果成功获取了锁，说明当前worker处于空闲状态</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>thread <span class="token operator">!=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      thread<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            runLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>这里有一个非常巧妙的设计方式，假如我们来设计线程池，可能会有一个任务分派线程，当发现有线程空闲时，就从任务缓存队列中取一个任务交给空闲线程执行。但是在这里，并没有采用这样的方式，因为这样会要额外地对任务分派线程进行管理，无形地会增加难度和复杂度，这里直接让执行完任务的线程去任务缓存队列里面取任务来执行。</p><p>　　我们再看addIfUnderMaximumPoolSize方法的实现，这个方法的实现思想和addIfUnderCorePoolSize方法的实现思想非常相似，唯一的区别在于addIfUnderMaximumPoolSize方法是在线程池中的线程数达到了核心池大小并且往任务队列中添加任务失败的情况下执行的：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">addIfUnderMaximumPoolSize</span><span class="token punctuation">(</span>Runnable firstTask<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Thread t <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">final</span> ReentrantLock mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>    mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>poolSize <span class="token operator">&lt;</span> maximumPoolSize <span class="token operator">&amp;&amp;</span> runState <span class="token operator">==</span> RUNNING<span class="token punctuation">)</span>            t <span class="token operator">=</span> <span class="token function">addThread</span><span class="token punctuation">(</span>firstTask<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>看到没有，其实它和addIfUnderCorePoolSize方法的实现基本一模一样，只是if语句判断条件中的poolSize &lt; maximumPoolSize不同而已。</p><p>　　到这里，大部分朋友应该对任务提交给线程池之后到被执行的整个过程有了一个基本的了解，下面总结一下：</p><p>　　1）首先，要清楚corePoolSize和maximumPoolSize的含义；</p><p>　　2）其次，要知道Worker是用来起到什么作用的；</p><p>　　3）要知道任务提交给线程池之后的处理策略，这里总结一下主要有4点：</p><ul><li>如果当前线程池中的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务；</li><li>如果当前线程池中的线程数目&gt;=corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程去执行这个任务；</li><li>如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理；</li><li>如果线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过keepAliveTime，线程也会被终止。</li></ul></blockquote><h4 id="3-线程池中的线程初始化"><a href="#3-线程池中的线程初始化" class="headerlink" title="3.线程池中的线程初始化"></a><strong>3.线程池中的线程初始化</strong></h4><blockquote><p>默认情况下，创建线程池之后，线程池中是没有线程的，需要提交任务之后才会创建线程。</p><p>　　在实际中如果需要线程池创建之后立即创建线程，可以通过以下两个方法办到：</p><ul><li>prestartCoreThread()：初始化一个核心线程；</li><li>prestartAllCoreThreads()：初始化所有核心线程</li></ul><p>　　下面是这2个方法的实现：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">prestartCoreThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">addIfUnderCorePoolSize</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//注意传进去的参数是null</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">prestartAllCoreThreads</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">addIfUnderCorePoolSize</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//注意传进去的参数是null</span>        <span class="token operator">++</span>n<span class="token punctuation">;</span>    <span class="token keyword">return</span> n<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>注意上面传进去的参数是null，根据第2小节的分析可知如果传进去的参数为null，则最后执行线程会阻塞在getTask方法中的</p></blockquote><pre class=" language-java"><code class="language-java">r <span class="token operator">=</span> workQueue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>即等待任务队列中有任务。</p></blockquote><h4 id="4-任务缓存队列及排队策略"><a href="#4-任务缓存队列及排队策略" class="headerlink" title="4.任务缓存队列及排队策略"></a><strong>4.任务缓存队列及排队策略</strong></h4><blockquote><p>在前面我们多次提到了任务缓存队列，即workQueue，它用来存放等待执行的任务。</p><p>　　workQueue的类型为BlockingQueue<runnable>，通常可以取下面三种类型：</runnable></p><p>　　1）ArrayBlockingQueue：基于数组的先进先出队列，此队列创建时必须指定大小；</p><p>　　2）LinkedBlockingQueue：基于链表的先进先出队列，如果创建时没有指定此队列大小，则默认为Integer.MAX_VALUE；</p><p>　　3）synchronousQueue：这个队列比较特殊，它不会保存提交的任务，而是将直接新建一个线程来执行新来的任务。</p></blockquote><h4 id="5-任务拒绝策略"><a href="#5-任务拒绝策略" class="headerlink" title="5.任务拒绝策略"></a><strong>5.任务拒绝策略</strong></h4><blockquote><p>当线程池的任务缓存队列已满并且线程池中的线程数目达到maximumPoolSize，如果还有任务到来就会采取任务拒绝策略，通常有以下四种策略：</p></blockquote><pre class=" language-java"><code class="language-java">ThreadPoolExecutor<span class="token punctuation">.</span>AbortPolicy<span class="token operator">:</span>丢弃任务并抛出RejectedExecutionException异常。ThreadPoolExecutor<span class="token punctuation">.</span>DiscardPolicy：也是丢弃任务，但是不抛出异常。ThreadPoolExecutor<span class="token punctuation">.</span>DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）ThreadPoolExecutor<span class="token punctuation">.</span>CallerRunsPolicy：由调用线程处理该任务</code></pre><h4 id="6-线程池的关闭"><a href="#6-线程池的关闭" class="headerlink" title="6.线程池的关闭"></a><strong>6.线程池的关闭</strong></h4><blockquote><p>ThreadPoolExecutor提供了两个方法，用于线程池的关闭，分别是shutdown()和shutdownNow()，其中：</p><ul><li>shutdown()：不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务</li><li>shutdownNow()：立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务</li></ul></blockquote><h4 id="7-线程池容量的动态调整"><a href="#7-线程池容量的动态调整" class="headerlink" title="7.线程池容量的动态调整"></a><strong>7.线程池容量的动态调整</strong></h4><blockquote><p>ThreadPoolExecutor提供了动态调整线程池容量大小的方法：setCorePoolSize()和setMaximumPoolSize()，</p><ul><li>setCorePoolSize：设置核心池大小</li><li>setMaximumPoolSize：设置线程池最大能创建的线程数目大小</li></ul><p>　　当上述参数从小变大时，ThreadPoolExecutor进行线程赋值，还可能立即创建新的线程来执行任务。</p></blockquote><h3 id="三-代码示例"><a href="#三-代码示例" class="headerlink" title="三.代码示例"></a>三.代码示例</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>springboot<span class="token punctuation">.</span>executor<span class="token punctuation">.</span>executortest<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>springboot<span class="token punctuation">.</span>executor<span class="token punctuation">.</span>executordemo<span class="token punctuation">.</span>MyTask<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ArrayBlockingQueue<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ThreadPoolExecutor<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeUnit<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019-07-30 * @Time: 15:55 * @Vsersion: 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExecutorTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ThreadPoolExecutor executor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">200</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">15</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            MyTask myTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyTask</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>myTask<span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程池中线程数目："</span><span class="token operator">+</span>executor<span class="token punctuation">.</span><span class="token function">getPoolSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"，队列中等待执行的任务数目："</span><span class="token operator">+</span>                    executor<span class="token punctuation">.</span><span class="token function">getQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"，已执行完别的任务数目："</span><span class="token operator">+</span>executor<span class="token punctuation">.</span><span class="token function">getCompletedTaskCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        executor<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>springboot<span class="token punctuation">.</span>executor<span class="token punctuation">.</span>executordemo<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019-07-30 * @Time: 16:01 * @Vsersion: 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyTask</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> taskNum<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">MyTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">MyTask</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>taskNum <span class="token operator">=</span> num<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"正在执行task"</span><span class="token operator">+</span>taskNum<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">4000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"task"</span><span class="token operator">+</span>taskNum<span class="token operator">+</span><span class="token string">"执行完毕"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>执行结果：</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/30/xian-cheng-chi/001.png" alt></p><blockquote><p>从执行结果可以看出，当线程池中线程的数目大于5时，便将任务放入任务缓存队列里面，当任务缓存队列满了之后，便创建新的线程。如果上面程序中，将for循环中改成执行20个任务，就会抛出任务拒绝异常了。</p><p>　　不过在java doc中，并不提倡我们直接使用ThreadPoolExecutor，而是使用Executors类中提供的几个静态方法来创建线程池：</p></blockquote><pre class=" language-java"><code class="language-java">Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//创建一个缓冲池，缓冲池容量大小为Integer.MAX_VALUE</span>Executors<span class="token punctuation">.</span><span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//创建容量为1的缓冲池</span>Executors<span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//创建固定容量大小的缓冲池</span></code></pre><blockquote><p>下面是这三个静态方法的具体实现;</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> nThreads<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>nThreads<span class="token punctuation">,</span> nThreads<span class="token punctuation">,</span>                                  0L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>                                  <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FinalizableDelegatedExecutorService</span>        <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span>                                0L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>                                <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span>                                  60L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>                                  <span class="token keyword">new</span> <span class="token class-name">SynchronousQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>从它们的具体实现来看，它们实际上也是调用了ThreadPoolExecutor，只不过参数都已配置好了。</p><p>　　newFixedThreadPool创建的线程池corePoolSize和maximumPoolSize值是相等的，它使用的LinkedBlockingQueue；</p><p>　　newSingleThreadExecutor将corePoolSize和maximumPoolSize都设置为1，也使用的LinkedBlockingQueue；</p><p>　　newCachedThreadPool将corePoolSize设置为0，将maximumPoolSize设置为Integer.MAX_VALUE，使用的SynchronousQueue，也就是说来了任务就创建线程运行，当线程空闲超过60秒，就销毁线程。</p><p>　　实际中，如果Executors提供的三个静态方法能满足要求，就尽量使用它提供的三个方法，因为自己去手动配置ThreadPoolExecutor的参数有点麻烦，要根据实际任务的类型和数量来进行配置。</p><p>　　另外，如果ThreadPoolExecutor达不到要求，可以自己继承ThreadPoolExecutor类进行重写。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> executor </tag>
            
            <tag> ThreadPoolExecutor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot（五）</title>
      <link href="/2019/07/29/springboot-wu/"/>
      <url>/2019/07/29/springboot-wu/</url>
      
        <content type="html"><![CDATA[<h1 id="Springboot整合sharding-jdbc中间件，实现数据分库分表"><a href="#Springboot整合sharding-jdbc中间件，实现数据分库分表" class="headerlink" title="Springboot整合sharding-jdbc中间件，实现数据分库分表"></a>Springboot整合sharding-jdbc中间件，实现数据分库分表</h1><h3 id="一、什么sharding-jdbc"><a href="#一、什么sharding-jdbc" class="headerlink" title="一、什么sharding-jdbc"></a>一、什么sharding-jdbc</h3><blockquote><p>当当开源的，属于 client 层方案，目前已经更名为 [<code>ShardingSphere</code>]。确实之前用的还比较多一些，因为 SQL 语法支持也比较多，没有太多限制，而且截至 2019.4，已经推出到了 <code>4.0.0-RC1</code> 版本，支持分库分表、读写分离、分布式 id 生成、柔性事务（最大努力送达型事务、TCC 事务）。而且确实之前使用的公司会比较多一些（这个在官网有登记使用的公司，可以看到从 2017 年一直到现在，是有不少公司在用的），目前社区也还一直在开发和维护，还算是比较活跃。</p></blockquote><h3 id="二、水平分割"><a href="#二、水平分割" class="headerlink" title="二、水平分割"></a>二、水平分割</h3><h4 id="1、水平分库"><a href="#1、水平分库" class="headerlink" title="1、水平分库"></a>1、水平分库</h4><blockquote><p>1)、概念：<br>以字段为依据，按照一定策略，将一个库中的数据拆分到多个库中。<br>2)、结果<br>每个库的结构都一样；数据都不一样；<br>所有库的并集是全量数据；</p></blockquote><h4 id="2、水平分表"><a href="#2、水平分表" class="headerlink" title="2、水平分表"></a>2、水平分表</h4><blockquote><p>1)、概念<br>以字段为依据，按照一定策略，将一个表中的数据拆分到多个表中。<br>2)、结果<br>每个表的结构都一样；数据都不一样；<br>所有表的并集是全量数据；</p></blockquote><h3 id="三、Shard-jdbc-中间件"><a href="#三、Shard-jdbc-中间件" class="headerlink" title="三、Shard-jdbc 中间件"></a>三、Shard-jdbc 中间件</h3><h4 id="1、架构图"><a href="#1、架构图" class="headerlink" title="1、架构图"></a>1、架构图</h4><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/29/springboot-wu/002.png" alt></p><h4 id="2、特点"><a href="#2、特点" class="headerlink" title="2、特点"></a>2、特点</h4><blockquote><p>1)、Sharding-JDBC直接封装JDBC API，旧代码迁移成本几乎为零。<br>2)、适用于任何基于Java的ORM框架，如Hibernate、Mybatis等 。<br>3)、可基于任何第三方的数据库连接池，如DBCP、C3P0、 BoneCP、Druid等。<br>4)、以jar包形式提供服务，无proxy代理层，无需额外部署，无其他依赖。<br>5)、分片策略灵活，可支持等号、between、in等多维度分片，也可支持多分片键。<br>6)、SQL解析功能完善，支持聚合、分组、排序、limit、or等查询。</p></blockquote><h3 id="四、创建Springboot工程"><a href="#四、创建Springboot工程" class="headerlink" title="四、创建Springboot工程"></a>四、创建Springboot工程</h3><h4 id="1、pom依赖"><a href="#1、pom依赖" class="headerlink" title="1、pom依赖"></a>1、pom依赖</h4>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot2.0 </tag>
            
            <tag> sharding-jdbc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构——单链表</title>
      <link href="/2019/07/26/shu-ju-jie-gou-dan-lian-biao/"/>
      <url>/2019/07/26/shu-ju-jie-gou-dan-lian-biao/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构—单链表"><a href="#数据结构—单链表" class="headerlink" title="数据结构—单链表"></a>数据结构—单链表</h1><p>[TOC]</p><h3 id="一、什么是链表？"><a href="#一、什么是链表？" class="headerlink" title="一、什么是链表？"></a>一、什么是链表？</h3><blockquote><p>​        链表是一种最常见的数据结构，其内部数据呈线性排列，属于线性表结构，什么是线性表？表中的数据按顺序依次排列，就像用一条线把数据串联起来一样。</p></blockquote><p><img src="/Volumes/work/hexo/source/_posts/数据结构——单链表/001.png" alt></p><blockquote><p>​        链表就是这种排布方式，特点是添加数据和删除数据速度快，但是查询数据会比较耗时，这是因为链表在内存中的存储结构造成的。</p><p>​        这里我们可以将数组与链表进行对比，数组大家应该都很熟悉，学过 Java 的都会用，但是你真的了解它在内存中的存储结构吗？数组的特点是查询数据很快，添加数据和删除数据效率低，这一特征与链表恰好相反，数组的缺陷正是链表的优势，数组的优势则是链表的缺陷，所以二者对比着来记，效果会更好。</p><p>​        来说说为什么数组和链表的特点恰好相反，首先来看看二者在内存中的存储结构。</p><p>​        数组和链表都是线性表结构，数组在内存中是一串连续的内存空间，比如定义一个 int 类型数组，int[] array = new int[6]，计算机会为 array 分配一块连续的空间，如下图所示。</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/26/shu-ju-jie-gou-dan-lian-biao/002.png" alt></p><blockquote><p>​        1000-1003 这段空间用来存储数组中的第一个元素 array[0]，1004-1007 的空间用来存储 array[1]，以此类推数组中的每个元素都对应一块大小为 4 byte 的空间，这种结构就决定了数组查询数据速度很快，只需要知道首地址（在栈内存中记录的就是数组的首地址，可以直接获取），再结合寻址公式就可以很快找到对应元素的地址，从而取出数据。</p><p>数组的寻址公式：i_address = first_address + data_size*i</p><p>​        带入上述案例中，比如要找到数组中第 3 个元素，也就是下标为 2 ，该元素的首地址即 2_address = 1000 + 2*4 = 1008，计算机只需要执行一个简单的数学运算就可以找到元素的首地址，进而取出对应的值，对于计算机来讲，简单数学运算的耗时几乎可以忽略不计，所以数组查询数据速度非常快。</p><p>​        也正是因为这种结构导致数组添加和删除数据效率很低，因为这两种操作不仅仅是在数组中添加或者移除一个元素那么简单，同时还需要移动其他已存在的元素。</p><p>​        数组中各个元素的内存地址都是连续，不间断的，删除某个元素之后需要保证数组仍然是连续的，所以就需要移动数据，比如要删除 array[2]，删除之后需要依次将 array[3]、array[4]、array[5] 向前移动一位，如下图所示。</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/26/shu-ju-jie-gou-dan-lian-biao/003.png" alt></p><blockquote><p>同理，如果此时将 0 添加到数组中的第 2 位，即 array[1] 的位置，同样需要先将 array[1] 及其之后的各个元素依次向后移动 1 位，给新数据腾出位置才能添加，如下图所示。</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/26/shu-ju-jie-gou-dan-lian-biao/004.png" alt></p><blockquote><p>因为要移动元素，所以无论是添加数据还是删除数据，效率都不高。</p><p>搞清楚数组的存储结构之后，我们再来看看链表的存储结构，在内存中，链表中的数据是分散的，无须存储在一块连续的内存空间中，如下图所示。</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/26/shu-ju-jie-gou-dan-lian-biao/005.png" alt></p><blockquote><p>链表中存储了 3 个元素分别是 1、2、3，每个元素都有一个指针，指向下一个元素的内存地址，1 的指针就指向 2 的内存地址 1008，2 的指针就指向 3 的内存地址 1020，依次类推。</p><p>不同元素之间的物理空间间隔也是不确定的，所以这样的结构就无法通过一个固定的公式来求出某个元素的内存地址，只能从首元素开始依次向后查找，直到找到目标元素。如果目标元素位于链表的最后一位，则需要遍历整个链表才能找到它，效率很低。</p><p>同样，正是因为这样的结构，使得链表添加和删除元素效率很高，无须移动其他已存在的元素，只需要修改元素指针即可。比如，删除 2，则只需要将 1 的指针指向 3 即可，如下图所示。</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/26/shu-ju-jie-gou-dan-lian-biao/006.png" alt></p><blockquote><p>添加元素也是一样，要在 2 和 3 之间添加元素 0 ，只需要随机分配一块空间存储 0，然后将 2 的指针指向 0，0 的指针指向 3 即可，如下图所示。</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/26/shu-ju-jie-gou-dan-lian-biao/007.png" alt></p><blockquote><p>所以在链表中，无论是添加还是删除元素，都只需要修改相关节点的指针即可，效率很高。</p><p>搞清楚链表的结构之后，我们使用 Java 语言来实现一个单链表的结构。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java分布式锁三种实现方案</title>
      <link href="/2019/07/24/java-fen-bu-shi-suo-san-chong-shi-xian-fang-an/"/>
      <url>/2019/07/24/java-fen-bu-shi-suo-san-chong-shi-xian-fang-an/</url>
      
        <content type="html"><![CDATA[<h1 id="Java分布式锁三种实现方案"><a href="#Java分布式锁三种实现方案" class="headerlink" title="Java分布式锁三种实现方案"></a>Java分布式锁三种实现方案</h1><h3 id="方案一：数据库乐观锁"><a href="#方案一：数据库乐观锁" class="headerlink" title="方案一：数据库乐观锁"></a>方案一：数据库乐观锁</h3><blockquote><p>​        乐观锁通常实现基于数据版本(version)的记录机制实现的，比如有一张红包表（t_bonus），有一个字段(left_count)记录礼物的剩余个数，用户每领取一个奖品，对应的left_count减1，在并发的情况下如何要保证left_count不为负数，乐观锁的实现方式为在红包表上添加一个版本号字段（version），默认为0。</p></blockquote><h4 id="异常实现流程"><a href="#异常实现流程" class="headerlink" title="异常实现流程"></a>异常实现流程</h4><pre><code>-- 可能会发生的异常情况-- 线程1查询，当前left_count为1，则有记录select * from t_bonus where id = 10001 and left_count &gt; 0-- 线程2查询，当前left_count为1，也有记录select * from t_bonus where id = 10001 and left_count &gt; 0-- 线程1完成领取记录，修改left_count为0,update t_bonus set left_count = left_count - 1 where id = 10001-- 线程2完成领取记录，修改left_count为-1，产生脏数据update t_bonus set left_count = left_count - 1 where id = 10001</code></pre><h4 id="通过乐观锁实现"><a href="#通过乐观锁实现" class="headerlink" title="通过乐观锁实现"></a>通过乐观锁实现</h4><pre><code>-- 添加版本号控制字段ALTER TABLE table ADD COLUMN version INT DEFAULT &#39;0&#39; NOT NULL AFTER t_bonus;-- 线程1查询，当前left_count为1，则有记录，当前版本号为1234select left_count, version from t_bonus where id = 10001 and left_count &gt; 0-- 线程2查询，当前left_count为1，有记录，当前版本号为1234select left_count, version from t_bonus where id = 10001 and left_count &gt; 0-- 线程1,更新完成后当前的version为1235，update状态为1，更新成功update t_bonus set version = 1235, left_count = left_count-1 where id = 10001 and version = 1234-- 线程2,更新由于当前的version为1235，udpate状态为0，更新失败，再针对相关业务做异常处理update t_bonus set version = 1235, left_count = left_count-1 where id = 10001 and version = 1234</code></pre><h3 id="方案二：基于Redis的分布式锁"><a href="#方案二：基于Redis的分布式锁" class="headerlink" title="方案二：基于Redis的分布式锁"></a>方案二：基于Redis的分布式锁</h3><pre><code>SETNX命令（SET if Not eXists）语法：SETNX key value功能：原子性操作，当且仅当 key 不存在，将 key 的值设为 value ，并返回1；若给定的 key 已经存在，则 SETNX 不做任何动作，并返回0。Expire命令语法：expire(key, expireTime)功能：key设置过期时间GETSET命令语法：GETSET key value功能：将给定 key 的值设为 value ，并返回 key 的旧值 (old value)，当 key 存在但不是字符串类型时，返回一个错误，当key不存在时，返回nil。GET命令语法：GET key功能：返回 key 所关联的字符串值，如果 key 不存在那么返回特殊值 nil 。DEL命令语法：DEL key [KEY …]功能：删除给定的一个或多个 key ,不存在的 key 会被忽略。</code></pre><h5 id="第一种：使用redis的setnx-、expire-方法，用于分布式锁"><a href="#第一种：使用redis的setnx-、expire-方法，用于分布式锁" class="headerlink" title="第一种：使用redis的setnx()、expire()方法，用于分布式锁"></a>第一种：使用redis的setnx()、expire()方法，用于分布式锁</h5><blockquote><ol><li>setnx(lockkey, 1) 如果返回0，则说明占位失败；如果返回1，则说明占位成功</li><li>expire()命令对lockkey设置超时时间，为的是避免死锁问题。</li><li>执行完业务代码后，可以通过delete命令删除key。</li></ol></blockquote><pre><code>        这个方案其实是可以解决日常工作中的需求的，但从技术方案的探讨上来说，可能还有一些可以完善的地方。比如，如果在第一步setnx执行成功后，在expire()命令执行成功前，发生了宕机的现象，那么就依然会出现死锁的问题</code></pre><h5 id="第二种：使用redis的setnx-、get-、getset-方法，用于分布式锁，解决死锁问题"><a href="#第二种：使用redis的setnx-、get-、getset-方法，用于分布式锁，解决死锁问题" class="headerlink" title="第二种：使用redis的setnx()、get()、getset()方法，用于分布式锁，解决死锁问题"></a>第二种：使用redis的setnx()、get()、getset()方法，用于分布式锁，解决死锁问题</h5><blockquote><ol><li>setnx(lockkey, 当前时间+过期超时时间) ，如果返回1，则获取锁成功；如果返回0则没有获取到锁，转向2。</li><li>get(lockkey)获取值oldExpireTime ，并将这个value值与当前的系统时间进行比较，如果小于当前系统时间，则认为这个锁已经超时，可以允许别的请求重新获取，转向3。</li><li>计算newExpireTime=当前时间+过期超时时间，然后getset(lockkey, newExpireTime) 会返回当前lockkey的值currentExpireTime。</li><li>判断currentExpireTime与oldExpireTime 是否相等，如果相等，说明当前getset设置成功，获取到了锁。如果不相等，说明这个锁又被别的请求获取走了，那么当前请求可以直接返回失败，或者继续重试。</li><li>在获取到锁之后，当前线程可以开始自己的业务处理，当处理完毕后，比较自己的处理时间和对于锁设置的超时时间，如果小于锁设置的超时时间，则直接执行delete释放锁；如果大于锁设置的超时时间，则不需要再锁进行处理。</li></ol></blockquote><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><blockquote><p>使用的是jedis来连接Redis。</p></blockquote><h4 id="实现思想"><a href="#实现思想" class="headerlink" title="实现思想"></a>实现思想</h4><blockquote><ul><li>获取锁的时候，使用setnx加锁，并使用expire命令为锁添加一个超时时间，超过该时间则自动释放锁，锁的value值为一个随机生成的UUID，通过此在释放锁的时候进行判断。</li><li>获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。</li><li>释放锁的时候，通过UUID判断是不是该锁，若是该锁，则执行delete进行锁释放。</li></ul></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>springboot<span class="token punctuation">.</span>lock<span class="token punctuation">.</span>redislock<span class="token punctuation">;</span><span class="token keyword">import</span> redis<span class="token punctuation">.</span>clients<span class="token punctuation">.</span>jedis<span class="token punctuation">.</span>Jedis<span class="token punctuation">;</span><span class="token keyword">import</span> redis<span class="token punctuation">.</span>clients<span class="token punctuation">.</span>jedis<span class="token punctuation">.</span>JedisPool<span class="token punctuation">;</span><span class="token keyword">import</span> redis<span class="token punctuation">.</span>clients<span class="token punctuation">.</span>jedis<span class="token punctuation">.</span>Transaction<span class="token punctuation">;</span><span class="token keyword">import</span> redis<span class="token punctuation">.</span>clients<span class="token punctuation">.</span>jedis<span class="token punctuation">.</span>exceptions<span class="token punctuation">.</span>JedisException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>List<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>UUID<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019-07-25 * @Time: 07:38 * @Vsersion: 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DistributedLock</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> JedisPool jedisPool<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">DistributedLock</span><span class="token punctuation">(</span>JedisPool jedisPool<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>jedisPool <span class="token operator">=</span> jedisPool<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 加锁     * @param localName  锁的key     * @param acquireTimeout  获取超时时间     * @param timeout   锁的超时时间     * @return 锁标识     */</span>    <span class="token keyword">public</span> String <span class="token function">lockWithTimeout</span><span class="token punctuation">(</span>String localName<span class="token punctuation">,</span> Long acquireTimeout<span class="token punctuation">,</span> Long timeout<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Jedis conn <span class="token operator">=</span> null<span class="token punctuation">;</span>        String retIdentifier <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 获取连接</span>            conn <span class="token operator">=</span> jedisPool<span class="token punctuation">.</span><span class="token function">getResource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 随机生成一个value</span>            String identifier <span class="token operator">=</span> UUID<span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 锁名，即key值</span>            String lockKey <span class="token operator">=</span> <span class="token string">"lock:"</span> <span class="token operator">+</span> localName<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 超时时间，上锁后超过此时间则自动释放锁</span>            <span class="token keyword">int</span> lockExpire <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>timeout <span class="token operator">/</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 获取锁的超时时间，超过这个时间则放弃获取锁</span>            <span class="token keyword">long</span> end <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> acquireTimeout<span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>conn<span class="token punctuation">.</span><span class="token function">setnx</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">,</span> identifier<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    conn<span class="token punctuation">.</span><span class="token function">expire</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">,</span> lockExpire<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 返回value值，用于释放锁时间确认</span>                    retIdentifier <span class="token operator">=</span> identifier<span class="token punctuation">;</span>                    <span class="token keyword">return</span> retIdentifier<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// 返回-1代表key没有设置超时时间，为key设置一个超时时间</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>conn<span class="token punctuation">.</span><span class="token function">ttl</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    conn<span class="token punctuation">.</span><span class="token function">expire</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">,</span> lockExpire<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">JedisException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>conn <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                conn<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> retIdentifier<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 释放锁     * @param lockName 锁的key     * @param identifier    释放锁的标识     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">releaseLock</span><span class="token punctuation">(</span>String lockName<span class="token punctuation">,</span> String identifier<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Jedis conn <span class="token operator">=</span> null<span class="token punctuation">;</span>        String lockKey <span class="token operator">=</span> <span class="token string">"lock:"</span> <span class="token operator">+</span> lockName<span class="token punctuation">;</span>        <span class="token keyword">boolean</span> retFlag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            conn <span class="token operator">=</span> jedisPool<span class="token punctuation">.</span><span class="token function">getResource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 监视lock，准备开始事务</span>                conn<span class="token punctuation">.</span><span class="token function">watch</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 通过前面返回的value值判断是不是该锁，若是该锁，则删除，释放锁</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>identifier<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    Transaction transaction <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">multi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    transaction<span class="token punctuation">.</span><span class="token function">del</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">)</span><span class="token punctuation">;</span>                    List<span class="token operator">&lt;</span>Object<span class="token operator">></span> results <span class="token operator">=</span> transaction<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>results <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">continue</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    retFlag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                conn<span class="token punctuation">.</span><span class="token function">unwatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">JedisException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>conn <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                conn<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> retFlag<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>测试分布式锁；<br>例子中使用50个线程模拟秒杀一个商品，使用–运算符来实现商品减少，从结果有序性就可以看出是否为加锁状态。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>springboot<span class="token punctuation">.</span>lock<span class="token punctuation">.</span>redislock<span class="token punctuation">;</span><span class="token keyword">import</span> redis<span class="token punctuation">.</span>clients<span class="token punctuation">.</span>jedis<span class="token punctuation">.</span>JedisPool<span class="token punctuation">;</span><span class="token keyword">import</span> redis<span class="token punctuation">.</span>clients<span class="token punctuation">.</span>jedis<span class="token punctuation">.</span>JedisPoolConfig<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019-07-24 * @Time: 21:54 * @Vsersion: 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedisService</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> JedisPool pool <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        JedisPoolConfig config <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JedisPoolConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 设置最大连接数</span>        config<span class="token punctuation">.</span><span class="token function">setMaxTotal</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 设置最大空闲数</span>        config<span class="token punctuation">.</span><span class="token function">setMaxIdle</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 设置最大等待时间</span>        config<span class="token punctuation">.</span><span class="token function">setMaxWaitMillis</span><span class="token punctuation">(</span><span class="token number">1000</span> <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 在borrow一个jedis实例时，是否需要验证，若为true，则所有jedis实例均是可用的</span>        config<span class="token punctuation">.</span><span class="token function">setTestOnBorrow</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        pool <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JedisPool</span><span class="token punctuation">(</span>config<span class="token punctuation">,</span> <span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span> <span class="token number">6379</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    DistributedLock lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DistributedLock</span><span class="token punctuation">(</span>pool<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">500</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">seckill</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 返回锁的value值，供释放锁时候进行判断</span>        String indentifier <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">lockWithTimeout</span><span class="token punctuation">(</span><span class="token string">"resource"</span><span class="token punctuation">,</span> 5000L<span class="token punctuation">,</span> 1000L<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"获得了锁"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token operator">--</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        lock<span class="token punctuation">.</span><span class="token function">releaseLock</span><span class="token punctuation">(</span><span class="token string">"resource"</span><span class="token punctuation">,</span> indentifier<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="基于ZooKeeper实现分布式锁"><a href="#基于ZooKeeper实现分布式锁" class="headerlink" title="基于ZooKeeper实现分布式锁"></a>基于ZooKeeper实现分布式锁</h3><blockquote><p>ZooKeeper是一个分布式的，开放源码的<strong>分布式应用程序协调服务</strong>，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。它是<strong>一个为分布式应用提供一致性服务的软件</strong>，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。</p><p>ZooKeeper的架构通过<strong>冗余服务</strong>实现高可用性。因此，如果第一次无应答，客户端就可以询问另一台ZooKeeper主机。ZooKeeper节点将它们的数据存储于一个<strong>分层的命名空间</strong>，非常类似于一个文件系统或一个前缀树结构。客户端可以在节点读写，从而以这种方式拥有一个共享的配置服务。更新是全序的。</p></blockquote><h4 id="基于ZooKeeper分布式锁的流程"><a href="#基于ZooKeeper分布式锁的流程" class="headerlink" title="基于ZooKeeper分布式锁的流程"></a>基于ZooKeeper分布式锁的流程</h4><blockquote><ul><li>在zookeeper指定节点（locks）下创建临时顺序节点node_n</li><li>获取locks下所有子节点children</li><li>对子节点按节点自增序号从小到大排序</li><li>判断本节点是不是第一个子节点，若是，则获取锁；若不是，则监听比该节点小的那个节点的删除事件</li><li>若监听事件生效，则回到第二步重新进行判断，直到获取到锁</li></ul></blockquote><blockquote><p>这里推荐一个Apache的开源库Curator，它是一个ZooKeeper客户端，Curator提供的InterProcessMutex是分布式锁的实现，acquire方法用于获取锁，release方法用于释放锁。</p><p>优点：具备高可用、可重入、阻塞锁特性，可解决失效死锁问题。<br>缺点：因为需要频繁的创建和删除节点，性能上不如Redis方式。</p><p>使用zookeeper的<strong>可靠性和稳定性</strong>是要大于使用redis实现的分布式锁的，但是相比而言，redis的<strong>性能</strong>更好。</p></blockquote><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><blockquote><p>下面就具体使用java和zookeeper实现分布式锁，操作zookeeper使用的是apache提供的zookeeper的包。</p><ul><li>通过实现Watch接口，实现process(WatchedEvent event)方法来实施监控，使CountDownLatch来完成监控，在等待锁的时候使用CountDownLatch来计数，等到后进行countDown，停止等待，继续运行。</li><li>以下整体流程基本与上述描述流程一致，只是在监听的时候使用的是CountDownLatch来监听前一个节点。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 乐观锁 </tag>
            
            <tag> redis </tag>
            
            <tag> zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac下安装Kafka</title>
      <link href="/2019/07/21/mac-xia-an-zhuang-kafka/"/>
      <url>/2019/07/21/mac-xia-an-zhuang-kafka/</url>
      
        <content type="html"><![CDATA[<h1 id="Mac下安装Kafka"><a href="#Mac下安装Kafka" class="headerlink" title="Mac下安装Kafka"></a>Mac下安装Kafka</h1><blockquote><p>使用brew安装</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/21/mac-xia-an-zhuang-kafka/001.png" alt></p><p>安装完之后，安装目录为：</p><pre><code># kafka安装目录/usr/local/Cellar/kafka/2.2.1# 配置文件目录/usr/local/etc/kafka/</code></pre><blockquote><p>如果需要修改配置，可以进入对应目录，修改配置文件就好</p></blockquote><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><blockquote><p>kafka<code>是基于zookeeper的，启动</code>kafka<code>之前，需要先启动</code>zookeeper</p></blockquote><pre><code>zkServer start</code></pre><blockquote><p>启动后，查看启动是否成功</p></blockquote><pre><code>ps aux|grep zookeeper</code></pre><blockquote><p>启动kafka</p></blockquote><pre><code>kafka-server-start /usr/local/etc/kafka/server.properties &amp;</code></pre><blockquote><p>查看启动是否成功</p></blockquote><pre><code>ps aux | grep kafka</code></pre><h4 id="创建一个topic"><a href="#创建一个topic" class="headerlink" title="创建一个topic"></a>创建一个topic</h4><pre><code># 命令行参数含义，后续补充，当前页不是很清楚，约莫能猜出个大概kafka-topics --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic ZongMan</code></pre><h4 id="查看topic列表"><a href="#查看topic列表" class="headerlink" title="查看topic列表"></a>查看topic列表</h4><pre><code>kafka-topics --list --zookeeper localhost:2181</code></pre><h4 id="创建一个生产者"><a href="#创建一个生产者" class="headerlink" title="创建一个生产者"></a>创建一个生产者</h4><pre><code>kafka-console-producer --broker-list localhost:9092 --topic ZongMan</code></pre><h4 id="创建二个消费者"><a href="#创建二个消费者" class="headerlink" title="创建二个消费者"></a>创建二个消费者</h4><pre><code>kafka-console-consumer --bootstrap-server localhost:9092 --topic test --from-beginning</code></pre><h4 id="服务的关闭"><a href="#服务的关闭" class="headerlink" title="服务的关闭"></a>服务的关闭</h4><blockquote><p>服务关闭的顺序是先<code>kafka</code>，然后<code>zookeeper</code></p></blockquote><pre><code># 关闭kafka/usr/local/Cellar/kafka/2.2.1/bin/kafka-server-stop#关闭zookeeper/usr/local/Cellar/kafka/2.2.1/bin/zookeeper-server-stop</code></pre>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
            <tag> kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM如何判断对象是否还存活</title>
      <link href="/2019/07/18/jvm-ru-he-pan-duan-dui-xiang-shi-fou-huan-cun-huo/"/>
      <url>/2019/07/18/jvm-ru-he-pan-duan-dui-xiang-shi-fou-huan-cun-huo/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM如何判断对象是否还存活"><a href="#JVM如何判断对象是否还存活" class="headerlink" title="JVM如何判断对象是否还存活"></a>JVM如何判断对象是否还存活</h1><blockquote><p>在java堆中存活着几乎所有的对象实例，垃圾收集器在回收之前需要判断哪些对象还存活着，哪些对象已经死去。</p></blockquote><h3 id="一、引用计数法"><a href="#一、引用计数法" class="headerlink" title="一、引用计数法"></a>一、引用计数法</h3><blockquote><p>引用计算法的算法大致如下：给对象添加一个引用计数器，每当有地方引用它时，计数器就加1；当引用失效时，计数器就减1；当计数器为0时就表示该对象已经死去。</p><p>客观的说，引用计数法的实现简单，判定效率也很高，在大多数情况下是一种不错的算法，也有很多经典的应用案例，比如微软公司的COM（Component Object Model）技术、使用ActionScript 3的FlashPlayer、Python语言和在游戏脚本领域广泛应用的Squirrel中都使用了引用计数算法进行了内存管理。<strong>但在主流的java虚拟机中没有选用引用计数法来管理内存，主要是因为它很难解决对象之间相互循环引用的问题</strong>。</p><p>现在我们就通过对象循环引用的例子来测试java虚拟机是否会回收？</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>jvm<span class="token punctuation">.</span>demo<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019-07-18 * @Time: 21:42 * @Vsersion: 1.0 * 测试java虚拟机会否用引用计数法进行垃圾回收 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReferenceCountTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> Object instance <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> oneMB<span class="token operator">=</span><span class="token number">1024</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bigSize <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token operator">*</span>oneMB<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 该成员属性用来占点内存，方便gc日志中观察内存回收过程     * @param args     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ReferenceCountTest a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceCountTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ReferenceCountTest b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceCountTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        a<span class="token punctuation">.</span>instance <span class="token operator">=</span> b<span class="token punctuation">;</span>        b<span class="token punctuation">.</span>instance <span class="token operator">=</span> a<span class="token punctuation">;</span>        a <span class="token operator">=</span> null<span class="token punctuation">;</span>        b <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//当发生gc时，对象a和对象b能否被回收？</span>        System<span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="二、可达性分析算法"><a href="#二、可达性分析算法" class="headerlink" title="二、可达性分析算法"></a>二、可达性分析算法</h3><blockquote><p>在主流的商用语言中（例如Java、C#）的主流实现中，都是通过可达性分析（Reachability Analysis）来判定对象是否存活的。这个算法的思路就是：</p><p>通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连时（也就是从GC Roots到这个对象不可达时 ），则说明此对象是不可用的。如下图所示，虽然Object5、Object6、Object7之间是相互关联的，但它们与GC Roots是断开的，所以它们被判定为可回收的对象。</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/18/jvm-ru-he-pan-duan-dui-xiang-shi-fou-huan-cun-huo/001.png" alt></p><blockquote><p>在java中，可作为GC Roots的对象有以下几种：</p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li><li>方法区中类静态属性引用的对象。</li><li>方法区中常量引用的对象。</li><li>本地方法栈中JNI（即一般说的Native方法）引用的对象。</li></ul></blockquote><h3 id="三、四种引用类型"><a href="#三、四种引用类型" class="headerlink" title="三、四种引用类型"></a>三、四种引用类型</h3><blockquote><p>在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）四种，这四种引用强度依次逐渐减弱。以下是它们的定义：</p><ul><li><strong>强引用</strong>就是指在程序代码中普遍存在的，类型“Object object = new Object()”这类的引用，垃圾回收器永远不会回收这类被引用的对象。</li><li><strong>软引用</strong>用来描述一些还有用但并非必须的对象。对于软引用关联的对象，在系统将要发生内存溢出之前，将会将这些对象列进回收范围进行第二次回收。若这次回收后还没有足够的内存，才会抛出内存溢出异常，在JDK1.2后，提供了SoftReference类来实现软引用。</li><li><strong>弱引用</strong>也用来描述非必须对象，但它的强度比软引用更弱些，被弱引用关联的对象只能生存到下一次垃圾回收之前。无论当前内存是否足够，垃圾回收都会回收掉被弱引用的对象。JDK1.2后，专门用WeakReference类来实现弱引用。</li><li><strong>虚引用</strong>也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设立虚引用的目的就是在这个对象被垃圾回收前收到一条系统通知。JDK1.2后，提供了PhantomRerence类来实现虚引用。</li></ul></blockquote><h3 id="四、对象生存或死亡"><a href="#四、对象生存或死亡" class="headerlink" title="四、对象生存或死亡"></a>四、对象生存或死亡</h3><blockquote><p>在可达性分析算法中不可达的对象，并非一定会垃圾回收的，这时候它们暂时处于“缓刑“阶段，要真正宣告一个对象的死亡，至少要经历两次标记过程：</p><ol><li><strong>如果对象在进行可达性分析时发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选</strong>，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。</li><li><strong>如果这个对象被判定为有必要执行finalize()方法，那么这个对象将被放置在一个叫做F-Queue的队列之中，并在稍后由虚拟机自动建立的、低优先级的Finalizer线程去执行它</strong>。这里所谓的执行是指虚拟机会触发这个方法，但它不会承诺会等待它运行结束。这样做的原因是，如果对象在finalize()方法中运行缓慢，或者发生了死循环或更糟糕的情况，这将可能导致F-Queue队列中其他对象永久处于等待，甚至整个内存回收系统崩溃。finalize方法是对象逃脱被回收的最后一次机会，稍后GC将对F-Queue队列中的对象进行第二次小规模的标记，如果对象要在finalize中成功拯救自己——只要重新与GC Roots重新建立关联即可，这样在第二次标记时它将被移出“即将回收”集合，否则将会被回收。</li></ol></blockquote><h3 id="五、回收方法区"><a href="#五、回收方法区" class="headerlink" title="五、回收方法区"></a>五、回收方法区</h3><blockquote><p>在堆中，尤其在新生代中，常规进行一次垃圾回收一般可以回收70%~95%的空间，而方法区（或者HotSpot虚拟机中的永久代）的垃圾回收效率远低于此。</p><p>方法区的垃圾回收主要回收两部分内容：<strong>废弃常量和无用的类</strong>。</p><p>判断一个常量是否为废弃常量的条件比较简单，以常量池中字面量的回收为例，假如一个字符串“a”已经进入了常量池中，但当前系统没有任何一个String对象是叫做“a”的，也就是说没有任何String对象引用长常量池中的“a”变量，也没有其他地方引用了这个字面量，那么垃圾回收时，这个“a”常量就会被系统清理出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。</p><p>判断一个类是否是无用的类条件就苛刻些，需要满足以下三个条件才可以被回收，而不是像对象一样不使用了，必然被回收，是否被类进行回收，Hotspot虚拟机提供了相关参数进行控制：</p><ul><li>该类的所有实例都已经被回收。</li><li>加载该类的ClassLoader已经被回收</li><li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><p>在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGI这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证方法区（永久代）不溢出。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 回收机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式全局ID生成方案</title>
      <link href="/2019/07/17/fen-bu-shi-quan-ju-id-sheng-cheng-fang-an/"/>
      <url>/2019/07/17/fen-bu-shi-quan-ju-id-sheng-cheng-fang-an/</url>
      
        <content type="html"><![CDATA[<h1 id="分布式全局ID生成方案"><a href="#分布式全局ID生成方案" class="headerlink" title="分布式全局ID生成方案"></a>分布式全局ID生成方案</h1><p>[TOC]</p><h3 id="一、分布式ID的特性"><a href="#一、分布式ID的特性" class="headerlink" title="一、分布式ID的特性"></a>一、分布式ID的特性</h3><blockquote><ul><li>唯一性：确保生成的ID是全网唯一的。</li><li>有序递增性：确保生成的ID是对于某个用户或者业务是按一定的数字有序递增的。</li><li>高可用性：确保任何时候都能正确的生成ID。</li><li>带时间：ID里面包含时间，一眼扫过去就知道哪天的交易。</li></ul></blockquote><h3 id="二、分布式ID的生成方案"><a href="#二、分布式ID的生成方案" class="headerlink" title="二、分布式ID的生成方案"></a>二、分布式ID的生成方案</h3><h4 id="1、数据库自增长序列或字段"><a href="#1、数据库自增长序列或字段" class="headerlink" title="1、数据库自增长序列或字段"></a>1、数据库自增长序列或字段</h4><blockquote><p>最常见的方式。利用数据库，全数据库唯一。</p></blockquote><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><blockquote><p>1）简单，代码方便，性能可以接受。<br>2）数字ID天然排序，对分页或者需要排序的结果很有帮助。</p></blockquote><h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><blockquote><p>1）不同数据库语法和实现不同，数据库迁移的时候或多数据库版本支持的时候需要处理。<br>2）在单个数据库或读写分离或一主多从的情况下，只有一个主库可以生成。有单点故障的风险。<br>3）在性能达不到要求的情况下，比较难于扩展。<br>4）如果遇见多个系统需要合并或者涉及到数据迁移会相当痛苦。<br>5）分表分库的时候会有麻烦。</p></blockquote><h5 id="优化方案："><a href="#优化方案：" class="headerlink" title="优化方案："></a>优化方案：</h5><blockquote><p>针对主库单点，如果有多个Master库，则每个Master库设置的起始数字不一样，步长一样，可以是Master的个数。比如：Master1 生成的是 1，4，7，10，Master2生成的是2,5,8,11 Master3生成的是 3,6,9,12。这样就可以有效生成集群中的唯一ID，也可以大大降低ID生成数据库操作的负载。</p></blockquote><h4 id="2、UUID"><a href="#2、UUID" class="headerlink" title="2、UUID"></a>2、UUID</h4><blockquote><p>常见的方式。可以利用数据库也可以利用程序生成，一般来说全球唯一。</p></blockquote><h5 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h5><blockquote><p>1）简单，代码方便。<br>2）生成ID性能非常好，基本不会有性能问题。<br>3）全球唯一，在遇见数据迁移，系统数据合并，或者数据库变更等情况下，可以从容应对。</p></blockquote><h5 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h5><blockquote><p>1）没有排序，无法保证趋势递增。<br>2）UUID往往是使用字符串存储，查询的效率比较低。<br>3）存储空间比较大，如果是海量数据库，就需要考虑存储量的问题。<br>4）传输数据量大<br>5）不可读。</p></blockquote><h4 id="3、批量生成ID"><a href="#3、批量生成ID" class="headerlink" title="3、批量生成ID"></a>3、批量生成ID</h4><blockquote><p>一次按需批量生成多个ID，每次生成都需要访问数据库，将数据库修改为最大的ID值，并在内存中记录当前值及最大值。</p></blockquote><h5 id="优点：-2"><a href="#优点：-2" class="headerlink" title="优点："></a>优点：</h5><blockquote><p>避免了每次生成ID都要访问数据库并带来压力，提高性能</p></blockquote><h5 id="缺点：-2"><a href="#缺点：-2" class="headerlink" title="缺点："></a>缺点：</h5><blockquote><p>属于本地生成策略，存在单点故障，服务重启造成ID不连续</p></blockquote><h4 id="4、Redis生成ID"><a href="#4、Redis生成ID" class="headerlink" title="4、Redis生成ID"></a>4、Redis生成ID</h4><blockquote><p>当使用数据库来生成ID性能不够要求的时候，可以尝试使用Redis来生成ID。这主要依赖于Redis是单线程的，所以也可以用生成全局唯一的ID。可以用Redis的原子操作 INCR和INCRBY来实现。</p><p>可以使用Redis集群来获取更高的吞吐量。假如一个集群中有5台Redis。可以初始化每台Redis的值分别是1,2,3,4,5，然后步长都是5。各个Redis生成的ID为：</p></blockquote><pre><code>A：1,6,11,16,21B：2,7,12,17,22C：3,8,13,18,23D：4,9,14,19,24E：5,10,15,20,25</code></pre><blockquote><p>这个，随便负载到哪个机确定好，未来很难做修改。但是3-5台服务器基本能够满足器上，都可以获得不同的ID。但是步长和初始值一定需要事先需要了。使用Redis集群也可以方式单点故障的问题。</p><p>另外，比较适合使用Redis来生成每天从0开始的流水号。比如订单号=日期+当日自增长号。可以每天在Redis中生成一个Key，使用INCR进行累加。</p></blockquote><h5 id="优点：-3"><a href="#优点：-3" class="headerlink" title="优点："></a>优点：</h5><blockquote><p>1）不依赖于数据库，灵活方便，且性能优于数据库。<br>2）数字ID天然排序，对分页或者需要排序的结果很有帮助。</p></blockquote><h5 id="缺点：-3"><a href="#缺点：-3" class="headerlink" title="缺点："></a>缺点：</h5><blockquote><p>1）如果系统中没有Redis，还需要引入新的组件，增加系统复杂度。<br>2）需要编码和配置的工作量比较大。</p></blockquote><h4 id="5、Twitter的snowflake算法"><a href="#5、Twitter的snowflake算法" class="headerlink" title="5、Twitter的snowflake算法"></a>5、Twitter的snowflake算法</h4><blockquote><p>snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。雪花算法将生成不高于19位的有序Long型整数，多用于分布式环境的数据主键。</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/17/fen-bu-shi-quan-ju-id-sheng-cheng-fang-an/001.png" alt></p><blockquote><p>雪花算法解析 结构 snowflake的结构如下(每部分用-分开):<br>0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000<br>第一位为未使用，接下来的41位为毫秒级时间(41位的长度可以使用69年)，</p><p>然后是5位datacenterId和5位workerId(10位的长度最多支持部署1024个节点） ，</p><p>最后12位是毫秒内的计数（12位的计数顺序号支持每个节点每毫秒产生4096个ID序号）</p><p>一共加起来刚好64位，为一个Long型。(转换成字符串长度为18)。</p><p>Snowflake算法核心把时间戳，工作机器id，序列号组合在一起。</p><p>整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞（由datacenter和机器ID作区分），</p><p>并且效率较高，经测试，snowflake每秒能够产生26万ID左右，完全满足需要。</p><p>其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是0。</p></blockquote><h5 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h5><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>springboot<span class="token punctuation">.</span>snowflake<span class="token punctuation">.</span>globalid<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019-09-05 * @Time: 22:34 * @Vsersion: 1.0 * 描述: Twitter的分布式自增ID雪花算法snowflake (Java版) **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SnowFlake</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 起始的时间戳     */</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">long</span> START_STMP <span class="token operator">=</span> 1480166465631L<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 每一部分占用的位数     */</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">long</span> SEQUENCE_BIT <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//序列号占用的位数</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">long</span> MACHINE_BIT <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//机器标识占用的位数</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">long</span> DATACENTER_BIT <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//数据中心占用的位数</span>    <span class="token comment" spellcheck="true">/**     * 每一部分的最大值     */</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">long</span> MAX_DATACENTER_NUM <span class="token operator">=</span> <span class="token operator">-</span>1L <span class="token operator">^</span> <span class="token punctuation">(</span><span class="token operator">-</span>1L <span class="token operator">&lt;&lt;</span> DATACENTER_BIT<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">long</span> MAX_MACHINE_NUM <span class="token operator">=</span> <span class="token operator">-</span>1L <span class="token operator">^</span> <span class="token punctuation">(</span><span class="token operator">-</span>1L <span class="token operator">&lt;&lt;</span> MACHINE_BIT<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">long</span> MAX_SEQUENCE <span class="token operator">=</span> <span class="token operator">-</span>1L <span class="token operator">^</span> <span class="token punctuation">(</span><span class="token operator">-</span>1L <span class="token operator">&lt;&lt;</span> SEQUENCE_BIT<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 每一部分向左的位移     */</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">long</span> MACHINE_LEFT <span class="token operator">=</span> SEQUENCE_BIT<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">long</span> DATACENTER_LEFT <span class="token operator">=</span> SEQUENCE_BIT <span class="token operator">+</span> MACHINE_BIT<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">long</span> TIMESTMP_LEFT <span class="token operator">=</span> DATACENTER_LEFT <span class="token operator">+</span> DATACENTER_BIT<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">long</span> datacenterId<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//数据中心</span>    <span class="token keyword">private</span> <span class="token keyword">long</span> machineId<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//机器标识</span>    <span class="token keyword">private</span> <span class="token keyword">long</span> sequence <span class="token operator">=</span> 0L<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//序列号</span>    <span class="token keyword">private</span> <span class="token keyword">long</span> lastStmp <span class="token operator">=</span> <span class="token operator">-</span>1L<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//上一次时间戳</span>    <span class="token keyword">public</span> <span class="token function">SnowFlake</span><span class="token punctuation">(</span><span class="token keyword">long</span> datacenterId<span class="token punctuation">,</span> <span class="token keyword">long</span> machineId<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>datacenterId <span class="token operator">></span> MAX_DATACENTER_NUM <span class="token operator">||</span> datacenterId <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"datacenterId can't be greater than MAX_DATACENTER_NUM or less than 0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>machineId <span class="token operator">></span> MAX_MACHINE_NUM <span class="token operator">||</span> machineId <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"machineId can't be greater than MAX_MACHINE_NUM or less than 0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>datacenterId <span class="token operator">=</span> datacenterId<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>machineId <span class="token operator">=</span> machineId<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 产生下一个ID     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">long</span> <span class="token function">nextId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">long</span> currStmp <span class="token operator">=</span> <span class="token function">getNewstmp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>currStmp <span class="token operator">&lt;</span> lastStmp<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"Clock moved backwards.  Refusing to generate id"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>currStmp <span class="token operator">==</span> lastStmp<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//相同毫秒内，序列号自增</span>            sequence <span class="token operator">=</span> <span class="token punctuation">(</span>sequence <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> MAX_SEQUENCE<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//同一毫秒的序列数已经达到最大</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>sequence <span class="token operator">==</span> 0L<span class="token punctuation">)</span> <span class="token punctuation">{</span>                currStmp <span class="token operator">=</span> <span class="token function">getNextMill</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//不同毫秒内，序列号置为0</span>            sequence <span class="token operator">=</span> 0L<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        lastStmp <span class="token operator">=</span> currStmp<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>currStmp <span class="token operator">-</span> START_STMP<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> TIMESTMP_LEFT <span class="token comment" spellcheck="true">//时间戳部分</span>                <span class="token operator">|</span> datacenterId <span class="token operator">&lt;&lt;</span> DATACENTER_LEFT       <span class="token comment" spellcheck="true">//数据中心部分</span>                <span class="token operator">|</span> machineId <span class="token operator">&lt;&lt;</span> MACHINE_LEFT             <span class="token comment" spellcheck="true">//机器标识部分</span>                <span class="token operator">|</span> sequence<span class="token punctuation">;</span>                             <span class="token comment" spellcheck="true">//序列号部分</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">long</span> <span class="token function">getNextMill</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">long</span> mill <span class="token operator">=</span> <span class="token function">getNewstmp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>mill <span class="token operator">&lt;=</span> lastStmp<span class="token punctuation">)</span> <span class="token punctuation">{</span>            mill <span class="token operator">=</span> <span class="token function">getNewstmp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> mill<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">long</span> <span class="token function">getNewstmp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SnowFlake snowFlake <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SnowFlake</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> start <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>snowFlake<span class="token punctuation">.</span><span class="token function">nextId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式id </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式锁</title>
      <link href="/2019/07/16/fen-bu-shi-suo/"/>
      <url>/2019/07/16/fen-bu-shi-suo/</url>
      
        <content type="html"><![CDATA[<h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><p>[TOC]</p><h3 id="一、什么是锁？"><a href="#一、什么是锁？" class="headerlink" title="一、什么是锁？"></a>一、什么是锁？</h3><blockquote><ul><li>在单进程的系统中，当存在多个线程可以同时改变某个变量（可变共享变量）时，就需要对变量或代码块做同步，使其在修改这种变量时能够线性执行消除并发修改变量。</li><li>而同步的本质是通过锁来实现的。为了实现多个线程在一个时刻同一个代码块只能有一个线程可执行，那么需要在某个地方做个标记，这个标记必须每个线程都能看到，当标记不存在时可以设置该标记，其余后续线程发现已经有标记了则等待拥有标记的线程结束同步代码块取消标记后再去尝试设置标记。这个标记可以理解为锁。</li><li>不同地方实现锁的方式也不一样，只要能满足所有线程都能看得到标记即可。如 Java 中 synchronize 是在对象头设置标记，Lock 接口的实现类基本上都只是某一个 volitile 修饰的 int 型变量其保证每个线程都能拥有对该 int 的可见性和原子修改，linux 内核中也是利用互斥量或信号量等内存数据做标记。</li><li>除了利用内存数据做锁其实任何互斥的都能做锁（只考虑互斥情况），如流水表中流水号与时间结合做幂等校验可以看作是一个不会释放的锁，或者使用某个文件是否存在作为锁等。只需要满足在对标记进行修改能保证原子性和内存可见性即可。</li></ul></blockquote><h3 id="二、什么是分布式？"><a href="#二、什么是分布式？" class="headerlink" title="二、什么是分布式？"></a>二、什么是分布式？</h3><blockquote><p>分布式的 CAP 理论告诉我们:</p></blockquote><blockquote><p>任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance），最多只能同时满足两项。</p><p>目前很多大型网站及应用都是分布式部署的，分布式场景中的数据一致性问题一直是一个比较重要的话题。基于 CAP理论，很多系统在设计之初就要对这三者做出取舍。在互联网领域的绝大多数的场景中，都需要牺牲强一致性来换取系统的高可用性，系统往往只需要保证最终一致性。</p><p>分布式场景</p><p><strong>此处主要指集群模式下，多个相同服务同时开启.</strong></p></blockquote><blockquote><p>在许多的场景中，我们为了保证数据的最终一致性，需要很多的技术方案来支持，比如<code>分布式事务</code>、<code>分布式锁</code>等。很多时候我们需要保证一个方法在同一时间内只能被同一个线程执行。在单机环境中，通过 Java 提供的并发 API 我们可以解决，但是在分布式环境下，就没有那么简单啦。</p><ul><li>分布式与单机情况下最大的不同在于其不是多线程而是<code>多进程</code>。</li><li>多线程由于可以共享堆内存，因此可以简单的采取内存作为标记存储位置。而进程之间甚至可能都不在同一台物理机上，因此需要将标记存储在一个所有进程都能看到的地方。</li></ul></blockquote><h3 id="三、什么是分布式锁？"><a href="#三、什么是分布式锁？" class="headerlink" title="三、什么是分布式锁？"></a>三、什么是分布式锁？</h3><blockquote><ul><li>当在分布式模型下，数据只有一份（或有限制），此时需要利用锁的技术控制某一时刻修改数据的进程数。</li><li>与单机模式下的锁不仅需要保证进程可见，还需要考虑进程与锁之间的网络问题。（我觉得分布式情况下之所以问题变得复杂，主要就是需要考虑到网络的延时和不可靠。。。一个大坑）</li><li>分布式锁还是可以将标记存在内存，只是该内存不是某个进程分配的内存而是公共内存如 Redis、Memcache。至于利用数据库、文件等做锁与单机的实现是一样的，只要保证标记能互斥就行。</li></ul></blockquote><h3 id="四、我们需要怎样的分布式锁？"><a href="#四、我们需要怎样的分布式锁？" class="headerlink" title="四、我们需要怎样的分布式锁？"></a>四、我们需要怎样的分布式锁？</h3><blockquote><ul><li>可以保证在分布式部署的应用集群中，同一个方法在同一时间只能被一台机器-上的一个线程执行。</li><li>这把锁要是一把可重入锁（避免死锁）</li><li>这把锁最好是一把阻塞锁（根据业务需求考虑要不要这条）</li><li>这把锁最好是一把公平锁（根据业务需求考虑要不要这条）</li><li>有高可用的获取锁和释放锁功能</li><li>获取锁和释放锁的性能要好</li></ul></blockquote><h3 id="五、基于数据库做分布式锁"><a href="#五、基于数据库做分布式锁" class="headerlink" title="五、基于数据库做分布式锁"></a>五、基于数据库做分布式锁</h3><h4 id="基于乐观锁"><a href="#基于乐观锁" class="headerlink" title="基于乐观锁"></a>基于乐观锁</h4><h6 id="基于表主键唯一做分布式锁"><a href="#基于表主键唯一做分布式锁" class="headerlink" title="基于表主键唯一做分布式锁"></a>基于表主键唯一做分布式锁</h6><blockquote><p><strong>思路：</strong>利用主键唯一的特性，如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功，那么我们就可以认为操作成功的那个线程获得了该方法的锁，当方法执行完毕之后，想要释放锁的话，删除这条数据库记录即可。</p><p>上面这种简单的实现有以下几个问题：</p><ul><li>这把锁强依赖数据库的可用性，数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。</li><li>这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。</li><li>这把锁只能是非阻塞的，因为数据的 insert操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。</li><li>这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。</li><li>这把锁是非公平锁，所有等待锁的线程凭运气去争夺锁。</li><li>在 MySQL 数据库中采用主键冲突防重，在大并发情况下有可能会造成锁表现象。</li></ul><h5 id="当然，我们也可以有其他方式解决上面的问题。"><a href="#当然，我们也可以有其他方式解决上面的问题。" class="headerlink" title="当然，我们也可以有其他方式解决上面的问题。"></a>当然，我们也可以有其他方式解决上面的问题。</h5><ul><li>数据库是单点？搞两个数据库，数据之前双向同步，一旦挂掉快速切换到备库上。</li><li>没有失效时间？只要做一个定时任务，每隔一定时间把数据库中的超时数据清理一遍。</li><li>非阻塞的？搞一个 while 循环，直到 insert 成功再返回成功。</li><li>非重入的？在数据库表中加个字段，记录当前获得锁的机器的主机信息和线程信息，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了。</li><li>非公平的？再建一张中间表，将等待锁的线程全记录下来，并根据创建时间排序，只有最先创建的允许获取锁。</li><li>比较好的办法是在程序中生产主键进行防重。</li></ul></blockquote><h4 id="基于表字段版本号做分布式锁"><a href="#基于表字段版本号做分布式锁" class="headerlink" title="基于表字段版本号做分布式锁"></a>基于表字段版本号做分布式锁</h4><blockquote><p>这个策略源于 mysql 的 mvcc 机制，使用这个策略其实本身没有什么问题，唯一的问题就是对数据表侵入较大，我们要为每个表设计一个版本号字段，然后写一条判断 sql 每次进行判断，增加了数据库操作的次数，在高并发的要求下，对数据库连接的开销也是无法忍受的。</p><p>基于悲观锁</p></blockquote><h4 id="基于数据库排他锁做分布式锁"><a href="#基于数据库排他锁做分布式锁" class="headerlink" title="基于数据库排他锁做分布式锁"></a>基于数据库排他锁做分布式锁</h4><blockquote><p>在查询语句后面增加<code>for update</code>，数据库会在查询过程中给数据库表增加排他锁 (注意： InnoDB 引擎在加锁的时候，只有通过索引进行检索的时候才会使用行级锁，否则会使用表级锁。这里我们希望使用行级锁，就要给要执行的方法字段名添加索引，值得注意的是，这个索引一定要创建成唯一索引，否则会出现多个重载方法之间无法同时被访问的问题。重载方法的话建议把参数类型也加上。)。当某条记录被加上排他锁之后，其他线程无法再在该行记录上增加排他锁。</p><p>我们可以认为获得排他锁的线程即可获得分布式锁，当获取到锁之后，可以执行方法的业务逻辑，执行完方法之后，通过<code>connection.commit()</code>操作来释放锁。</p><p>这种方法可以有效的解决上面提到的无法释放锁和阻塞锁的问题。</p><ul><li>阻塞锁？ <code>for update</code>语句会在执行成功后立即返回，在执行失败时一直处于阻塞状态，直到成功。</li><li>锁定之后服务宕机，无法释放？使用这种方式，服务宕机之后数据库会自己把锁释放掉。</li></ul><p>但是还是无法直接解决数据库单点和可重入问题。</p><p>这里还可能存在另外一个问题，虽然我们对方法字段名使用了唯一索引，并且显示使用 for update 来使用行级锁。但是，MySQL 会对查询进行优化，即便在条件中使用了索引字段，但是否使用索引来检索数据是由 MySQL 通过判断不同执行计划的代价来决定的，如果 MySQL 认为全表扫效率更高，比如对一些很小的表，它就不会使用索引，这种情况下 InnoDB 将使用表锁，而不是行锁。如果发生这种情况就悲剧了。。。</p><p>还有一个问题，就是我们要使用排他锁来进行分布式锁的 lock，那么一个排他锁长时间不提交，就会占用数据库连接。一旦类似的连接变得多了，就可能把数据库连接池撑爆。</p></blockquote><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><blockquote><p><strong>优点</strong>：简单，易于理解</p><p><strong>缺点</strong>：会有各种各样的问题（操作数据库需要一定的开销，使用数据库的行级锁并不一定靠谱，性能不靠谱）</p></blockquote><h3 id="基于-Redis-做分布式锁"><a href="#基于-Redis-做分布式锁" class="headerlink" title="基于 Redis 做分布式锁"></a>基于 Redis 做分布式锁</h3><blockquote><p>基于 REDIS 的 SETNX()、EXPIRE() 方法做分布式锁</p></blockquote><blockquote><p>目前几乎很多大型网站及应用都是分布式部署的，分布式场景中的数据一致性问题一直是一个比较重要的话题。分布式的CAP理论告诉我们“任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance），最多只能同时满足两项。”所以，很多系统在设计之初就要对这三者做出取舍。在互联网领域的绝大多数的场景中，都需要牺牲强一致性来换取系统的高可用性，系统往往只需要保证“最终一致性”，只要这个最终时间是在用户可以接受的范围内即可。</p><p>在很多场景中，我们为了保证数据的最终一致性，需要很多的技术方案来支持，比如分布式事务、分布式锁等。</p></blockquote><h4 id="1-选用Redis实现分布式锁原因"><a href="#1-选用Redis实现分布式锁原因" class="headerlink" title="1.选用Redis实现分布式锁原因"></a>1.选用Redis实现分布式锁原因</h4><blockquote><p>Redis有很高的性能</p><p>Redis命令对此支持较好，实现起来比较方便</p></blockquote><h4 id="2-Redis常用命令"><a href="#2-Redis常用命令" class="headerlink" title="2.Redis常用命令"></a>2.Redis常用命令</h4><blockquote><p>SETNX key val</p><p>setnx 的含义就是 SET if Not Exists，其主要有两个参数 setnx(key, value)。该方法是原子的，如果 key 不存在，则设置当前 key 成功，返回 1；如果当前 key 已经存在，则设置当前 key 失败，返回 0。</p></blockquote><blockquote><p>expire()</p><p>expire key timeout<br>为key设置一个超时时间，单位为second，超过这个时间锁会自动释放，避免死锁。</p></blockquote><blockquote><p>delete<br>delete key<br>删除key</p></blockquote><h4 id="3-实现"><a href="#3-实现" class="headerlink" title="3.实现"></a>3.实现</h4><blockquote><p>使用的是jedis来连接Redis。</p></blockquote><h4 id="4-实现思想"><a href="#4-实现思想" class="headerlink" title="4.实现思想"></a>4.实现思想</h4><blockquote><p>获取锁的时候，使用setnx加锁，并使用expire命令为锁添加一个超时时间，超过该时间则自动释放锁，锁的value值为一个随机生成的UUID，通过此在释放锁的时候进行判断。</p><p>获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。</p><p>释放锁的时候，通过UUID判断是不是该锁，若是该锁，则执行delete进行锁释放。</p></blockquote><h4 id="5-使用步骤"><a href="#5-使用步骤" class="headerlink" title="5.使用步骤"></a>5.使用步骤</h4><blockquote><p>1、setnx(lockkey, 1) 如果返回 0，则说明占位失败；如果返回 1，则说明占位成功</p><p>2、expire() 命令对 lockkey 设置超时时间，为的是避免死锁问题。</p><p>3、执行完业务代码后，可以通过 delete 命令删除 key。</p><p>这个方案其实是可以解决日常工作中的需求的，但从技术方案的探讨上来说，可能还有一些可以完善的地方。</p><p>比如，如果在第一步 setnx 执行成功后，在 expire() 命令执行成功前，发生了宕机的现象，那么就依然会出现死锁的问题，所以如果要对其进行完善的话，可以使用 redis 的 setnx()、get() 和 getset() 方法来实现分布式锁。</p></blockquote><h3 id="基于-REDIS-的-SETNX-、GET-、GETSET-方法做分布式锁"><a href="#基于-REDIS-的-SETNX-、GET-、GETSET-方法做分布式锁" class="headerlink" title="基于 REDIS 的 SETNX()、GET()、GETSET()方法做分布式锁"></a>基于 REDIS 的 SETNX()、GET()、GETSET()方法做分布式锁</h3><blockquote><p>这个方案的背景主要是在 setnx() 和 expire() 的方案上针对可能存在的死锁问题，做了一些优化。</p></blockquote><h5 id="getset"><a href="#getset" class="headerlink" title="getset()"></a>getset()</h5><blockquote><p>这个命令主要有两个参数 getset(key，newValue)。该方法是原子的，对 key 设置 newValue 这个值，并且返回 key 原来的旧值。假设 key 原来是不存在的，那么多次执行这个命令，会出现下边的效果：</p><ul><li>getset(key, “value1”) 返回 null 此时 key 的值会被设置为 value1</li><li>getset(key, “value2”) 返回 value1 此时 key 的值会被设置为 value2</li><li>依次类推！</li></ul></blockquote><h4 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤:"></a>使用步骤:</h4><blockquote><ul><li>setnx(lockkey, 当前时间+过期超时时间)，如果返回 1，则获取锁成功；如果返回 0 则没有获取到锁，转向 2。</li><li>get(lockkey) 获取值 oldExpireTime ，并将这个 value 值与当前的系统时间进行比较，如果小于当前系统时间，则认为这个锁已经超时，可以允许别的请求重新获取，转向 3。</li><li>计算 newExpireTime = 当前时间+过期超时时间，然后 getset(lockkey, newExpireTime) 会返回当前 lockkey 的值currentExpireTime。</li><li>判断 currentExpireTime 与 oldExpireTime 是否相等，如果相等，说明当前 getset 设置成功，获取到了锁。如果不相等，说明这个锁又被别的请求获取走了，那么当前请求可以直接返回失败，或者继续重试。</li><li>在获取到锁之后，当前线程可以开始自己的业务处理，当处理完毕后，比较自己的处理时间和对于锁设置的超时时间，如果小于锁设置的超时时间，则直接执行 delete 释放锁；如果大于锁设置的超时时间，则不需要再锁进行处理。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud（五）</title>
      <link href="/2019/07/15/springcloud-wu/"/>
      <url>/2019/07/15/springcloud-wu/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JSONWeb令牌</title>
      <link href="/2019/07/15/jsonweb-ling-pai/"/>
      <url>/2019/07/15/jsonweb-ling-pai/</url>
      
        <content type="html"><![CDATA[<h1 id="JSON-Web令牌（JWT）"><a href="#JSON-Web令牌（JWT）" class="headerlink" title="JSON Web令牌（JWT）"></a>JSON Web令牌（JWT）</h1><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/15/jsonweb-ling-pai/001.png" alt></p><blockquote><p>JSON Web Token（JWT）是目前最流行的跨域身份验证解决方案。</p></blockquote><h4 id="1-跨域身份验证"><a href="#1-跨域身份验证" class="headerlink" title="1.跨域身份验证"></a>1.跨域身份验证</h4><blockquote><p>Internet服务无法与用户身份验证分开。一般过程如下。</p><p>1.用户向服务器发送用户名和密码。</p><p>2.验证服务器后，相关数据（如用户角色，登录时间等）将保存在当前会话中。</p><p>3.服务器向用户返回session_id，session信息都会写入到用户的Cookie。</p><p>4.用户的每个后续请求都将通过在Cookie中取出session_id传给服务器。</p><p>5.服务器收到session_id并对比之前保存的数据，确认用户的身份。</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/15/jsonweb-ling-pai/002.png" alt></p><blockquote><p>这种模式最大的问题是，没有分布式架构，无法支持横向扩展。如果使用一个服务器，该模式完全没有问题。但是，如果它是服务器群集或面向服务的跨域体系结构的话，则需要一个统一的session数据库库来保存会话数据实现共享，这样负载均衡下的每个服务器才可以正确的验证用户身份。</p><p>例如:举一个实际中常见的单点登陆的需求：站点A和站点B提供同一公司的相关服务。现在要求用户只需要登录其中一个网站，然后它就会自动登录到另一个网站。怎么做？</p><p>一种解决方案是听过持久化session数据，写入数据库或文件持久层等。收到请求后，验证服务从持久层请求数据。该解决方案的优点在于架构清晰，而缺点是架构修改比较费劲，整个服务的验证逻辑层都需要重写，工作量相对较大。而且由于依赖于持久层的数据库或者问题系统，会有单点风险，如果持久层失败，整个认证体系都会挂掉。</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/15/jsonweb-ling-pai/003.png" alt></p><blockquote><p>本文给大家介绍另外一种灵活的解决方案，通过客户端保存数据，而服务器根本不保存会话数据，每个请求都被发送回服务器。 JWT是这种解决方案的代表。</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/15/jsonweb-ling-pai/004.png" alt></p><h4 id="2-JWT的原则"><a href="#2-JWT的原则" class="headerlink" title="2. JWT的原则"></a>2. JWT的原则</h4><blockquote><p>JWT的原则是在服务器身份验证之后，将生成一个JSON对象并将其发送回用户，如下所示。</p><p>{</p><p>“UserName”: “ZongMan”,</p><p>“Role”: “Admin”,</p><p>“Expire”: “2018-08-08 20:15:56”</p><p>}</p><p>之后，当用户与服务器通信时，客户在请求中发回JSON对象。服务器仅依赖于这个JSON对象来标识用户。为了防止用户篡改数据，服务器将在生成对象时添加签名（有关详细信息，请参阅下文）。</p><p>服务器不保存任何会话数据，即服务器变为无状态，使其更容易扩展。</p></blockquote><h4 id="3-JWT的数据结构"><a href="#3-JWT的数据结构" class="headerlink" title="3. JWT的数据结构"></a>3. JWT的数据结构</h4><blockquote><p>典型的，一个JWT看起来如下图。</p><p>改对象为一个很长的字符串，字符之间通过”.”分隔符分为三个子串。注意JWT对象为一个长字串，各字串之间也没有换行符，此处为了演示需要，我们特意分行并用不同颜色表示了。每一个子串表示了一个功能块，总共有以下三个部分：</p><p>JWT的三个部分如下。JWT头、有效载荷和签名，将它们写成一行如下。</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/15/jsonweb-ling-pai/005.png" alt></p><blockquote><p>我们将在下面介绍这三个部分。</p></blockquote><h5 id="3-1-JWT头"><a href="#3-1-JWT头" class="headerlink" title="3.1 JWT头"></a>3.1 JWT头</h5><blockquote><p>JWT头部分是一个描述JWT元数据的JSON对象，通常如下所示。</p><p>{</p><p>“alg”: “HS256”,</p><p>“typ”: “JWT”</p><p>}</p><p>在上面的代码中，alg属性表示签名使用的算法，默认为HMAC SHA256（写为HS256）；typ属性表示令牌的类型，JWT令牌统一写为JWT。</p><p>最后，使用Base64 URL算法将上述JSON对象转换为字符串保存。</p></blockquote><h5 id="3-2-有效载荷"><a href="#3-2-有效载荷" class="headerlink" title="3.2 有效载荷"></a>3.2 有效载荷</h5><blockquote><p>有效载荷部分，是JWT的主体内容部分，也是一个JSON对象，包含需要传递的数据。 JWT指定七个默认字段供选择。</p><p>iss：发行人</p><p>exp：到期时间</p><p>sub：主题</p><p>aud：用户</p><p>nbf：在此之前不可用</p><p>iat：发布时间</p><p>jti：JWT ID用于标识该JWT</p><p>除以上默认字段外，我们还可以自定义私有字段，如下例：</p><p>{</p><p>“sub”: “1234567890”,</p><p>“name”: “chongchong”,</p><p>“admin”: true</p><p>}</p><p>请注意，默认情况下JWT是未加密的，任何人都可以解读其内容，因此不要构建隐私信息字段，存放保密信息，以防止信息泄露。</p><p>JSON对象也使用Base64 URL算法转换为字符串保存。</p></blockquote><h5 id="3-3签名哈希"><a href="#3-3签名哈希" class="headerlink" title="3.3签名哈希"></a>3.3签名哈希</h5><blockquote><p>签名哈希部分是对上面两部分数据签名，通过指定的算法生成哈希，以确保数据不会被篡改。</p><p>首先，需要指定一个密码（secret）。该密码仅仅为保存在服务器中，并且不能向用户公开。然后，使用标头中指定的签名算法（默认情况下为HMAC SHA256）根据以下公式生成签名。</p><p>HMACSHA256(base64UrlEncode(header) + “.” + base64UrlEncode(payload),</p><p>secret)</p><p>在计算出签名哈希后，JWT头，有效载荷和签名哈希的三个部分组合成一个字符串，每个部分用”.”分隔，就构成整个JWT对象。</p></blockquote><h5 id="3-4-Base64URL算法"><a href="#3-4-Base64URL算法" class="headerlink" title="3.4 Base64URL算法"></a>3.4 Base64URL算法</h5><blockquote><p>如前所述，JWT头和有效载荷序列化的算法都用到了Base64URL。该算法和常见Base64算法类似，稍有差别。</p><p>作为令牌的JWT可以放在URL中（例如api.example/?token=xxx）。 Base64中用的三个字符是”+”，”/“和”=”，由于在URL中有特殊含义，因此Base64URL中对他们做了替换：”=”去掉，”+”用”-“替换，”/“用”_”替换，这就是Base64URL算法，很简单把。</p></blockquote><h4 id="4-JWT的用法"><a href="#4-JWT的用法" class="headerlink" title="4.JWT的用法"></a>4.JWT的用法</h4><blockquote><p>客户端接收服务器返回的JWT，将其存储在Cookie或localStorage中。</p><p>此后，客户端将在与服务器交互中都会带JWT。如果将它存储在Cookie中，就可以自动发送，但是不会跨域，因此一般是将它放入HTTP请求的Header Authorization字段中。</p><p>Authorization: Bearer</p><p>当跨域时，也可以将JWT被放置于POST请求的数据主体中。</p></blockquote><h4 id="5-JWT问题和趋势"><a href="#5-JWT问题和趋势" class="headerlink" title="5.JWT问题和趋势"></a>5.JWT问题和趋势</h4><blockquote><p>1、JWT默认不加密，但可以加密。生成原始令牌后，可以使用改令牌再次对其进行加密。</p><p>2、当JWT未加密方法是，一些私密数据无法通过JWT传输。</p><p>3、JWT不仅可用于认证，还可用于信息交换。善用JWT有助于减少服务器请求数据库的次数。</p><p>4、JWT的最大缺点是服务器不保存会话状态，所以在使用期间不可能取消令牌或更改令牌的权限。也就是说，一旦JWT签发，在有效期内将会一直有效。</p><p>5、JWT本身包含认证信息，因此一旦信息泄露，任何人都可以获得令牌的所有权限。为了减少盗用，JWT的有效期不宜设置太长。对于某些重要操作，用户在使用时应该每次都进行进行身份验证。</p><p>6、为了减少盗用和窃取，JWT不建议使用HTTP协议来传输代码，而是使用加密的HTTPS协议进行传输。</p></blockquote><h4 id="6-JWT工具类"><a href="#6-JWT工具类" class="headerlink" title="6.JWT工具类"></a>6.JWT工具类</h4><blockquote><p>用于生成Token和Token验证</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JwtUtils</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 签发JWT     * @param id     * @param subject 可以是JSON数据 尽可能少     * @param ttlMillis     * @return  String     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">createJWT</span><span class="token punctuation">(</span>String id<span class="token punctuation">,</span> String subject<span class="token punctuation">,</span> <span class="token keyword">long</span> ttlMillis<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SignatureAlgorithm signatureAlgorithm <span class="token operator">=</span> SignatureAlgorithm<span class="token punctuation">.</span>HS256<span class="token punctuation">;</span>        <span class="token keyword">long</span> nowMillis <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Date now <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span>nowMillis<span class="token punctuation">)</span><span class="token punctuation">;</span>        SecretKey secretKey <span class="token operator">=</span> <span class="token function">generalKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        JwtBuilder builder <span class="token operator">=</span> Jwts<span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">setSubject</span><span class="token punctuation">(</span>subject<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">// 主题</span>                <span class="token punctuation">.</span><span class="token function">setIssuer</span><span class="token punctuation">(</span><span class="token string">"user"</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">// 签发者</span>                <span class="token punctuation">.</span><span class="token function">setIssuedAt</span><span class="token punctuation">(</span>now<span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">// 签发时间</span>                <span class="token punctuation">.</span><span class="token function">signWith</span><span class="token punctuation">(</span>signatureAlgorithm<span class="token punctuation">,</span> secretKey<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 签名算法以及密匙</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ttlMillis <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">long</span> expMillis <span class="token operator">=</span> nowMillis <span class="token operator">+</span> ttlMillis<span class="token punctuation">;</span>            Date expDate <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span>expMillis<span class="token punctuation">)</span><span class="token punctuation">;</span>            builder<span class="token punctuation">.</span><span class="token function">setExpiration</span><span class="token punctuation">(</span>expDate<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 过期时间</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> builder<span class="token punctuation">.</span><span class="token function">compact</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 验证JWT     * @param jwtStr     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> CheckResult <span class="token function">validateJWT</span><span class="token punctuation">(</span>String jwtStr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        CheckResult checkResult <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CheckResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Claims claims <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            claims <span class="token operator">=</span> <span class="token function">parseJWT</span><span class="token punctuation">(</span>jwtStr<span class="token punctuation">)</span><span class="token punctuation">;</span>            checkResult<span class="token punctuation">.</span><span class="token function">setSuccess</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            checkResult<span class="token punctuation">.</span><span class="token function">setClaims</span><span class="token punctuation">(</span>claims<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ExpiredJwtException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            checkResult<span class="token punctuation">.</span><span class="token function">setErrCode</span><span class="token punctuation">(</span>SystemConstant<span class="token punctuation">.</span>JWT_ERRCODE_EXPIRE<span class="token punctuation">)</span><span class="token punctuation">;</span>            checkResult<span class="token punctuation">.</span><span class="token function">setSuccess</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SignatureException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            checkResult<span class="token punctuation">.</span><span class="token function">setErrCode</span><span class="token punctuation">(</span>SystemConstant<span class="token punctuation">.</span>JWT_ERRCODE_FAIL<span class="token punctuation">)</span><span class="token punctuation">;</span>            checkResult<span class="token punctuation">.</span><span class="token function">setSuccess</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            checkResult<span class="token punctuation">.</span><span class="token function">setErrCode</span><span class="token punctuation">(</span>SystemConstant<span class="token punctuation">.</span>JWT_ERRCODE_FAIL<span class="token punctuation">)</span><span class="token punctuation">;</span>            checkResult<span class="token punctuation">.</span><span class="token function">setSuccess</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> checkResult<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> SecretKey <span class="token function">generalKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> encodedKey <span class="token operator">=</span> Base64<span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span>SystemConstant<span class="token punctuation">.</span>JWT_SECERT<span class="token punctuation">)</span><span class="token punctuation">;</span>        SecretKey key <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SecretKeySpec</span><span class="token punctuation">(</span>encodedKey<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> encodedKey<span class="token punctuation">.</span>length<span class="token punctuation">,</span> <span class="token string">"AES"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> key<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     *      * 解析JWT字符串     * @param jwt     * @return     * @throws Exception     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Claims <span class="token function">parseJWT</span><span class="token punctuation">(</span>String jwt<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        SecretKey secretKey <span class="token operator">=</span> <span class="token function">generalKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> Jwts<span class="token punctuation">.</span><span class="token function">parser</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">setSigningKey</span><span class="token punctuation">(</span>secretKey<span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">parseClaimsJws</span><span class="token punctuation">(</span>jwt<span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>如何使用？<br>代码实例：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LoginController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    UserRepository userRepository<span class="token punctuation">;</span>    <span class="token annotation punctuation">@ApiOperation</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">"用户登陆"</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">"login"</span><span class="token punctuation">,</span>method <span class="token operator">=</span> RequestMethod<span class="token punctuation">.</span>POST<span class="token punctuation">)</span>    <span class="token keyword">public</span> ReturnVo <span class="token function">login</span><span class="token punctuation">(</span>String username<span class="token punctuation">,</span> String password<span class="token punctuation">,</span>HttpServletResponse            response<span class="token punctuation">)</span> <span class="token punctuation">{</span>        User user <span class="token operator">=</span>  userRepository<span class="token punctuation">.</span><span class="token function">findByUsername</span><span class="token punctuation">(</span>username<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>user<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">getPassword</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>password<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//把token返回给客户端-->客户端保存至cookie-->客户端每次请求附带cookie参数</span>                String JWT <span class="token operator">=</span> JwtUtils<span class="token punctuation">.</span><span class="token function">createJWT</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">,</span> username<span class="token punctuation">,</span> SystemConstant<span class="token punctuation">.</span>JWT_TTL<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> ReturnVo<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span>JWT<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> ReturnVo<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> ReturnVo<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@ApiOperation</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">"获取用户信息"</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">"description"</span><span class="token punctuation">,</span>method <span class="token operator">=</span> RequestMethod<span class="token punctuation">.</span>POST<span class="token punctuation">)</span>    <span class="token keyword">public</span> ReturnVo <span class="token function">description</span><span class="token punctuation">(</span>String username<span class="token punctuation">)</span> <span class="token punctuation">{</span>        User user <span class="token operator">=</span>  userRepository<span class="token punctuation">.</span><span class="token function">findByUsername</span><span class="token punctuation">(</span>username<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ReturnVo<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 日常学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JSON WEB </tag>
            
            <tag> JWT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java源代码的执行原理</title>
      <link href="/2019/07/13/java-yuan-dai-ma-de-zhi-xing-yuan-li/"/>
      <url>/2019/07/13/java-yuan-dai-ma-de-zhi-xing-yuan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="解析java执行内幕"><a href="#解析java执行内幕" class="headerlink" title="解析java执行内幕"></a>解析java执行内幕</h1><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/13/java-yuan-dai-ma-de-zhi-xing-yuan-li/Snipaste_2019-07-16_08-02-00.png" alt></p><h4 id="一-编写java源程序"><a href="#一-编写java源程序" class="headerlink" title="一 编写java源程序"></a>一 编写java源程序</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test02</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>Test02被public修饰，故存储该java源码的文件名为Test02</p><p>一个java源文件可以包含多个类，但只允许一个类为public</p></blockquote><h4 id="二-编译java源代码"><a href="#二-编译java源代码" class="headerlink" title="二 编译java源代码"></a>二 编译java源代码</h4><blockquote><p>idea自带命令行工具切换到Test02目录下：</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/13/java-yuan-dai-ma-de-zhi-xing-yuan-li/001.png" alt></p><blockquote><p>Javac 编译Test02.java文件</p><p>Tip:当javac.exe编译java源代码时，java源代码有几个类，就会编译成一个对应的字节码文件(.class文件)，</p><p>其中，字节码文件的文件名就是每个类的类名。需要注意的是，类即使不在源文件中定义，但被源文件引用，</p><p>编译后，也会编程相应的字节码文件，如类A引用类C，但类C不定义在类A的源文件中，编译后，类C也被编</p><p>译成对应的字节码文件C.class</p></blockquote><h4 id="三-执行java源文件"><a href="#三-执行java源文件" class="headerlink" title="三 执行java源文件"></a>三 执行java源文件</h4><blockquote><p>执行步骤：</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/13/java-yuan-dai-ma-de-zhi-xing-yuan-li/003.png" alt></p><blockquote><p>如上总结，已经抽象化了在JVM中的执行，接下来，我们将分析，字节码文件（.calss文件）如何在虚拟机中一步一执行的。</p></blockquote><h4 id="四-JVM如何执行字节码文件"><a href="#四-JVM如何执行字节码文件" class="headerlink" title="四 JVM如何执行字节码文件"></a>四 JVM如何执行字节码文件</h4><h5 id="（一）-装载字节码文件"><a href="#（一）-装载字节码文件" class="headerlink" title="（一） 装载字节码文件"></a><strong>（一） 装载字节码文件</strong></h5><blockquote><p>当.java源码被javac.exe编译器编译成.class字节码文件后，接下来的工作就交给JVM处理，JVM首先通过类加载器(ClassLoader)</p><p>将class文件和相关Java API加载装入JVM，以供JVM后续处理。</p><p>在该阶段中，涉及到如下一些基本概念和知识。</p></blockquote><h6 id="1-JDK-JRE和JVM关系"><a href="#1-JDK-JRE和JVM关系" class="headerlink" title="1.JDK,JRE和JVM关系"></a>1.JDK,JRE和JVM关系</h6><blockquote><p>（1）JDK（Java Development Kit），Java开发工具包，主要用于开发，在JDK7前，JDK包括JRE</p><p>（2）JRE（Java Runtime Environment），Java程序运行的核心环境，包括JVM和一些核心库</p><p>（3）JVM（Java Virtual Machine），VM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟</p><p>各种计算机功能来实现的，是JRE核心模块。</p></blockquote><h6 id="2-JVM"><a href="#2-JVM" class="headerlink" title="2.JVM"></a>2.JVM</h6><blockquote><p>JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。Java虚拟机</p><p>虚拟机的主要任务是装载class文件并执行其中的字节码，不同的Java虚拟机中，执行引擎可能由不同的实现，大致有如下几种引擎：</p><ul><li>一次性解释字节码引擎</li><li>即时编译引擎</li><li>自适应优化器</li></ul><p>关于虚拟机的实现方式，采用软件方式、硬件方式和软件硬件结合方式，这个要根据具体厂商而定。</p></blockquote><h6 id="3-什么是ClassLoader"><a href="#3-什么是ClassLoader" class="headerlink" title="3.什么是ClassLoader"></a>3.什么是ClassLoader</h6><blockquote><p>虚拟机的主要任务是装载class文件并执行其中的字节码，而class文件是由虚拟机的类加载器(ClassLoader)完成的，在一个Java虚拟机，有可能存在多个类加载器。</p><p>任何java运用程序，可能会使用两种类加载器，即启动类加载器(bootstrap)和用户自定义类加载器。</p><p>启动类加载器是Java虚拟机唯一实现的一部分，它又可分为原始类装载器，系统类装载器或默认类装载器，它的主要作用是从操作系统的</p><p>磁盘装载相应的类，如Java API类等。</p><p>用户自定义装载类，按照用户自定义的方式来装载类。</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/13/java-yuan-dai-ma-de-zhi-xing-yuan-li/004.png" alt></p><h5 id="（二）将字节码文件存储在JVM内存区"><a href="#（二）将字节码文件存储在JVM内存区" class="headerlink" title="（二）将字节码文件存储在JVM内存区"></a><strong>（二）将字节码文件存储在JVM内存区</strong></h5><blockquote><p>当JAVA虚拟机运行一个程序时，它需要内存来存储许多东西，如字节码，从已装载的class文件中得到的其他信息，程序创建的对象，传递给</p><p>方法的参数，返回值，局部变量以及运算的中间结果等，这些相关信息被组织到“运行时数据区”。</p><p>根据厂商的不同，在Java虚拟机中，运行时数据区也有所不同，有些运行时数据区由线程共享，有些只能由某个特定线程共享。运行时数据区</p><p>大致可分几个区：方法区，堆区，栈区，PC寄存器区和本地方法栈区。</p><p>在该阶段中，涉及到如下基本概念和知识。</p></blockquote><h6 id="1-方法区"><a href="#1-方法区" class="headerlink" title="1.方法区"></a>1.方法区</h6><blockquote><p>方法区用来存储解析被加载的class文件的相关信息。当虚拟装载一个class文件后，它会从这个class文件包含的二进制数据中解析类型信息，然后将该相关信息存储到方法区中。</p></blockquote><h6 id="2-堆"><a href="#2-堆" class="headerlink" title="2.堆"></a>2.堆</h6><blockquote><p>堆是用来存储相关引用类型的，如new对象。当程序运行时，虚拟机会把所有该程序在运行时创建的对象都放到堆中。</p></blockquote><h6 id="3-PC寄存器"><a href="#3-PC寄存器" class="headerlink" title="3.PC寄存器"></a>3.PC寄存器</h6><blockquote><p>PC寄存器主要用来存储线程。当新创建一个线程时，该线程都将得到一个自己的PC寄存器(程序计数器)以及一个java栈。</p><p>Java虚拟机没有寄存器，其指令集使用Java栈来存储中间数据。</p></blockquote><h6 id="4-栈区"><a href="#4-栈区" class="headerlink" title="4.栈区"></a>4.栈区</h6><blockquote><p>栈区主要用来存储值类型的，如基本数据类型，需要注意的时，String为引用类型，是存在堆中的。Java栈是由许多栈帧组成的，一个栈帧包含一个Java方法调用的状态，当线程调用一个方法时，虚拟机压入一个新的栈帧到该线程的Java栈中，当该方法返回时，这个栈帧从Java栈中弹出。</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/13/java-yuan-dai-ma-de-zhi-xing-yuan-li/005.png" alt></p><h5 id="（三）执行引擎与运行时数据区交互"><a href="#（三）执行引擎与运行时数据区交互" class="headerlink" title="（三）执行引擎与运行时数据区交互"></a><strong>（三）执行引擎与运行时数据区交互</strong></h5><blockquote><p>运行时数据区为执行引擎提供了执行环境和相关数据，执行引擎通过与运行时数据区交互，从而获取</p><p>执行时需要的相关信息，存储执行的中间结果等</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/13/java-yuan-dai-ma-de-zhi-xing-yuan-li/006.png" alt></p><h5 id="（四）执行引擎与本地方法接口"><a href="#（四）执行引擎与本地方法接口" class="headerlink" title="（四）执行引擎与本地方法接口"></a><strong>（四）执行引擎与本地方法接口</strong></h5><blockquote><p>当要执行本地方法时，执行引擎将调用本地方法接口来获取相关OS本地方法，需要注意的是，本地方法与操作系统强耦合的。</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/13/java-yuan-dai-ma-de-zhi-xing-yuan-li/007.png" alt></p><h5 id="（五）JVM在具体操作系统上执行"><a href="#（五）JVM在具体操作系统上执行" class="headerlink" title="（五）JVM在具体操作系统上执行"></a><strong>（五）JVM在具体操作系统上执行</strong></h5><blockquote><p>JVM通过调用本地接口来获取本地方法，从而实现在具体的平台上执行，如在Linux系统上执行，在Window系统上执行和在Unix系统上执行。</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/13/java-yuan-dai-ma-de-zhi-xing-yuan-li/008.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 日常学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java底层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL索引为什么要用B+树实现</title>
      <link href="/2019/07/12/mysql-suo-yin-wei-shi-me-yao-yong-b-shu-shi-xian/"/>
      <url>/2019/07/12/mysql-suo-yin-wei-shi-me-yao-yong-b-shu-shi-xian/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL索引为什么要用B-树实现"><a href="#MySQL索引为什么要用B-树实现" class="headerlink" title="MySQL索引为什么要用B+树实现"></a>MySQL索引为什么要用B+树实现</h1><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><blockquote><p>在从一堆数据中查找指定的数据时，我们常用的数据结构是哈希表和二叉查找树，表本质上就是一堆数据的集合，所以MySQL数据库用了B+树和哈希表来实现索引</p><p>B+树是通过二叉查找树，再由平衡二叉树，B树（又名B-树）演化而来的，B+树中的B不是代表二叉（binary），而是代表平衡（balance），因为B+树是从最早的平衡二叉树演化而来，但是B+树不是一个二叉树</p></blockquote><h3 id="二、二叉查找树和平衡二叉树"><a href="#二、二叉查找树和平衡二叉树" class="headerlink" title="二、二叉查找树和平衡二叉树"></a>二、二叉查找树和平衡二叉树</h3><blockquote><p>二叉查找树的效率和平衡二叉树的查找效率已经很高了，为什么不用这两种数据结构来实现索引呢？慢慢来分析</p><p>二叉查找树是带有特殊属性的二叉树，需要满足以下属性</p><ol><li>非叶子节点最多拥有两个子节点</li><li>非叶子节值大于左边子节点、小于右边子节点</li><li>没有值相等重复的节点;</li></ol></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/12/mysql-suo-yin-wei-shi-me-yao-yong-b-shu-shi-xian/001.png" alt></p><blockquote><p>对上图这个二叉树进行查找，如查键值为5的记录，先找到根，其值时6，大于5，查找6的左子树，找到3，5大于3，再找其右子树，一共找了3次。同理，查找键值为8的记录，用了3次。所有键值平均查找次数为(1+2+2+3+3+3)/6=2.3次，假如对这些键值进行顺序查找，平均查找次数为(1+2+3+4+5+6)/6=3.3（查找顺序摆放的数，第一个数肯定是1次，而第2个数是2次，以此类推），显然二叉查找树的平均查找速度比顺序查找更快</p><p>二叉查找树可以任意的构造，假如二叉查找树按照如下方式构造</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/12/mysql-suo-yin-wei-shi-me-yao-yong-b-shu-shi-xian/002.png" alt></p><blockquote><p>平均查找速度为(1+2+3+4+5+5)/6=3.16次，和顺序查找差不多。为了提高二叉查找树的查询效率，需要二叉查找数是平衡的，这就引出了平衡二叉树。</p><p>平衡二叉树除了满足上面3个属性，还要满足如下1个属性</p><ol><li>树的左右两边的层级数相差不会大于1</li></ol><p>平衡二叉树的查找效率确实很快，但维护一颗平衡二叉树的代价是非常大的，需要1次或多次左旋和右旋来得到插入或更新后树的平衡性。简单举个例子。</p><p>初始平衡二叉树</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/12/mysql-suo-yin-wei-shi-me-yao-yong-b-shu-shi-xian/003.png" alt></p><blockquote><p>插入3</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/12/mysql-suo-yin-wei-shi-me-yao-yong-b-shu-shi-xian/004.png" alt></p><blockquote><p>右旋一次</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/12/mysql-suo-yin-wei-shi-me-yao-yong-b-shu-shi-xian/005.png" alt></p><blockquote><p>再左旋一次</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/12/mysql-suo-yin-wei-shi-me-yao-yong-b-shu-shi-xian/006.png" alt></p><blockquote><p>作为一个科普性的文章，这里不对左旋的右旋的细节进行分析，放几个图片能理解左旋和右旋即可</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/12/mysql-suo-yin-wei-shi-me-yao-yong-b-shu-shi-xian/3b0f670f16c8413e8cfa0011fe85c98f.gif" alt></p><blockquote><p>对x进行左旋，意味着将x变为一个左结点</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/12/mysql-suo-yin-wei-shi-me-yao-yong-b-shu-shi-xian/007.png" alt></p><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/12/mysql-suo-yin-wei-shi-me-yao-yong-b-shu-shi-xian/008.gif" alt></p><blockquote><p>对y进行右旋，意味着将y变为一个右节点</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/12/mysql-suo-yin-wei-shi-me-yao-yong-b-shu-shi-xian/009.png" alt></p><blockquote><p>回头看上面例子的左旋和右旋，是不是很清楚了？</p></blockquote><h3 id="B树和B-树"><a href="#B树和B-树" class="headerlink" title="B树和B+树"></a>B树和B+树</h3><blockquote><p>B树和B-树是同一种树，假如用平衡二叉树实现索引，效率已经很高了，查找一个节点所做的IO次数是这个节点所处的树的高度，因为我们无法把整个索引都加载到内存，并且节点数据在磁盘中不是顺序排放的。所以最坏情况下，磁盘的IO次数为树的高度。</p><p>虽然平衡二叉树查找效率确实很高，但是频繁的IO才是阻碍提高性能的瓶颈，怎样减少IO次数呢？前辈们很聪明的提出了局部性原理，分为时间局部性原理，即假如你查询id为1的用户数据，过一段时间你还会查询id为1的数据，所以会将这部分数据缓存下来。空间局部性原理，当你查询id为1的用户数据的时候，你有很大的概率会去查询id为2，3，4的用户的数据，所以会一次性的把id为1，2，3，4的数据都读到内存中去，这个最小的单位就是页。</p><p>B树和B+树的概念比较复杂，有兴趣的小伙伴可以点原文链接看看知乎上写的一篇文章，这里只做一个宏观的介绍，前文已经提到树高决定着IO的次数，那么降低树高不就能减少IO的次数吗，怎么减少呢，每个节点的数据多放一点不就行了，并且这个数据是存放在一块的，对应的是数据库中的读取的最小单位页，一次IO就可以将这些数据读取出来，虽然比较的次数有可能会增加，但是在内存中的比较和磁盘IO相比差几个数量级，整体上效率还是提高了。</p><p>所以你看到的B树是这样的</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/12/mysql-suo-yin-wei-shi-me-yao-yong-b-shu-shi-xian/010.png" alt></p><blockquote><p>B+树是这样的</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/12/mysql-suo-yin-wei-shi-me-yao-yong-b-shu-shi-xian/011.png" alt></p><blockquote><p>那么B树和B+树的区别在哪呢？</p><ol><li>B+跟B树不同B+树的非叶子节点不保存键值对应的数据，这样使得B+树每个节点所能保存的键值大大增加；</li><li>B+树叶子节点保存了父节点的所有键值和键值对应的数据，每个叶子节点的键值从小到大链接；</li><li>B+树的根节点键值数量和其子节点个数相等;</li><li>B+的非叶子节点只进行数据索引，不会存实际的键值对应的数据，所有数据必须要到叶子节点才能获取到，所以每次数据查询的次数都一样；</li></ol><p>放个图理解的更清楚一点，B树</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/12/mysql-suo-yin-wei-shi-me-yao-yong-b-shu-shi-xian/012.png" alt></p><blockquote><p>B+树</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/12/mysql-suo-yin-wei-shi-me-yao-yong-b-shu-shi-xian/013.png" alt></p><blockquote><p>在B+树的基础上每个节点存储的关键字数更多，树的层级更少所以查询数据更快，所有关键字数据都存在叶子节点，所以每次查找的次数都相同，查询速度比B树更稳定。除此之外，B+树的叶子节点是跟后序节点相连接的，这对范围查找是非常有用的。</p></blockquote><h3 id="聚集索引和联合索引"><a href="#聚集索引和联合索引" class="headerlink" title="聚集索引和联合索引"></a>聚集索引和联合索引</h3><blockquote><p>在InnoDB存储引擎中，是以主键为索引来组织数据的。在InnoDB存储引擎中，每张表都有个主键，如果在创建表时没有显示的定义主键，则InnoDB存储引擎会按如下方式选择或创建主键。</p><ol><li>首先判断表中是否有非空的唯一索引，如果有，则该列即为主键</li><li>如果不符合上述条件，InnoDB存储引擎自动创建一个6字节大小的指针作为索引</li><li>如果有多个非空唯一索引时，InnoDB存储引擎将选择建表时第一个定义的非空唯一索引作为主键</li></ol><p>假如说有如下数据，用户id为主键（1， tom），（2，mike），（3，sam），（4，lisa），（5，li）则数据是这样存储的，图1</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/12/mysql-suo-yin-wei-shi-me-yao-yong-b-shu-shi-xian/014.png" alt></p><blockquote><p>假如说我们现在对用户名建索引，用户名索引是怎么存的呢？图2</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/12/mysql-suo-yin-wei-shi-me-yao-yong-b-shu-shi-xian/015.png" alt></p><blockquote><p>用户名索引叶子节点数据存储的是主键，所以当我们运行如下sql语句时</p></blockquote><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">table</span> <span class="token keyword">where</span> name <span class="token operator">=</span><span class="token string">"sam"</span></code></pre><blockquote><p>过程是这样的，先在name索引上找到对应的主键，在根据对应的主键去建表时建立的B+树上找到对应的记录，即先在图1上找，再到图2上找。</p><p>聚集索引：数据行的物理顺序与列值（一般是主键的那一列）的逻辑顺序相同，一个表中只能拥有一个聚集索引。图1用的就是聚集索引</p><p>非聚集索引：定义：该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同，一个表中可以拥有多个非聚集索引。图2用的就是非聚集索引</p><p>最后再说一个联合索引，联合索引是指对表上的多个列进行索引。创建方式如下：</p></blockquote><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>t<span class="token punctuation">`</span> <span class="token punctuation">(</span> <span class="token punctuation">`</span><span class="token number">a</span><span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">`</span><span class="token number">b</span><span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span><span class="token number">a</span><span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_a_b<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span><span class="token number">a</span><span class="token punctuation">`</span><span class="token punctuation">,</span><span class="token punctuation">`</span><span class="token number">b</span><span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span><span class="token punctuation">;</span></code></pre><blockquote><p>联合索引也是一颗B+树，不同的是联合索引的键值的数量不是1，而是大于等于2，多个键值的B+树是如下存的</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/12/mysql-suo-yin-wei-shi-me-yao-yong-b-shu-shi-xian/016.png" alt></p><blockquote><p>可以看到键值都是排序的，就上面的例子来说（1，1）（1，2）（2，1）（2，4）（3，1）（3，2），数据按照（a，b）的顺序进行了存放。</p><p>因此对于查询select <em> from table where a = xxx and b = xxx，显然是可以使用（a，b）这个联合索引的。对于单个的a列查询select </em> from table where a = xxx，也可以使用（a，b）这个索引。但对于b列的查询select * from table where b = xxx，则不可以使用这颗B+树索引。可以发现叶子节点上的b值为1，2，1，4，1，2，显然不是排序的，因此对于b列的查询使用不到（a，b）的索引</p></blockquote><h3 id="自适应哈希索引"><a href="#自适应哈希索引" class="headerlink" title="自适应哈希索引"></a>自适应哈希索引</h3><blockquote><p>InnoDB存储引擎会监控对表上各项索引页的查询。如果观察到建立哈希索引可以带来速度提升，则建立哈希索引，称之为自适应哈希索引，DBA不能对建立哈希索引的过程进行干预，只能启动或禁用自适应哈希索引</p><p>数据库一般采用除法散列的方法，即取k除以m的余数，将关键词k映射到m个槽的某一个去，即哈希函数为h(k) = k mod m，当发生冲突时，即两个关键字可能映射到同一个槽上，采用链接法，即以链表的形式保存冲突的关键字，和HashMap类似</p><p>当对热点数据建立了哈希索引以后，省去在B+树上进行查找，可以极大地提高服务的性能，自适应哈希索引对于字典类型的查找非常迅速，如select * from table where id = xxx，但是对于范围查找就无能无力了</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/12/mysql-suo-yin-wei-shi-me-yao-yong-b-shu-shi-xian/017.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySql，B+ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题集锦</title>
      <link href="/2019/07/11/mian-shi-ti-ji-jin/"/>
      <url>/2019/07/11/mian-shi-ti-ji-jin/</url>
      
        <content type="html"><![CDATA[<h1 id="面试必刷真题（持续更新中）"><a href="#面试必刷真题（持续更新中）" class="headerlink" title="面试必刷真题（持续更新中）"></a>面试必刷真题（持续更新中）</h1><p>[TOC]</p><h3 id="一、Java-基础"><a href="#一、Java-基础" class="headerlink" title="一、Java 基础"></a>一、Java 基础</h3><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/11/mian-shi-ti-ji-jin/001.png" alt></p><h4 id="1-JDK-和-JRE-有什么区别？"><a href="#1-JDK-和-JRE-有什么区别？" class="headerlink" title="1.JDK 和 JRE 有什么区别？"></a>1.JDK 和 JRE 有什么区别？</h4><blockquote><p>JDK是Java Development Kit，它是功能齐全的Java SDK。它拥有JRE所拥有的一切，还有编译器（javac）和工具（如javadoc和jdb）。它能够创建和编译程序。</p><p>JRE 是 Java运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java虚拟机（JVM），Java类库，java命令和其他的一些基础构件。但是，它不能用于创建新程序。</p><p>如果你只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。如果你需要进行一些 Java 编程方面的工作，那么你就需要安装JDK了。但是，这不是绝对的。有时，即使您不打算在计算机上进行任何Java开发，仍然需要安装JDK。例如，如果要使用JSP部署Web应用程序，那么从技术上讲，您只是在应用程序服务器中运行Java程序。那你为什么需要JDK呢？因为应用程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译 servlet。</p></blockquote><h4 id="2-和-equals-的区别是什么？"><a href="#2-和-equals-的区别是什么？" class="headerlink" title="2.== 和 equals 的区别是什么？"></a>2.== 和 equals 的区别是什么？</h4><blockquote><p><strong>==</strong> : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)</p><p><strong>equals()</strong> : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p><ul><li>情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。</li><li>情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。</li></ul></blockquote><blockquote><p>举个例子：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">test01</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"ab"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// a 为一个引用</span>        String b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"ab"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// b为另一个引用,对象的内容一样</span>        String aa <span class="token operator">=</span> <span class="token string">"ab"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 放在常量池中</span>        String bb <span class="token operator">=</span> <span class="token string">"ab"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 从常量池中查找</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>aa <span class="token operator">==</span> bb<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// true</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"aa==bb"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// false，非同一对象</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"a==b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// true</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"aEQb"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">42</span> <span class="token operator">==</span> <span class="token number">42.0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// true</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"true"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p><strong>说明：</strong></p><ul><li>String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。</li><li>当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。</li></ul></blockquote><h4 id="3-hashCode-相同，则-equals-也一定为-true，对吗？"><a href="#3-hashCode-相同，则-equals-也一定为-true，对吗？" class="headerlink" title="3. hashCode()相同，则 equals()也一定为 true，对吗？"></a>3. hashCode()相同，则 equals()也一定为 true，对吗？</h4><blockquote><ol><li>如果两个对象相等，则hashcode一定也是相同的</li><li>两个对象相等,对两个对象分别调用equals方法都返回true</li><li>两个对象有相同的hashcode值，它们也不一定是相等的</li><li><strong>因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</strong></li><li>hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li></ol></blockquote><h4 id="4-hashCode（）介绍"><a href="#4-hashCode（）介绍" class="headerlink" title="4.hashCode（）介绍"></a>4.hashCode（）介绍</h4><blockquote><p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数。</p><p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p></blockquote><h4 id="5-为什么要有-hashCode"><a href="#5-为什么要有-hashCode" class="headerlink" title="5.为什么要有 hashCode"></a>5.为什么要有 hashCode</h4><h5 id="我们以“HashSet-如何检查重复”为例子来说明为什么要有-hashCode："><a href="#我们以“HashSet-如何检查重复”为例子来说明为什么要有-hashCode：" class="headerlink" title="我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode："></a><strong>我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：</strong></h5><blockquote><p>当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals（）方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的Java启蒙书《Head first java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p></blockquote><h4 id="6-final-在-java-中有什么作用？"><a href="#6-final-在-java-中有什么作用？" class="headerlink" title="6.final 在 java 中有什么作用？"></a>6.final 在 java 中有什么作用？</h4><blockquote><p>final关键字主要用在三个地方：变量、方法、类。</p><ol><li>对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。</li><li>当用final修饰一个类时，表明这个类不能被继承。final类中的所有成员方法都会被隐式地指定为final方法。</li><li>使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的Java版本已经不需要使用final方法进行这些优化了）。类中所有的private方法都隐式地指定为final。</li></ol></blockquote><h4 id="7-java-中的-Math-round-1-5-等于多少？"><a href="#7-java-中的-Math-round-1-5-等于多少？" class="headerlink" title="7.java 中的 Math.round(-1.5) 等于多少？"></a>7.java 中的 Math.round(-1.5) 等于多少？</h4><blockquote><p>Math.round(1.5)的返回值是2，Math.round(-1.5)的返回值是-1。四舍五入的原理是在参数上加0.5然后做向下取整。</p></blockquote><h4 id="8-String-属于基础的数据类型吗？"><a href="#8-String-属于基础的数据类型吗？" class="headerlink" title="8.String 属于基础的数据类型吗？"></a>8.String 属于基础的数据类型吗？</h4><blockquote><p>String不是基本的数据类型，是final修饰的java类，java中的基本类型一共有8个，它们分别为：</p><p>1 字符类型：byte，char</p><p>2 基本整型：short，int，long</p><p>3 浮点型：float，double</p><p>4 布尔类型：boolean</p></blockquote><h4 id="9-java-中操作字符串都有哪些类？它们之间有什么区别？"><a href="#9-java-中操作字符串都有哪些类？它们之间有什么区别？" class="headerlink" title="9.java 中操作字符串都有哪些类？它们之间有什么区别？"></a>9.java 中操作字符串都有哪些类？它们之间有什么区别？</h4><blockquote><p>String、StringBuffer、StringBuilder</p><p>String : final修饰，String类的方法都是返回new String。即对String对象的任何改变都不影响到原对象，对字符串的修改操作都会生成新的对象。<br>StringBuffer : 对字符串的操作的方法都加了synchronized，保证线程安全。</p><p>StringBuilder : 不保证线程安全，在方法体内需要进行字符串的修改操作，可以new StringBuilder对象，调用StringBuilder对象的append、replace、delete等方法修改字符串。</p></blockquote><h4 id="10-Java中String直接赋字符串和new-String的区别-如String-str-new-String-“a”-和String-str-“a”有什么区别"><a href="#10-Java中String直接赋字符串和new-String的区别-如String-str-new-String-“a”-和String-str-“a”有什么区别" class="headerlink" title="10.Java中String直接赋字符串和new String的区别 如String str=new String(“a”)和String str = “a”有什么区别?"></a>10.Java中String直接赋字符串和new String的区别 如String str=new String(“a”)和String str = “a”有什么区别?</h4><blockquote><p>String A=”ABC”;</p><p>String B=new String(“ABC”);</p><p>这两个值，A,B 是否相等，如果都往HashSet里面放，能放下吗？</p><p>答：(a)A==B 的判断为false;</p><p>​         (b)A.equals(B)为true ；因为值相等，所以都往HashSet里面放不下，只能放一个 </p><h3 id="问题：-与equals-的区别："><a href="#问题：-与equals-的区别：" class="headerlink" title="问题：==与equals()的区别："></a>问题：==与equals()的区别：</h3><ol><li>==:比较引用类型比较的是地址值是否相同</li><li>equals:比较引用类型默认也是比较地址值是否相同，注意:<strong>String类重写了equals()方法</strong>，比较的是内容是否相同。</li></ol><p><strong>String A = “ABC”;内存会去查找永久代(常量池) ，如果没有的话，在永久代中中开辟一块儿内存空间，把地址赋给栈指针，如果已经有了”ABC”的内存，直接把地址赋给栈指针；</strong></p><p><strong>因此</strong></p><p><strong>String str1=”aa”;</strong></p><p><strong>Srting str2=”aa”;</strong></p><p><strong>String Str3=”aa”;</strong></p><p><strong>….</strong></p><p><strong>这样下去，str1==Str2==str3;会一直相等下去，(a) ==的判断， (b) equals()的判断；都相等，因为他们的地址都相等，因此只在常量池中有一份内存空间，地址全部相同；</strong> </p><p> <strong>而String str = new String(“a”);是根据”a”这个String对象再次构造一个String对象;在堆中从新new一块儿内存，把指针赋给栈，</strong></p><p><strong>将新构造出来的String对象的引用赋给str。 因此 只要是new String()，则，栈中的地址都是指向最新的new出来的堆中的地址，</strong></p><p><strong>(a)“”==“” 是判断地址的，当然不相同；</strong></p><p><strong>(b)至于equals,String类型重写了 equals()方法，判断值是否相等，明显相等，因此 equals 是相等的；</strong></p><p>这是String 重写的equals:</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token operator">*</span> <span class="token annotation punctuation">@see</span>  #<span class="token function">compareTo</span><span class="token punctuation">(</span>String<span class="token punctuation">)</span>     <span class="token operator">*</span> <span class="token annotation punctuation">@see</span>  #<span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span>String<span class="token punctuation">)</span>     <span class="token operator">*</span><span class="token operator">/</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>Object anObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> anObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>anObject <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            String anotherString <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span> anObject<span class="token punctuation">;</span>            <span class="token keyword">int</span> n <span class="token operator">=</span> value<span class="token punctuation">.</span>length<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> anotherString<span class="token punctuation">.</span>value<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">char</span> v1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>                <span class="token keyword">char</span> v2<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> anotherString<span class="token punctuation">.</span>value<span class="token punctuation">;</span>                <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token operator">--</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>v1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> v2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    i<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StringDemo2</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String s2 <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// false</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// true</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">*</span><span class="token operator">*</span>运行结果：<span class="token operator">*</span><span class="token operator">*</span><span class="token operator">></span> <span class="token boolean">false</span> <span class="token operator">></span> <span class="token boolean">true</span></code></pre><p><strong>代码详解</strong></p><blockquote><ol><li>首先，通过main（）方法进栈。</li><li>然后再栈中定义一个对象s1,去堆中开辟一个内存空间，将内存空间的引用赋值给s1，“hello”是常量，然后去字符串常量池 查看是否有hello字符串对象，没有的话分配一个空间存放hello，并且将其空间地址存入堆中new出来的空间中。</li><li>在栈中定义一个对象s2，然后去字符串常量池中查看是否有”hello”字符串对象，有，直接把”hello”的地址赋值给s2.</li><li>即s1中存的是堆中分配的空间，堆中分配的空间中存的是字符串常量池中分配空间存放”hello”的空间的地址值。而s2中之间存的是字符串常量池中分配空间存放”hello”的空间的地址值。</li><li>由于s1与s2中存放的地址不同，所以输出false。因为，类String重写了equals()方法，它比较的是引用类型的 的值是否相等，所以输出true。即结果为false、true。</li></ol></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/11/mian-shi-ti-ji-jin/020.png" alt></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StringDemo1</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String s2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// false</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// true</span>        String s3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String s4 <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s3 <span class="token operator">==</span> s4<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// false</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s3<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>s4<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// true</span>        String s5 <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>        String s6 <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s5 <span class="token operator">==</span> s6<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// true</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s5<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>s6<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// true</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>s1~s6用equals()的比较不解释，都是比较的值，均为true。以下讲解==</p><ol><li>s1、s2：二者均为new出来的，各自在堆中分配有空间，并各自将内存地址赋值给s1、s2。空间地址不同，==比较为false。但是各自在堆中空间中保存的值均为在字符串常量池中的同一个对象的地址。根据Demo处的图即解释不难理解。</li><li>s3、s4同上Demo出解释。</li><li>s5、s6都是在常量池中取值，二者都指向常量池中同一对象，其地址值相同，所以结果为true。</li></ol></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StringDemo4</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String s1 <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>        String s2 <span class="token operator">=</span> <span class="token string">"world"</span><span class="token punctuation">;</span>        String s3 <span class="token operator">=</span> <span class="token string">"helloworld"</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s3 <span class="token operator">==</span> s1 <span class="token operator">+</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// false</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s3<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s1 <span class="token operator">+</span> s2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// true</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s3 <span class="token operator">==</span> <span class="token string">"hello"</span> <span class="token operator">+</span> <span class="token string">"world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//false</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s3<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"hello"</span> <span class="token operator">+</span> <span class="token string">"world"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// true</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="Demo2详解"><a href="#Demo2详解" class="headerlink" title="Demo2详解"></a>Demo2详解</h5><blockquote><p>equals()比较方法不解释，比较值，均相等，均为true。</p><ol><li>s1与s2相加是先在字符串常量池中开一个空间，然后拼接，这个空间的地址就是s1与s2拼接后的地址。与s3的地址不同，所以输出为false。</li><li>s3与”hello”+”world”作比较，”hello”+”world”先拼接成”helloworld”,然后再去字符串常量池中找是否有”helloworld”,有，所以和s3共用一个字符串对象，则为true。</li></ol></blockquote><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li><blockquote><ol><li>String s = new String(“hello”)会创建2（1）个对象，String s = “hello”创建1（0）个对象。<br>注：当字符串常量池中有对象hello时括号内成立！</li><li>字符串如果是变量相加，先开空间，在拼接。</li><li>字符串如果是常量相加，是先加，然后在常量池找，如果有就直接返回，否则，就创建。</li></ol></blockquote></li></ol><h4 id="11、如何将字符串反转？"><a href="#11、如何将字符串反转？" class="headerlink" title="11、如何将字符串反转？"></a>11、如何将字符串反转？</h4><h4 id="12、String-类的常用方法都有那些？"><a href="#12、String-类的常用方法都有那些？" class="headerlink" title="12、String 类的常用方法都有那些？"></a>12、String 类的常用方法都有那些？</h4><h4 id="13、抽象类必须要有抽象方法吗？"><a href="#13、抽象类必须要有抽象方法吗？" class="headerlink" title="13、抽象类必须要有抽象方法吗？"></a>13、抽象类必须要有抽象方法吗？</h4><h4 id="14、普通类和抽象类有哪些区别？"><a href="#14、普通类和抽象类有哪些区别？" class="headerlink" title="14、普通类和抽象类有哪些区别？"></a>14、普通类和抽象类有哪些区别？</h4><h4 id="15、抽象类能使用-final-修饰吗？"><a href="#15、抽象类能使用-final-修饰吗？" class="headerlink" title="15、抽象类能使用 final 修饰吗？"></a>15、抽象类能使用 final 修饰吗？</h4><h4 id="16、接口和抽象类有什么区别？"><a href="#16、接口和抽象类有什么区别？" class="headerlink" title="16、接口和抽象类有什么区别？"></a>16、接口和抽象类有什么区别？</h4><h4 id="17、java-中-IO-流分为几种？"><a href="#17、java-中-IO-流分为几种？" class="headerlink" title="17、java 中 IO 流分为几种？"></a>17、java 中 IO 流分为几种？</h4><h4 id="18、BIO、NIO、AIO-有什么区别？"><a href="#18、BIO、NIO、AIO-有什么区别？" class="headerlink" title="18、BIO、NIO、AIO 有什么区别？"></a>18、BIO、NIO、AIO 有什么区别？</h4><h4 id="19、Files的常用方法都有哪些？"><a href="#19、Files的常用方法都有哪些？" class="headerlink" title="19、Files的常用方法都有哪些？"></a>19、Files的常用方法都有哪些？</h4><h4 id="20、Arraylist-与-LinkedList-异同"><a href="#20、Arraylist-与-LinkedList-异同" class="headerlink" title="20、Arraylist 与 LinkedList 异同"></a>20、Arraylist 与 LinkedList 异同</h4><blockquote><ul><li><ol><li>是否保证线程安全：** ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；</li></ol></li><li><strong>2. 底层数据结构：</strong> Arraylist 底层使用的是Object数组；LinkedList 底层使用的是双向链表数据结构（JDK1.6之前为循环链表，JDK1.7取消了循环。注意双向链表和双向循环链表的区别：）； 详细可阅读<a href="https://www.cnblogs.com/xingele0917/p/3696593.html" target="_blank" rel="noopener">JDK1.7-LinkedList循环链表优化</a></li><li><strong>3. 插入和删除是否受元素位置的影响：</strong> ① <strong>ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。</strong> 比如：执行<code>add(E e)</code>方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。 ② <strong>LinkedList 采用链表存储，所以插入，删除元素时间复杂度不受元素位置的影响，都是近似 O（1）而数组为近似 O（n）。</strong></li><li><strong>4. 是否支持快速随机访问：</strong> LinkedList 不支持高效的随机元素访问，而 ArrayList 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</li><li><strong>5. 内存空间占用：</strong> ArrayList的空 间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）。 </li><li>补充内容:RandomAccess接口**</li></ul></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">RandomAccess</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><blockquote><p>查看源码我们发现实际上 RandomAccess 接口中什么都没有定义。所以，在我看来 RandomAccess 接口不过是一个标识罢了。标识什么？ 标识实现这个接口的类具有随机访问功能。</p><p>在binarySearch（）方法中，它要判断传入的list 是否RamdomAccess的实例，如果是，调用indexedBinarySearch（）方法，如果不是，那么调用iteratorBinarySearch（）方法</p></blockquote><pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span>    <span class="token keyword">int</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> T<span class="token operator">>></span> list<span class="token punctuation">,</span> T key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>list <span class="token keyword">instanceof</span> <span class="token class-name">RandomAccess</span> <span class="token operator">||</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>BINARYSEARCH_THRESHOLD<span class="token punctuation">)</span>            <span class="token keyword">return</span> Collections<span class="token punctuation">.</span><span class="token function">indexedBinarySearch</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token keyword">return</span> Collections<span class="token punctuation">.</span><span class="token function">iteratorBinarySearch</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><blockquote><p>ArraysList 实现了 RandomAccess 接口， 而 LinkedList 没有实现。为什么呢？我觉得还是和底层数据结构有关！ArraysList 底层是数组，而 LinkedList 底层是链表。数组天然支持随机访问，时间复杂度为 O（1），所以称为快速随机访问。链表需要遍历到特定位置才能访问特定位置的元素，时间复杂度为 O（n），所以不支持快速随机访问。，ArraysList 实现了 RandomAccess 接口，就表明了他具有快速随机访问功能。 RandomAccess 接口只是标识，并不是说 ArraysList 实现 RandomAccess 接口才具有快速随机访问功能的！</p><p><strong>下面再总结一下 list 的遍历方式选择：</strong></p><ul><li>实现了RandomAccess接口的list，优先选择普通for循环 ，其次foreach,</li><li>未实现RandomAccess接口的ist， 优先选择iterator遍历（foreach遍历底层也是通过iterator实现的），大size的数据，千万不要使用普通for循环</li></ul><h3 id="补充：数据结构基础之双向链表"><a href="#补充：数据结构基础之双向链表" class="headerlink" title="补充：数据结构基础之双向链表"></a>补充：数据结构基础之双向链表</h3><p>双向链表也叫双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。一般我们都构造双向循环链表，如下图所示，同时下图也是LinkedList 底层使用的是双向循环链表数据结构。</p></blockquote><h4 id="21、Object类中方法总结：基于Java8"><a href="#21、Object类中方法总结：基于Java8" class="headerlink" title="21、Object类中方法总结：基于Java8"></a>21、Object类中方法总结：基于Java8</h4><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/11/mian-shi-ti-ji-jin/024.png" alt></p><blockquote><h5 id="hashcode"><a href="#hashcode" class="headerlink" title="hashcode()"></a>hashcode()</h5><p>hashCode()方法返回的就是一个数值，从方法的名称上就可以看出，其目的是生成一个hash码。hash码的主要用途就是在对对象进行散列的时候作为key输入，据此很容易推断出，我们需要每个对象的hash码尽可能不同，这样才能保证散列的存取性能。哈希算法也称为散列算法，是将数据依特定算法直接指定到一个地址上。</p><pre><code>初学者可以这样理解，hashCode方法实际上返回的就是对象存储的物理地址（实际可能并不是）。</code></pre><hr><h5 id="hashcode-和-equals-的区别"><a href="#hashcode-和-equals-的区别" class="headerlink" title="hashcode() 和 equals() 的区别"></a><strong>hashcode() 和 equals() 的区别</strong></h5><p>1、如果两个对象equals，Java运行时环境会认为他们的hashcode一定相等。<br>2、如果两个对象不equals，他们的hashcode有可能相等。<br>3、如果两个对象hashcode相等，他们不一定equals。</p><p>4、如果两个对象hashcode不相等，他们一定不equals。 </p><hr><h4 id="wait-wait-long-wait-long-int-notify-notifyAll"><a href="#wait-wait-long-wait-long-int-notify-notifyAll" class="headerlink" title="wait(),wait(long),wait(long,int),notify(),notifyAll()"></a>wait(),wait(long),wait(long,int),notify(),notifyAll()</h4><p>这几个函数体现的是Java的多线程机制<br>在使用的时候要求在synchronize语句中使用<br>wait()用于让当前线程失去操作权限，当前线程进入等待序列<br>notify()用于随机通知一个持有对象的锁的线程获取操作权限<br>notifyAll()用于通知所有持有对象的锁的线程获取操作权限</p><p>wait(long) 和wait(long,int)用于设定下一次获取锁的距离当前释放锁的时间间隔</p><h4 id="toString-和getClass"><a href="#toString-和getClass" class="headerlink" title="toString()和getClass()"></a>toString()和getClass()</h4><p>toString()返回一个String对象，用来标识自己</p><p>如Object类默认的:</p><pre class=" language-JAVA"><code class="language-JAVA">public String toString() {       return getClass().getName() + "@" + Integer.toHexString(hashCode());   }</code></pre><p>getClass()返回一个Class对象。</p><h4 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h4><p>其实是使用了原型模式，</p><p>使用clone方法的几个条件：<br>1）在派生类中实现Cloneable借口。</p><p>　2）为了获取对象的一份拷贝，我们可以利用Object类的clone方法。<br>　3）在派生类中覆盖积累的clone方法，声明为public。</p><p>　4）在派生类的clone方法中，调用super.clone()。</p><h4 id="finalize-用于在垃圾回收"><a href="#finalize-用于在垃圾回收" class="headerlink" title="finalize()用于在垃圾回收"></a>finalize()用于在垃圾回收</h4><h4 id="registerNatives-本地注册"><a href="#registerNatives-本地注册" class="headerlink" title="registerNatives() 本地注册"></a>registerNatives() 本地注册</h4><p>native修饰的方法表示本地方法（跟系统有关，也可以理解为这个方法不是在java中实现的），据说这个方法在一个名为java.dll的动态库文件中。Object类中第40行（我的是jdk1.8）开始的 static{ registerNatives(); } 表示的是在类被加载时，调用 registerNatives()方法进行一些跟系统有关的方法调用，而这个方法的实现就在java.dll中（里面会根据不同系统来执行不同的底层操作）。</p></blockquote><h3 id="二、容器"><a href="#二、容器" class="headerlink" title="二、容器"></a>二、容器</h3><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/11/mian-shi-ti-ji-jin/002.png" alt></p><ol><li>java 容器都有哪些？</li><li>Collection 和 Collections 有什么区别？</li><li>List、Set、Map 之间的区别是什么？</li><li>HashMap 和 Hashtable 有什么区别？</li><li>如何决定使用 HashMap 还是 TreeMap？</li><li>说一下 HashMap 的实现原理？</li><li>说一下 HashSet 的实现原理？</li><li>ArrayList 和 LinkedList 的区别是什么？</li><li>如何实现数组和 List 之间的转换？</li><li>ArrayList 和 Vector 的区别是什么？</li><li>Array 和 ArrayList 有何区别？</li><li>在 Queue 中 poll()和 remove()有什么区别？</li><li>哪些集合类是线程安全的？</li><li>迭代器 Iterator 是什么？</li><li>Iterator 怎么使用？有什么特点？</li><li>Iterator 和 ListIterator 有什么区别？</li><li>怎么确保一个集合不能被修改？</li></ol><h3 id="三、多线程"><a href="#三、多线程" class="headerlink" title="三、多线程"></a>三、多线程</h3><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/11/mian-shi-ti-ji-jin/003.png" alt></p><ol><li>并行和并发有什么区别？</li><li>线程和进程的区别？</li><li>守护线程是什么？</li><li>创建线程有哪几种方式？</li><li>说一下 runnable 和 callable 有什么区别？</li><li>线程有哪些状态？</li><li>sleep() 和 wait() 有什么区别？</li><li>notify()和 notifyAll()有什么区别？</li><li>线程的 run()和 start()有什么区别？</li><li>创建线程池有哪几种方式？</li><li>线程池都有哪些状态？</li><li>线程池中 submit()和 execute()方法有什么区别？</li><li>在 java 程序中怎么保证多线程的运行安全？</li><li>多线程锁的升级原理是什么？</li><li>什么是死锁？</li><li>怎么防止死锁？</li><li>ThreadLocal 是什么？有哪些使用场景？</li><li>说一下 synchronized 底层实现原理？</li><li>synchronized 和 volatile 的区别是什么？</li><li>synchronized 和 Lock 有什么区别？</li><li>synchronized 和 ReentrantLock 区别是什么？</li><li>说一下 atomic 的原理？</li></ol><h3 id="四、反射"><a href="#四、反射" class="headerlink" title="四、反射"></a>四、反射</h3><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/11/mian-shi-ti-ji-jin/004.png" alt></p><ol><li>什么是反射？</li><li>什么是 java 序列化？什么情况下需要序列化？</li><li>动态代理是什么？有哪些应用？</li><li>怎么实现动态代理？</li></ol><h3 id="五、对象拷贝"><a href="#五、对象拷贝" class="headerlink" title="五、对象拷贝"></a>五、对象拷贝</h3><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/11/mian-shi-ti-ji-jin/005.png" alt></p><ol><li>为什么要使用克隆？</li><li>如何实现对象克隆？</li><li>深拷贝和浅拷贝区别是什么？</li></ol><h3 id="六、Java-Web"><a href="#六、Java-Web" class="headerlink" title="六、Java Web"></a>六、Java Web</h3><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/11/mian-shi-ti-ji-jin/006.png" alt></p><ol><li>jsp 和 servlet 有什么区别？</li><li>jsp 有哪些内置对象？作用分别是什么？</li><li>说一下 jsp 的 4 种作用域？</li><li>session 和 cookie 有什么区别？</li><li>说一下 session 的工作原理？</li><li>如果客户端禁止 cookie 能实现 session 还能用吗？</li><li>spring mvc 和 struts 的区别是什么？</li><li>如何避免 sql 注入？</li><li>什么是 XSS 攻击，如何避免？</li><li>什么是 CSRF 攻击，如何避免？</li></ol><h3 id="七、异常"><a href="#七、异常" class="headerlink" title="七、异常"></a>七、异常</h3><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/11/mian-shi-ti-ji-jin/007.png" alt></p><ol><li>throw 和 throws 的区别？</li><li>final、finally、finalize 有什么区别？</li><li>try-catch-finally 中哪个部分可以省略？</li><li>try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</li><li>常见的异常类有哪些？</li></ol><h3 id="八、网络"><a href="#八、网络" class="headerlink" title="八、网络"></a>八、网络</h3><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/11/mian-shi-ti-ji-jin/008.png" alt></p><ol><li>http 响应码 301 和 302 代表的是什么？有什么区别？</li><li>forward 和 redirect 的区别？</li><li>简述 tcp 和 udp的区别？</li><li>tcp 为什么要三次握手，两次不行吗？为什么？</li><li>说一下 tcp 粘包是怎么产生的？</li><li>OSI 的七层模型都有哪些？</li><li>get 和 post 请求有哪些区别？</li><li>如何实现跨域？</li><li>说一下 JSONP 实现原理？</li></ol><h3 id="九、设计模式"><a href="#九、设计模式" class="headerlink" title="九、设计模式"></a>九、设计模式</h3><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/11/mian-shi-ti-ji-jin/009.png" alt></p><ol><li>说一下你熟悉的设计模式？</li></ol><ul><li>简单工厂和抽象工厂有什么区别？</li></ul><h3 id="十、Spring-Spring-MVC"><a href="#十、Spring-Spring-MVC" class="headerlink" title="十、Spring/Spring MVC"></a>十、Spring/Spring MVC</h3><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/11/mian-shi-ti-ji-jin/010.png" alt></p><ol><li><h4 id="为什么要使用-spring？"><a href="#为什么要使用-spring？" class="headerlink" title="为什么要使用 spring？"></a>为什么要使用 spring？</h4></li><li><h4 id="解释一下什么是-aop？"><a href="#解释一下什么是-aop？" class="headerlink" title="解释一下什么是 aop？"></a>解释一下什么是 aop？</h4></li><li><h4 id="解释一下什么是-ioc？"><a href="#解释一下什么是-ioc？" class="headerlink" title="解释一下什么是 ioc？"></a>解释一下什么是 ioc？</h4></li><li><h4 id="spring-有哪些主要模块？"><a href="#spring-有哪些主要模块？" class="headerlink" title="spring 有哪些主要模块？"></a>spring 有哪些主要模块？</h4></li><li><h4 id="spring-常用的注入方式有哪些？"><a href="#spring-常用的注入方式有哪些？" class="headerlink" title="spring 常用的注入方式有哪些？"></a>spring 常用的注入方式有哪些？</h4></li><li><h4 id="spring-中的-bean-是线程安全的吗？"><a href="#spring-中的-bean-是线程安全的吗？" class="headerlink" title="spring 中的 bean 是线程安全的吗？"></a>spring 中的 bean 是线程安全的吗？</h4></li><li><h4 id="spring-支持几种-bean-的作用域？"><a href="#spring-支持几种-bean-的作用域？" class="headerlink" title="spring 支持几种 bean 的作用域？"></a>spring 支持几种 bean 的作用域？</h4></li><li><h4 id="spring-自动装配-bean-有哪些方式？"><a href="#spring-自动装配-bean-有哪些方式？" class="headerlink" title="spring 自动装配 bean 有哪些方式？"></a>spring 自动装配 bean 有哪些方式？</h4></li><li><h4 id="spring-事务实现方式有哪些？"><a href="#spring-事务实现方式有哪些？" class="headerlink" title="spring 事务实现方式有哪些？"></a>spring 事务实现方式有哪些？</h4></li><li><h4 id="说一下-spring-的事务隔离？"><a href="#说一下-spring-的事务隔离？" class="headerlink" title="说一下 spring 的事务隔离？"></a>说一下 spring 的事务隔离？</h4></li><li><h4 id="说一下-spring-mvc-运行流程？"><a href="#说一下-spring-mvc-运行流程？" class="headerlink" title="说一下 spring mvc 运行流程？"></a>说一下 spring mvc 运行流程？</h4><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/11/mian-shi-ti-ji-jin/023.jpeg" alt></p></li><li><h4 id="spring-mvc-有哪些组件？"><a href="#spring-mvc-有哪些组件？" class="headerlink" title="spring mvc 有哪些组件？"></a>spring mvc 有哪些组件？</h4></li><li><h4 id="RequestMapping-的作用是什么？"><a href="#RequestMapping-的作用是什么？" class="headerlink" title="@RequestMapping 的作用是什么？"></a>@RequestMapping 的作用是什么？</h4></li><li><h4 id="Autowired-的作用是什么？"><a href="#Autowired-的作用是什么？" class="headerlink" title="@Autowired 的作用是什么？"></a>@Autowired 的作用是什么？</h4></li><li><h4 id="Spring-bean的生命周期？"><a href="#Spring-bean的生命周期？" class="headerlink" title="Spring bean的生命周期？"></a>Spring bean的生命周期？</h4><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/11/mian-shi-ti-ji-jin/022.png" alt></p><blockquote><p>（1）<strong>BeanFactoryPostProcessor</strong>的postProcessorBeanFactory()方法：若某个IoC容器内添加了实现了BeanFactoryPostProcessor接口的实现类Bean，那么在该容器中实例化任何其他Bean之前可以回调该Bean中的postPrcessorBeanFactory()方法来对Bean的配置元数据进行更改，比如从XML配置文件中获取到的配置信息。</p><p>（2）Bean的实例化：Bean的实例化是使用反射实现的。</p><p>（3）Bean属性注入：Bean实例化完成后，利用反射技术实现属性及依赖Bean的注入。</p><p>（4）<strong>BeanNameAware</strong>的setBeanName()方法：如果某个Bean实现了BeanNameAware接口，那么Spring将会将Bean实例的ID传递给setBeanName()方法，在Bean类中新增一个beanName字段，并实现setBeanName()方法。</p><p>（5）<strong>BeanFactoryAware</strong>的setBeanFactory()方法：如果某个Bean实现了BeanFactoryAware接口，那么Spring将会将创建Bean的BeanFactory传递给setBeanFactory()方法，在Bean类中新增了一个beanFactory字段用来保存BeanFactory的值，并实现setBeanFactory()方法。</p><p>（6）<strong>ApplicationContextAware</strong>的setApplicationContext()方法：如果某个Bean实现了ApplicationContextAware接口，那么Spring将会将该Bean所在的上下文环境ApplicationContext传递给setApplicationContext()方法，在Bean类中新增一个ApplicationContext字段用来保存ApplicationContext的值，并实现setApplicationContext()方法。</p><p>（7）<strong>BeanPostProcessor</strong>预初始化方法：如果某个IoC容器中增加的实现BeanPostProcessor接口的实现类Bean，那么在该容器中实例化Bean之后，执行初始化之前会调用BeanPostProcessor中的postProcessBeforeInitialization()方法执行预初始化处理。</p><p>（8）<strong>InitializingBean</strong>的afterPropertiesSet()方法：如果Bean实现了InitializingBean接口，那么Bean在实例化完成后将会执行接口中的afterPropertiesSet()方法来进行初始化。</p><p>（9）自定义的inti-method指定的方法：如果配置文件中使用init-method属性指定了初始化方法，那么Bean在实例化完成后将会调用该属性指定的初始化方法进行Bean的初始化。</p><p>（10）<strong>BeanPostProcessor</strong>初始化后方法：如果某个IoC容器中增加的实现BeanPostProcessor接口的实现类Bean，那么在该容器中实例化Bean之后并且完成初始化调用后执行该接口中的postProcessorAfterInitialization()方法进行初始化后处理。</p><p>（11）使用Bean：此时有关Bean的所有准备工作均已完成，Bean可以被程序使用了，它们将会一直驻留在应用上下文中，直到该上下文环境被销毁。</p><p>（12）<strong>DisposableBean</strong>的destory()方法：如果Bean实现了DisposableBean接口，Spring将会在Bean实例销毁之前调用该接口的destory()方法，来完成一些销毁之前的处理工作。</p><p>（13）自定义的destory-method指定的方法：如果在配置文件中使用destory-method指定了销毁方法，那么在Bean实例销毁之前会调用该指定的方法完成一些销毁之前的处理工作。</p><p><em>注意：</em></p><p><em>1、BeanFactoryPostProcessor接口与BeanPostProcessor接口的作用范围是整个上下文环境中，使用方法是单独新增一个类来实现这些接口，那么在处理其他Bean的某些时刻就会回调响应的接口中的方法。</em></p><p><em>2、BeanNameAware、BeanFactoryAware、ApplicationContextAware的作用范围的Bean范围，即仅仅对实现了该接口的指定Bean有效，所有其使用方法是在要使用该功能的Bean自己来实现该接口。</em></p><p><em>3、第8点与第9点所述的两个初始化方法作用是一样的，我们完全可以使用其中的一种即可，一般情况我们使用第9点所述的方式，尽量少的去来Bean中实现某些接口，保持其独立性，低耦合性，尽量不要与Spring代码耦合在一起。第12和第13也是如此。</em></p></blockquote></li><li></li></ol><h3 id="十一、Spring-Boot-Spring-Cloud"><a href="#十一、Spring-Boot-Spring-Cloud" class="headerlink" title="十一、Spring Boot/Spring Cloud"></a>十一、Spring Boot/Spring Cloud</h3><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/11/mian-shi-ti-ji-jin/011.png" alt></p><ol><li>什么是 spring boot？</li><li>为什么要用 spring boot？</li><li>spring boot 核心配置文件是什么？</li><li>spring boot 配置文件有哪几种类型？它们有什么区别？</li><li>spring boot 有哪些方式可以实现热部署？</li><li>jpa 和 hibernate 有什么区别？</li><li>什么是 spring cloud？</li><li>spring cloud 断路器的作用是什么？</li><li>spring cloud 的核心组件有哪些？</li></ol><h3 id="十二、Hibernate"><a href="#十二、Hibernate" class="headerlink" title="十二、Hibernate"></a>十二、Hibernate</h3><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/11/mian-shi-ti-ji-jin/012.png" alt></p><ol><li>为什么要使用 hibernate？</li><li>什么是 ORM 框架？</li><li>hibernate 中如何在控制台查看打印的 sql 语句？</li><li>hibernate 有几种查询方式？</li><li>hibernate 实体类可以被定义为 final 吗？</li><li>在 hibernate 中使用 Integer 和 int 做映射有什么区别？</li><li>hibernate 是如何工作的？</li><li>get()和 load()的区别？</li><li>说一下 hibernate 的缓存机制？</li><li>hibernate 对象有哪些状态？</li><li>在 hibernate 中 getCurrentSession 和 openSession 的区别是什么？</li><li>hibernate 实体类必须要有无参构造函数吗？为什么？</li></ol><h3 id="十三、Mybatis"><a href="#十三、Mybatis" class="headerlink" title="十三、Mybatis"></a>十三、Mybatis</h3><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/11/mian-shi-ti-ji-jin/013.png" alt></p><ol><li>mybatis 中 #{}和 ${}的区别是什么？</li><li>mybatis 有几种分页方式？</li><li>RowBounds 是一次性查询全部结果吗？为什么？</li><li>mybatis 逻辑分页和物理分页的区别是什么？</li><li>mybatis 是否支持延迟加载？延迟加载的原理是什么？</li><li>说一下 mybatis 的一级缓存和二级缓存？</li><li>mybatis 和 hibernate 的区别有哪些？</li><li>mybatis 有哪些执行器（Executor）？</li><li>mybatis 分页插件的实现原理是什么？</li><li>mybatis 如何编写一个自定义插件？</li></ol><h3 id="十四、RabbitMQ"><a href="#十四、RabbitMQ" class="headerlink" title="十四、RabbitMQ"></a>十四、RabbitMQ</h3><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/11/mian-shi-ti-ji-jin/014.png" alt></p><ol><li>rabbitmq 的使用场景有哪些？</li><li>rabbitmq 有哪些重要的角色？</li><li>rabbitmq 有哪些重要的组件？</li><li>rabbitmq 中 vhost 的作用是什么？</li><li>rabbitmq 的消息是怎么发送的？</li><li>rabbitmq 怎么保证消息的稳定性？</li><li>rabbitmq 怎么避免消息丢失？</li><li>要保证消息持久化成功的条件有哪些？</li><li>rabbitmq 持久化有什么缺点？</li><li>rabbitmq 有几种广播类型？</li><li>rabbitmq 怎么实现延迟消息队列？</li><li>rabbitmq 集群有什么用？</li><li>rabbitmq 节点的类型有哪些？</li><li>rabbitmq 集群搭建需要注意哪些问题？</li><li>rabbitmq 每个节点是其他节点的完整拷贝吗？为什么？</li><li>rabbitmq 集群中唯一一个磁盘节点崩溃了会发生什么情况？</li><li>rabbitmq 对集群节点停止顺序有要求吗？</li></ol><h3 id="十五、Kafka"><a href="#十五、Kafka" class="headerlink" title="十五、Kafka"></a>十五、Kafka</h3><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/11/mian-shi-ti-ji-jin/015.png" alt></p><ol><li>kafka 可以脱离 zookeeper 单独使用吗？为什么？</li><li>kafka 有几种数据保留的策略？</li><li>kafka 同时设置了 7 天和 10G 清除数据，到第五天的时候消息达到了 10G，这个时候 kafka 将如何处理？</li><li>什么情况会导致 kafka 运行变慢？</li><li>使用 kafka 集群需要注意什么？</li></ol><h3 id="十六、Zookeeper"><a href="#十六、Zookeeper" class="headerlink" title="十六、Zookeeper"></a>十六、Zookeeper</h3><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/11/mian-shi-ti-ji-jin/016.png" alt></p><ol><li>zookeeper 是什么？</li><li>zookeeper 都有哪些功能？</li><li>zookeeper 有几种部署模式？</li><li>zookeeper 怎么保证主从节点的状态同步？</li><li>集群中为什么要有主节点？</li><li>集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？</li><li>说一下 zookeeper 的通知机制？</li></ol><h3 id="十七、MySql"><a href="#十七、MySql" class="headerlink" title="十七、MySql"></a>十七、MySql</h3><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/11/mian-shi-ti-ji-jin/017.png" alt></p><ol><li>数据库的三范式是什么？</li><li>一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 mysql 数据库，又插入了一条数据，此时 id 是几？</li><li>如何获取当前数据库版本？</li><li>说一下 ACID 是什么？</li><li>char 和 varchar 的区别是什么？</li><li>float 和 double 的区别是什么？</li><li>mysql 的内连接、左连接、右连接有什么区别？</li><li>mysql 索引是怎么实现的？</li><li>怎么验证 mysql 的索引是否满足需求？</li><li>说一下数据库的事务隔离？</li><li>说一下 mysql 常用的引擎？</li><li>说一下 mysql 的行锁和表锁？</li><li>说一下乐观锁和悲观锁？</li><li>mysql 问题排查都有哪些手段？</li><li>如何做 mysql 的性能优化？</li></ol><h3 id="十八、Redis"><a href="#十八、Redis" class="headerlink" title="十八、Redis"></a>十八、Redis</h3><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/11/mian-shi-ti-ji-jin/018.png" alt></p><ol><li><h4 id="redis-是什么？都有哪些使用场景？"><a href="#redis-是什么？都有哪些使用场景？" class="headerlink" title="redis 是什么？都有哪些使用场景？"></a>redis 是什么？都有哪些使用场景？</h4><blockquote><p>Redis 的全称是：Remote Dictionary.Server，本质上是一个 Key-Value 类型的内存数据库，很像memcached，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据 flush 到硬盘上进行保存。因为是纯内存操作，Redis 的性能非常出色，每秒可以处理超过 10 万次读写操作，是已知性能最快的Key-Value DB。</p><p>Redis 的出色之处不仅仅是性能，Redis 最大的魅力是支持保存多种数据结构，此外单个 value 的最大限制是 1GB，不像 memcached 只能保存 1MB 的数据，因此 Redis 可以用来实现很多有用的功能。</p><p>比方说用他的 List 来做 FIFO 双向链表，实现一个轻量级的高性 能消息队列服务，用他的 Set 可以做高性能的 tag 系统等等。</p><p>另外 Redis 也可以对存入的 Key-Value 设置 expire 时间，因此也可以被当作一 个功能加强版的memcached 来用。 Redis 的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此 Redis 适合的场景主要局限在较小数据量的高性能操作和运算上。</p></blockquote><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><h5 id="（1）会话缓存（Session-Cache）"><a href="#（1）会话缓存（Session-Cache）" class="headerlink" title="（1）会话缓存（Session Cache）"></a>（1）会话缓存（Session Cache）</h5><blockquote><p>最常用的一种使用 Redis 的情景是会话缓存（sessioncache），用 Redis 缓存会话比其他存储（如Memcached）的优势在于：Redis 提供持久化。当维护一个不是严格要求一致性的缓存时，如果用户的购物车信息全部丢失，大部分人都会不高兴的，现在，他们还会这样吗？</p><p>幸运的是，随着 Redis 这些年的改进，很容易找到怎么恰当的使用 Redis 来缓存会话的文档。甚至广为人知的商业平台 Magento 也提供 Redis 的插件。</p></blockquote><h5 id="2）全页缓存（FPC）"><a href="#2）全页缓存（FPC）" class="headerlink" title="(2）全页缓存（FPC）"></a>(2）全页缓存（FPC）</h5><blockquote><p>除基本的会话 token 之外，Redis 还提供很简便的 FPC 平台。回到一致性问题，即使重启了 Redis 实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似 PHP 本地FPC。</p><p>再次以 Magento 为例，Magento 提供一个插件来使用 Redis 作为全页缓存后端。</p><p>此外，对 WordPress 的用户来说，Pantheon 有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。</p></blockquote><h5 id="（3）队列"><a href="#（3）队列" class="headerlink" title="（3）队列"></a>（3）队列</h5><blockquote><p>Reids 在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得 Redis 能作为一个很好的消息队列平台来使用。Redis 作为队列使用的操作，就类似于本地程序语言（如 Python）对 list 的 push/pop操作。</p><p>如果你快速的在 Google 中搜索“Redis queues”，你马上就能找到大量的开源项目，这些项目的目的就是利用 Redis 创建非常好的后端工具，以满足各种队列需求。例如，Celery 有一个后台就是使用Redis 作为 broker，你可以从这里去查看。</p></blockquote><h5 id="4）排行榜-计数器"><a href="#4）排行榜-计数器" class="headerlink" title="(4）排行榜/计数器"></a>(4）排行榜/计数器</h5><blockquote><p>Redis 在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（SortedSet）也使得我们在执行这些操作的时候变的非常简单，Redis 只是正好提供了这两种数据结构。</p><p>所以，我们要从排序集合中获取到排名最靠前的 10 个用户–我们称之为“user_scores”，我们只需要像下面一样执行即可：</p><p>当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你需要这样执行：</p><p>ZRANGE user_scores 0 10 WITHSCORESAgora Games 就是一个很好的例子，用 Ruby 实现的，它的排行榜就是使用 Redis 来存储数据的，你可以在这里看到。</p></blockquote><h5 id="（5）发布-订阅"><a href="#（5）发布-订阅" class="headerlink" title="（5）发布/订阅"></a>（5）发布/订阅</h5><blockquote><p>Redis 的发布/订阅功能。发布/订阅的使用场景确实非常多。我已看见人们在社交网络连接中使用，还可作为基于发布/订阅的脚本触发器，甚至用 Redis 的发布/订阅功能来建立聊天系统！</p></blockquote></li><li><h4 id="redis-有哪些功能？"><a href="#redis-有哪些功能？" class="headerlink" title="redis 有哪些功能？"></a>redis 有哪些功能？</h4></li><li><h4 id="redis-和-memecache-有什么区别？"><a href="#redis-和-memecache-有什么区别？" class="headerlink" title="redis 和 memecache 有什么区别？"></a>redis 和 memecache 有什么区别？</h4><blockquote><ul><li>memcached 所有的值均是简单的字符串，redis 作为其替代者，支持更为丰富的数据类型</li><li>redis 的速度比 memcached 快很多 redis 的速度比 memcached 快很多</li><li>redis 可以持久化其数据 redis 可以持久化其数据</li></ul></blockquote></li><li><h4 id="redis-为什么是单线程的？"><a href="#redis-为什么是单线程的？" class="headerlink" title="redis 为什么是单线程的？"></a>redis 为什么是单线程的？</h4></li><li><h4 id="什么是缓存穿透？怎么解决？"><a href="#什么是缓存穿透？怎么解决？" class="headerlink" title="什么是缓存穿透？怎么解决？"></a>什么是缓存穿透？怎么解决？</h4></li><li><h4 id="redis-支持的数据类型有哪些？"><a href="#redis-支持的数据类型有哪些？" class="headerlink" title="redis 支持的数据类型有哪些？"></a>redis 支持的数据类型有哪些？</h4><blockquote><p>String、List、Set、Sorted Set、hashes</p></blockquote></li><li><h4 id="redis-支持的-java-客户端都有哪些？"><a href="#redis-支持的-java-客户端都有哪些？" class="headerlink" title="redis 支持的 java 客户端都有哪些？"></a>redis 支持的 java 客户端都有哪些？</h4><blockquote><p>Redisson、Jedis、lettuce 等等，官方推荐使用 Redisson。</p></blockquote></li><li><h4 id="jedis-和-redisson-有哪些区别？"><a href="#jedis-和-redisson-有哪些区别？" class="headerlink" title="jedis 和 redisson 有哪些区别？"></a>jedis 和 redisson 有哪些区别？</h4><blockquote><p>Jedis 是 Redis 的 Java 实现的客户端，其 API 提供了比较全面的 Redis 命令的支持；</p><p>Redisson 实现了分布式和可扩展的 Java 数据结构，和 Jedis 相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等 Redis 特性。Redisson 的宗旨是促进使用者对 Redis 的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</p></blockquote></li><li><h4 id="怎么保证缓存和数据库数据的一致性？"><a href="#怎么保证缓存和数据库数据的一致性？" class="headerlink" title="怎么保证缓存和数据库数据的一致性？"></a>怎么保证缓存和数据库数据的一致性？</h4></li><li><h4 id="redis-持久化有几种方式？"><a href="#redis-持久化有几种方式？" class="headerlink" title="redis 持久化有几种方式？"></a>redis 持久化有几种方式？</h4></li><li><h4 id="redis-怎么实现分布式锁？"><a href="#redis-怎么实现分布式锁？" class="headerlink" title="redis 怎么实现分布式锁？"></a>redis 怎么实现分布式锁？</h4></li><li><h4 id="redis-分布式锁有什么缺陷？"><a href="#redis-分布式锁有什么缺陷？" class="headerlink" title="redis 分布式锁有什么缺陷？"></a>redis 分布式锁有什么缺陷？</h4></li><li><h4 id="redis-如何做内存优化？"><a href="#redis-如何做内存优化？" class="headerlink" title="redis 如何做内存优化？"></a>redis 如何做内存优化？</h4></li><li><h4 id="redis-淘汰策略有哪些？"><a href="#redis-淘汰策略有哪些？" class="headerlink" title="redis 淘汰策略有哪些？"></a>redis 淘汰策略有哪些？</h4></li><li><h4 id="redis-常见的性能问题有哪些？该如何解决？"><a href="#redis-常见的性能问题有哪些？该如何解决？" class="headerlink" title="redis 常见的性能问题有哪些？该如何解决？"></a>redis 常见的性能问题有哪些？该如何解决？</h4></li></ol><h3 id="十九、JVM"><a href="#十九、JVM" class="headerlink" title="十九、JVM"></a>十九、JVM</h3><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/11/mian-shi-ti-ji-jin/019.png" alt></p><ol><li>说一下 jvm 的主要组成部分？及其作用？</li><li>说一下 jvm 运行时数据区？</li><li>说一下堆栈的区别？</li><li>队列和栈是什么？有什么区别？</li><li>什么是双亲委派模型？</li><li>说一下类加载的执行过程？</li><li>怎么判断对象是否可以被回收？</li><li>java 中都有哪些引用类型？</li><li>说一下 jvm 有哪些垃圾回收算法？</li><li>说一下 jvm 有哪些垃圾回收器？</li><li>详细介绍一下 CMS 垃圾回收器？</li><li>新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？</li><li>简述分代垃圾回收器是怎么工作的？</li><li>说一下 jvm 调优的工具？</li><li>常用的 jvm 调优的参数都有哪些？</li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容器，多线程，反射，对象拷贝 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac下安装Nginx</title>
      <link href="/2019/07/10/mac-xia-an-zhuang-nginx/"/>
      <url>/2019/07/10/mac-xia-an-zhuang-nginx/</url>
      
        <content type="html"><![CDATA[<h1 id="Mac下安装Nginx"><a href="#Mac下安装Nginx" class="headerlink" title="Mac下安装Nginx"></a>Mac下安装Nginx</h1><h4 id="一、检查更新"><a href="#一、检查更新" class="headerlink" title="一、检查更新"></a>一、检查更新</h4><pre><code>brew update</code></pre><h4 id="二、查询要安装的软件是否存在"><a href="#二、查询要安装的软件是否存在" class="headerlink" title="二、查询要安装的软件是否存在"></a>二、查询要安装的软件是否存在</h4><pre><code>brew search nginx</code></pre><h4 id="三、安装软件"><a href="#三、安装软件" class="headerlink" title="三、安装软件"></a>三、安装软件</h4><pre><code>brew install nginx</code></pre><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/10/mac-xia-an-zhuang-nginx/001.png" alt></p><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/10/mac-xia-an-zhuang-nginx/002.png" alt></p><blockquote><p>我们可以看到，nginx在本地还未安装（Not installed），nginx的来源（From），Docroot默认为/usr/local/var/www，在/usr/local/etc/nginx/nginx.conf配置文件中默认端口被配置为8080从而使nginx运行时不需要加sudo，nginx将在/usr/local/etc/nginx/servers/目录中加载所有文件，以及我们可以通过最简单的命令 ‘nginx’ 来启动nginx。</p></blockquote><h4 id="四、查看nginx安装目录"><a href="#四、查看nginx安装目录" class="headerlink" title="四、查看nginx安装目录"></a>四、查看nginx安装目录</h4><pre><code>open /usr/local/etc/nginx/</code></pre><pre><code>open /usr/local/Cellar/nginx  //其实这个才是nginx被安装到的目录</code></pre><h4 id="五、启动nginx，终端输入如下命令："><a href="#五、启动nginx，终端输入如下命令：" class="headerlink" title="五、启动nginx，终端输入如下命令："></a>五、启动nginx，终端输入如下命令：</h4><pre><code>nginx</code></pre><h4 id="六、浏览器访问"><a href="#六、浏览器访问" class="headerlink" title="六、浏览器访问"></a>六、浏览器访问</h4><pre><code>localhost:8080</code></pre><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/10/mac-xia-an-zhuang-nginx/003.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx，负载均衡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac下安装Redis</title>
      <link href="/2019/07/09/mac-xia-an-zhuang-redis/"/>
      <url>/2019/07/09/mac-xia-an-zhuang-redis/</url>
      
        <content type="html"><![CDATA[<h1 id="Mac下安装Redis"><a href="#Mac下安装Redis" class="headerlink" title="Mac下安装Redis"></a>Mac下安装Redis</h1><h4 id="1-下载"><a href="#1-下载" class="headerlink" title="1.下载"></a>1.下载</h4><blockquote><p>打开官网：<a href="https://redis.io/" target="_blank" rel="noopener">https://redis.io/</a></p><p>这里下载的是最新版本</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/09/mac-xia-an-zhuang-redis/001.png" alt></p><h4 id="2-安装"><a href="#2-安装" class="headerlink" title="2.安装"></a>2.安装</h4><blockquote><p>下载完成后，打开命令行工具，执行解压命令</p></blockquote><pre><code>tar zxvf redis-5.0.5.tar.gz</code></pre><blockquote><p>将解压后文件夹放到/usr/local</p></blockquote><pre><code>mv redis-5.0.5 /usr/local/</code></pre><blockquote><p>切换到相应目录</p></blockquote><pre><code>cd /usr/local/redis-5.0.5/</code></pre><blockquote><p>编译测试</p></blockquote><pre><code>sudo make test</code></pre><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/09/mac-xia-an-zhuang-redis/002.png" alt></p><blockquote><p>编译安装</p></blockquote><pre><code>sudo make install</code></pre><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/09/mac-xia-an-zhuang-redis/003.png" alt></p><blockquote><p>启动Redis</p></blockquote><pre><code>redis-server</code></pre><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/09/mac-xia-an-zhuang-redis/004.png" alt></p><h4 id="3-配置"><a href="#3-配置" class="headerlink" title="3.配置"></a>3.配置</h4><blockquote><p>在redis目录下建立bin，etc，db三个目录</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/09/mac-xia-an-zhuang-redis/005.png" alt></p><blockquote><p>拷贝 redis.conf 到 /usr/local/redis/etc下</p></blockquote><pre><code>cp /usr/local/redis/redis.conf /usr/local/redis/etc/</code></pre><blockquote><p>把/usr/local/redis/src目录下的mkreleasehdr.sh，redis-benchmark， redis-check-rdb， redis-cli， redis-server拷贝到bin目录</p></blockquote><pre><code>cp redis-benchmark /usr/local/redis/bin/cp redis-check-rdb /usr/local/redis/bin/cp redis-cli /usr/local/redis/bin/cp redis-server /usr/local/redis/bin/</code></pre><blockquote><p>修改redis.conf</p></blockquote><pre class=" language-xml"><code class="language-xml">#修改为守护模式daemonize yes#设置进程锁文件pidfile /usr/local/redis/redis.pid#端口port 6379#客户端超时时间timeout 300#日志级别loglevel debug#日志文件位置logfile /usr/local/redis/log-redis.log#设置数据库的数量，默认数据库为0，可以使用SELECT <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dbid</span><span class="token punctuation">></span></span>命令在连接上指定数据库iddatabases 16##指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合#save <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>seconds</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>changes</span><span class="token punctuation">></span></span>#Redis默认配置文件中提供了三个条件：save 900 1save 300 10save 60 10000#指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，#可以关闭该#选项，但会导致数据库文件变的巨大rdbcompression yes#指定本地数据库文件名dbfilename dump.rdb#指定本地数据库路径dir /usr/local/redis/db/#指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能#会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有#的数据会在一段时间内只存在于内存中appendonly no#指定更新日志条件，共有3个可选值：#no：表示等操作系统进行数据缓存同步到磁盘（快）#always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）#everysec：表示每秒同步一次（折衷，默认值）appendfsync everysec</code></pre><blockquote><p>启动服务</p></blockquote><pre><code>r</code></pre><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/09/mac-xia-an-zhuang-redis/007.png" alt></p><blockquote><p>查看日志</p></blockquote><pre><code>tail -f log-redis.log</code></pre><blockquote><p>打开redis客户端</p></blockquote><pre><code>./bin/redis-cli</code></pre><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/09/mac-xia-an-zhuang-redis/008.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot启动原理</title>
      <link href="/2019/07/08/springboot-qi-dong-yuan-li/"/>
      <url>/2019/07/08/springboot-qi-dong-yuan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot启动原理"><a href="#SpringBoot启动原理" class="headerlink" title="SpringBoot启动原理"></a>SpringBoot启动原理</h1><blockquote><p>熟悉而又陌生的启动类：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>springcloud<span class="token punctuation">.</span>eureka<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>SpringApplication<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>SpringBootApplication<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>cloud<span class="token punctuation">.</span>netflix<span class="token punctuation">.</span>eureka<span class="token punctuation">.</span>server<span class="token punctuation">.</span>EnableEurekaServer<span class="token punctuation">;</span><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EurekaApplication</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>EurekaApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>可以看到，此类中添加了注解 @SpringBootApplication，main 方法里通过 SpringApplication.run 来启动整个应用程序。因此要研究 Spring Boot 的启动原理，我们就需要从这个注解和这个run方法入手。</p></blockquote><h4 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="SpringBootApplication"></a>SpringBootApplication</h4><blockquote><p>首先，我们先来看看 SpringBootApplication 源码是怎么定义这个注解的：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Inherited</span><span class="token annotation punctuation">@SpringBootConfiguration</span><span class="token annotation punctuation">@EnableAutoConfiguration</span><span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span>excludeFilters <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token annotation punctuation">@Filter</span><span class="token punctuation">(</span>type <span class="token operator">=</span> FilterType<span class="token punctuation">.</span>CUSTOM<span class="token punctuation">,</span> classes <span class="token operator">=</span> TypeExcludeFilter<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token annotation punctuation">@Filter</span><span class="token punctuation">(</span>type <span class="token operator">=</span> FilterType<span class="token punctuation">.</span>CUSTOM<span class="token punctuation">,</span> classes <span class="token operator">=</span> AutoConfigurationExcludeFilter<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">SpringBootApplication</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@AliasFor</span><span class="token punctuation">(</span>annotation <span class="token operator">=</span> EnableAutoConfiguration<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">exclude</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@AliasFor</span><span class="token punctuation">(</span>annotation <span class="token operator">=</span> EnableAutoConfiguration<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">excludeName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@AliasFor</span><span class="token punctuation">(</span>annotation <span class="token operator">=</span> ComponentScan<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> attribute <span class="token operator">=</span> <span class="token string">"basePackages"</span><span class="token punctuation">)</span>    String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">scanBasePackages</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@AliasFor</span><span class="token punctuation">(</span>annotation <span class="token operator">=</span> ComponentScan<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> attribute <span class="token operator">=</span> <span class="token string">"basePackageClasses"</span><span class="token punctuation">)</span>    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">scanBasePackageClasses</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>可以看到，除了最基础的注解外，还增加了三个</p><ul><li>@SpringBootConfiguration</li><li>@EnableAutoConfiguration</li><li>@ComponentScan</li></ul><p>这里我们可以将 SpringBootApplication 替换成上面三个注解也是相同的效果：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>springcloud<span class="token punctuation">.</span>eureka<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>SpringApplication<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>SpringBootApplication<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>cloud<span class="token punctuation">.</span>netflix<span class="token punctuation">.</span>eureka<span class="token punctuation">.</span>server<span class="token punctuation">.</span>EnableEurekaServer<span class="token punctuation">;</span><span class="token annotation punctuation">@SpringBootConfiguration</span><span class="token annotation punctuation">@EnableAutoConfiguration</span><span class="token annotation punctuation">@ComponentScan</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EurekaApplication</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>EurekaApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>但是如果咱们每次都写这三个注解那岂不是很麻烦吗？所以我们只要写一个注解 @SpringBootApplication 就ok了。</p><p>下面，我们分别来介绍这三个注解。</p></blockquote><h4 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="SpringBootConfiguration"></a>SpringBootConfiguration</h4><blockquote><p>我们先来看看SpringBootConfiguration的源码：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Documented<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>ElementType<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Retention<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>RetentionPolicy<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Target<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Configuration<span class="token punctuation">;</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">SpringBootConfiguration</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><blockquote><p>该注解上有个注解@Configuration ，所以可以得知@SpringBootConfiguration 就是 @Configuration ，但是Spring Boot推荐用 SpringBootConfiguration 来代替 Configuration。同时Spring Boot 社区推荐使用 JavaConfig 配置，所以要用到 @Configuration。</p><p>回到配置Spring的年代，我们来看看是如何实现的。先从 SpringMVC 中基于 xml是如何配置开始：</p></blockquote><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd<span class="token punctuation">"</span></span> <span class="token attr-name">default-lazy-init</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--bean定义--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">></span></span></code></pre><blockquote><p>而 EurekaConfig 的配置是这样的</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>SpringBootConfiguration<span class="token punctuation">;</span><span class="token annotation punctuation">@SpringBootConfiguration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EurekaConfig</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//bean定义</span> <span class="token annotation punctuation">@Bean</span> <span class="token keyword">public</span> UserService <span class="token function">service</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>             <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">UserServiceImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>任何标注了 Bean 的方法都被定义为一个 Bean，我们可以在任何 Spring 的 IoC 容器中注入进去。</p></blockquote><h4 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="EnableAutoConfiguration"></a>EnableAutoConfiguration</h4><blockquote><p>这个注解的作用就是自动将 EurekaConfig中的 Bean 装载到 IoC 容器中。</p><p>先看看期源码：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Inherited</span><span class="token annotation punctuation">@AutoConfigurationPackage</span><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span>AutoConfigurationImportSelector<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">EnableAutoConfiguration</span> <span class="token punctuation">{</span>    String ENABLED_OVERRIDE_PROPERTY <span class="token operator">=</span> <span class="token string">"spring.boot.enableautoconfiguration"</span><span class="token punctuation">;</span>    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">exclude</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">excludeName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>该注解引入了 @AutoConfigurationPackage 注解，通过其字面意思，就知道它的作用是自动配置 Package，即它会默认配置启动类所在包及其子包下的所有标注了 Configuration 注解的类。</p><p>而以上注解使用 @Import 注解，该注解的作用是自动执行该注解指定的类。在上述注解中，其导入了 AutoConfigurationImportSelector 类，通过其类名就知道该类的作用是自动配置选择器，因此，我们使用了 @EnableAutoConfiguration 注解后，它就会自动执行 AutoConfigurationImportSelector 类，最终会调用哪个方法呢？请看它的源码：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Group</span><span class="token operator">></span> <span class="token function">getImportGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">return</span> AutoConfigurationGroup<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>程序启动后，只要标注了 @EnableAutoConfiguration 注解，那么最后会调用 getImportGroup 方法，它返回的是一个 Group 对象。而上述代码中 AutoConfigurationGroup 继承的是 Group 接口，通过查看 Group 源码得知，Group 接口被定义在 DeferredImportSelector 接口中，继续查看 AutoConfigurationGroup 类的代码，我们发现以下源码：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span>AnnotationMetadata annotationMetadata<span class="token punctuation">,</span>                        DeferredImportSelector deferredImportSelector<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Assert<span class="token punctuation">.</span><span class="token function">state</span><span class="token punctuation">(</span>                deferredImportSelector <span class="token keyword">instanceof</span> <span class="token class-name">AutoConfigurationImportSelector</span><span class="token punctuation">,</span>                <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> String<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"Only %s implementations are supported, got %s"</span><span class="token punctuation">,</span>                        AutoConfigurationImportSelector<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getSimpleName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                        deferredImportSelector<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        AutoConfigurationEntry autoConfigurationEntry <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>AutoConfigurationImportSelector<span class="token punctuation">)</span> deferredImportSelector<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">getAutoConfigurationEntry</span><span class="token punctuation">(</span><span class="token function">getAutoConfigurationMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                        annotationMetadata<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>autoConfigurationEntries<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>autoConfigurationEntry<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>String importClassName <span class="token operator">:</span> autoConfigurationEntry<span class="token punctuation">.</span><span class="token function">getConfigurations</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>entries<span class="token punctuation">.</span><span class="token function">putIfAbsent</span><span class="token punctuation">(</span>importClassName<span class="token punctuation">,</span> annotationMetadata<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Iterable<span class="token operator">&lt;</span>Entry<span class="token operator">></span> <span class="token function">selectImports</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>autoConfigurationEntries<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> Collections<span class="token punctuation">.</span><span class="token function">emptyList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        Set<span class="token operator">&lt;</span>String<span class="token operator">></span> allExclusions <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>autoConfigurationEntries<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>AutoConfigurationEntry<span class="token operator">:</span><span class="token operator">:</span>getExclusions<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span>Collection<span class="token operator">:</span><span class="token operator">:</span>stream<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Set<span class="token operator">&lt;</span>String<span class="token operator">></span> processedConfigurations <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>autoConfigurationEntries<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>AutoConfigurationEntry<span class="token operator">:</span><span class="token operator">:</span>getConfigurations<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span>Collection<span class="token operator">:</span><span class="token operator">:</span>stream<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toCollection</span><span class="token punctuation">(</span>LinkedHashSet<span class="token operator">:</span><span class="token operator">:</span><span class="token keyword">new</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        processedConfigurations<span class="token punctuation">.</span><span class="token function">removeAll</span><span class="token punctuation">(</span>allExclusions<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">sortAutoConfigurations</span><span class="token punctuation">(</span>processedConfigurations<span class="token punctuation">,</span>                <span class="token function">getAutoConfigurationMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span>importClassName<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">(</span>                        <span class="token keyword">this</span><span class="token punctuation">.</span>entries<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>importClassName<span class="token punctuation">)</span><span class="token punctuation">,</span> importClassName<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><blockquote><p>也就是说最终会自动执行 process 和 selectImports 方法。</p><p>可以注意到 autoConfigurationEntry.getConfigurations()，它就是获取所有标注了 @Configuration 注解的类，并加入到 Map 中。</p><p>需要注意的是，AutoConfigurationImportSelector 类实现的是 DeferredImportSelector 接口，而 process 是 DeferredImportSelector.Group 接口定义的方法。</p></blockquote><h4 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="ComponentScan"></a>ComponentScan</h4><blockquote><p>这个注解的作用是自动扫描并加载符合条件的组件（如：Component、Bean 等），我们可以通过 basePakcages 来指定其扫描的范围，如果不指定，则默认从标注了 @ComponentScan 注解的类所在包开始扫描。如下代码：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span>basePackages <span class="token operator">=</span> <span class="token string">"com.lawt"</span><span class="token punctuation">)</span></code></pre><blockquote><p>因此，Spring Boot 的启动类最好放在 root package 下面，因为默认不指定 basePackages，这样能保证扫描到所有包。</p></blockquote><h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/08/springboot-qi-dong-yuan-li/001.jpeg" alt></p><blockquote><p>启动类先调用了 SpringApplication 的静态方法 run，跟踪进去后发现，它会先实例化 SpringApplication，然后调用 run 方法。</p></blockquote><pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> <span class="token keyword">static</span> ConfigurableApplicationContext <span class="token function">run</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> primarySources<span class="token punctuation">,</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SpringApplication</span><span class="token punctuation">(</span>primarySources<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><blockquote><p>所以，要分析它的启动源码，首先要分析 SpringApplicaiton 的构造过程。</p></blockquote><h4 id="SpringApplication-构造器"><a href="#SpringApplication-构造器" class="headerlink" title="SpringApplication 构造器"></a>SpringApplication 构造器</h4><blockquote><p>在 SpringApplication 构造函数内部，他会初始化一些信息：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">SpringApplication</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> primarySources<span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token keyword">this</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> primarySources<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token function">SpringApplication</span><span class="token punctuation">(</span>ResourceLoader resourceLoader<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> primarySources<span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token keyword">this</span><span class="token punctuation">.</span>resourceLoader <span class="token operator">=</span> resourceLoader<span class="token punctuation">;</span>            Assert<span class="token punctuation">.</span><span class="token function">notNull</span><span class="token punctuation">(</span>primarySources<span class="token punctuation">,</span> <span class="token string">"PrimarySources must not be null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token keyword">this</span><span class="token punctuation">.</span>primarySources <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>primarySources<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token keyword">this</span><span class="token punctuation">.</span>webApplicationType <span class="token operator">=</span> WebApplicationType<span class="token punctuation">.</span><span class="token function">deduceFromClasspath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token function">setInitializers</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Collection<span class="token punctuation">)</span> <span class="token function">getSpringFactoriesInstances</span><span class="token punctuation">(</span>             ApplicationContextInitializer<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token function">setListeners</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Collection<span class="token punctuation">)</span> <span class="token function">getSpringFactoriesInstances</span><span class="token punctuation">(</span>ApplicationListener<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token keyword">this</span><span class="token punctuation">.</span>mainApplicationClass <span class="token operator">=</span> <span class="token function">deduceMainApplicationClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><blockquote><p>通过上述代码，我们分析到 SpringApplication 实例化时有以下几个步骤：</p><p>1.将所有 sources 加入到全局 sources 中，目前只有一个 Application。</p><p>2.判断是否为 Web 程序（javax.servlet.Servlet、</p><p>org.springframework.web.context.ConfigurableWebApplicationContext 这两个类必须存在于类加载器中）。</p><p>判断过程可以参看以下源码：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> WebApplicationType <span class="token function">deduceFromClasspath</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ClassUtils<span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token string">"org.springframework.web.reactive.DispatcherHandler"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>ClassLoader<span class="token punctuation">)</span>null<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>ClassUtils<span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token string">"org.springframework.web.servlet.DispatcherServlet"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>ClassLoader<span class="token punctuation">)</span>null<span class="token punctuation">)</span>  <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>ClassUtils<span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token string">"org.glassfish.jersey.servlet.ServletContainer"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>ClassLoader<span class="token punctuation">)</span>null<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> REACTIVE<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> var0 <span class="token operator">=</span> SERVLET_INDICATOR_CLASSES<span class="token punctuation">;</span> <span class="token keyword">int</span> var1 <span class="token operator">=</span> var0<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> var2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> var2 <span class="token operator">&lt;</span> var1<span class="token punctuation">;</span> <span class="token operator">++</span>var2<span class="token punctuation">)</span> <span class="token punctuation">{</span> String className <span class="token operator">=</span> var0<span class="token punctuation">[</span>var2<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ClassUtils<span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span>className<span class="token punctuation">,</span> <span class="token punctuation">(</span>ClassLoader<span class="token punctuation">)</span>null<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> NONE<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span> <span class="token keyword">return</span> SERVLET<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><blockquote><p>3.设置应用程序初始化器 ApplicationContextInitializer，做一些初始化的工作。</p><p>4.设置应用程序事件监听器 ApplicationListener。</p><p>5.找出启动类，设置到 mainApplicationClass 中。</p></blockquote><h4 id="SpringApplication-的执行流程"><a href="#SpringApplication-的执行流程" class="headerlink" title="SpringApplication 的执行流程"></a>SpringApplication 的执行流程</h4><blockquote><p>SpringApplication 构造完成后，就会调用 run 方法，这时才真正的开始应用程序的执行。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> ConfigurableApplicationContext <span class="token function">run</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        StopWatch stopWatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StopWatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stopWatch<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ConfigurableApplicationContext context <span class="token operator">=</span> null<span class="token punctuation">;</span>        FailureAnalyzers analyzers <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token function">configureHeadlessProperty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        SpringApplicationRunListeners listeners <span class="token operator">=</span> <span class="token function">getRunListeners</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//1.获取监听器</span>        listeners<span class="token punctuation">.</span><span class="token function">starting</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// -->启动！</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            ApplicationArguments applicationArguments <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultApplicationArguments</span><span class="token punctuation">(</span>                    args<span class="token punctuation">)</span><span class="token punctuation">;</span>            ConfigurableEnvironment environment <span class="token operator">=</span> <span class="token function">prepareEnvironment</span><span class="token punctuation">(</span>listeners<span class="token punctuation">,</span><span class="token comment" spellcheck="true">//2.准备好环境，触发ApplicationEnvironmentPreparedEvent事件</span>                    applicationArguments<span class="token punctuation">)</span><span class="token punctuation">;</span>            Banner printedBanner <span class="token operator">=</span> <span class="token function">printBanner</span><span class="token punctuation">(</span>environment<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//打印启动提示字符，默认spring的字符图</span>            context <span class="token operator">=</span> <span class="token function">createApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//实例化一个可配置应用上下文</span>            analyzers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FailureAnalyzers</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">prepareContext</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> environment<span class="token punctuation">,</span> listeners<span class="token punctuation">,</span> applicationArguments<span class="token punctuation">,</span><span class="token comment" spellcheck="true">//3.准备上下文</span>                    printedBanner<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">refreshContext</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//4.刷新上下文</span>            <span class="token function">afterRefresh</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> applicationArguments<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//5.刷新上下文后</span>            listeners<span class="token punctuation">.</span><span class="token function">finished</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">--</span>关闭！            stopWatch<span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>logStartupInfo<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">new</span> <span class="token class-name">StartupInfoLogger</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>mainApplicationClass<span class="token punctuation">)</span>                        <span class="token punctuation">.</span><span class="token function">logStarted</span><span class="token punctuation">(</span><span class="token function">getApplicationLog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> stopWatch<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> context<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">handleRunFailure</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> listeners<span class="token punctuation">,</span> analyzers<span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/08/springboot-qi-dong-yuan-li/002.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>负载均衡</title>
      <link href="/2019/07/07/fu-zai-jun-heng/"/>
      <url>/2019/07/07/fu-zai-jun-heng/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="负载神器-LVS、Nginx及HAProxy工作原理"><a href="#负载神器-LVS、Nginx及HAProxy工作原理" class="headerlink" title="负载神器 LVS、Nginx及HAProxy工作原理"></a>负载神器 LVS、Nginx及HAProxy工作原理</h1><blockquote><p>​        当前大多数的互联网系统都使用了服务器集群技术，集群是将相同服务部署在多台服务器上构成一个集群整体对外提供服务，这些集群可以是 Web 应用服务器集群，也可以是数据库服务器集群，还可以是分布式缓存服务器集群等等。</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/07/fu-zai-jun-heng/001.png" alt></p><blockquote><p>​        在实际应用中，在 Web 服务器集群之前总会有一台负载均衡服务器，负载均衡设备的任务就是作为 Web 服务器流量的入口，挑选最合适的一台 Web 服务器，将客户端的请求转发给它处理，实现客户端到真实服务端的透明转发。</p><p>​        最近几年很火的「云计算」以及分布式架构，本质上也是将后端服务器作为计算资源、存储资源，由某台管理服务器封装成一个服务对外提供，客户端不需要关心真正提供服务的是哪台机器，在它看来，就好像它面对的是一台拥有近乎无限能力的服务器，而本质上，真正提供服务的，是后端的集群。</p></blockquote><h3 id="LVS、Nginx、HAProxy-是目前使用最广泛的三种负载均衡软件。"><a href="#LVS、Nginx、HAProxy-是目前使用最广泛的三种负载均衡软件。" class="headerlink" title="LVS、Nginx、HAProxy 是目前使用最广泛的三种负载均衡软件。"></a>LVS、Nginx、HAProxy 是目前使用最广泛的三种负载均衡软件。</h3><blockquote><p>​        一般对负载均衡的使用是随着网站规模的提升根据不同的阶段来使用不同的技术。具体的应用需求还得具体分析，如果是中小型的 Web 应用，比如日 PV 小于1000万，用 Nginx 就完全可以了；如果机器不少，可以用 DNS 轮询，LVS 所耗费的机器还是比较多的；大型网站或重要的服务，且服务器比较多时，可以考虑用 LVS。</p><p>​        目前关于网站架构一般比较合理流行的架构方案：Web 前端采用 Nginx/HAProxy+Keepalived 作负载均衡器；后端采用 MySQ L数据库一主多从和读写分离，采用 LVS+Keepalived 的架构。</p></blockquote><h4 id="一、LVS"><a href="#一、LVS" class="headerlink" title="一、LVS"></a>一、LVS</h4><blockquote><p>​        LVS 是 Linux Virtual Server 的简称，也就是 Linux 虚拟服务器。现在 LVS 已经是 Linux 标准内核的一部分，从 Linux2.4 内核以后，已经完全内置了 LVS 的各个功能模块，无需给内核打任何补丁，可以直接使用 LVS 提供的各种功能。</p><p>​        LVS 自从1998年开始，发展到现在已经是一个比较成熟的技术项目了。</p></blockquote><h5 id="1、LVS-的体系结构"><a href="#1、LVS-的体系结构" class="headerlink" title="1、LVS 的体系结构"></a>1、LVS 的体系结构</h5><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/07/fu-zai-jun-heng/002.png" alt></p><blockquote><p>LVS 架设的服务器集群系统有三个部分组成：</p><p>(1) 最前端的负载均衡层，用 Load Balancer 表示</p><p>(2) 中间的服务器集群层，用 Server Array 表示</p><p>(3) 最底端的数据共享存储层，用 Shared Storage 表示</p></blockquote><h5 id="2、LVS-负载均衡机制"><a href="#2、LVS-负载均衡机制" class="headerlink" title="2、LVS 负载均衡机制"></a>2、LVS 负载均衡机制</h5><blockquote><p>LVS 不像 HAProxy 等七层软负载面向的是 HTTP 包，所以七层负载可以做的 URL 解析等工作，LVS 无法完成。</p><p>LVS 是四层负载均衡，也就是说建立在 OSI 模型的第四层——传输层之上，传输层上有我们熟悉的 TCP/UDP，LVS 支持 TCP/UDP 的负载均衡。因为 LVS 是四层负载均衡，因此它相对于其它高层负载均衡的解决办法，比如 DNS 域名轮流解析、应用层负载的调度、客户端的调度等，它的效率是非常高的。</p><p>所谓四层负载均衡 ，也就是主要通过报文中的目标地址和端口。七层负载均衡 ，也称为“内容交换”，也就是主要通过报文中的真正有意义的应用层内容。</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/07/fu-zai-jun-heng/003.png" alt></p><blockquote><p>LVS 的转发主要通过修改 IP 地址（NAT 模式，分为源地址修改 SNAT 和目标地址修改 DNAT）、修改目标 MAC（DR 模式）来实现。</p></blockquote><h5 id="3、NAT-模式：网络地址转换"><a href="#3、NAT-模式：网络地址转换" class="headerlink" title="3、NAT 模式：网络地址转换"></a>3、NAT 模式：网络地址转换</h5><blockquote><p>NAT（Network Address Translation）是一种外网和内网地址映射的技术。</p><p>NAT 模式下，网络数据报的进出都要经过 LVS 的处理。LVS 需要作为 RS（真实服务器）的网关。</p><p>当包到达 LVS 时，LVS 做目标地址转换（DNAT），将目标 IP 改为 RS 的 IP。RS 接收到包以后，仿佛是客户端直接发给它的一样。RS 处理完，返回响应时，源 IP 是 RS IP，目标 IP 是客户端的 IP。这时 RS 的包通过网关（LVS）中转，LVS 会做源地址转换（SNAT），将包的源地址改为 VIP，这样，这个包对客户端看起来就仿佛是 LVS 直接返回给它的。</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/07/fu-zai-jun-heng/004.png" alt></p><h5 id="4、DR-模式：直接路由"><a href="#4、DR-模式：直接路由" class="headerlink" title="4、DR 模式：直接路由"></a>4、DR 模式：直接路由</h5><blockquote><p>DR 模式下需要 LVS 和 RS 集群绑定同一个 VIP（RS 通过将 VIP 绑定在 loopback 实现），但与 NAT 的不同点在于：请求由 LVS 接受，由真实提供服务的服务器（RealServer，RS）直接返回给用户，返回的时候不经过 LVS。</p><p>详细来看，一个请求过来时，LVS 只需要将网络帧的 MAC 地址修改为某一台 RS 的 MAC，该包就会被转发到相应的 RS 处理，注意此时的源 IP 和目标 IP 都没变，LVS 只是做了一下移花接木。RS 收到 LVS 转发来的包时，链路层发现 MAC 是自己的，到上面的网络层，发现 IP 也是自己的，于是这个包被合法地接受，RS 感知不到前面有 LVS 的存在。而当 RS 返回响应时，只要直接向源 IP（即用户的 IP）返回即可，不再经过 LVS。</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/07/fu-zai-jun-heng/005.png" alt></p><blockquote><p>DR 负载均衡模式数据分发过程中不修改 IP 地址，只修改 mac 地址，由于实际处理请求的真实物理 IP 地址和数据请求目的 IP 地址一致，所以不需要通过负载均衡服务器进行地址转换，可将响应数据包直接返回给用户浏览器，避免负载均衡服务器网卡带宽成为瓶颈。因此，DR 模式具有较好的性能，也是目前大型网站使用最广泛的一种负载均衡手段。</p></blockquote><h5 id="5、LVS-的优点"><a href="#5、LVS-的优点" class="headerlink" title="5、LVS 的优点"></a>5、LVS 的优点</h5><blockquote><ul><li>抗负载能力强、是工作在传输层上仅作分发之用，没有流量的产生，这个特点也决定了它在负载均衡软件里的性能最强的，对内存和 cpu 资源消耗比较低。</li><li>配置性比较低，这是一个缺点也是一个优点，因为没有可太多配置的东西，所以并不需要太多接触，大大减少了人为出错的几率。</li><li>工作稳定，因为其本身抗负载能力很强，自身有完整的双机热备方案，如 LVS + Keepalived。</li><li>无流量，LVS 只分发请求，而流量并不从它本身出去，这点保证了均衡器 IO 的性能不会受到大流量的影响。</li><li>应用范围比较广，因为 LVS 工作在传输层，所以它几乎可以对所有应用做负载均衡，包括 http、数据库、在线聊天室等等。</li></ul></blockquote><h5 id="6、LVS-的缺点"><a href="#6、LVS-的缺点" class="headerlink" title="6、LVS 的缺点"></a>6、LVS 的缺点</h5><blockquote><ul><li>软件本身不支持正则表达式处理，不能做动静分离；而现在许多网站在这方面都有较强的需求，这个是 Nginx、HAProxy + Keepalived 的优势所在。</li><li>如果是网站应用比较庞大的话，LVS/DR + Keepalived 实施起来就比较复杂了，相对而言，Nginx / HAProxy + Keepalived 就简单多了。</li></ul></blockquote><h4 id="二、Nginx"><a href="#二、Nginx" class="headerlink" title="二、Nginx"></a>二、Nginx</h4><blockquote><p>Nginx 是一个强大的 Web 服务器软件，用于处理高并发的 HTTP 请求和作为反向代理服务器做负载均衡。具有高性能、轻量级、内存消耗少，强大的负载均衡能力等优势。</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/07/fu-zai-jun-heng/006.png" alt></p><h5 id="1、Nignx-的架构设计"><a href="#1、Nignx-的架构设计" class="headerlink" title="1、Nignx 的架构设计"></a>1、Nignx 的架构设计</h5><blockquote><p>​        相对于传统基于进程或线程的模型（Apache就采用这种模型）在处理并发连接时会为每一个连接建立一个单独的进程或线程，且在网络或者输入/输出操作时阻塞。这将导致内存和 CPU 的大量消耗，因为新起一个单独的进程或线程需要准备新的运行时环境，包括堆和栈内存的分配，以及新的执行上下文，当然，这些也会导致多余的 CPU 开销。最终，会由于过多的上下文切换而导致服务器性能变差。</p><p>反过来，Nginx 的架构设计是采用模块化的、基于事件驱动、异步、单线程且非阻塞。</p><p>​        Nginx 大量使用多路复用和事件通知，Nginx 启动以后，会在系统中以 daemon 的方式在后台运行，其中包括一个 master 进程，n(n&gt;=1) 个 worker 进程。所有的进程都是单线程（即只有一个主线程）的，且进程间通信主要使用共享内存的方式。</p><p>​        其中，master 进程用于接收来自外界的信号，并给 worker 进程发送信号，同时监控 worker 进程的工作状态。worker 进程则是外部请求真正的处理者，每个 worker 请求相互独立且平等的竞争来自客户端的请求。请求只能在一个 worker 进程中被处理，且一个 worker 进程只有一个主线程，所以同时只能处理一个请求。（原理同 Netty 很像）</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/07/fu-zai-jun-heng/007.png" alt></p><h5 id="2、Nginx-负载均衡"><a href="#2、Nginx-负载均衡" class="headerlink" title="2、Nginx 负载均衡"></a>2、Nginx 负载均衡</h5><blockquote><p>Nginx 负载均衡主要是对七层网络通信模型中的第七层应用层上的 http、https 进行支持。</p><p>Nginx 是以反向代理的方式进行负载均衡的。反向代理（Reverse Proxy）方式是指以代理服务器来接受 Internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 Internet 上请求连接的客户端，此时代理服务器对外就表现为一个服务器。</p><p>Nginx 实现负载均衡的分配策略有很多，Nginx 的 upstream 目前支持以下几种方式：</p><ul><li>轮询（默认）：每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器 down 掉，能自动剔除。</li><li>weight：指定轮询几率，weight 和访问比率成正比，用于后端服务器性能不均的情况。</li><li>ip_hash：每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器，可以解决 session 的问题。</li><li>fair（第三方）：按后端服务器的响应时间来分配请求，响应时间短的优先分配。</li><li>url_hash（第三方）：按访问 url 的 hash 结果来分配请求，使每个 url 定向到同一个后端服务器，后端服务器为缓存时比较有效。</li></ul></blockquote><h5 id="3、Nginx-的优点"><a href="#3、Nginx-的优点" class="headerlink" title="3、Nginx 的优点"></a>3、Nginx 的优点</h5><blockquote><ul><li>跨平台：Nginx 可以在大多数 Unix like OS编译运行，而且也有 Windows 的移植版本；</li><li>配置异常简单：非常容易上手。配置风格跟程序开发一样，神一般的配置；</li><li>非阻塞、高并发连接：官方测试能够支撑5万并发连接，在实际生产环境中跑到2～3万并发连接数；</li><li>事件驱动：通信机制采用 epoll 模型，支持更大的并发连接；</li><li>Master/Worker 结构：一个 master 进程，生成一个或多个 worker 进程；</li><li>内存消耗小：处理大并发的请求内存消耗非常小。在3万并发连接下，开启的10个 Nginx 进程才消耗150M 内存（15M*10=150M）；</li><li>内置的健康检查功能：如果 Nginx 代理的后端的某台 Web 服务器宕机了，不会影响前端访问；</li><li>节省带宽：支持 GZIP 压缩，可以添加浏览器本地缓存的 Header 头；</li><li>稳定性高：用于反向代理，宕机的概率微乎其微</li></ul></blockquote><h5 id="4、Nginx-的缺点"><a href="#4、Nginx-的缺点" class="headerlink" title="4、Nginx 的缺点"></a>4、Nginx 的缺点</h5><blockquote><ul><li>Nginx 仅能支 持http、https 、tcp、 Email等协议，这样就在适用范围上面小些，这个是它的缺点；</li><li>对后端服务器的健康检查，只支持通过端口来检测，不支持通过 ur l来检测。不支持 Session 的直接保持，但能通过 ip_hash 来解决；</li></ul></blockquote><h4 id="三、HAProxy"><a href="#三、HAProxy" class="headerlink" title="三、HAProxy"></a>三、HAProxy</h4><blockquote><p>HAProxy 支持两种代理模式 TCP（四层）和HTTP（七层），也是支持虚拟主机的。</p><p>HAProxy 的优点能够补充 Nginx 的一些缺点，比如支持 Session 的保持，Cookie 的引导；同时支持通过获取指定的 url 来检测后端服务器的状态。</p><p>HAProxy 跟 LVS 类似，本身就只是一款负载均衡软件；单纯从效率上来讲 HAProxy 会比 Nginx 有更出色的负载均衡速度，在并发处理上也是优于 Nginx 的。</p><p>HAProxy 支持 TCP 协议的负载均衡转发，可以对 MySQL 读进行负载均衡，对后端的 MySQL 节点进行检测和负载均衡，大家可以用 LVS+Keepalived 对 MySQL 主从做负载均衡。</p><p>HAProxy 负载均衡策略非常多：Round-robin（轮循）、Weight-round-robin（带权轮循）、source（原地址保持）、RI（请求URL）、rdp-cookie（根据cookie）。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 集群 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LVS </tag>
            
            <tag> Nginx </tag>
            
            <tag> HAProxy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机jvm类加载初始化</title>
      <link href="/2019/07/05/java-xu-ni-ji-jvm-lei-jia-zai-chu-shi-hua/"/>
      <url>/2019/07/05/java-xu-ni-ji-jvm-lei-jia-zai-chu-shi-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="Java虚拟机jvm类加载初始化"><a href="#Java虚拟机jvm类加载初始化" class="headerlink" title="Java虚拟机jvm类加载初始化"></a>Java虚拟机jvm类加载初始化</h1><h4 id="一、Classloader的作用"><a href="#一、Classloader的作用" class="headerlink" title="一、Classloader的作用"></a>一、Classloader的作用</h4><blockquote><p>概括来说就是将编译后的class装载、加载到机器内存中，为了以后的程序的执行提供前提条件。</p></blockquote><h4 id="二、java类在虚拟机（jvm）中的工作原理"><a href="#二、java类在虚拟机（jvm）中的工作原理" class="headerlink" title="二、java类在虚拟机（jvm）中的工作原理"></a>二、java类在虚拟机（jvm）中的工作原理</h4><blockquote><p>1）类加载load：从字节码二进制文件——.class文件将类加载到内存，从而达到类的从硬盘上到内存上的一个迁移，所有的程序必须加载到内存才能工作。将内存中的class放到运行时数据区的方法区内，之后在堆区建立一个java.lang.Class对象，用来封装方法区的数据结构。这个时候就体现出了万事万物皆对象了，干什么事情都得有个对象。就是到了最底层究竟是鸡生蛋，还是蛋生鸡呢？类加载的最终产物就是堆中的一个java.lang.Class对象。</p></blockquote><blockquote><p><strong>2）连接：连接又分为以下小步骤</strong></p><p><strong>验证：</strong>出于安全性的考虑，验证内存中的字节码是否符合JVM的规范，类的结构规范、语义检查、字节码操作是否合法、这个是为了防止用户自己建立一个非法的XX.class文件就进行工作了，或者是JVM版本冲突的问题，比如在JDK6下面编译通过的class（其中包含注解特性的类），是不能在JDK1.4的JVM下运行的。</p><p><strong>准备：</strong>将类的静态变量进行分配内存空间、初始化默认值。（对象还没生成呢，所以这个时候没有实例变量什么事情）</p><p><strong>解析：</strong>把类的符号引用转为直接引用（保留）</p></blockquote><blockquote><p><strong>3）类的初始化：</strong> 将类的静态变量赋予正确的初始值，这个初始值是开发者自己定义时赋予的初始值，而不是默认值。</p></blockquote><h4 id="三、类的主动使用与被动使用"><a href="#三、类的主动使用与被动使用" class="headerlink" title="三、类的主动使用与被动使用"></a>三、类的主动使用与被动使用</h4><blockquote><p>以下是视为主动使用一个类，其他情况均视为被动使用！</p><p>1）初学者最为常用的new一个类的实例对象（声明不叫主动使用）</p><p>2）对类的静态变量进行读取、赋值操作的。</p><p>3）直接调用类的静态方法。</p><p>4）反射调用一个类的方法。</p><p>5）初始化一个类的子类的时候，父类也相当于被程序主动调用了（如果调用子类的静态变量是从父类继承过来并没有复写的，那么也就相当于只用到了父类的东东，和子类无关，所以这个时候子类不需要进行类初始化）。</p><p>6）直接运行一个main函数入口的类。</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/05/java-xu-ni-ji-jvm-lei-jia-zai-chu-shi-hua/001.png" alt></p><blockquote><p>所有的JVM实现（不同的厂商有不同的实现，有人就说IBM的实现比Sun的要好……）在首次主动调用类和接口的时候才会初始化他们。</p></blockquote><h4 id="四、-类的加载方式"><a href="#四、-类的加载方式" class="headerlink" title="四、 类的加载方式"></a>四、 类的加载方式</h4><blockquote><p>1）：本地编译好的class中直接加载</p><p>2）：网络加载：java.net.URLClassLoader可以加载url指定的类</p><p>3）：从jar、zip等等压缩文件加载类，自动解析jar文件找到class文件去加载util类</p><p>4）：从java源代码文件动态编译成为class文件</p></blockquote><h4 id="五、类加载器"><a href="#五、类加载器" class="headerlink" title="五、类加载器"></a>五、类加载器</h4><blockquote><p>JVM自带的默认加载器</p><p>1）：根类加载器：bootstrap，由C++编写，所有Java程序无法获得。</p><p>2）：扩展类加载器：由Java编写。</p><p>3）：系统类、应用类加载器：由Java编写。</p><p>用户自定义的类加载器：java.lang.ClassLoader的子类，用户可以定制类的加载方式。每一个类都包含了加载他的ClassLoader的一个引用——getClass().getClassLoader()。如果返回的是null，证明加载他的ClassLoader是根加载器bootstrap。</p><p>如下代码</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException <span class="token punctuation">{</span>         Class <span class="token class-name">clazz</span> <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"java.lang.String"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>clazz<span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><blockquote><p>结果是null，证明java.lang.String是根类加载器去加载的。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>         Singleton mysingleton <span class="token operator">=</span> Singleton<span class="token punctuation">.</span><span class="token function">GetInstence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>mysingleton<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><blockquote><p>结果是sun.misc.Launcher$AppClassLoader@19821f，证明是AppClassLoader（系统类、应用类加载器）去加载的。像jre的rt.jar下面的java.lang.*都是默认的根类加载器去加载这些运行时的类。</p></blockquote><h4 id="六、解释类连接阶段的准备"><a href="#六、解释类连接阶段的准备" class="headerlink" title="六、解释类连接阶段的准备"></a>六、解释类连接阶段的准备</h4><blockquote><p>类的如下代码片段</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> a<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></code></pre><blockquote><p>在这个阶段，加载器会按照结构化似的，从上到下流程将静态变量int类型分配4个字节的空间，并且为其赋予默认值0，而像b = 10这段代码在此阶段是不起作用的，b仍然是默认值0。</p></blockquote><h4 id="七、解释类连接阶段的解析"><a href="#七、解释类连接阶段的解析" class="headerlink" title="七、解释类连接阶段的解析"></a>七、解释类连接阶段的解析</h4><blockquote><p>这里面的指针就是C++的指针</p></blockquote><h4 id="八、ClassLoader的剖析"><a href="#八、ClassLoader的剖析" class="headerlink" title="八、ClassLoader的剖析"></a>八、ClassLoader的剖析</h4><blockquote><p>ClassLoader的loadClass方法加载一个类不属于主动调用，不会导致类的初始化。如下代码块</p></blockquote><pre class=" language-java"><code class="language-java">  ClassLoader classLoader <span class="token operator">=</span> ClassLoader<span class="token punctuation">.</span><span class="token function">getSystemClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> clazz <span class="token operator">=</span> classLoader<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token string">"test01.ClassDemo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>并不会让类加载器初始化test01.ClassDemo，因为这不属于主动调用此类。</p></blockquote><p><strong>lassLoader的关系：</strong></p><blockquote><p><strong>根加载器——》扩展类加载器——》应用类加载器——》用户自定义类加载器</strong></p></blockquote><blockquote><p><strong>加载类的过程是首先从根加载器开始加载、根加载器加载不了的，由扩展类加载器加载，再加载不了的有应用加载器加载，应用加载器如果还加载不了就由自定义的加载器（一定继承自java.lang. ClassLoader）加载、如果自定义的加载器还加载不了。</strong>而且下面已经没有再特殊的类加载器了，就会抛出ClassNotFoundException，表面上异常是类找不到，实际上是class加载失败，更不能创建该类的Class对象。</p><p>若一个类能在某一层类加载器成功加载，那么这一层的加载器称为定义类加载器。那么在这层类生成的Class引用返回下一层加载器叫做初始类加载器。因为加载成功后返回一个Class引用给它的服务对象——也就是调用它的类加载器。考虑到安全，父委托加载机制。</p><p>ClassLoader加载类的原代码如下</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">synchronized</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">loadClass</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> resolve<span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException<span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// First, check if the class has already been loaded</span>        Class <span class="token class-name">c</span> <span class="token operator">=</span> <span class="token function">findLoadedClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    c <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    c <span class="token operator">=</span> <span class="token function">findBootstrapClassOrNull</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// ClassNotFoundException thrown if class not found</span>                <span class="token comment" spellcheck="true">// from the non-null parent class loader</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// If still not found, then invoke findClass in order</span>                <span class="token comment" spellcheck="true">// to find the class.</span>                c <span class="token operator">=</span> <span class="token function">findClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">resolveClass</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> c<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><blockquote><p>初始化系统ClassLoader代码如下</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">initSystemClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>sclSet<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>scl <span class="token operator">!=</span> null<span class="token punctuation">)</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"recursive invocation"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>Launcher l <span class="token operator">=</span> sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>Launcher<span class="token punctuation">.</span><span class="token function">getLauncher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                Throwable oops <span class="token operator">=</span> null<span class="token punctuation">;</span>                scl <span class="token operator">=</span> l<span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    PrivilegedExceptionAction a<span class="token punctuation">;</span>                    a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SystemClassLoaderAction</span><span class="token punctuation">(</span>scl<span class="token punctuation">)</span><span class="token punctuation">;</span>                    scl <span class="token operator">=</span> <span class="token punctuation">(</span>ClassLoader<span class="token punctuation">)</span> AccessController<span class="token punctuation">.</span><span class="token function">doPrivileged</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">PrivilegedActionException</span> pae<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    oops <span class="token operator">=</span> pae<span class="token punctuation">.</span><span class="token function">getCause</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>oops <span class="token keyword">instanceof</span> <span class="token class-name">InvocationTargetException</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        oops <span class="token operator">=</span> oops<span class="token punctuation">.</span><span class="token function">getCause</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>oops <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>oops <span class="token keyword">instanceof</span> <span class="token class-name">Error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">throw</span> <span class="token punctuation">(</span>Error<span class="token punctuation">)</span> oops<span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">// wrap the exception</span>                        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>oops<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            sclSet <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><blockquote><p>它里面调用了很多native的方法，也就是通过JNI调用底层C++的代码。</p></blockquote><h4 id="九、类（class）的生命周期"><a href="#九、类（class）的生命周期" class="headerlink" title="九、类（class）的生命周期"></a>九、类（class）的生命周期</h4><blockquote><p>当一个类被加载、连接、初始化后，它的生命周期就开始了，当代表该类的Class对象不再被引用、即已经不可触及的时候，Class对象的生命周期结束。那么该类的方法区内的数据也会被卸载，从而结束该类的生命周期。一个类的生命周期取决于它Class对象的生命周期。由Java虚拟机自带的默认加载器（根加载器、扩展加载器、系统加载器）所加载的类在JVM生命周期中始终不被卸载。所以这些类的Class对象（我称其为实例的模板对象）始终能被触及！而由用户自定义的类加载器所加载的类会被卸载掉！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 日常学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac下安装RabbitMq</title>
      <link href="/2019/07/04/mac-xia-an-zhuang-rabbitmq/"/>
      <url>/2019/07/04/mac-xia-an-zhuang-rabbitmq/</url>
      
        <content type="html"><![CDATA[<h1 id="Mac下安装RabbitMq"><a href="#Mac下安装RabbitMq" class="headerlink" title="Mac下安装RabbitMq"></a>Mac下安装RabbitMq</h1><blockquote><p>下载地址：<a href="https://www.rabbitmq.com/install-standalone-mac.html" target="_blank" rel="noopener">https://www.rabbitmq.com/install-standalone-mac.html</a></p></blockquote><p>先安装 Homebrew</p><p>ruby -e “$(curl -fsSL <a href="https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;" target="_blank" rel="noopener">https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</a></p><p>安装完查看版本</p><pre><code>brew --version</code></pre><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/04/mac-xia-an-zhuang-rabbitmq/001.png" alt></p><p>安装</p><pre><code>brew install rabbitmq</code></pre><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/04/mac-xia-an-zhuang-rabbitmq/002.png" alt></p><blockquote><p>首次安装，下载一些相关的包</p></blockquote><blockquote><p>真正安装rabbitmq</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/04/mac-xia-an-zhuang-rabbitmq/003.png" alt></p><pre><code>## 进入安装目录cd /usr/local/Cellar/rabbitmq/3.7.5# 启动brew services start rabbitmq# 当前窗口启动rabbitmq-server</code></pre><p>启动控制台之前需要先开启插件</p><pre><code>./rabbitmq-plugins enable rabbitmq_management</code></pre><p>启动成功</p><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/04/mac-xia-an-zhuang-rabbitmq/005.png" alt></p><blockquote><p>浏览器访问：<a href="http://localhost:15761" target="_blank" rel="noopener">http://localhost:15761</a></p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/04/mac-xia-an-zhuang-rabbitmq/006.png" alt></p><blockquote><p>用户名：guest</p><p>密    码：guest</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/04/mac-xia-an-zhuang-rabbitmq/007.png" alt></p><h3 id="II-配置与测试"><a href="#II-配置与测试" class="headerlink" title="II. 配置与测试"></a>II. 配置与测试</h3><h4 id="1-添加账号"><a href="#1-添加账号" class="headerlink" title="1. 添加账号"></a>1. 添加账号</h4><blockquote><p>首先是得启动mq</p></blockquote><pre><code>`## 添加账号./rabbitmqctl add_user admin admin## 添加访问权限./rabbitmqctl set_permissions -p &quot;/&quot; admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;## 设置超级权限./rabbitmqctl set_user_tags admin administrator`</code></pre><h4 id="2-编码实测"><a href="#2-编码实测" class="headerlink" title="2. 编码实测"></a>2. 编码实测</h4><blockquote><p>pom引入依赖</p></blockquote><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.rabbitmq<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>amqp-client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><blockquote><p>代码示例</p><p>生产者</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>rabbitmq<span class="token punctuation">.</span>zms<span class="token punctuation">.</span>rabbitmqdemo<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>rabbitmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>Channel<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>rabbitmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>Connection<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>rabbitmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>ConnectionFactory<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>Test<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeoutException<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019-07-07 * @Time: 09:41 * @Vsersion: 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RabbitMqDemo01</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//消息队列名称</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> String QUEUE_NAME <span class="token operator">=</span> <span class="token string">"Hello RabbitMq"</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">producers</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">,</span> TimeoutException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//创建连接工程</span>        ConnectionFactory factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConnectionFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span><span class="token function">setHost</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span><span class="token function">setPort</span><span class="token punctuation">(</span><span class="token number">5672</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span><span class="token string">"admin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">"admin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//创建连接</span>        Connection connection <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">newConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//创建消息通道</span>        Channel channel <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">createChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//生成一个消息队列</span>        channel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span>QUEUE_NAME<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            String message <span class="token operator">=</span> <span class="token string">"Hello World RabbitMQ count: "</span> <span class="token operator">+</span> i<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//发布消息，第一个参数表示路由（Exchange名称），未""则表示使用默认消息路由</span>            channel<span class="token punctuation">.</span><span class="token function">basicPublish</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> QUEUE_NAME<span class="token punctuation">,</span> null<span class="token punctuation">,</span> message<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"生产者------>producers()'"</span> <span class="token operator">+</span> message <span class="token operator">+</span> <span class="token string">"'"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//关闭消息通道和连接</span>        channel<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        connection<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/04/mac-xia-an-zhuang-rabbitmq/008.png" alt></p><blockquote><p>消费者</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>rabbitmq<span class="token punctuation">.</span>zms<span class="token punctuation">.</span>rabbitmqdemo<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>rabbitmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>Test<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeoutException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>atomic<span class="token punctuation">.</span>AtomicInteger<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019-07-07 * @Time: 09:55 * @Vsersion: 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RabbitMqDemo02</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//消息队列名称</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> String QUEUE_NAME <span class="token operator">=</span> <span class="token string">"Hello RabbitMq"</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">,</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>InterruptedException<span class="token punctuation">,</span> TimeoutException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//创建连接工厂</span>        ConnectionFactory factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConnectionFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span><span class="token function">setHost</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span><span class="token function">setPort</span><span class="token punctuation">(</span><span class="token number">5672</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span><span class="token string">"admin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">"admin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//创建连接</span>        Connection connection <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">newConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//创建消息信道</span>        Channel channel <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">createChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//消息队列</span>        channel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span>QUEUE_NAME<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"--------------消费列表----------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        AtomicInteger count <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//消费者用于获取消息信道绑定的消息队列中的信息</span>        Consumer consumer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultConsumer</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleDelivery</span><span class="token punctuation">(</span>String consumerTag<span class="token punctuation">,</span> Envelope envelope<span class="token punctuation">,</span> AMQP<span class="token punctuation">.</span>BasicProperties properties<span class="token punctuation">,</span>                                       <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> body<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>                String message <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>body<span class="token punctuation">,</span> <span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消费者------>consumer()'"</span> <span class="token operator">+</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消费了！！！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    channel<span class="token punctuation">.</span><span class="token function">basicAck</span><span class="token punctuation">(</span>envelope<span class="token punctuation">.</span><span class="token function">getDeliveryTag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        channel<span class="token punctuation">.</span><span class="token function">basicConsume</span><span class="token punctuation">(</span>QUEUE_NAME<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> consumer<span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span> <span class="token operator">*</span> <span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>需要注意的一点是：</p><ul><li>生产消息: <code>channel.queueDeclare(QUEUE_NAME, true, false, false, null);</code></li><li>消费消息: <code>channel.queueDeclare(QUEUE_NAME, true, false, false, null);</code></li><li>生产和消费都声明channel，要求两者的配置参数一致，否则无法消费数据</li></ul></blockquote><h4 id="3-ACK问题"><a href="#3-ACK问题" class="headerlink" title="3. ACK问题"></a>3. ACK问题</h4><blockquote><p>对于ack的问题，如果在消费数据的时候，出现异常，而我不希望数据丢失，这个时候就需要考虑手动ack的机制来保证了</p><p>首先需要设置手动ack</p></blockquote><pre><code>// 设置autoAck为falsechannel.basicConsume(QUEUE_NAME, false, consumer);</code></pre><blockquote><p>其次在消费数据完毕之后，主动ack/nack</p></blockquote><pre><code>if (success) {    channel.basicAck(envelope.getDeliveryTag(), false);} else {    channel.basicNack(envelope.getDeliveryTag(), false, false);}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rabbitmq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发工具类和并发容器</title>
      <link href="/2019/07/03/bing-fa-gong-ju-lei-he-bing-fa-rong-qi/"/>
      <url>/2019/07/03/bing-fa-gong-ju-lei-he-bing-fa-rong-qi/</url>
      
        <content type="html"><![CDATA[<h3 id="并发工具类和并发容器"><a href="#并发工具类和并发容器" class="headerlink" title="并发工具类和并发容器"></a>并发工具类和并发容器</h3><p>[TOC]</p><h4 id="1-ConcurrentHashMap"><a href="#1-ConcurrentHashMap" class="headerlink" title="1.ConcurrentHashMap"></a>1.ConcurrentHashMap</h4><h5 id="为什么要使用ConcurrentHashMap"><a href="#为什么要使用ConcurrentHashMap" class="headerlink" title="为什么要使用ConcurrentHashMap"></a>为什么要使用ConcurrentHashMap</h5><blockquote><p>在多线程环境下，使用HashMap进行put操作会引起死循环，导致CPU利用率接近100%，HashMap在并发执行put操作时会引起死循环，是因为多线程会导致HashMap的Entry链表</p><p>形成环形数据结构，一旦形成环形数据结构，Entry的next节点永远不为空，就会产生死循环获取Entry。</p><p>HashTable容器使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。因为当一个线程访问HashTable的同步方法，其他线程也访问HashTable的同步方法时，会进入阻塞或轮询状态。如线程1使用put进行元素添加，线程2不但不能使用put方法添加元素，也不能使用get方法来获取元素，所以竞争越激烈效率越低。</p></blockquote><h5 id="ConcurrentHashMap的一些有用的方法"><a href="#ConcurrentHashMap的一些有用的方法" class="headerlink" title="ConcurrentHashMap的一些有用的方法"></a>ConcurrentHashMap的一些有用的方法</h5><blockquote><p>很多时候我们希望在元素不存在时插入元素，我们一般会像下面那样写代码</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">synchronized</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span><span class="token punctuation">{</span>      <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>putIfAbsent(key,value)方法原子性的实现了同样的功能</p><p>V <strong>putIfAbsent</strong>(K key, V value)  </p><p>如果key对应的value不存在，则put进去，返回<strong>null</strong>。否则不put，返回已存在的value。  </p><p><strong>boolean</strong> remove(Object key, Object value)  </p><p> 如果key对应的值是value，则移除K-V，返回<strong>true</strong>。否则不移除，返回<strong>false</strong>。  </p><p><strong>boolean</strong> replace(K key, V oldValue, V newValue)  </p><p>如果key对应的当前值是oldValue，则替换为newValue，返回<strong>true</strong>。否则不替换，返回<strong>false</strong>。</p></blockquote><h4 id="Hash的解释"><a href="#Hash的解释" class="headerlink" title="Hash的解释"></a>Hash的解释</h4><blockquote><p>散列，任意长度的输入，通过一种算法，变换成固定长度的输出。属于压缩的映射。</p></blockquote><blockquote><p>hash算法示例图演示：</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/03/bing-fa-gong-ju-lei-he-bing-fa-rong-qi/001.png" alt></p><blockquote><p>类似于HaspMap的实现就是使用散列，比如把1000个元素放到长度为10的hashmap里面去，放入之前会把这1000个数经过hash算法映射到10个数组里面去，这时候就会存在相同的映射值在一个数组的相同位置，就会产生hash碰撞，此时hashmap就会在产生碰撞的数组的后面使用Entry链表来存储相同映射的值，然后使用equals方法来判断同一个链表存储的值是否一样来获取值，链表就是hashmap用来解决碰撞的方法，所以我们一般在写一个类的时候要写自己的hashcode方法和equals方法，如果键的hashcode相同，再使用键的equals方法判断键内容是不是一样的，一样的就获取值</p><p>Md5，Sha，取余都是散列算法，ConcurrentHashMap中是wang/jenkins算法</p></blockquote><h4 id="ConcurrentHashMap在1-7下的实现"><a href="#ConcurrentHashMap在1-7下的实现" class="headerlink" title="ConcurrentHashMap在1.7下的实现"></a>ConcurrentHashMap在1.7下的实现</h4><blockquote><p>分段锁的设计思想。</p></blockquote><blockquote><p>分段锁的思想示例图</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/03/bing-fa-gong-ju-lei-he-bing-fa-rong-qi/002.png" alt></p><blockquote><p>说明：</p><p>a)传统的hashtable是很小空间的数组整段锁住，这样性能比较低</p><p>b)ConcurrentHashMap是在很小空间数组的前面再加一个数组，映射的时候先映射到前面的数组，然后再映射到后面的很小空间的数组；读取的时候只需要把前面的数组锁住就可以了。这就是分段锁的思想</p><p>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment实际是一种可重入锁（ReentrantLock），也就是用于分段的锁。HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组。Segment的结构和HashMap类似，是一种数组和链表结构。一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素，每个Segment守护着一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得与它对应的Segment锁。</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/03/bing-fa-gong-ju-lei-he-bing-fa-rong-qi/003.png" alt></p><blockquote><p>说明：上图存在两次散列的过程：比如插入一个1000的数，首先是把1000的位数(最多是高16位)做一次散列找到在segments数组中的位置，然后再把1000本身做一次散列找到在table中的位置</p><p>获取值时一样</p><p>ConcurrentHashMap初始化方法是通过initialCapacity、loadFactor和concurrencyLevel(参数concurrencyLevel是用户估计的并发级别，就是说你觉得最多有多少线程共同修改这个map，根据这个来确定Segment数组的大小concurrencyLevel默认是DEFAULT_CONCURRENCY_LEVEL = 16;)。</p><p>ConcurrentHashMap完全允许多个读操作并发进行，读操作并不需要加锁。ConcurrentHashMap实现技术是保证HashEntry几乎是不可变的。HashEntry代表每个hash链中的一个节点，可以看到其中的对象属性要么是final的，要么是volatile的。</p><p>总结：<strong>ConcurrentHashMap在1.7及以下的实现使用数组+链表的方式，采用了分段锁的思想</strong></p></blockquote><h4 id="ConcurrentHashMap在1-8下的实现"><a href="#ConcurrentHashMap在1-8下的实现" class="headerlink" title="ConcurrentHashMap在1.8下的实现"></a>ConcurrentHashMap在1.8下的实现</h4><blockquote><p>改进一：取消segments字段,直接采用transient volatile HashEntry&lt;K,V&gt;[] table保存数据，采用table数组元素作为锁，从而实现了对每一行数据进行加锁，进一步减少并发冲突的概率。</p><p>改进二：将原先table数组＋单向链表的数据结构，变更为table数组＋单向链表＋红黑树的结构。对于个数超过8(默认值)的列表，jdk1.8中采用了红黑树的结构，那么查询的时间复杂度可以降低到O(logN)，可以改进性能。</p><p>总结：ConcurrentHashMap在1.8下的实现使用数组+链表+红黑树的方式，当链表个数超过8的时候就把原来的链表转成红黑树，使用红黑树来存取，采用了元素锁的思想</p></blockquote><h4 id="2-ConcurrentSkipListMap-和ConcurrentSkipListSet"><a href="#2-ConcurrentSkipListMap-和ConcurrentSkipListSet" class="headerlink" title="2. ConcurrentSkipListMap  和ConcurrentSkipListSet"></a>2. ConcurrentSkipListMap  和ConcurrentSkipListSet</h4><blockquote><p>ConcurrentSkipListMap    TreeMap的并发实现</p></blockquote><blockquote><p>ConcurrentSkipListSet     TreeSet的并发实现</p></blockquote><h4 id="了解什么是SkipList？"><a href="#了解什么是SkipList？" class="headerlink" title="了解什么是SkipList？"></a>了解什么是SkipList？</h4><blockquote><p>二分查找和AVL树查找</p></blockquote><blockquote><p>二分查找要求元素可以随机访问，所以决定了需要把元素存储在连续内存。这样查找确实很快，但是插入和删除元素的时候，为了保证元素的有序性，就需要大量的移动元素了。</p></blockquote><blockquote><p>如果需要的是一个能够进行二分查找，又能快速添加和删除元素的数据结构，首先就是二叉查找树，二叉查找树在最坏情况下可能变成一个链表。</p></blockquote><blockquote><p>于是，就出现了平衡二叉树，根据平衡算法的不同有AVL树，B-Tree，B+Tree，红黑树等，但是AVL树实现起来比较复杂，平衡操作较难理解，这时候就可以用SkipList跳跃表结构。</p></blockquote><blockquote><p>传统意义的单链表是一个线性结构，向有序的链表中插入一个节点需要O(n)的时间，查找操作需要O(n)的时间。</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/03/bing-fa-gong-ju-lei-he-bing-fa-rong-qi/004.png" alt></p><blockquote><p>如果我们使用上图所示的跳跃表，就可以减少查找所需时间为O(n/2)，因为我们可以先通过每个节点的最上面的指针先进行查找，这样子就能跳过一半的节点。</p><p>比如我们想查找19，首先和6比较，大于6之后，在和9进行比较，然后在和12进行比较……最后比较到21的时候，发现21大于19，说明查找的点在17和21之间，从这个过程中，我们可以看出，查找的时候跳过了3、7、12等点，因此查找的复杂度为O(n/2)。</p><p>跳跃表其实也是一种通过“空间来换取时间”的一个算法，通过在每个节点中增加了向前的指针，从而提升查找的效率。</p><p>跳跃表又被称为概率，或者说是随机化的数据结构，目前开源软件 Redis 和 lucence都有用到它。</p></blockquote><h4 id="3-ConcurrentLinkedQueue-无界非阻塞队列"><a href="#3-ConcurrentLinkedQueue-无界非阻塞队列" class="headerlink" title="3. ConcurrentLinkedQueue  无界非阻塞队列"></a>3. ConcurrentLinkedQueue  无界非阻塞队列</h4><blockquote><p>ConcurrentLinkedQueue   LinkedList 并发版本</p><p>Add,offer：添加元素</p><p>Peek()：get头元素并不把元素拿走</p><p>poll()：get头元素把元素拿走</p></blockquote><h4 id="4-CopyOnWriteArrayList和CopyOnWriteArraySet"><a href="#4-CopyOnWriteArrayList和CopyOnWriteArraySet" class="headerlink" title="4. CopyOnWriteArrayList和CopyOnWriteArraySet"></a><strong>4. CopyOnWriteArrayList和CopyOnWriteArraySet</strong></h4><blockquote><p>写的时候进行复制，可以进行并发的读。</p><p><strong>适用读多写少的场景：</strong>比如白名单，黑名单，商品类目的访问和更新场景，假如我们有一个搜索网站，用户在这个网站的搜索框中，输入关键字搜索内容，但是某些关键字不允许被搜索。这些不能被搜索的关键字会被放在一个黑名单当中，黑名单每天晚上更新一次。当用户搜索时，会检查当前关键字在不在黑名单当中，如果在，则提示不能搜索。</p><p><strong>弱点：内存占用高，数据一致性弱</strong></p><p>总结：写的时候重新复制一份数据，然后在复制的数据里面写入数据，写完以后再把原来的数据的引用执行复制的数据，所以存在数据的弱一致性，适用于读多写少的场景</p></blockquote><h4 id="5-什么是阻塞队列"><a href="#5-什么是阻塞队列" class="headerlink" title="5.什么是阻塞队列"></a>5.什么是阻塞队列</h4><blockquote><p>取数据和存数据不满足要求时，会对线程进行阻塞。例如取数据时发现队列里面没有数据就在那里阻塞等着有数据了再取；存数据时发现队列已经满了就在那里阻塞等着有数据被取走时再存</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/03/bing-fa-gong-ju-lei-he-bing-fa-rong-qi/005.png" alt></p><h4 id="常用阻塞队列"><a href="#常用阻塞队列" class="headerlink" title="常用阻塞队列"></a><strong>常用阻塞队列</strong></h4><blockquote><p>ArrayBlockingQueue： 数组结构组成有界阻塞队列。</p><p>先进先出原则，初始化必须传大小，take和put时候用的同一把锁</p><p>LinkedBlockingQueue：链表结构组成的有界阻塞队列</p><p>先进先出原则，初始化可以不传大小，put，take锁分离</p><p>PriorityBlockingQueue：支持优先级排序的无界阻塞队列，</p><p>排序，自然顺序升序排列，更改顺序：类自己实现compareTo()方法，初始化PriorityBlockingQueue指定一个比较器Comparator</p><p>DelayQueue： 使用了优先级队列的无界阻塞队列</p><p>支持延时获取，队列里的元素要实现Delay接口。<strong>DelayQueue**</strong>非常有用，可以将<strong><strong>DelayQueue</strong></strong>运用在以下应用场景。**</p></blockquote><blockquote><p><strong>缓存系统的设计：</strong>可以用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue中获取元素时，表示缓存有效期到了。</p><p><strong>还有订单到期，限时支付等等。</strong></p><p>SynchronousQueue：不存储元素的阻塞队列</p><p>每个put操作必须要等take操作</p><p>LinkedTransferQueue：链表结构组成的<strong>无</strong>界阻塞队列</p><p>Transfer,tryTransfer，生产者put时，当前有消费者take，生产者直接把元素传给消费者</p><p>LinkedBlockingDeque：链表结构组成的<strong>双向</strong>阻塞队列</p><p>可以在队列的两端插入和移除，xxxFirst头部操作,xxxLast尾部操作。工作窃取模式。</p></blockquote><h4 id="了解阻塞队列的实现原理"><a href="#了解阻塞队列的实现原理" class="headerlink" title="了解阻塞队列的实现原理"></a><strong>了解阻塞队列的实现原理</strong></h4><blockquote><p>使用了Condition实现。</p></blockquote><h4 id="生产者消费者模式"><a href="#生产者消费者模式" class="headerlink" title="生产者消费者模式"></a><strong>生产者消费者模式</strong></h4><blockquote><p>在并发编程中使用生产者和消费者模式能够解决绝大多数并发问题。该模式通过平衡生</p><p>产线程和消费线程的工作能力来提高程序整体处理数据的速度。</p><p>在线程世界里，生产者就是生产数据的线程，消费者就是消费数据的线程。在多线程开发</p><p>中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理</p><p>完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。为了解决这种生产消费能力不均衡的问题，便有了生产者和消费者模式。</p><p>生产者和消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通信，而是通过阻塞队列来进行通信，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。</p></blockquote><h3 id="什么是Fork-Join框架"><a href="#什么是Fork-Join框架" class="headerlink" title="什么是Fork/Join框架"></a>什么是Fork/Join框架</h3><blockquote><p>并行执行任务的框架，把大任务拆分成很多的小任务，汇总每个小任务的结果得到大任务的结果。</p></blockquote><h5 id="工作窃取算法"><a href="#工作窃取算法" class="headerlink" title="工作窃取算法"></a><strong>工作窃取算法</strong></h5><blockquote><p>工作窃取（work-stealing）算法是指某个线程从其他队列里窃取任务来执行，执行完以后把结果放回去</p><p>那么，为什么需要使用工作窃取算法呢？假如我们需要做一个比较大的任务，可以把这个任务分割为若干互不依赖的子任务，为了减少线程间的竞争，把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应。</p><p>比如A线程负责处理A队列里的任务。但是，有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务等待处理。干完活的线程与其等着，不如去帮其他线程干活，于是它就去其他线程的队列里窃取一个任务来执行。而在这时它们会访问同一个队列，所以为了减少窃取任务线程和被窃取任务线程之间的竞争，通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。</p></blockquote><h5 id="Fork-Join框架的使用"><a href="#Fork-Join框架的使用" class="headerlink" title="Fork/Join框架的使用"></a><strong>Fork/Join框架的使用</strong></h5><blockquote><p>Fork/Join使用两个类来完成以上两件事情。</p><p>①ForkJoinTask：我们要使用ForkJoin框架，必须首先创建一个ForkJoin任务。它提供在任务</p><p>中执行fork()和join()操作的机制。通常情况下，我们不需要直接继承ForkJoinTask类，只需要继承它的子类，Fork/Join框架提供了以下两个子类。</p><p>·RecursiveAction：用于没有返回结果的任务。</p><p>·RecursiveTask：用于有返回结果的任务。</p><p>②ForkJoinPool：ForkJoinTask需要通过ForkJoinPool来执行。</p><p>Fork/Join有同步和异步两种方式。</p></blockquote><h5 id="案例1：孙悟空摘桃子fork-join的案例"><a href="#案例1：孙悟空摘桃子fork-join的案例" class="headerlink" title="案例1：孙悟空摘桃子fork/join的案例"></a><strong>案例1：孙悟空摘桃子fork/join的案例</strong></h5><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 孙悟空摘桃子fork/join的案例，孙悟空去摘桃子时发现桃子太多就让猴子猴孙去帮忙在桃子， * 摘完以后再统一汇总求和 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ForkJoinWuKong</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">XiaoWuKong</span> <span class="token keyword">extends</span> <span class="token class-name">RecursiveTask</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">{</span>      <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">int</span> THRESHOLD <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//阈值，数组多小的时候，不再进行任务拆分操作</span>      <span class="token keyword">private</span> PanTao<span class="token punctuation">[</span><span class="token punctuation">]</span> src<span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token keyword">int</span> fromIndex<span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token keyword">int</span> toIndex<span class="token punctuation">;</span>      <span class="token keyword">private</span> IPickTaoZi pickTaoZi<span class="token punctuation">;</span>      <span class="token keyword">public</span> <span class="token function">XiaoWuKong</span><span class="token punctuation">(</span>PanTao<span class="token punctuation">[</span><span class="token punctuation">]</span> src<span class="token punctuation">,</span> <span class="token keyword">int</span> fromIndex<span class="token punctuation">,</span> <span class="token keyword">int</span> toIndex<span class="token punctuation">,</span> IPickTaoZi pickTaoZi<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>src <span class="token operator">=</span> src<span class="token punctuation">;</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>fromIndex <span class="token operator">=</span> fromIndex<span class="token punctuation">;</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>toIndex <span class="token operator">=</span> toIndex<span class="token punctuation">;</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>pickTaoZi <span class="token operator">=</span> pickTaoZi<span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token annotation punctuation">@Override</span>      <span class="token keyword">protected</span> Integer <span class="token function">compute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">//计算完以后结果汇总</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>toIndex<span class="token operator">-</span>fromIndex<span class="token operator">&lt;</span>THRESHOLD<span class="token punctuation">)</span><span class="token punctuation">{</span>              <span class="token keyword">int</span> count <span class="token operator">=</span><span class="token number">0</span> <span class="token punctuation">;</span>              <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>fromIndex<span class="token punctuation">;</span>i<span class="token operator">&lt;</span>toIndex<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                  <span class="token keyword">if</span> <span class="token punctuation">(</span>pickTaoZi<span class="token punctuation">.</span><span class="token function">pick</span><span class="token punctuation">(</span>src<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> count<span class="token operator">++</span><span class="token punctuation">;</span>              <span class="token punctuation">}</span>              <span class="token keyword">return</span> count<span class="token punctuation">;</span>          <span class="token punctuation">}</span>          <span class="token comment" spellcheck="true">//大任务拆分成小任务</span>          <span class="token keyword">else</span><span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">//fromIndex....mid......toIndex</span>              <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>fromIndex<span class="token operator">+</span>toIndex<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>              XiaoWuKong left <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XiaoWuKong</span><span class="token punctuation">(</span>src<span class="token punctuation">,</span>fromIndex<span class="token punctuation">,</span>mid<span class="token punctuation">,</span>pickTaoZi<span class="token punctuation">)</span><span class="token punctuation">;</span>              XiaoWuKong right <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XiaoWuKong</span><span class="token punctuation">(</span>src<span class="token punctuation">,</span>mid<span class="token punctuation">,</span>toIndex<span class="token punctuation">,</span>pickTaoZi<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token function">invokeAll</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token keyword">return</span> left<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span>right<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ForkJoinPool pool <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ForkJoinPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        PanTao<span class="token punctuation">[</span><span class="token punctuation">]</span> src <span class="token operator">=</span> MakePanTaoArray<span class="token punctuation">.</span><span class="token function">makeArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        IProcessTaoZi processTaoZi <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WuKongProcessImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        IPickTaoZi pickTaoZi <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WuKongPickImpl</span><span class="token punctuation">(</span>processTaoZi<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> start <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//构造一个ForkJoinTask</span>        XiaoWuKong xiaoWuKong <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XiaoWuKong</span><span class="token punctuation">(</span>src<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>                src<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>pickTaoZi<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//ForkJoinTask交给ForkJoinPool来执行。</span>        pool<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>xiaoWuKong<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"The count is "</span><span class="token operator">+</span> xiaoWuKong<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token operator">+</span><span class="token string">" spend time:"</span><span class="token operator">+</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>start<span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"ms"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="案例2：使用Fork-Join框架实现计算1-2-3-…-100的结果"><a href="#案例2：使用Fork-Join框架实现计算1-2-3-…-100的结果" class="headerlink" title="案例2：使用Fork/Join框架实现计算1+2+3+….+100的结果"></a><strong>案例2：使用Fork/Join框架实现计算1+2+3+….+100的结果</strong></h5><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>study<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>forkjoin<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ExecutionException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ForkJoinPool<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>Future<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>RecursiveTask<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * Fork/Join框架设计思路： * 第一步：分割任务。首先我们需要有一个fork类来把大任务分割成子任务，有可能子任务还是很大，所以还需要 *         不停的分割，直到分割出的子任务足够小。 * 第二步：执行任务并合并结果。分割的子任务分别放在双端队列里，然后启动几个线程分别从双端队列里获取任务执行。 *         子任务执行完的结果都统一放在一个队列里，启动一个线程从队列里拿数据，然后合并这些数据。  *  * Fork/Join框架的具体实现： * Fork/Join使用两个类来完成以上两件事情： * ForkJoinTask：我们要使用ForkJoin框架，必须首先创建一个ForkJoin任务。它提供在任务中执行fork()和join() *               操作的机制，通常情况下我们不需要直接继承ForkJoinTask类，而只需要继承它的子类，Fork/Join框架提供了以下两个子类： *               RecursiveAction：用于没有返回结果的任务。 *               RecursiveTask ：用于有返回结果的任务。 * ForkJoinPool ：ForkJoinTask需要通过ForkJoinPool来执行，任务分割出的子任务会添加到当前工作线程所维护的双端队列中， *                进入队列的头部。当一个工作线程的队列里暂时没有任务时，它会随机从其他工作线程的队列的尾部获取一个任务。 *                 * 实战：使用Fork/Join框架实现计算1+2+3+....+100的结果-100个数拆分成10个（阈值）子任务来执行最后汇总结果 * */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CountTask</span> <span class="token keyword">extends</span> <span class="token class-name">RecursiveTask</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 序列化     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 1L<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> THRESHOLD <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 阈值</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> start<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> end<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">CountTask</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>start <span class="token operator">=</span> start<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>end <span class="token operator">=</span> end<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> Integer <span class="token function">compute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果任务足够小就计算任务</span>        <span class="token keyword">boolean</span> canCompute <span class="token operator">=</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> THRESHOLD<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>canCompute<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> end<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                sum <span class="token operator">+=</span> i<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果任务大于阀值，就分裂成两个子任务计算</span>            <span class="token keyword">int</span> middle <span class="token operator">=</span> <span class="token punctuation">(</span>start <span class="token operator">+</span> end<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            CountTask leftTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountTask</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> middle<span class="token punctuation">)</span><span class="token punctuation">;</span>            CountTask rightTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountTask</span><span class="token punctuation">(</span>middle <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 执行子任务</span>            leftTask<span class="token punctuation">.</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            rightTask<span class="token punctuation">.</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 等待子任务执行完，并得到其结果</span>            <span class="token keyword">int</span> leftResult <span class="token operator">=</span> leftTask<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> rightResult <span class="token operator">=</span> rightTask<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 合并子任务</span>            sum <span class="token operator">=</span> leftResult <span class="token operator">+</span> rightResult<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ForkJoinPool forkJoinPool <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ForkJoinPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 生成一个计算任务，负责计算1+2+3+4</span>        CountTask task <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountTask</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 执行一个任务</span>        Future result <span class="token operator">=</span> forkJoinPool<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ExecutionException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="二、并发工具类"><a href="#二、并发工具类" class="headerlink" title="二、并发工具类"></a>二、并发工具类</h3><h4 id="1-CountDownLatch"><a href="#1-CountDownLatch" class="headerlink" title="1. CountDownLatch"></a><strong>1. CountDownLatch</strong></h4><blockquote><p>允许一个或多个线程等待其他线程完成操作。CountDownLatch的构造函数接收一个int类型的参数作为计数器，如果你想等待N个点完成，这里就传入N。当我们调用CountDownLatch的countDown方法时，N就会减1，CountDownLatch的await方法会阻塞当前线程，直到N变成零。</p><p>由于countDown方法可以用在任何地方，所以这里说的N个点，可以是N个线程，也可以是1个线程里的N个执行步骤。用在多个线程时，只需要把这个CountDownLatch的引用传递到线程里即可。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CountDownLatchCase</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> CountDownLatch c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SubThread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            c<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" is done"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                c<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"sleeping..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"sleep is completer"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                c<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span><span class="token number">4</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            Thread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">SubThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        c<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Main will gone....."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="2-CyclicBarrier"><a href="#2-CyclicBarrier" class="headerlink" title="2. CyclicBarrier"></a><strong>2. CyclicBarrier</strong></h4><blockquote><p>CyclicBarrier的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。CyclicBarrier默认的构造方法是CyclicBarrier（int parties），其参数表示屏障拦截的线程数量，每个线程调用await方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CyclicBarrriesBase</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> CyclicBarrier c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CyclicBarrier</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">,</span> BrokenBarrierException <span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    c<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//等待主线程完成</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"is going"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">BrokenBarrierException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"sleeping..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"main will sleep....."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        c<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">////等待子线程完成</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"All are complete."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>CyclicBarrier还提供一个更高级的构造函数CyclicBarrier（int parties，Runnable barrierAction），用于在线程到达屏障时，优先执行barrierAction，方便处理更复杂的业务场景。</p><p>CyclicBarrier可以用于多线程计算数据，最后合并计算结果的场景。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CyclicBarrierSum</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> CyclicBarrier c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CyclicBarrier</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">SumThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//子线程结果存放的缓存</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> ConcurrentHashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>Integer<span class="token operator">></span> resultMap <span class="token operator">=</span>            <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//所有子线程达到屏障后，会执行这个Runnable的任务</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SumThread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> result <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>Integer<span class="token operator">></span> workResult<span class="token operator">:</span>resultMap<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                result <span class="token operator">=</span> result<span class="token operator">+</span>workResult<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"result = "</span><span class="token operator">+</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"完全可以做与子线程，统计无关的事情....."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//工作线程，也就是子线程</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">WorkThread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>        <span class="token keyword">private</span> Random t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> r <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1000</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">":r="</span><span class="token operator">+</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>            resultMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">""</span><span class="token punctuation">,</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token operator">+</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>                c<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">BrokenBarrierException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span><span class="token number">4</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            Thread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">WorkThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="CyclicBarrier和CountDownLatch的区别"><a href="#CyclicBarrier和CountDownLatch的区别" class="headerlink" title="CyclicBarrier和CountDownLatch的区别"></a>CyclicBarrier和CountDownLatch的区别</h5><blockquote><p>CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置，CountDownLatch.await一般阻塞主线程，所有的工作线程执行countDown，而CyclicBarrierton通过工作线程调用await从而阻塞工作线程，直到所有工作线程达到屏障。</p></blockquote><h4 id="4-控制并发线程数的Semaphore"><a href="#4-控制并发线程数的Semaphore" class="headerlink" title="4. 控制并发线程数的Semaphore"></a>4. 控制并发线程数的Semaphore</h4><blockquote><p>Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。应用场景Semaphore可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接。假如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程并发地读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这时我们必须控制只有10个线程同时获取数据库连接保存数据，否则会报错无法获取数据库连接。这个时候，就可以使用Semaphore来做流量控制。。Semaphore的构造方法Semaphore（int permits）接受一个整型的数字，表示可用的许可证数量。Semaphore的用法也很简单，首先线程使用Semaphore的acquire()方法获取一个许可证，使用完之后调用release()方法归还许可证。还可以用tryAcquire()方法尝试获取许可证。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SemaphporeCase</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> Semaphore items<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//有多少元素可拿</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> Semaphore space<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//有多少空位可放元素</span>    <span class="token keyword">private</span> List queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">SemaphporeCase</span><span class="token punctuation">(</span><span class="token keyword">int</span> itemCounts<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>items <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Semaphore</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>space <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Semaphore</span><span class="token punctuation">(</span>itemCounts<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//放入数据</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span>T x<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        space<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//拿空位的许可，没有空位线程会在这个方法上阻塞</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">{</span>            queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        items<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//有元素了，可以释放一个拿元素的许可</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//取数据</span>    <span class="token keyword">public</span> T <span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        items<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//拿元素的许可，没有元素线程会在这个方法上阻塞</span>        T t<span class="token punctuation">;</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">{</span>            t <span class="token operator">=</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span>queue<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        space<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//有空位了，可以释放一个存在空位的许可</span>        <span class="token keyword">return</span> t<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>Semaphore还提供一些其他方法，具体如下。</p><p>·intavailablePermits()：返回此信号量中当前可用的许可证数。</p><p>·intgetQueueLength()：返回正在等待获取许可证的线程数。</p><p>·booleanhasQueuedThreads()：是否有线程正在等待获取许可证。</p><p>·void reducePermits（int reduction）：减少reduction个许可证，是个protected方法。</p></blockquote><h4 id="5-Exchanger"><a href="#5-Exchanger" class="headerlink" title="5. Exchanger"></a>5. Exchanger</h4><blockquote><p>Exchanger（交换者）是一个用于线程间协作的工具类。Exchanger用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。这两个线程通过exchange方法交换数据，如果第一个线程先执行exchange()方法，它会一直等待第二个线程也执行exchange方法，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExchangeCase</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> Exchanger<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>String<span class="token operator">>></span> exgr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Exchanger</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" insert A1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" insert A2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    list <span class="token operator">=</span> exgr<span class="token punctuation">.</span><span class="token function">exchange</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//交换数据</span>                    <span class="token keyword">for</span><span class="token punctuation">(</span>String item<span class="token operator">:</span>list<span class="token punctuation">)</span><span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">":"</span><span class="token operator">+</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" insert B1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" insert B2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" insert B3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" will sleep"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    list <span class="token operator">=</span> exgr<span class="token punctuation">.</span><span class="token function">exchange</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//交换数据</span>                    <span class="token keyword">for</span><span class="token punctuation">(</span>String item<span class="token operator">:</span>list<span class="token punctuation">)</span><span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">":"</span><span class="token operator">+</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java内存模型</title>
      <link href="/2019/07/02/java-nei-cun-mo-xing/"/>
      <url>/2019/07/02/java-nei-cun-mo-xing/</url>
      
        <content type="html"><![CDATA[<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><h4 id="什么是内存模型"><a href="#什么是内存模型" class="headerlink" title="什么是内存模型"></a>什么是内存模型</h4><blockquote><p>Java内存模型（Java Memory Model ,JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能得到一致效果的机制及规范。目的是解决由于多线程通过共享内存进行通信时，存在的原子性、可见性（缓存一致性）以及有序性问题。</p></blockquote><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><blockquote><p>线程是CPU调度的基本单位。CPU有时间片的概念，会根据不同的调度算法进行线程调度。所以在多线程场景下，就会发生原子性问题。因为线程在执行一个读改写操作时，在执行完读改之后，时间片耗完，就会被要求放弃CPU，并等待重新调度。这种情况下，读改写就不是一个原子操作。即存在原子性问题。</p></blockquote><h4 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h4><blockquote><p>在多核CPU，多线程的场景中，每个核都至少有一个L1 缓存。多个线程访问进程中的某个共享内存，且这多个线程分别在不同的核心上执行，则每个核心都会在各自的caehe中保留一份共享内存的缓冲。由于多核是可以并行的，可能会出现多个线程同时写各自的缓存的情况，而各自的cache之间的数据就有可能不同。</p><p>在CPU和主存之间增加缓存，在多线程场景下就可能存在缓存一致性问题，也就是说，在多核CPU中，每个核的自己的缓存中，关于同一个数据的缓存内容可能不一致。</p></blockquote><h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><blockquote><p>除了引入了时间片以外，由于处理器优化和指令重排等，CPU还可能对输入代码进行乱序执行，比如load-&gt;add-&gt;save 有可能被优化成load-&gt;save-&gt;add 。这就是有序性问题。</p><p>多CPU多级缓存导致的一致性问题、CPU时间片机制导致的原子性问题、以及处理器优化和指令重排导致的有序性问题等，都硬件的不断升级导致的。那么，有没有什么机制可以很好的解决上面的这些问题呢？</p><p>最简单直接的做法就是废除处理器和处理器的优化技术、废除CPU缓存，让CPU直接和主存交互。但是，这么做虽然可以保证多线程下的并发问题。但是，这就有点因噎废食了。</p><p>所以，为了保证并发编程中可以满足原子性、可见性及有序性。有一个重要的概念，那就是——<strong>内存模型</strong>。</p></blockquote><blockquote><p>为了保证共享内存的正确性（可见性、有序性、原子性），内存模型定义了共享内存系统中多线程程序读写操作行为的规范。通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。它与处理器有关、与缓存有关、与并发有关、与编译器也有关。他解决了CPU多级缓存、处理器优化、指令重排等导致的内存访问问题，保证了并发场景下的一致性、原子性和有序性。</p><p>针对上面的这些问题，不同的操作系统都有不同的解决方案，而Java语言为了屏蔽掉底层的差异，定义了一套属于Java语言的内存模型规范，即Java内存模型。</p><p>Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。</p><p>而JMM就作用于工作内存和主存之间数据同步过程。他规定了如何做数据同步以及什么时候做数据同步。</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/07/02/java-nei-cun-mo-xing/001.png" alt></p><h4 id="Java内存模型的实现"><a href="#Java内存模型的实现" class="headerlink" title="Java内存模型的实现"></a>Java内存模型的实现</h4><blockquote><p>了解Java多线程的朋友都知道，在Java中提供了一系列和并发处理相关的关键字，比如volatile、synchronized、final、concurren包等。其实这些就是Java内存模型封装了底层的实现后提供给程序员使用的一些关键字。</p><p>在开发多线程的代码的时候，我们可以直接使用synchronized等关键字来控制并发，从来就不需要关心底层的编译器优化、缓存一致性等问题。所以，Java内存模型，除了定义了一套规范，还提供了一系列原语，封装了底层实现后，供开发者直接使用。</p><p>本文并不准备把所有的关键字逐一介绍其用法，因为关于各个关键字的用法，网上有很多资料。读者可以自行学习。本文还有一个重点要介绍的就是，我们前面提到，并发编程要解决原子性、有序性和一致性的问题，我们就再来看下，在Java中，分别使用什么方式来保证。</p></blockquote><h5 id="原子性-1"><a href="#原子性-1" class="headerlink" title="原子性"></a><strong>原子性</strong></h5><blockquote><p>在Java中，为了保证原子性，提供了两个高级的字节码指令monitorenter和monitorexit。在synchronized的实现原理文章中，介绍过，这两个字节码，在Java中对应的关键字就是synchronized。</p><p>因此，在Java中可以使用synchronized来保证方法和代码块内的操作是原子性的。</p></blockquote><p><strong>可见性</strong></p><blockquote><p>Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值的这种依赖主内存作为传递媒介的方式来实现的。</p><p>Java中的volatile关键字提供了一个功能，那就是被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次是用之前都从主内存刷新。因此，可以使用volatile来保证多线程操作时变量的可见性。</p><p>除了volatile，Java中的synchronized和final两个关键字也可以实现可见性。只不过实现方式不同，这里不再展开了。</p></blockquote><h5 id="有序性-1"><a href="#有序性-1" class="headerlink" title="有序性"></a><strong>有序性</strong></h5><blockquote><p>在Java中，可以使用synchronized和volatile来保证多线程之间操作的有序性。实现方式有所区别：</p><p>volatile关键字会禁止指令重排。synchronized关键字保证同一时刻只允许一条线程操作。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 日常学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JMM Java内存模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySql主从复制与读写分离</title>
      <link href="/2019/06/30/mysql-zhu-cong-fu-zhi-yu-du-xie-fen-chi/"/>
      <url>/2019/06/30/mysql-zhu-cong-fu-zhi-yu-du-xie-fen-chi/</url>
      
        <content type="html"><![CDATA[<h1 id="MySql主从复制与读写分离"><a href="#MySql主从复制与读写分离" class="headerlink" title="MySql主从复制与读写分离"></a>MySql主从复制与读写分离</h1><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/30/mysql-zhu-cong-fu-zhi-yu-du-xie-fen-chi/Snipaste_2019-06-30_15-40-57.png" alt></p><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><blockquote><p>影响MySQL-A数据库的操作，在数据库执行后，都会写入本地的日志系统A中。</p><p>假设，实时的将变化了的日志系统中的数据库事件操作，在MYSQL-A的3306端口，通过网络发给MYSQL-B。</p><p>MYSQL-B收到后，写入本地日志系统B，然后一条条的将数据库事件在数据库中完成。</p><p>那么，MYSQL-A的变化，MYSQL-B也会变化，这样就是所谓的MYSQL的复制，即MYSQL replication。</p><p>在上面的模型中，MYSQL-A就是主服务器，即master，MYSQL-B就是从服务器，即slave。</p><p>日志系统A，其实它是MYSQL的日志类型中的二进制日志，也就是专门用来保存修改数据库表的所有动作，即bin log。【注意MYSQL会在执行语句之后，释放锁之前，写入二进制日志，确保事务安全】</p><p>日志系统B，并不是二进制日志，由于它是从MYSQL-A的二进制日志复制过来的，并不是自己的数据库变化产生的，有点接力的感觉，称为中继日志，即relay log。</p><p>可以发现，通过上面的机制，可以保证MYSQL-A和MYSQL-B的数据库数据一致，但是时间上肯定有延迟，即MYSQL-B的数据是滞后的。</p><p>【即便不考虑什么网络的因素，MYSQL-A的数据库操作是可以并发的执行的，但是MYSQL-B只能从relay log中读一条，执行下。因此MYSQL-A的写操作很频繁，MYSQL-B很可能跟不上。】</p></blockquote><h4 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h4><blockquote><p>数据如何不被丢失</p><p>备份</p><p>读写分离</p><p>数据库负载均衡</p><p>高可用</p></blockquote><h4 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a><strong>环境搭建</strong></h4><blockquote><p>1.准备环境</p><p>两台windows操作系统 ip分别为: 172.27.185.1(主)、172.27.185.2(从)</p><p>2.连接到主服务(172.27.185.1)服务器上，给从节点分配账号权限。</p><p>GRANT REPLICATION SLAVE ON <em>.</em> TO ‘root’@‘172.27.185.2’ IDENTIFIED BY ‘root’;</p><p>3.在主服务my.ini文件新增</p></blockquote><pre class=" language-mysql"><code class="language-mysql">server-id=200log-bin=mysql-binrelay-log=relay-binrelay-log-index=relay-bin-index</code></pre><blockquote><p>重启mysql服务</p><p>4.在从服务my.ini文件新增</p></blockquote><pre class=" language-mysql"><code class="language-mysql">server-id = 210replicate-do-db =itmayiedu #需要同步数据库</code></pre><blockquote><p>重启mysql服务</p><p>5.从服务同步主数据库</p></blockquote><pre class=" language-mysql"><code class="language-mysql">stop slave;changemaster to master_host='172.27.185.1',master_user='root',master_password='root';start slave;show slave status;</code></pre><blockquote><p>注意事项</p><p>①一定要在同一个局域网中</p><p>②使用360WiFi创建局域网</p><p>③最好把防火墙全部关闭掉</p></blockquote><h4 id="什么是读写分离"><a href="#什么是读写分离" class="headerlink" title="什么是读写分离"></a>什么是读写分离</h4><blockquote><p>在数据库集群架构中，让主库负责处理事务性查询，而从库只负责处理select查询，让两者分工明确达到提高数据库整体读写性能。当然，主数据库另外一个功能就是负责将事务性查询导致的数据变更同步到从库中，也就是写操作。</p></blockquote><h4 id="读写分离的好处"><a href="#读写分离的好处" class="headerlink" title="读写分离的好处"></a>读写分离的好处</h4><blockquote><p>1）分摊服务器压力，提高机器的系统处理效率</p><p>读写分离适用于读远比写的场景，如果有一台服务器，当select很多时，update和delete会被这些select访问中的数据堵塞，等待select结束，并发性能并不高，而主从只负责各自的写和读，极大程度的缓解X锁和S锁争用；</p><p>假如我们有1主3从，不考虑上述1中提到的从库单方面设置，假设现在1分钟内有10条写入，150条读取。那么，1主3从相当于共计40条写入，而读取总数没变，因此平均下来每台服务器承担了10条写入和50条读取（主库不承担读取操作）。因此，虽然写入没变，但是读取大大分摊了，提高了系统性能。另外，当读取被分摊后，又间接提高了写入的性能。所以，总体性能提高了，说白了就是拿机器和带宽换性能；</p><p>2）增加冗余，提高服务可用性，当一台数据库服务器宕机后可以调整另外一台从库以最快速度恢复服务</p></blockquote><h4 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h4><blockquote><p>依赖于二进制日志，binary-log.</p><p>二进制日志中记录引起数据库发生改变的语句</p><p>Insert 、delete、update、create table</p><p><strong>Scale-up与Scale-out区别</strong></p><p>Scale Out是指Application可以在水平方向上扩展。一般对数据中心的应用而言，Scale out指的是当添加更多的机器时，应用仍然可以很好的利用这些机器的资源来提升自己的效率从而达到很好的扩展性。</p><p>Scale Up是指Application可以在垂直方向上扩展。一般对单台机器而言，Scale Up值得是当某个计算节点（机器）添加更多的CPU Cores，存储设备，使用更大的内存时，应用可以很充分的利用这些资源来提升自己的效率从而达到很好的扩展性。</p></blockquote><h4 id="MyCat"><a href="#MyCat" class="headerlink" title="MyCat"></a>MyCat</h4><h5 id="什么是-Mycat"><a href="#什么是-Mycat" class="headerlink" title="什么是 Mycat"></a>什么是 Mycat</h5><blockquote><p>是一个开源的分布式数据库系统，但是因为数据库一般都有自己的数据库引擎，而Mycat并没有属于自己的独有数据库引擎，所有严格意义上说并不能算是一个完整的数据库系统，只能说是一个在应用和数据库之间起桥梁作用的中间件。</p><p>在Mycat中间件出现之前，MySQL主从复制集群，如果要实现读写分离，一般是在程序段实现，这样就带来了一个问题，即数据段和程序的耦合度太高，如果数据库的地址发生了改变，那么我的程序也要进行相应的修改，如果数据库不小心挂掉了，则同时也意味着程序的不可用，而对于很多应用来说，并不能接受；</p><p>引入Mycat中间件能很好地对程序和数据库进行解耦，这样，程序只需关注数据库中间件的地址，而无需知晓底层数据库是如何提供服务的，大量的通用数据聚合、事务、数据源切换等工作都由中间件来处理；</p><p>Mycat中间件的原理是对数据进行分片处理，从原有的一个库，被切分为多个分片数据库，所有的分片数据库集群构成完成的数据库存储，有点类似磁盘阵列中的RAID0.</p></blockquote><h5 id="Mycat安装"><a href="#Mycat安装" class="headerlink" title="Mycat安装"></a>Mycat安装</h5><blockquote><p><strong>创建表结构</strong></p><p>CREATE DATABASE IF NOT EXISTS <code>weibo_simple</code>;</p><hr><p>– Table structure for <code>t_users</code> 用户表</p><hr><p>DROP TABLE IF EXISTS <code>t_users</code>;</p><p>CREATE TABLE <code>t_users</code> (</p><p><code>user_id</code> varchar(64) NOT NULL COMMENT ‘注册用户ID’,</p><p><code>user_email</code> varchar(64) NOT NULL COMMENT ‘注册用户邮箱’,</p><p><code>user_password</code> varchar(64) NOT NULL COMMENT ‘注册用户密码’,</p><p><code>user_nikename</code> varchar(64) NOT NULL COMMENT ‘注册用户昵称’,</p><p><code>user_creatime</code> datetime NOT NULL COMMENT ‘注册时间’,</p><p><code>user_status</code> tinyint(1) NOT NULL COMMENT ‘验证状态 1：已验证 0：未验证’,</p><p><code>user_deleteflag</code> tinyint(1) NOT NULL COMMENT ‘删除标记 1：已删除 0：未删除’,</p><p>PRIMARY KEY (<code>user_id</code>)</p><p>) ENGINE=InnoDB DEFAULT CHARSET=utf8;</p><hr><p>– Table structure for <code>t_message</code>微博表</p><hr><p>DROP TABLE IF EXISTS <code>t_message</code>;</p><p>CREATE TABLE <code>t_message</code> (</p><p><code>messages_id</code> varchar(64) NOT NULL COMMENT ‘微博ID’,</p><p><code>user_id</code> varchar(64) NOT NULL COMMENT ‘发表用户’,</p><p><code>messages_info</code> varchar(255) DEFAULT NULL COMMENT ‘微博内容’,</p><p><code>messages_time</code> datetime DEFAULT NULL COMMENT ‘发布时间’,</p><p><code>messages_commentnum</code> int(12) DEFAULT NULL COMMENT ‘评论次数’,</p><p><code>message_deleteflag</code> tinyint(1) NOT NULL COMMENT ‘删除标记 1：已删除 0：未删除’,</p><p><code>message_viewnum</code> int(12) DEFAULT NULL COMMENT ‘被浏览量’,</p><p>PRIMARY KEY (<code>messages_id</code>),</p><p>KEY <code>user_id</code> (<code>user_id</code>),</p><p>CONSTRAINT <code>t_message_ibfk_1</code> FOREIGN KEY (<code>user_id</code>) REFERENCES <code>t_users</code> (<code>user_id</code>)</p><p>) ENGINE=InnoDB DEFAULT CHARSET=utf8;</p></blockquote><h5 id="配置server-xml"><a href="#配置server-xml" class="headerlink" title="配置server.xml"></a>配置server.xml</h5><pre class=" language-xml"><code class="language-xml">    <span class="token comment" spellcheck="true">&lt;!-- 添加user --></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>user</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mycat<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>mycat<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>schemas<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>mycat<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>user</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 添加user --></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>user</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mycat_red<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>mycat_red<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>schemas<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>mycat<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>readOnly<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>user</span><span class="token punctuation">></span></span></code></pre><h5 id="配置schema-xml"><a href="#配置schema-xml" class="headerlink" title="配置schema.xml"></a>配置schema.xml</h5><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0"?></span><span class="token doctype">&lt;!DOCTYPE mycat:schema SYSTEM "schema.dtd"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mycat:</span>schema</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>mycat</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://org.opencloudb/<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!-- 与server.xml中user的schemas名一致 --></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>schema</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mycat<span class="token punctuation">"</span></span> <span class="token attr-name">checkSQLschema</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token attr-name">sqlMaxLimit</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>t_users<span class="token punctuation">"</span></span> <span class="token attr-name">primaryKey</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user_id<span class="token punctuation">"</span></span> <span class="token attr-name">dataNode</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn1<span class="token punctuation">"</span></span> <span class="token attr-name">rule</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>rule1<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>t_message<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>global<span class="token punctuation">"</span></span> <span class="token attr-name">primaryKey</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>messages_id<span class="token punctuation">"</span></span> <span class="token attr-name">dataNode</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn1<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>schema</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataNode</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn1<span class="token punctuation">"</span></span> <span class="token attr-name">dataHost</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jdbchost<span class="token punctuation">"</span></span> <span class="token attr-name">database</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>weibo_simple<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataHost</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jdbchost<span class="token punctuation">"</span></span> <span class="token attr-name">maxCon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1000<span class="token punctuation">"</span></span> <span class="token attr-name">minCon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>10<span class="token punctuation">"</span></span> <span class="token attr-name">balance</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span> <span class="token attr-name">writeType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token attr-name">dbType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mysql<span class="token punctuation">"</span></span> <span class="token attr-name">dbDriver</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>native<span class="token punctuation">"</span></span> <span class="token attr-name">switchType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span> <span class="token attr-name">slaveThreshold</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>heartbeat</span><span class="token punctuation">></span></span>select user()<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>heartbeat</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>writeHost</span> <span class="token attr-name">host</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>hostMaster<span class="token punctuation">"</span></span> <span class="token attr-name">url</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>172.27.185.1:3306<span class="token punctuation">"</span></span> <span class="token attr-name">user</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span> <span class="token attr-name">password</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>writeHost</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>writeHost</span> <span class="token attr-name">host</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>hostSlave<span class="token punctuation">"</span></span> <span class="token attr-name">url</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>172.27.185.2:3306<span class="token punctuation">"</span></span> <span class="token attr-name">user</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span> <span class="token attr-name">password</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dataHost</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">mycat:</span>schema</span><span class="token punctuation">></span></span></code></pre><h5 id="配置rule-xml文件"><a href="#配置rule-xml文件" class="headerlink" title="配置rule.xml文件"></a>配置rule.xml文件</h5><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token comment" spellcheck="true">&lt;!-- - - Licensed under the Apache License, Version 2.0 (the "License");     - you may not use this file except in compliance with the License. - You     may obtain a copy of the License at - - http://www.apache.org/licenses/LICENSE-2.0     - - Unless required by applicable law or agreed to in writing, software -     distributed under the License is distributed on an "AS IS" BASIS, - WITHOUT     WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. - See the     License for the specific language governing permissions and - limitations     under the License. --></span><span class="token doctype">&lt;!DOCTYPE mycat:rule SYSTEM "rule.dtd"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mycat:</span>rule</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>mycat</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://org.opencloudb/<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tableRule</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>rule1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>rule</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>columns</span><span class="token punctuation">></span></span>user_id<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>columns</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>algorithm</span><span class="token punctuation">></span></span>func1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>algorithm</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>rule</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tableRule</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>function</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>func1<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.opencloudb.route.function.AutoPartitionByLong<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mapFile<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>autopartition-long.txt<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>function</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">mycat:</span>rule</span><span class="token punctuation">></span></span></code></pre><blockquote><p><strong>为了更好地定位错误，修改log4j.xml</strong></p><p>双击startup_nowrap.bat开始启动</p><p><strong>常见问题</strong></p><p>SHOW MASTER STATUS 如果为，则在my.ini文件中添加一行</p><p>log-bin=mysql-bin</p><p>给账号分配权限</p><p>grant all privileges on <em>.</em> to ‘root’@‘172.27.185.1’ identified by ‘root’;</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySql </tag>
            
            <tag> MyCat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSM框架常见面试题</title>
      <link href="/2019/06/29/ssm-kuang-jia-chang-jian-mian-shi-ti/"/>
      <url>/2019/06/29/ssm-kuang-jia-chang-jian-mian-shi-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="SSM框架常见面试题"><a href="#SSM框架常见面试题" class="headerlink" title="SSM框架常见面试题"></a>SSM框架常见面试题</h1><h3 id="一、Spring面试题"><a href="#一、Spring面试题" class="headerlink" title="一、Spring面试题"></a>一、Spring面试题</h3><h4 id="1、Spring-在ssm中起什么作用？"><a href="#1、Spring-在ssm中起什么作用？" class="headerlink" title="1、Spring 在ssm中起什么作用？"></a>1、Spring 在ssm中起什么作用？</h4><blockquote><ul><li>Spring：轻量级框架</li><li>作用：Bean工厂，用来管理Bean的生命周期和框架集成。</li><li>两大核心：1、IOC/DI(控制反转/依赖注入) ：把dao依赖注入到service层，service层反转给action层，Spring顶层容器为BeanFactory。2、AOP：面向切面编程</li></ul></blockquote><h4 id="2、Spring的事务？"><a href="#2、Spring的事务？" class="headerlink" title="2、Spring的事务？"></a>2、Spring的事务？</h4><blockquote><ul><li>编程式事务管理：编程方式管理事务，极大灵活性，难维护。</li><li>声明式事务管理：可以将业务代码和事务管理分离，用注解和xml配置来管理事务。</li></ul></blockquote><h4 id="3、IOC-在项目中的作用？"><a href="#3、IOC-在项目中的作用？" class="headerlink" title="3、IOC 在项目中的作用？"></a>3、IOC 在项目中的作用？</h4><blockquote><p>作用：Ioc解决对象之间的依赖问题，把所有Bean的依赖关系通过配置文件或注解关联起来，降低了耦合度。</p></blockquote><h4 id="4、Spring的配置文件中的内容？"><a href="#4、Spring的配置文件中的内容？" class="headerlink" title="4、Spring的配置文件中的内容？"></a>4、Spring的配置文件中的内容？</h4><blockquote><ul><li>开启事务注解驱动</li><li>事务管理器</li><li>开启注解功能，并配置扫描包</li><li>配置数据库</li><li>配置SQL会话工厂，别名，映射文件</li><li>不用编写Dao层的实现类</li></ul></blockquote><h4 id="5、Spring下的注解？"><a href="#5、Spring下的注解？" class="headerlink" title="5、Spring下的注解？"></a>5、Spring下的注解？</h4><blockquote><ul><li>注册：@Controller @Service @Component</li><li>注入：@Autowired @Resource</li><li>请求地址：@RequestMapping</li><li>返回具体数据类型而非跳转：@ResponseBody</li></ul></blockquote><h4 id="6、Spring-DI-的三种方式"><a href="#6、Spring-DI-的三种方式" class="headerlink" title="6、Spring DI 的三种方式?"></a>6、Spring DI 的三种方式?</h4><blockquote><p>构造器注入：通过构造方法初始化</p><p>setter方法注入：通过setter方法初始化</p><p>接口注入</p></blockquote><h4 id="7、Spring主要使用了什么模式？"><a href="#7、Spring主要使用了什么模式？" class="headerlink" title="7、Spring主要使用了什么模式？"></a>7、Spring主要使用了什么模式？</h4><blockquote><ul><li>工厂模式：每个Bean的创建通过方法</li><li>单例模式：默认的每个Bean的作用域都是单例</li><li>代理模式：关于Aop的实现通过代理模式</li></ul></blockquote><h4 id="8、IOC，AOP的实现原理？"><a href="#8、IOC，AOP的实现原理？" class="headerlink" title="8、IOC，AOP的实现原理？"></a>8、IOC，AOP的实现原理？</h4><blockquote><ul><li>IOC：通过反射机制生成对象注入</li><li>AOP：动态代理</li></ul></blockquote><h3 id="二、SpringMvc面试题"><a href="#二、SpringMvc面试题" class="headerlink" title="二、SpringMvc面试题"></a>二、SpringMvc面试题</h3><h4 id="1、SpringMvc-的控制器是不是单例模式，如果是，有什么问题，怎么解决？"><a href="#1、SpringMvc-的控制器是不是单例模式，如果是，有什么问题，怎么解决？" class="headerlink" title="1、SpringMvc 的控制器是不是单例模式，如果是，有什么问题，怎么解决？"></a>1、SpringMvc 的控制器是不是单例模式，如果是，有什么问题，怎么解决？</h4><blockquote><ul><li>问题：单例模式，在多线程访问时有线程安全问题</li><li>解决方法：不要用同步，在控制器里面不能写字段</li></ul></blockquote><h4 id="2、SpringMvc-中控制器的注解？"><a href="#2、SpringMvc-中控制器的注解？" class="headerlink" title="2、SpringMvc 中控制器的注解？"></a>2、SpringMvc 中控制器的注解？</h4><blockquote><p>@Controller：该注解表明该类扮演控制器的角色</p></blockquote><h4 id="3、-RequestMapping-注解用在类上的作用？"><a href="#3、-RequestMapping-注解用在类上的作用？" class="headerlink" title="3、@RequestMapping 注解用在类上的作用？"></a>3、@RequestMapping 注解用在类上的作用？</h4><blockquote><p>作用：用来映射一个URL到一个类或者一个特定的处理方法上</p></blockquote><h4 id="4、前台多个参数，这些参数都是一个对象，快速得到对象？"><a href="#4、前台多个参数，这些参数都是一个对象，快速得到对象？" class="headerlink" title="4、前台多个参数，这些参数都是一个对象，快速得到对象？"></a>4、前台多个参数，这些参数都是一个对象，快速得到对象？</h4><blockquote><p>方法：直接在方法中声明这个对象，SpringMvc就自动把属性赋值到这个对象里面</p></blockquote><h4 id="5、SpringMvc中函数的返回值？"><a href="#5、SpringMvc中函数的返回值？" class="headerlink" title="5、SpringMvc中函数的返回值？"></a>5、SpringMvc中函数的返回值？</h4><blockquote><p>String，ModelAndView，List，Set 等</p><p>一般String，Ajax请求，返回一个List集合</p></blockquote><h5 id="6、SpringMvc中的转发和重定向"><a href="#6、SpringMvc中的转发和重定向" class="headerlink" title="6、SpringMvc中的转发和重定向?"></a>6、SpringMvc中的转发和重定向?</h5><blockquote><ul><li>转发：return：“hello”</li><li>重定向 ：return：“redirect:hello.jsp”</li></ul></blockquote><h5 id="7、SpringMvc和Ajax之间的相互调用？"><a href="#7、SpringMvc和Ajax之间的相互调用？" class="headerlink" title="7、SpringMvc和Ajax之间的相互调用？"></a>7、SpringMvc和Ajax之间的相互调用？</h5><p>通过JackSon框架把java里面对象直接转换成js可识别的json对象，具体步骤如下：</p><blockquote><ul><li>加入JackSon.jar</li><li>在配置文件中配置json的映射</li><li>在接受Ajax方法里面直接返回Object，list等，方法前面需要加上注解@ResponseBody</li></ul></blockquote><h4 id="8、SpringMvc的工作流程图"><a href="#8、SpringMvc的工作流程图" class="headerlink" title="8、SpringMvc的工作流程图?"></a>8、SpringMvc的工作流程图?</h4><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/29/ssm-kuang-jia-chang-jian-mian-shi-ti/001.png" alt></p><h4 id="9、Struts2-和-SpringMvc的区别"><a href="#9、Struts2-和-SpringMvc的区别" class="headerlink" title="9、Struts2 和 SpringMvc的区别?"></a>9、Struts2 和 SpringMvc的区别?</h4><blockquote><p>入口不同：</p></blockquote><ul><li>Struts2：filter过滤器</li><li>SpringMvc：一个Servlet即前端控制器</li></ul><blockquote><p>开发方式不同：</p></blockquote><ul><li>Struts2：基于类开发，传递参数通过类的属性，只能设置为多例</li><li>SpringMvc：基于方法开发(一个url对应一个方法)，请求参数传递到方法形参，可以为单例也可以为多例(建议单例)</li></ul><blockquote><p>请求方式不同：</p></blockquote><ul><li>Struts2：值栈村塾请求和响应的数据，通过OGNL存取数据</li><li>SpringMvc：通过参数解析器将request请求内容解析，给方法形参赋值，将数据和视图封装成ModelAndView对象，最后又将ModelAndView中的模型数据通过request域传输到页面，jsp视图解析器默认使用的是jstl。</li></ul><h3 id="三、Mybatis面试题"><a href="#三、Mybatis面试题" class="headerlink" title="三、Mybatis面试题"></a>三、Mybatis面试题</h3><h4 id="1、Ibatis和Mybatis？"><a href="#1、Ibatis和Mybatis？" class="headerlink" title="1、Ibatis和Mybatis？"></a>1、Ibatis和Mybatis？</h4><ul><li>Ibatis：2010年，apache的Ibatis框架停止更新，并移交给了google团队，同时更名为MyBatis。从2010年后Ibatis在没更新过，彻底变成了一个孤儿框架。一个没人维护的框架注定被mybatis拍在沙滩上。</li><li>Mybatis：Ibatis的升级版本。</li></ul><h4 id="2、什么是Mybatis的接口绑定，有什么好处？"><a href="#2、什么是Mybatis的接口绑定，有什么好处？" class="headerlink" title="2、什么是Mybatis的接口绑定，有什么好处？"></a>2、什么是Mybatis的接口绑定，有什么好处？</h4><p>Mybatis实现了DAO接口与xml映射文件的绑定，自动为我们生成接口的具体实现，使用起来变得更加省事和方便。</p><h4 id="3、什么情况用注解，什么情况用xml绑定？"><a href="#3、什么情况用注解，什么情况用xml绑定？" class="headerlink" title="3、什么情况用注解，什么情况用xml绑定？"></a>3、什么情况用注解，什么情况用xml绑定？</h4><ul><li>注解使用情况：Sql语句简单时</li><li>xml绑定使用情况：xml绑定 (@RequestMap用来绑定xml文件)</li></ul><h4 id="4、Mybatis在核心处理类叫什么"><a href="#4、Mybatis在核心处理类叫什么" class="headerlink" title="4、Mybatis在核心处理类叫什么?"></a>4、Mybatis在核心处理类叫什么?</h4><p>SqlSession</p><h4 id="5、查询表名和返回实体Bean对象不一致，如何处理？"><a href="#5、查询表名和返回实体Bean对象不一致，如何处理？" class="headerlink" title="5、查询表名和返回实体Bean对象不一致，如何处理？"></a>5、查询表名和返回实体Bean对象不一致，如何处理？</h4><p>映射键值对即可</p><h5 id="6、Mybatis的好处？"><a href="#6、Mybatis的好处？" class="headerlink" title="6、Mybatis的好处？"></a>6、Mybatis的好处？</h5><ul><li>把Sql语句从Java中独立出来。</li><li>封装了底层的JDBC，API的调用，并且能够将结果集自动转换成JavaBean对象，简化了Java数据库编程的重复工作。</li><li>自己编写Sql语句，更加的灵活。</li><li>入参无需用对象封装（或者map封装）,使用@Param注解</li></ul><h5 id="7、Mybatis配置一对多？"><a href="#7、Mybatis配置一对多？" class="headerlink" title="7、Mybatis配置一对多？"></a>7、Mybatis配置一对多？</h5><pre><code>&lt;collection property=&quot;topicComment&quot; column =&quot;id&quot; ofType=&quot;com.zms.pojo.Comment&quot;select = &quot;selectComment&quot;/&gt;</code></pre><ul><li>property：属性名</li><li>column：共同列</li><li>ofType：集合中元素的类型</li><li>select：要连接的查询</li></ul><h5 id="8、Mybatis配置一对一？"><a href="#8、Mybatis配置一对一？" class="headerlink" title="8、Mybatis配置一对一？"></a>8、Mybatis配置一对一？</h5><pre><code>&lt;association  property=&quot;topicType&quot; select=&quot;selectType&quot; column=&quot;topics_type_id&quot; javaType=&quot;com.zms.pojo.Type&quot;/&gt;</code></pre><ul><li>property：属性名</li><li>select：要连接的查询</li><li>column：共同列</li><li>javaType：集合中元素的类型</li></ul><h5 id="9-、-和-的区别？"><a href="#9-、-和-的区别？" class="headerlink" title="9 、${} 和 #{}的区别？"></a>9 、${} 和 #{}的区别？</h5><blockquote><ul><li>${}：简单字符串替换，把${}直接替换成变量的值，不做任何转换，这种是取值以后再去编译SQL语句。</li><li>#{}：预编译处理，sql中的#{}替换成？，补全预编译语句，有效的防止Sql语句注入，这种取值是编译好SQL语句再取值。</li></ul><p>总结：一般用#{}来进行列的代替</p></blockquote><h5 id="10、获取上一次自动生成的主键值？"><a href="#10、获取上一次自动生成的主键值？" class="headerlink" title="10、获取上一次自动生成的主键值？"></a>10、获取上一次自动生成的主键值？</h5><pre><code>select last_insert_id()</code></pre><h4 id="11、Mybatis如何分页，分页原理？"><a href="#11、Mybatis如何分页，分页原理？" class="headerlink" title="11、Mybatis如何分页，分页原理？"></a>11、Mybatis如何分页，分页原理？</h4><ul><li>RowBounds对象分页</li><li>在Sql内直接书写，带有物理分页</li></ul><h5 id="12、Mybatis工作原理？"><a href="#12、Mybatis工作原理？" class="headerlink" title="12、Mybatis工作原理？"></a>12、Mybatis工作原理？</h5><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/29/ssm-kuang-jia-chang-jian-mian-shi-ti/002.png" alt></p><blockquote><p>原理：</p><ul><li>通过SqlSessionFactoryBuilder从mybatis-config.xml配置文件中构建出SqlSessionFactory。</li><li>SqlSessionFactory开启一个SqlSession，通过SqlSession实例获得Mapper对象并且运行Mapper映射的Sql语句。</li><li>完成数据库的CRUD操作和事务提交，关闭SqlSession。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>平衡二叉树、B树、B+树，B*树的区别</title>
      <link href="/2019/06/27/ping-heng-er-cha-shu-b-shu-b-shu-b-shu-de-qu-bie/"/>
      <url>/2019/06/27/ping-heng-er-cha-shu-b-shu-b-shu-b-shu-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<h1 id="平衡二叉树、B树、B-树，B-树的区别"><a href="#平衡二叉树、B树、B-树，B-树的区别" class="headerlink" title="平衡二叉树、B树、B+树，B*树的区别"></a>平衡二叉树、B树、B+树，B*树的区别</h1><p>[TOC]</p><h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><blockquote><p>定义：<strong>基于</strong>二分法<strong>的策略</strong>提高数据的查找速度**的一种二叉树数据结构；</p><p><strong>特点：</strong>平衡二叉树是采用<strong>二分法</strong>思想把数据按规则组装成一个树形结构的数据，用这个树形结构的数据减少无关数据的检索，大大的提升了数据检索的速度；平衡二叉树的数据结构组装过程遵循以下规则：</p><p>（1）<strong>非叶子节点</strong>只能允许<strong>最多两个子节点</strong>存在。</p><p>（2）每一个非叶子节点数据分布规则为<strong>左边的子节点小当前节点的值</strong>，<strong>右边的子节点大于当前节点的值</strong>(这里值是基于自己的算法规则而定的，比如hash值)；</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/27/ping-heng-er-cha-shu-b-shu-b-shu-b-shu-de-qu-bie/001.png" alt></p><blockquote><p>平衡树的层级结构：因为平衡二叉树<strong>查询复杂度</strong>和<strong>树的层级（h高度）</strong>成反比，h值越小查询越快，为了保证树的左右两端数据大致平衡以<strong>降低二叉树的查询难度</strong>一般会采用一种算法机制实现<strong>节点数据结构的平</strong>衡，实现了这种算法的有比如<strong>AVL</strong>、<strong>Treap</strong>、<strong>红黑树</strong>等，使用平衡二叉树能保证数据的<strong>左右两边的节点层级相差不会大于1</strong>，这样可以避免树形结构由于删除增加变成线性链表进而影响查询效率。保证数据平衡的情况下查找数据的速度近于二分法查找。</p></blockquote><h5 id="总结平衡二叉树特点："><a href="#总结平衡二叉树特点：" class="headerlink" title="总结平衡二叉树特点："></a>总结平衡二叉树特点：</h5><blockquote><ol><li>非叶子节点最多拥有两个子节点；</li><li>非叶子节值大于左边子节点、小于右边子节点；</li><li>树的左右两边的层级数相差不会大于1;</li><li>没有值相等重复的节点;</li></ol></blockquote><h4 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h4><blockquote><p>定义：B树和平衡二叉树稍有不同的是B树属于<strong>多叉树</strong>又名<strong>平衡多路查找树</strong>（查找路径不只两个），<strong>数据库索引</strong>技术里大量使用者B树和B+树的数据结构</p></blockquote><h5 id="规则："><a href="#规则：" class="headerlink" title="规则："></a>规则：</h5><blockquote><ol><li><strong>排序方式</strong>：所有节点关键字是按<strong>递增次序</strong>排列，并遵循<strong>左小右大</strong>原则；</li><li><strong>子节点数</strong>：非叶节点的<strong>子节点数&gt;1</strong>，且<strong>&lt;=M （M&gt;=2）</strong>，空树除外（注：M阶代表一个树节点最多有多少个查找路径，M=M路,当M=2则是2叉树,M=3则是3叉）；</li><li><strong>关键字数</strong>：枝节点的<strong>关键字数量</strong>大于等于ceil(m/2)-1个且小于等于M-1个（注：ceil()是个朝正无穷方向取整的函数 如ceil(1.1)结果为2);</li><li>所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null对应下图最后一层节点的空格子;</li></ol><p>示意图如下图所示，这里假设字母的排序规则为A&gt;B&gt;C…：</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/27/ping-heng-er-cha-shu-b-shu-b-shu-b-shu-de-qu-bie/002.png" alt></p><blockquote><p>如上图我要从上图中找到E，查找流程如下</p><ol><li>获取根节点的关键字进行比较，当前根节点关键字为M，E&lt;M，所以往找到指向左边的子节点（二分法规则，左小右大，左边放小于当前节点值的子节点、右边放大于当前节点值的子节点）；</li><li>拿到关键字D和G，D&lt;E&lt;G 所以直接找到D和G中间的节点；</li><li>拿到E和F，因为E=E 所以直接返回关键字和指针信息（如果树结构里面没有包含所要查找的节点则返回null）；</li></ol></blockquote><h4 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h4><blockquote><p><strong>概念：</strong>B+树是B树的一个升级版，相对于B树来说B+树更充分的利用了节点的空间，让查询速度更加稳定，其速度完全接近于二分法查找。为什么说B+树查找的效率要比B树更高、更稳定；</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/27/ping-heng-er-cha-shu-b-shu-b-shu-b-shu-de-qu-bie/003.png" alt></p><blockquote><p>如上图所示，我们看看B+树遵循的规则：</p><ol><li>B+跟B树不同之处在于B+树的<strong>非叶子</strong>节点不保存关键字记录的指针，只进行数据索引，即有k个子树的中间节点包含有k个元素，而B树中是k-1个元素，这样使得B+树每个<strong>非叶子</strong>节点所能保存的关键字大大增加；</li><li>B+树<strong>叶子</strong>节点保存了父节点的所有关键字记录的指针，所有数据地址必须要到叶子节点才能获取到，所以<strong>每次数据查询的次数都一样</strong>；</li><li>B+树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针（如图中红色虚线框中所示）。</li><li>所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素(如图中黑色和红色标出的数字)</li><li>非叶子节点的子节点数=关键字数，另一种规则是非叶节点的关键字数=子节点数-1，虽然这两种规则数据排列结构不一样，但其原理还是一样的<strong>Mysql 的B+树是用第一种方式实现</strong>;</li></ol><p>可能有的读者对上面的第1点不太理解，从图上看B树和B+树的节点中都是数字啊，有什么不一样，为什么说B+树的非叶子节点不保存关键字记录的指针？这里引入一个<strong>“卫星数据”</strong>的概念来给大家解释，所谓卫星数据，指的是<strong>索引元素所指向的数据记录</strong>，也就是我们这里说的<strong>“关键字记录的指针”</strong>，比如数据库中的某一行。在B树中，无论中间节点还是叶子节点都带有卫星数据，而B+树只有叶子节点才带有卫星数据，我们来给一张对比图：</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/27/ping-heng-er-cha-shu-b-shu-b-shu-b-shu-de-qu-bie/004.png" alt></p><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/27/ping-heng-er-cha-shu-b-shu-b-shu-b-shu-de-qu-bie/005.png" alt></p><blockquote><p>从上面两幅图就可以就看出，B树的每一个节点都有一个<strong>“关键字记录的指针”</strong>（即图中的data部分），而B+树只有叶子节点才有。</p><p><strong>特点：</strong></p><p>1、B+<strong>树的层级更少</strong>：相较于B树B+每个<strong>非叶子</strong>节点存储的关键字数更多，树的层级更少所以查询数据更快；</p><p>2、B+<strong>树查询速度更稳定</strong>：B+所有关键字数据地址都存在<strong>叶子</strong>节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;</p><p>3、B+<strong>树天然具备排序功能：</strong>B+树所有的<strong>叶子</strong>节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。</p><p>4、B+<strong>树全节点遍历更快：</strong>B+树遍历整棵树只需要遍历所有的<strong>叶子</strong>节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。</p><p><strong>B树</strong>相对于<strong>B+树</strong>的优点是，如果经常访问的数据离根节点很近，而<strong>B树</strong>的<strong>非叶子</strong>节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比<strong>B+树</strong>快</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/27/ping-heng-er-cha-shu-b-shu-b-shu-b-shu-de-qu-bie/006.png" alt></p><blockquote><p>规则：B*树是B+树的变种，相对于B+树他们的不同之处如下：</p><ol><li>首先是关键字个数限制问题，B+树初始化的关键字初始化个数是ceil(m/2)，b*树的初始化个数为$ceil(rac{2}{3}m)$</li><li>B<em>树中**</em>非根<strong><em>和</em></strong>非叶子结点<em>**增加\</em>指向兄弟的指针*，如上图的红色箭头所示。</li><li>B+树节点满时就会分裂，而B<em>树节点满时会**</em>检查兄弟节点是否满<em>**（因为每个节点都有指向兄弟的指针），如果兄弟节点未满则向兄弟节点转移关键字，如果兄弟节点已满，则\</em>从当前节点和兄弟节点各拿出1/3的数据创建一个新的节点出来*；</li></ol><p>特点：</p><p>在B+树的基础上因其初始化的容量变大，使得节点空间使用率更高，而又存有兄弟节点的指针，可以向兄弟节点转移关键字的特性使得B*树的分解次数变得更少；</p></blockquote><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote><p><strong>1、相同思想和策略</strong></p><p>从平衡二叉树、B树、B+树、B*树总体来看它们的贯彻的思想是相同的，都是采用二分法和数据平衡策略来提升查找数据的速度；</p><p><strong>2、不同的方式的磁盘空间利用</strong></p><p>不同点是他们一个一个在演变的过程中通过IO从磁盘读取数据的原理进行一步步的演变，每一次演变都是为了让节点的空间更合理的运用起来，从而使树的层级减少达到快速查找数据的目的；</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 日常学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 平衡二叉树 B树 B+树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CAS单点登录原理解析</title>
      <link href="/2019/06/26/cas-dan-dian-deng-lu-yuan-li-jie-xi/"/>
      <url>/2019/06/26/cas-dan-dian-deng-lu-yuan-li-jie-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="CAS单点登录原理解析"><a href="#CAS单点登录原理解析" class="headerlink" title="CAS单点登录原理解析"></a>CAS单点登录原理解析</h1><h4 id="1、基于Cookie的单点登录的回顾"><a href="#1、基于Cookie的单点登录的回顾" class="headerlink" title="1、基于Cookie的单点登录的回顾"></a>1、基于Cookie的单点登录的回顾</h4><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/26/cas-dan-dian-deng-lu-yuan-li-jie-xi/001.png" alt></p><blockquote><p>基于Cookie的单点登录核心原理：</p><p>​      将用户名密码加密之后存于Cookie中，之后访问网站时在过滤器（filter）中校验用户权限，如果没有权限则从Cookie中取出用户名密码进行登录，让用户从某种意义上觉得只登录了一次。</p><p>​      该方式缺点就是多次传送用户名密码，增加被盗风险，以及不能跨域。同时<a href="http://www.qiandu.com与mail.qiandu.com同时拥有登录逻辑的代码，如果涉及到修改操作，则需要修改两处。" target="_blank" rel="noopener">www.qiandu.com与mail.qiandu.com同时拥有登录逻辑的代码，如果涉及到修改操作，则需要修改两处。</a></p></blockquote><h4 id="2、统一认证中心方案原理"><a href="#2、统一认证中心方案原理" class="headerlink" title="2、统一认证中心方案原理"></a>2、统一认证中心方案原理</h4><blockquote><p>​        在生活中我们也有类似的相关生活经验，例如你去食堂吃饭，食堂打饭的阿姨（<a href="http://www.qiandu.com）告诉你，不收现金。并且告诉你，你去门口找换票的（passport.com）换小票。于是你换完票之后，再去找食堂阿姨，食堂阿姨拿着你的票，问门口换票的，这个票是真的吗？换票的说，是真的，于是给你打饭了。" target="_blank" rel="noopener">www.qiandu.com）告诉你，不收现金。并且告诉你，你去门口找换票的（passport.com）换小票。于是你换完票之后，再去找食堂阿姨，食堂阿姨拿着你的票，问门口换票的，这个票是真的吗？换票的说，是真的，于是给你打饭了。</a></p><p>​      基于上述生活中的场景，我们将基于Cookie的单点登录改良以后的方案如下：</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/26/cas-dan-dian-deng-lu-yuan-li-jie-xi/002.png" alt></p><blockquote><p>经过分析，Cookie单点登录认证太过于分散，每个网站都持有一份登陆认证代码。于是我们将认证统一化，形成一个独立的服务。当我们需要登录操作时，则重定向到统一认证中心<a href="http://passport.com。于是乎整个流程就如上图所示：" target="_blank" rel="noopener">http://passport.com。于是乎整个流程就如上图所示：</a><br>     第一步：用户访问<a href="http://www.qiandu.com。过滤器判断用户是否登录，没有登录，则重定向（302）到网站http://passport.com。" target="_blank" rel="noopener">www.qiandu.com。过滤器判断用户是否登录，没有登录，则重定向（302）到网站http://passport.com。</a><br>     第二步：重定向到passport.com，输入用户名密码。passport.com将用户登录的信息记录到服务器的session中。<br>     第三步：passport.com给浏览器发送一个特殊的凭证，浏览器将凭证交给<a href="http://www.qiandu.com，www.qiandu.com则拿着浏览器交给他的凭证去passport.com验证凭证是否有效，从而判断用户是否登录成功。" target="_blank" rel="noopener">www.qiandu.com，www.qiandu.com则拿着浏览器交给他的凭证去passport.com验证凭证是否有效，从而判断用户是否登录成功。</a><br>     第四步：登录成功，浏览器与网站之间进行正常的访问。</p></blockquote><h4 id="3、Yelu大学研发的CAS-Central-Authentication-Server"><a href="#3、Yelu大学研发的CAS-Central-Authentication-Server" class="headerlink" title="3、Yelu大学研发的CAS(Central Authentication Server)"></a>3、Yelu大学研发的CAS(Central Authentication Server)</h4><blockquote><p>下面就以耶鲁大学研发的CAS为分析依据，分析其工作原理。首先看一下最上层的项目部署图：</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/26/cas-dan-dian-deng-lu-yuan-li-jie-xi/003.png" alt></p><blockquote><p>部署项目时需要部署一个独立的认证中心（cas.qiandu.com），以及其他N个用户自己的web服务。</p><p>认证中心：也就是cas.qiandu.com，即cas-server。用来提供认证服务，由CAS框架提供，用户只需要根据业务实现认证的逻辑即可。</p><p>用户web项目：只需要在web.xml中配置几个过滤器，用来保护资源，过滤器也是CAS框架提供了，即cas-client，基本不需要改动可以直接使用。</p></blockquote><h4 id="4、CAS的详细登录流程"><a href="#4、CAS的详细登录流程" class="headerlink" title="4、CAS的详细登录流程"></a>4、CAS的详细登录流程</h4><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/26/cas-dan-dian-deng-lu-yuan-li-jie-xi/004.png" alt></p><blockquote><p>上图是3个登录场景，分别为：第一次访问<a href="http://www.qiandu.com、第二次访问、以及登录状态下第一次访问mail.qiandu.com。" target="_blank" rel="noopener">www.qiandu.com、第二次访问、以及登录状态下第一次访问mail.qiandu.com。</a></p><p>下面就详细说明上图中每个数字标号做了什么，以及相关的请求内容，响应内容。</p></blockquote><h5 id="4-1、第一次访问www-qiandu-com"><a href="#4-1、第一次访问www-qiandu-com" class="headerlink" title="4.1、第一次访问www.qiandu.com"></a>4.1、第一次访问<a href="http://www.qiandu.com" target="_blank" rel="noopener">www.qiandu.com</a></h5><blockquote><p>标号1：用户访问<a href="http://www.qiandu.com，经过他的第一个过滤器（cas提供，在web.xml中配置）AuthenticationFilter。" target="_blank" rel="noopener">http://www.qiandu.com，经过他的第一个过滤器（cas提供，在web.xml中配置）AuthenticationFilter。</a></p><p>​      过滤器全称：org.jasig.cas.client.authentication.AuthenticationFilter</p><p>​      主要作用：判断是否登录，如果没有登录则重定向到认证中心。</p><p>标号2：<a href="http://www.qiandu.com发现用户没有登录，则返回浏览器重定向地址。" target="_blank" rel="noopener">www.qiandu.com发现用户没有登录，则返回浏览器重定向地址。</a></p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/26/cas-dan-dian-deng-lu-yuan-li-jie-xi/005.png" alt></p><blockquote><p>首先可以看到我们请求<a href="http://www.qiandu.com，之后浏览器返回状态码302，然后让浏览器重定向到cas.qiandu.com并且通过get的方式添加参数service，该参数目的是登录成功之后会要重定向回来，因此需要该参数。并且你会发现，其实server的值就是编码之后的我们请求www.qiandu.com的地址。" target="_blank" rel="noopener">www.qiandu.com，之后浏览器返回状态码302，然后让浏览器重定向到cas.qiandu.com并且通过get的方式添加参数service，该参数目的是登录成功之后会要重定向回来，因此需要该参数。并且你会发现，其实server的值就是编码之后的我们请求www.qiandu.com的地址。</a></p><p>标号3：浏览器接收到重定向之后发起重定向，请求cas.qiandu.com。</p><p>标号4：认证中心cas.qiandu.com接收到登录请求，返回登陆页面。</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/26/cas-dan-dian-deng-lu-yuan-li-jie-xi/006.png" alt></p><blockquote><p>上图就是标号3的请求，以及标号4的响应。请求的URL是标号2返回的URL。之后认证中心就展示登录的页面，等待用户输入用户名密码。</p><p>标号5：用户在cas.qiandu.com的login页面输入用户名密码，提交。</p><p>标号6：服务器接收到用户名密码，则验证是否有效，验证逻辑可以使用cas-server提供现成的，也可以自己实现。</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/26/cas-dan-dian-deng-lu-yuan-li-jie-xi/007.png" alt></p><blockquote><p>上图就是标号5的请求，以及标号6的响应了。当cas.qiandu.com即csa-server认证通过之后，会返回给浏览器302，重定向的地址就是Referer中的service参数对应的值。后边并通过get的方式挟带了一个ticket令牌，这个ticket就是ST（数字3处）。同时会在Cookie中设置一个CASTGC，该cookie是网站cas.qiandu.com的cookie，只有访问这个网站才会携带这个cookie过去。</p><p>​      Cookie中的CASTGC：向cookie中添加该值的目的是当下次访问cas.qiandu.com时，浏览器将Cookie中的TGC携带到服务器，服务器根据这个TGC，查找与之对应的TGT。从而判断用户是否登录过了，是否需要展示登录页面。TGT与TGC的关系就像SESSION与Cookie中SESSIONID的关系。</p><p>​      TGT：Ticket Granted Ticket（俗称大令牌，或者说票根，他可以签发ST）</p><p>​      TGC：Ticket Granted Cookie（cookie中的value），存在Cookie中，根据他可以找到TGT。</p><p>​      ST：Service Ticket （小令牌），是TGT生成的，默认是用一次就生效了。也就是上面数字3处的ticket值。</p><p>标号7：浏览器从cas.qiandu.com哪里拿到ticket之后，就根据指示重定向到<a href="http://www.qiandu.com，请求的url就是上面返回的url。" target="_blank" rel="noopener">www.qiandu.com，请求的url就是上面返回的url。</a></p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/26/cas-dan-dian-deng-lu-yuan-li-jie-xi/008.png" alt></p><blockquote><p>标号8：<a href="http://www.qiandu.com在过滤器中会取到ticket的值，然后通过http方式调用cas.qiandu.com验证该ticket是否是有效的。" target="_blank" rel="noopener">www.qiandu.com在过滤器中会取到ticket的值，然后通过http方式调用cas.qiandu.com验证该ticket是否是有效的。</a></p><p>标号9：cas.qiandu.com接收到ticket之后，验证，验证通过返回结果告诉<a href="http://www.qiandu.com该ticket有效。" target="_blank" rel="noopener">www.qiandu.com该ticket有效。</a></p><p>标号10：<a href="http://www.qiandu.com接收到cas-server的返回，知道了用户合法，展示相关资源到用户浏览器上。" target="_blank" rel="noopener">www.qiandu.com接收到cas-server的返回，知道了用户合法，展示相关资源到用户浏览器上。</a></p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/26/cas-dan-dian-deng-lu-yuan-li-jie-xi/009.png" alt></p><blockquote><p>至此，第一次访问的整个流程结束，其中标号8与标号9的环节是通过代码调用的，并不是浏览器发起，所以没有截取到报文。</p></blockquote><h4 id="4-2、第二次访问www-qiandu-com"><a href="#4-2、第二次访问www-qiandu-com" class="headerlink" title="4.2、第二次访问www.qiandu.com"></a>4.2、第二次访问<a href="http://www.qiandu.com" target="_blank" rel="noopener">www.qiandu.com</a></h4><blockquote><p>上面以及访问过一次了，当第二次访问的时候发生了什么呢？</p><p>标号11：用户发起请求，访问<a href="http://www.qiandu.com。会经过cas-client，也就是过滤器，因为第一次访问成功之后www.qiandu.com中会在session中记录用户信息，因此这里直接就通过了，不用验证了。" target="_blank" rel="noopener">www.qiandu.com。会经过cas-client，也就是过滤器，因为第一次访问成功之后www.qiandu.com中会在session中记录用户信息，因此这里直接就通过了，不用验证了。</a></p><p>标号12：用户通过权限验证，浏览器返回正常资源。</p></blockquote><h4 id="4-3、访问mail-qiandu-com"><a href="#4-3、访问mail-qiandu-com" class="headerlink" title="4.3、访问mail.qiandu.com"></a>4.3、访问mail.qiandu.com</h4><blockquote><p>标号13：用户在<a href="http://www.qiandu.com正常上网，突然想访问mail.qiandu.com，于是发起访问mail.qiandu.com的请求。" target="_blank" rel="noopener">www.qiandu.com正常上网，突然想访问mail.qiandu.com，于是发起访问mail.qiandu.com的请求。</a></p><p>标号14：mail.qiandu.com接收到请求，发现第一次访问，于是给他一个重定向的地址，让他去找认证中心登录。</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/26/cas-dan-dian-deng-lu-yuan-li-jie-xi/010.png" alt></p><blockquote><p>上图可以看到，用户请求mail.qiandu.com，然后返回给他一个网址，状态302重定向，service参数就是回来的地址。</p><p>标号15：浏览器根据14返回的地址，发起重定向，因为之前访问过一次了，因此这次会携带上次返回的Cookie：TGC到认证中心。</p><p>标号16：认证中心收到请求，发现TGC对应了一个TGT，于是用TGT签发一个ST，并且返回给浏览器，让他重定向到mail.qiandu.com</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/26/cas-dan-dian-deng-lu-yuan-li-jie-xi/011.png" alt></p><blockquote><p>可以发现请求的时候是携带Cookie：CASTGC的，响应的就是一个地址加上TGT签发的ST也就是ticket。</p><p>标号17：浏览器根据16返回的网址发起重定向。</p><p>标号18：mail.qiandu.com获取ticket去认证中心验证是否有效。</p><p>标号19：认证成功，返回在mail.qiandu.com的session中设置登录状态，下次就直接登录。</p><p>标号20：认证成功之后就反正用想要访问的资源了。</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/26/cas-dan-dian-deng-lu-yuan-li-jie-xi/012.png" alt></p><h4 id="五、转自：https-www-cnblogs-com-lihuidu-p-6495247-html"><a href="#五、转自：https-www-cnblogs-com-lihuidu-p-6495247-html" class="headerlink" title="五、转自：https://www.cnblogs.com/lihuidu/p/6495247.html"></a>五、转自：<a href="https://www.cnblogs.com/lihuidu/p/6495247.html" target="_blank" rel="noopener">https://www.cnblogs.com/lihuidu/p/6495247.html</a></h4>]]></content>
      
      
      <categories>
          
          <category> 单点登录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CAS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac下安装Dubbo和Zookeeper</title>
      <link href="/2019/06/25/mac-xia-an-zhuang-dubbo-he-zookeeper/"/>
      <url>/2019/06/25/mac-xia-an-zhuang-dubbo-he-zookeeper/</url>
      
        <content type="html"><![CDATA[<h1 id="Mac下安装Dubbo和Zookeeper"><a href="#Mac下安装Dubbo和Zookeeper" class="headerlink" title="Mac下安装Dubbo和Zookeeper"></a>Mac下安装Dubbo和Zookeeper</h1><h2 id="一、Zookeeper"><a href="#一、Zookeeper" class="headerlink" title="一、Zookeeper"></a>一、Zookeeper</h2><blockquote><p>zookeeper支持brew安装,检查安装环境</p></blockquote><pre><code>brew info zookeeper</code></pre><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/25/mac-xia-an-zhuang-dubbo-he-zookeeper/001.png" alt></p><pre><code>brew install zookeeper</code></pre><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/25/mac-xia-an-zhuang-dubbo-he-zookeeper/002.png" alt></p><blockquote><p>安装后zookeeper配置文件位置：</p></blockquote><pre><code>/usr/local/etc/zookeeper</code></pre><h4 id="二-、配置文件zookeeper详解"><a href="#二-、配置文件zookeeper详解" class="headerlink" title="二 、配置文件zookeeper详解"></a>二 、配置文件zookeeper详解</h4><h5 id="1、参数详解："><a href="#1、参数详解：" class="headerlink" title="1、参数详解："></a>1、参数详解：</h5><blockquote><p>tickTime：ZK中的一个时间单元。ZK中所有时间都是以这个时间单元为基础，进行整数倍配置的。例如，session的最小超时时间是2*tickTime。</p><p>initLimit：Follower在启动过程中，会从Leader同步所有最新数据，然后确定自己能够对外服务的起始状态。Leader允许F在initLimit时间内完成这个工作。通常情况下，我们不用太在意这个参数的设置。如果ZK集群的数据量确实很大了，F在启动的时候，从Leader上同步数据的时间也会相应变长，因此在这种情况下，有必要适当调大这个参数了。(No Java system property)</p><p>syncLimit：在运行过程中，Leader负责与ZK集群中所有机器进行通信，例如通过一些心跳检测机制，来检测机器的存活状态。如果L发出心跳包在syncLimit之后，还没有从F那里收到响应，那么就认为这个F已经不在线了。注意：不要把这个参数设置得过大，否则可能会掩盖一些问题。(No Java system property)</p><p>dataDir：存储快照文件snapshot的目录。默认情况下，事务日志也会存储在这里。建议同时配置参数dataLogDir, 事务日志的写性能直接影响zk性能。</p><p>-clientPort： 客户端连接server的端口，即对外服务端口，一般设置为2181吧。</p></blockquote><blockquote><p>server.x=[hostname]:nnnnn[:nnnnn]：这里的x是一个数字，与myid文件中的id是一致的。右边可以配置两个端口，第一个端口用于F和L之间的数据同步和其它通信，第二个端口用于Leader选举过程中投票通信。</p></blockquote><h5 id="2-配置启动"><a href="#2-配置启动" class="headerlink" title="2.配置启动"></a>2.配置启动</h5><blockquote><p>安装后，在<code>/usr/local/etc/zookeeper/</code>目录下，已经有了缺省的<code>配置文件</code>。</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/25/mac-xia-an-zhuang-dubbo-he-zookeeper/003.png" alt></p><blockquote><p>打开配置文件</p></blockquote><pre class=" language-cfg"><code class="language-cfg"># The number of milliseconds of each ticktickTime=2000# The number of ticks that the initial# synchronization phase can takeinitLimit=10# The number of ticks that can pass between# sending a request and getting an acknowledgementsyncLimit=5# the directory where the snapshot is stored.# do not use /tmp for storage, /tmp here is just# example sakes.dataDir=/usr/local/var/run/zookeeper/data# the port at which the clients will connectclientPort=2181# the maximum number of client connections.# increase this if you need to handle more clients#maxClientCnxns=60## Be sure to read the maintenance section of the# administrator guide before turning on autopurge.## http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance## The number of snapshots to retain in dataDir#autopurge.snapRetainCount=3# Purge task interval in hours# Set to "0" to disable auto purge feature#autopurge.purgeInterval=1</code></pre><blockquote><p>主要配置</p></blockquote><pre><code>tickTime=2000initLimit=10syncLimit=5dataDir=/usr/local/var/run/zookeeper/dataclientPort=2181</code></pre><blockquote><p>启动zk</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/25/mac-xia-an-zhuang-dubbo-he-zookeeper/004.png" alt></p><h5 id="连接ZooKeeper服务器"><a href="#连接ZooKeeper服务器" class="headerlink" title="连接ZooKeeper服务器"></a>连接ZooKeeper服务器</h5><blockquote><p>ZooKeeper命令行界面（CLI）用于与ZooKeeper集合进行交互以进行开发。它有助于调试和解决不同的选项。使用如下命令：</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/25/mac-xia-an-zhuang-dubbo-he-zookeeper/005.png" alt></p><blockquote><p>一旦客户端启动，就可以使用命令与zookeeper服务器进行交互了。<br>最后使用 <code>Ctrl + c</code> 即可退出zkCli。</p></blockquote><h5 id="停止zookeeper服务器"><a href="#停止zookeeper服务器" class="headerlink" title="停止zookeeper服务器"></a>停止zookeeper服务器</h5><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/25/mac-xia-an-zhuang-dubbo-he-zookeeper/006.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dobbo，zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解跨域SSO单点登录原理与技术</title>
      <link href="/2019/06/24/shen-ru-li-jie-kua-yu-sso-dan-dian-deng-lu-yuan-li-yu-ji-zhu/"/>
      <url>/2019/06/24/shen-ru-li-jie-kua-yu-sso-dan-dian-deng-lu-yuan-li-yu-ji-zhu/</url>
      
        <content type="html"><![CDATA[<h1 id="深入理解跨域SSO单点登录原理与技术"><a href="#深入理解跨域SSO单点登录原理与技术" class="headerlink" title="深入理解跨域SSO单点登录原理与技术"></a>深入理解跨域SSO单点登录原理与技术</h1><p>[TOC]</p><h3 id="一：SSO体系结构"><a href="#一：SSO体系结构" class="headerlink" title="一：SSO体系结构"></a>一：SSO体系结构</h3><h4 id="SSO"><a href="#SSO" class="headerlink" title="SSO"></a>SSO</h4><blockquote><p>SSO英文全称Single Sign On，单点登录。SSO是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。它包括可以将这次主要的登录映射到其他应用中用于同一个用户的登录的机制。它是目前比较流行的企业业务整合的解决方案之一。</p></blockquote><h4 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h4><blockquote><p>当用户第一次访问应用系统1的时候，因为还没有登录，会被引导到认证系统中进行登录；根据用户提供的登录信息，认证系统进行身份校验，如果通过校验，应该返回给用户一个认证的凭据－－token；用户再访问别的应用的时候就会将这个token带上，作为自己认证的凭据，应用系统接受到请求之后会把token送到认证系统进行校验，检查token的合法性。如果通过校验，用户就可以在不用再次登录的情况下访问应用系统2和应用系统3了 。</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/24/shen-ru-li-jie-kua-yu-sso-dan-dian-deng-lu-yuan-li-yu-ji-zhu/001.png" alt></p><h4 id="Token（令牌）"><a href="#Token（令牌）" class="headerlink" title="Token（令牌）"></a>Token（令牌）</h4><blockquote><p>token的意思是“令牌”，是服务端生成的一串字符串，作为客户端进行请求的一个标识。</p><p>当用户第一次登录后，服务器生成一个token并将此token返回给客户端，客户端收到token后把它存储起来，可以放在cookie或者Local Storage（本地存储）里。 以后客户端只需带上这个token前来请求数据即可，无需再次带上用户名和密码。</p><p>简单token的组成；uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign（签名，token的前几位以哈希算法压缩成的一定长度的十六进制字符串。为防止token泄露）。</p><p><strong>设计token的值可以有以下方式</strong></p><ol><li>用设备mac地址作为token</li><li>用sessionid作为token</li></ol></blockquote><h4 id="同域SSO原理分析"><a href="#同域SSO原理分析" class="headerlink" title="同域SSO原理分析"></a>同域SSO原理分析</h4><blockquote><blockquote><p>实际上，HTTP协议是无状态的，单个系统的会话由服务端Session进行维持，Session保持会话的原理是通过Cookie把sessionId写入浏览器，每次访问都会自动携带全部Cookie，在服务端读取其中的sessionId进行验证实现会话保持。同域下单点登录其实就是手写token代替sessionId进行会话认证。</p></blockquote><p><strong>token的生成</strong></p><p>服务端生成token后，将token与user对象存储在Map结构中，token为Key，user对象为value，response.addCookie()生成新的Cookie，名为token，值为token的值。</p><p><strong>token过期移除</strong></p><p>将服务端的token从Map中移除，再删除浏览器端的名为token的Cookie。</p></blockquote><h5 id="认证流程"><a href="#认证流程" class="headerlink" title="认证流程"></a>认证流程</h5><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/24/shen-ru-li-jie-kua-yu-sso-dan-dian-deng-lu-yuan-li-yu-ji-zhu/002.png" alt></p><h4 id="跨域SSO原理分析"><a href="#跨域SSO原理分析" class="headerlink" title="跨域SSO原理分析"></a>跨域SSO原理分析</h4><blockquote><p>当有多个系统时，认证机制的流程如下：</p><ol><li>提供用户登录界面，供用户进行身份认证</li><li>用户验证通过后，生成新token</li><li>将token<->user 对存入全局MAP中供校验</-></li><li><strong>将token写入所有域的Cookie中</strong></li><li>页面重定向回原始请求URL</li></ol><p><strong>分析</strong></p><p>当系统有多个并且在不同域(domain)时，Cookie只会作用在当前域下。</p><p>将token写入所有域的Cookie中才是解决跨域SSO的核心。</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/24/shen-ru-li-jie-kua-yu-sso-dan-dian-deng-lu-yuan-li-yu-ji-zhu/003.png" alt></p><h3 id="二：Cookie增删改查"><a href="#二：Cookie增删改查" class="headerlink" title="二：Cookie增删改查"></a>二：Cookie增删改查</h3><h4 id="如何读取Cookie？"><a href="#如何读取Cookie？" class="headerlink" title="如何读取Cookie？"></a>如何读取Cookie？</h4><blockquote><p>通过Servlet中的request对象可以读取到Cookie数组，然后foreach遍历读取，一般只是获取到nam和value，其他信息写入到浏览器后，浏览器不主动再发回来，读取并无意义。</p></blockquote><pre class=" language-java"><code class="language-java">        Cookie<span class="token punctuation">[</span><span class="token punctuation">]</span> cookies <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getCookies</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cookies <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Cookie cookie <span class="token operator">:</span> cookies<span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>                        cookie<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>                        cookie<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>                        cookie<span class="token punctuation">.</span><span class="token function">getMaxAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>                        cookie<span class="token punctuation">.</span><span class="token function">getPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>                        cookie<span class="token punctuation">.</span><span class="token function">getDomain</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>                        cookie<span class="token punctuation">.</span><span class="token function">getSecure</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>                        cookie<span class="token punctuation">.</span><span class="token function">isHttpOnly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//客户端js是否可以获取</span>                <span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span></code></pre><h4 id="如何写入Cookie带浏览器？"><a href="#如何写入Cookie带浏览器？" class="headerlink" title="如何写入Cookie带浏览器？"></a>如何写入Cookie带浏览器？</h4><blockquote><p>新建Cookie对象设置一系列属性，然后添加到response中去。需要注意的是，当设置path为“/”时，表示所有路径都会被该Cookie作用到，如果设置为<code>/path1</code>那么由<code>/path2</code>发起请求就不会携带该Cookie。默认不设置只作用在当前路径下。</p></blockquote><pre class=" language-java"><code class="language-java">        Cookie cookie <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cookie</span><span class="token punctuation">(</span><span class="token string">"myCookieName"</span><span class="token punctuation">,</span><span class="token string">"myCookieValue"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cookie<span class="token punctuation">.</span><span class="token function">setHttpOnly</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//Javascript不能处理</span>        <span class="token comment" spellcheck="true">//一个正值表示cookie将在经过许多秒之后过期。注意，值是cookie过期的最大时间，而不是cookie当前的时间。</span>        <span class="token comment" spellcheck="true">//负值表示cookie没有持久存储，在Web浏览器退出时将被删除。零值会导致删除cookie。</span>        cookie<span class="token punctuation">.</span><span class="token function">setMaxAge</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cookie<span class="token punctuation">.</span><span class="token function">setSecure</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//如果为true，仅支持HTTPS协议</span>        <span class="token comment" spellcheck="true">//cookie对指定目录中的所有页面以及该目录子目录中的所有页面都可见。</span>        cookie<span class="token punctuation">.</span><span class="token function">setPath</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//cookie.setDomain("www.a.com");//默认情况下，cookie只返回给发送cookie的服务器。</span>        response<span class="token punctuation">.</span><span class="token function">addCookie</span><span class="token punctuation">(</span>cookie<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="修改Cookie"><a href="#修改Cookie" class="headerlink" title="修改Cookie"></a>修改Cookie</h4><blockquote><p>修改更新Cookie时，除了要保证Cookie的name是相同的，也要保证Cookie的一系列属性是相同的，否则浏览器会生成新的Cookie。</p></blockquote><h4 id="删除Cookie"><a href="#删除Cookie" class="headerlink" title="删除Cookie"></a>删除Cookie</h4><blockquote><p>只需要设置Cookie的MaxAge为负值，意味着是过去的Cookie，浏览器就会清除。</p></blockquote><h3 id="三：跨域读写Cookie"><a href="#三：跨域读写Cookie" class="headerlink" title="三：跨域读写Cookie"></a>三：跨域读写Cookie</h3><h4 id="1-利用HTML的script标签跨域写Cookie"><a href="#1-利用HTML的script标签跨域写Cookie" class="headerlink" title="1.利用HTML的script标签跨域写Cookie"></a>1.利用HTML的script标签跨域写Cookie</h4><blockquote><p>比如当前域是<a href="http://www.a.com,下面的script标签是跨域写cookie的核心，通过此标签实现了向www.b.com域写入cookie：" target="_blank" rel="noopener">www.a.com,下面的script标签是跨域写cookie的核心，通过此标签实现了向www.b.com域写入cookie：</a></p></blockquote><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.b.com/setCookie?cname<span class="token punctuation">=</span>token&amp;cval<span class="token punctuation">=</span>123456<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><blockquote><h4 id="P3P协议"><a href="#P3P协议" class="headerlink" title="P3P协议"></a>P3P协议</h4><p>P3P是一种被称为个人隐私安全平台项目（the Platform for Privacy Preferences）的标准，能够保护在线隐私权，使Internet冲浪者可以选择在浏览网页时，是否被第三方收集并利用自己的个人信息。如果一个站点不遵守P3P标准的话，那么有关它的Cookies将被自动拒绝，并且P3P还能够自动识破多种Cookies的嵌入方式。p3p是由全球资讯联盟网所开发的。</p><p><strong>举个例子：</strong></p><p>我们在访问A网站时，理论上说，我们只能把Cookie信息保存到A站域名下，而不能写入到B网站下。如果想要跨域读写Cookie，只是通过script标签变相访问B网站在一些浏览器是行不通的，此时B网站的服务器应该告诉浏览器允许A网站写入Cookie，否则浏览器将会拒绝执行，这就是P3P协议。</p><p><strong>服务端如何告诉浏览器？</strong></p><p>P3P提供了一种简单的方式 ，来加载用户隐私策略，只要在http响应的头信息中增加 <code>response.setHeader(&quot;P3P&quot;,&quot;CP=NON DSP COR CURa ADMa DEVa TAIa PSAa PSDa IVAa IVDa CONa HISa TELa OTPa OUR UNRa IND UNI COM NAV INT DEM CNT PRE LOC);</code>而无需指定隐私策略文件也可以达到指定隐私策略的目的。 CP=后面的字符串分别代表不同的策略信息。</p><p><strong>总结</strong></p><p>因为P3P协议所以不能保证所有浏览器都能通过script标签方式跨域写Cookie，有的浏览器本身就是拒绝跨域的。</p><p>显然这种方式是不能保证跨域写cookie的成功性。</p></blockquote><h4 id="2-通过URL参数实现跨域信息传递"><a href="#2-通过URL参数实现跨域信息传递" class="headerlink" title="2.通过URL参数实现跨域信息传递"></a>2.通过URL参数实现跨域信息传递</h4><blockquote><p>我们要在A域实现写入token到B域，需要在A域设计一个servlet接收请求，代码：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@WebServlet</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"tg"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Servlet</span> <span class="token keyword">extends</span> <span class="token class-name">HttpServlet</span> <span class="token punctuation">{</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doPost</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span> HttpServletResponse response<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//获取请求的目标域</span>        String from <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">"from"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//生成token，</span>        String token <span class="token operator">=</span> <span class="token string">"123456"</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//重定向到目标域</span>        response<span class="token punctuation">.</span><span class="token function">sendRedirect</span><span class="token punctuation">(</span>from <span class="token operator">+</span> <span class="token string">"?cname=token&amp;cval="</span> <span class="token operator">+</span> token<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span></code></pre><blockquote><p>由a域发起请求，请求地址：<code>http://www.a.com/tg?from=http://www.b.com/set_cookie</code>, 请求后该Servlet会获取<code>from</code>参数的值并生成<code>token</code>最后让客户端重定向到<code>http://www.b.com/set_cookie?cname=token&amp;cval=123456</code>，然后B域的Servlet(“set_cookie”)获取Url参数写入Cookie到客户端，代码：</p></blockquote><pre class=" language-java"><code class="language-java">        <span class="token comment" spellcheck="true">//将要写入的cookie项，调用者通过参数传递</span>        String cookieName <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">"cname"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String cookieValue <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">"cval"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//生成cookie</span>        Cookie cookie <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cookie</span><span class="token punctuation">(</span>cookieName<span class="token punctuation">,</span>cookieValue<span class="token punctuation">)</span><span class="token punctuation">;</span>        cookie<span class="token punctuation">.</span><span class="token function">setPath</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//一般可以将domain设置到顶级域</span>        <span class="token comment" spellcheck="true">//cookie.setDomain("www.b.com");</span>        response<span class="token punctuation">.</span><span class="token function">addCookie</span><span class="token punctuation">(</span>cookie<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>这时候再查看B域下的Cookie就可以发现(token=123456)已经被写入到浏览器。</p></blockquote><h4 id="3-读取其它域的Cookie"><a href="#3-读取其它域的Cookie" class="headerlink" title="3.读取其它域的Cookie"></a>3.读取其它域的Cookie</h4><blockquote><p><strong>利用script标签</strong></p><p>利用script标签执行另一个域实现的读取cookie方法，script标签返回结果将是变量定义形式的JS代码，每一个变量表示一个cookie项，这些代码加载后，此页面后续JS代码可以直接在script脚本中读取已定义的变量值，即各cookie值。</p></blockquote><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.b.com/reaf_cookies<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><blockquote><p>HTML页面读取</p></blockquote><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript"><span class="token function">alert</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><blockquote><p><strong>B域的url为/read_cookies的Servlet是如何实现的？</strong></p><p>如图，首先我们先在request中获取cookie数组，然后for循环遍历拼接为类似<code>var token=&#39;test123&#39;;</code>的字符串。最重要的是设置<code>ContentType</code>为<code>application/javascript</code>，代码如下：</p></blockquote><pre class=" language-java"><code class="language-java">    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doGet</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span> HttpServletResponse response<span class="token punctuation">)</span> <span class="token keyword">throws</span> ServletException<span class="token punctuation">,</span> IOException <span class="token punctuation">{</span>        Cookie<span class="token punctuation">[</span><span class="token punctuation">]</span> cookies <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getCookies</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        StringBuilder stringBuilder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//一定要设置响应类型，否则可能导致IE不解析js直接进行下载操作</span>        response<span class="token punctuation">.</span><span class="token function">setContentType</span><span class="token punctuation">(</span><span class="token string">"application/javascript"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cookies <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Cookie cookie <span class="token operator">:</span> cookies<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//结果类似于这样 var token='123456';</span>                stringBuilder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"var "</span><span class="token punctuation">)</span>                        <span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>cookie<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                        <span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"="</span><span class="token punctuation">)</span>                        <span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"'"</span><span class="token punctuation">)</span>                        <span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>cookie<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                        <span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"'"</span><span class="token punctuation">)</span>                        <span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">";"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            response<span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>stringBuilder<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>     <span class="token punctuation">}</span></code></pre><h3 id="四：跨域Ajax请求"><a href="#四：跨域Ajax请求" class="headerlink" title="四：跨域Ajax请求"></a>四：跨域Ajax请求</h3><h4 id="1-Jsonp的方式"><a href="#1-Jsonp的方式" class="headerlink" title="1.Jsonp的方式"></a>1.Jsonp的方式</h4><blockquote><p>跨域Ajax请求在浏览器阶段就会被阻止，我们可以通过script标签返回想要的json数据。如图：</p></blockquote><pre class=" language-html"><code class="language-html"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.b.com/user_info_2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><blockquote><p>后台Servlet代码</p></blockquote><pre class=" language-java"><code class="language-java">        <span class="token comment" spellcheck="true">//要正确设置响应类型,避免IE出现下载</span>        response<span class="token punctuation">.</span><span class="token function">setContentType</span><span class="token punctuation">(</span><span class="token string">"application/javascript"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String userInfo <span class="token operator">=</span> <span class="token string">"{\"id\":1,\"name\":\"zhangsan\"}"</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//返回拼接的javascript语句字符串，语句本身执行一个调用函数的操作</span>        String ret <span class="token operator">=</span> <span class="token string">"showResult("</span><span class="token operator">+</span>userInfo<span class="token operator">+</span><span class="token string">")"</span><span class="token punctuation">;</span></code></pre><blockquote><p>在Servlet中设置返回类型为<code>javascript</code>，并正常获取json格式的数据，最关键的是在最后拼接为js语句字符串，语句本身就是执行一个调用函数的操作：</p></blockquote><pre><code>showResult({&quot;id&quot;:1,&quot;name&quot;:&quot;zhangsan&quot;})</code></pre><blockquote><p>而<code>showResult(ret)</code>回调函数自然需要我们在之前就定义好：</p></blockquote><pre class=" language-html"><code class="language-html">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">        <span class="token keyword">function</span> <span class="token function">showResult</span><span class="token punctuation">(</span>ret<span class="token punctuation">)</span><span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>ret<span class="token punctuation">)</span>        <span class="token punctuation">}</span>    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><blockquote><p><strong>优化</strong></p><p>这种方式，前端的回调函数和后端耦合度较高。前端可以在调用后端方法时带上回调函数名（?callback=xxxxx），后端优化后的代码：</p></blockquote><pre class=" language-java"><code class="language-java">        <span class="token comment" spellcheck="true">//通过参数传递回调函数名，一定程度降低了前后端代码的耦合度</span>        String callback <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">"callback"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//返回拼接的javascript语句字符串，语句本身执行一个调用函数的操作</span>        String ret <span class="token operator">=</span> callback<span class="token operator">+</span><span class="token string">"("</span><span class="token operator">+</span>userInfo<span class="token operator">+</span><span class="token string">")"</span><span class="token punctuation">;</span></code></pre><blockquote><p><strong>再优化</strong></p><p>HTML页面加载到我们定义的script标签时就会执行我们的回调方法，更多时候我们想要控制回调方法的执行时机。这个问题可以通过前端动态生成节点来解决，当我们执行完之后再移除节点即可：</p></blockquote><pre class=" language-html"><code class="language-html">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">        <span class="token keyword">var</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"script"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        script<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">"http://www.b.com/user_info_2?callback=showResult"</span><span class="token punctuation">;</span>        document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">;</span>        script<span class="token punctuation">.</span>onload <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><blockquote><p><strong>JQuery</strong></p><p>我们可以把这些封装到一个方法里，随时调用。这里可以使用Jquery封装好的API。</p></blockquote><pre class=" language-js"><code class="language-js">                $<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">{</span>                    url<span class="token punctuation">:</span> <span class="token string">"http://localhost:9090/query"</span><span class="token punctuation">,</span>                    type<span class="token punctuation">:</span> <span class="token string">"GET"</span><span class="token punctuation">,</span>                    dataType<span class="token punctuation">:</span> <span class="token string">"jsonp"</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">//指定服务器返回的数据类型</span>                    jsonpCallback<span class="token punctuation">:</span> <span class="token string">"showData"</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">//指定回调函数名称</span>                    success<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        console<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"调用success"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">function</span> <span class="token function">showData</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">var</span> result <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span></code></pre><h4 id="2-CORS简介"><a href="#2-CORS简介" class="headerlink" title="2.CORS简介"></a>2.CORS简介</h4><blockquote><p>出于安全原因，浏览器限制从脚本内发起的跨源HTTP请求。 例如，XMLHttpRequest和Fetch API遵循同源策略。 这意味着使用这些API的Web应用程序只能从加载应用程序的同一个域请求HTTP资源，除非使用CORS头文件。</p><p>跨域资源共享（ <a href="https://developer.mozilla.org/en-US/docs/Glossary/CORS" target="_blank" rel="noopener">CORS</a> ）机制允许 Web 应用服务器进行跨域访问控制，从而使跨域数据传输得以安全进行。浏览器支持在 API 容器中（例如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest" target="_blank" rel="noopener"><code>XMLHttpRequest</code></a> 或 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" target="_blank" rel="noopener">Fetch</a> ）使用 CORS，以降低跨域 HTTP 请求所带来的风险。</p><p><strong>GET跨域请求原理</strong></p><p>当客户端浏览器发起一个跨域的HTTP请求，浏览器经过请求响应，如果没有看到<code>Access-Control-Allow-Origin</code>的header头部，会认为你的请求是不合法的。换句话说，我们只要在被请求的服务器上设置这个头部，浏览器就会允许我们进行请求。</p><p><strong>解决方法</strong></p><p>对于简单的请求，我们直接在服务端 设置就可以了。如图，只要请求的地址是<code>www.a.com</code>就会被浏览器允许跨域。如果想要允许对于多个来源可以用<code>,</code>号进行隔开；如果想要允许所有来源，设置为<code>*</code>就可以，不过建议不要使用，这样会造成安全隐患。</p></blockquote><pre class=" language-java"><code class="language-java">    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doGet</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span> HttpServletResponse response<span class="token punctuation">)</span> <span class="token keyword">throws</span> ServletException<span class="token punctuation">,</span> IOException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//简单请求，直接设置Access-Control-Allow-Origin就可以了</span>        response<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">"Access-Control-Allow-Origin"</span><span class="token punctuation">,</span><span class="token string">"*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//要正确设置响应类型,避免IE出现下载</span>        response<span class="token punctuation">.</span><span class="token function">setContentType</span><span class="token punctuation">(</span><span class="token string">"application/json"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        response<span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"{\"id\":1,\"name\":\"zhangsan\"}"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><blockquote><p>对于复杂的请求，比如POST，或者加入了自定义header头部，上面的方法就不适用了。下面继续看。</p></blockquote><h4 id="CORS流程"><a href="#CORS流程" class="headerlink" title="CORS流程"></a>CORS流程</h4><blockquote><p>请求发起时,浏览器先判断当前是否是跨域的AJAX;</p><p>如果是,判断是否是普通类型请求(GET类型,无自定义头数据);</p><p>普通请求,直接发起GET到服务端,在响应头中寻找 Access-Contro-Alow- Origin,如果有且允许,处理响应结果;</p><p>不是普通请求(非GET类型,或有自定义头), 先 PreFlight(即发起一个 method= OPTIONS)的请求,</p><p>要求返回 Access-Control-Allow- Methods和 Access-Control-Allow- Headers, 内容体为空</p><p>PreFlight正确执行后, 再发起GET请求, 获得响应结果, 并处理结果.</p><p><strong>实现</strong></p><p>归根到我们的代码中的实现，只需要在servlet中定义options请求的处理方法即可。如图</p></blockquote><pre class=" language-java"><code class="language-java">    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doOptions</span><span class="token punctuation">(</span>HttpServletRequest req<span class="token punctuation">,</span> HttpServletResponse response<span class="token punctuation">)</span> <span class="token punctuation">{</span>        response<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">"Access-Control-Allow-Origin"</span><span class="token punctuation">,</span><span class="token string">"*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        response<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">"Access-Control-Allow-Methods"</span><span class="token punctuation">,</span><span class="token string">"GET,POST,OPTIONS,DELETE"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        response<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">"Access-Control-Allow-Headers"</span><span class="token punctuation">,</span><span class="token string">"reqid,xxx"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><blockquote><p>注意：<code>Access-Control-Allow-Origin</code>是必需的。</p></blockquote><h4 id="3-两种跨域AJax请求对比"><a href="#3-两种跨域AJax请求对比" class="headerlink" title="3.两种跨域AJax请求对比"></a>3.两种跨域AJax请求对比</h4><blockquote><p><strong>兼容性</strong></p><p>Jsonp对所有浏览器兼容，CORS对现代浏览器兼容（IE8之后）。</p><p><strong>请求方式</strong></p><p>Jsonp只支持GET方式，CORS支持GET，POST等。</p><p><strong>调用方式</strong></p><p>Jsonp需要服务端封装返回信息，CORS更像原生AJax一样使用。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 单点登录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM的垃圾回收机制</title>
      <link href="/2019/06/20/jvm-de-la-ji-hui-shou-ji-zhi/"/>
      <url>/2019/06/20/jvm-de-la-ji-hui-shou-ji-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM的垃圾回收机制"><a href="#JVM的垃圾回收机制" class="headerlink" title="JVM的垃圾回收机制"></a>JVM的垃圾回收机制</h1><h4 id="一、-技术背景"><a href="#一、-技术背景" class="headerlink" title="一、 技术背景"></a>一、 技术背景</h4><blockquote><p>说起垃圾回收（GC），大部分人都把这项技术当做Java语言的伴生产物。</p><p>事实上，GC的历史比Java久远，早在1960年Lisp这门语言中就使用了内存动态分配和垃圾回收技术。</p></blockquote><h4 id="二、-哪些内存需要回收？"><a href="#二、-哪些内存需要回收？" class="headerlink" title="二、 哪些内存需要回收？"></a>二、 哪些内存需要回收？</h4><blockquote><p>JVM的内存结构包括五大区域：程序计数器、虚拟机栈、本地方法栈、堆区、方法区。</p><p>其中程序计数器、虚拟机栈、本地方法栈3个区域随线程而生、随线程而灭，因此这几个区域的内存分配和回收都具备确定性，就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。</p><p>而Java堆区和方法区则不一样，这部分内存的分配和回收是动态的，正是垃圾收集器所需关注的部分。</p><p>垃圾收集器在对堆区和方法区进行回收前，首先要确定这些区域的对象哪些可以被回收，哪些暂时还不能回收，这就要用到判断对象是否存活的算法！</p></blockquote><h5 id="2-1-引用计数算法"><a href="#2-1-引用计数算法" class="headerlink" title="2.1 引用计数算法"></a>2.1 引用计数算法</h5><h6 id="2-1-1-算法分析"><a href="#2-1-1-算法分析" class="headerlink" title="2.1.1 算法分析"></a>2.1.1 算法分析</h6><blockquote><p>引用计数是垃圾收集器中的早期策略。在这种方法中，堆中每个对象实例都有一个引用计数。</p><p>当一个对象被创建时，就将该对象实例分配给一个变量，该变量计数设置为1。</p><p>当任何其它变量被赋值为这个对象的引用时，计数加1（a = b,则b引用的对象实例的计数器+1），但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数器减1。</p><p>任何引用计数器为0的对象实例可以被当作垃圾收集。当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器减1。</p></blockquote><h6 id="2-1-2-优缺点"><a href="#2-1-2-优缺点" class="headerlink" title="2.1.2 优缺点"></a>2.1.2 优缺点</h6><blockquote><p><strong>优点</strong>：引用计数收集器可以很快的执行，交织在程序运行中。对程序需要不被长时间打断的实时环境比较有利。</p><p><strong>缺点</strong>：无法检测出循环引用。如父对象有一个对子对象的引用，子对象反过来引用父对象。这样，他们的引用计数永远不可能为0。</p></blockquote><p>2.1.3 示例代码</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReferenceFindTest</span> <span class="token punctuation">{</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>         MyObject object1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         MyObject object2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         object1<span class="token punctuation">.</span>object <span class="token operator">=</span> object2<span class="token punctuation">;</span>         object2<span class="token punctuation">.</span>object <span class="token operator">=</span> object1<span class="token punctuation">;</span>         object1 <span class="token operator">=</span> null<span class="token punctuation">;</span>         object2 <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>这段代码是用来验证引用计数算法不能检测出循环引用。最后面两句将object1和object2赋值为null</p><p>也就是说object1和object2指向的对象已经不可能再被访问，但是由于它们互相引用对方，导致它们的引用计数器都不为0，那么垃圾收集器就永远不会回收它们。</p></blockquote><h5 id="2-2-可达性分析算法"><a href="#2-2-可达性分析算法" class="headerlink" title="2.2 可达性分析算法"></a>2.2 可达性分析算法</h5><blockquote><p>可达性分析算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/20/jvm-de-la-ji-hui-shou-ji-zhi/001.png" alt></p><blockquote><p>找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点，无用的节点将会被判定为是可回收的对象。</p></blockquote><blockquote><p>在Java语言中，可作为GC Roots的对象包括下面几种：</p><ul><li>虚拟机栈中引用的对象（栈帧中的本地变量表）；</li><li>方法区中类静态属性引用的对象；</li><li>方法区中常量引用的对象；</li><li>本地方法栈中JNI（Native方法）引用的对象。</li></ul></blockquote><h5 id="2-3-Java中的引用"><a href="#2-3-Java中的引用" class="headerlink" title="2.3 Java中的引用"></a>2.3 Java中的引用</h5><blockquote><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与“引用”有关。</p><p>在Java语言中，将引用又分为强引用、软引用、弱引用、虚引用4种，这四种引用强度依次逐渐减弱。</p></blockquote><h6 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h6><blockquote><p>在程序代码中普遍存在的，类似 Object obj = new Object() 这类引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</p></blockquote><h6 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h6><blockquote><p>用来描述一些还有用但并非必须的对象。</p><p>对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存溢出异常。</p></blockquote><h6 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h6><blockquote><p>也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。</p><p>当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</p></blockquote><h6 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h6><blockquote><p>也叫幽灵引用或幻影引用（名字真会取，很魔幻的样子），是最弱的一种引用关系。</p><p>一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。</p><p>它的作用是能在这个对象被收集器回收时收到一个系统通知。</p><p>不要被概念吓到，也别担心，还没跑题，再深入，可就不好说了。小编罗列这四个概念的目的是为了说明，无论引用计数算法还是可达性分析算法都是基于强引用而言的。</p></blockquote><h5 id="2-4-对象死亡（被回收）前的最后一次挣扎"><a href="#2-4-对象死亡（被回收）前的最后一次挣扎" class="headerlink" title="2.4 对象死亡（被回收）前的最后一次挣扎"></a>2.4 对象死亡（被回收）前的最后一次挣扎</h5><blockquote><p>即使在可达性分析算法中不可达的对象，也并非是“非死不可”，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程。</p><p><strong>第一次标记</strong>：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记；</p><p><strong>第二次标记</strong>：第一次标记后接着会进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。在finalize()方法中没有重新与引用链建立关联关系的，将被进行第二次标记。</p><p>第二次标记成功的对象将真的会被回收，如果对象在finalize()方法中重新与引用链建立了关联关系，那么将会逃离本次回收，继续存活。</p></blockquote><h5 id="2-5-方法区如何判断是否需要回收"><a href="#2-5-方法区如何判断是否需要回收" class="headerlink" title="2.5 方法区如何判断是否需要回收"></a>2.5 方法区如何判断是否需要回收</h5><blockquote><p>方法区存储内容是否需要回收的判断可就不一样咯。方法区主要回收的内容有：废弃常量和无用的类。</p><p>对于废弃常量也可通过引用的可达性来判断，但是对于无用的类则需要同时满足下面3个条件：</p><ul><li>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例；</li><li>加载该类的ClassLoader已经被回收；</li><li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul></blockquote><h4 id="三、常用的垃圾收集算法"><a href="#三、常用的垃圾收集算法" class="headerlink" title="三、常用的垃圾收集算法"></a>三、常用的垃圾收集算法</h4><h5 id="3-1-标记-清除算法"><a href="#3-1-标记-清除算法" class="headerlink" title="3.1 标记-清除算法"></a>3.1 标记-清除算法</h5><blockquote><p>标记-清除算法采用从根集合（GC Roots）进行扫描，对存活的对象进行标记</p><p>标记完毕后，再扫描整个空间中未被标记的对象，进行回收，如下图所示。</p><p>标记-清除算法不需要进行对象的移动，只需对不存活的对象进行处理，在存活对象比较多的情况下极为高效</p><p>但由于标记-清除算法直接回收不存活的对象，因此会造成<strong>内存碎片</strong></p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/20/jvm-de-la-ji-hui-shou-ji-zhi/002.png" alt></p><h5 id="3-2-复制算法"><a href="#3-2-复制算法" class="headerlink" title="3.2 复制算法"></a>3.2 复制算法</h5><blockquote><p>复制算法的提出是为了克服句柄的开销和解决内存碎片的问题。</p><p>它开始时把堆分成 一个对象面和多个空闲面， 程序从对象面为对象分配空间，当对象满了，基于copying算法的垃圾收集就从根集合（GC Roots）中扫描活动对象，并将每个活动对象复制到空闲面(使得活动对象所占的内存之间没有空闲洞)</p><p>这样空闲面变成了对象面，原来的对象面变成了空闲面，程序会在新的对象面中分配内存。</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/20/jvm-de-la-ji-hui-shou-ji-zhi/003.png" alt></p><h5 id="3-3-标记-整理算法"><a href="#3-3-标记-整理算法" class="headerlink" title="3.3 标记-整理算法"></a>3.3 标记-整理算法</h5><blockquote><p>标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往左端空闲空间移动，并更新对应的指针。</p><p>标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。</p><p>具体流程见下图：</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/20/jvm-de-la-ji-hui-shou-ji-zhi/004.png" alt></p><h5 id="3-4-分代收集算法"><a href="#3-4-分代收集算法" class="headerlink" title="3.4 分代收集算法"></a>3.4 分代收集算法</h5><blockquote><p>分代收集算法是目前大部分JVM的垃圾收集器采用的算法。它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。</p><p>一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），在堆区之外还有一个代就是永久代（Permanet Generation）。</p><p>老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法。</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/20/jvm-de-la-ji-hui-shou-ji-zhi/005.png" alt></p><h6 id="3-4-1-年轻代（Young-Generation）的回收算法"><a href="#3-4-1-年轻代（Young-Generation）的回收算法" class="headerlink" title="3.4.1 年轻代（Young Generation）的回收算法"></a>3.4.1 年轻代（Young Generation）的回收算法</h6><blockquote><p><strong>a)</strong> 所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。</p><p><strong>b)</strong> 新生代内存按照8:1:1的比例分为一个eden区和两个survivor(survivor0,survivor1)区。</p><p>大部分对象在Eden区中生成，回收时先将eden区存活对象复制到一个survivor0区，然后清空eden区。</p><p>当这个survivor0区也存放满了时，则将eden区和survivor0区存活对象复制到另一个survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的</p><p>然后将survivor0区和survivor1区交换，即保持survivor1区为空， 如此往复。</p><p><strong>c)</strong> 当survivor1区不足以存放 eden和survivor0的存活对象时，就将存活对象直接存放到老年代。</p><p>若是老年代也满了就会触发一次Full GC，也就是新生代、老年代都进行回收。</p><p><strong>d)</strong> 新生代发生的GC也叫做Minor GC，MinorGC发生频率比较高(不一定等Eden区满了才触发)。</p></blockquote><h6 id="3-4-2-年老代（Old-Generation）的回收算法"><a href="#3-4-2-年老代（Old-Generation）的回收算法" class="headerlink" title="3.4.2 年老代（Old Generation）的回收算法"></a><strong>3.4.2 年老代（Old Generation）的回收算法</strong></h6><blockquote><p><strong>a)</strong> 在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。</p><p>因此，可以认为年老代中存放的都是一些生命周期较长的对象。</p><p><strong>b)</strong> 内存比新生代也大很多(大概比例是1:2)，当老年代内存满时触发Major GC即Full GC，Full GC发生频率比较低，老年代对象存活时间比较长，存活率标记高。</p></blockquote><h6 id="3-4-3-持久代（Permanent-Generation）的回收算法"><a href="#3-4-3-持久代（Permanent-Generation）的回收算法" class="headerlink" title="3.4.3 持久代（Permanent Generation）的回收算法"></a><strong>3.4.3 持久代（Permanent Generation）的回收算法</strong></h6><blockquote><p>用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate 等，</p><p>在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。</p><p>持久代也称方法区，具体的回收可参见上文2.5节。</p></blockquote><h4 id="四、常见的垃圾收集器"><a href="#四、常见的垃圾收集器" class="headerlink" title="四、常见的垃圾收集器"></a><strong>四、常见的垃圾收集器</strong></h4><blockquote><p>下面一张图是HotSpot虚拟机包含的所有收集器:</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/20/jvm-de-la-ji-hui-shou-ji-zhi/006.png" alt></p><blockquote><ul><li><strong>Serial收集器（复制算法)</strong></li><li>新生代单线程收集器，标记和清理都是单线程，优点是简单高效。是client级别默认的GC方式，可以通过-XX:+UseSerialGC来强制指定。</li></ul></blockquote><blockquote><ul><li><strong>Serial Old收集器(标记-整理算法)</strong></li><li>老年代单线程收集器，Serial收集器的老年代版本</li></ul></blockquote><blockquote><ul><li><strong>ParNew收集器(停止-复制算法)</strong>　</li><li>新生代收集器，可以认为是Serial收集器的多线程版本,在多核CPU环境下有着比Serial更好的表现。</li></ul></blockquote><blockquote><ul><li><strong>Parallel Scavenge收集器(停止-复制算法)</strong></li><li>并行收集器，追求高吞吐量，高效利用CPU。吞吐量一般为99%， 吞吐量= 用户线程时间/(用户线程时间+GC线程时间)。适合后台应用等对交互相应要求不高的场景。是server级别默认采用的GC方式，可用-XX:+UseParallelGC来强制指定，用-XX:ParallelGCThreads=4来指定线程数</li></ul></blockquote><blockquote><ul><li><strong>Parallel Old收集器(停止-复制算法)</strong></li><li>Parallel Scavenge收集器的老年代版本，并行收集器，吞吐量优先。</li></ul></blockquote><blockquote><ul><li><strong>CMS(Concurrent Mark Sweep)收集器（标记-清理算法）</strong></li><li>高并发、低停顿，追求最短GC回收停顿时间，cpu占用比较高，响应时间快，停顿时间短，多核cpu 追求高响应时间的选择。</li></ul></blockquote><h4 id="五、GC什么时候触发的"><a href="#五、GC什么时候触发的" class="headerlink" title="五、GC什么时候触发的"></a><strong>五、GC什么时候触发的</strong></h4><blockquote><p>由于对象进行了分代处理，因此垃圾回收区域、时间也不一样。GC有两种类型：Scavenge GC和Full GC。</p></blockquote><h5 id="5-1-Scavenge-GC"><a href="#5-1-Scavenge-GC" class="headerlink" title="5.1 Scavenge GC"></a><strong>5.1 Scavenge GC</strong></h5><blockquote><p>一般情况下，当新对象生成，并且在Eden申请空间失败时，就会触发Scavenge GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区。然后整理Survivor的两个区。</p><p>这种方式的GC是对年轻代的Eden区进行，不会影响到年老代。因为大部分对象都是从Eden区开始的，同时Eden区不会分配的很大，所以Eden区的GC会频繁进行。</p><p>因而，一般在这里需要使用速度快、效率高的算法，使Eden去能尽快空闲出来。</p></blockquote><h5 id="5-2-Full-GC"><a href="#5-2-Full-GC" class="headerlink" title="5.2 Full GC"></a><strong>5.2 Full GC</strong></h5><blockquote><p>对整个堆进行整理，包括Young、Tenured和Perm。</p><p>Full GC因为需要对整个堆进行回收，所以比Scavenge GC要慢，因此应该尽可能减少Full GC的次数。</p><p>在对JVM调优的过程中，很大一部分工作就是对于Full GC的调节。</p><p>有如下原因可能导致Full GC：</p><ul><li>老年代（Tenured）被写满；</li><li>持久代（Perm）被写满；</li><li>System.gc()被显示调用；</li><li>上一次GC之后Heap的各域分配策略动态变化；</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 回收机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud（四）</title>
      <link href="/2019/06/19/springcloud-si/"/>
      <url>/2019/06/19/springcloud-si/</url>
      
        <content type="html"><![CDATA[<h1 id="Eureka-Ribbon（负载均衡服务调用者）"><a href="#Eureka-Ribbon（负载均衡服务调用者）" class="headerlink" title="Eureka Ribbon（负载均衡服务调用者）"></a>Eureka Ribbon（负载均衡服务调用者）</h1><h3 id="一、Spring-Cloud-Ribbon"><a href="#一、Spring-Cloud-Ribbon" class="headerlink" title="一、Spring Cloud Ribbon"></a>一、Spring Cloud Ribbon</h3><blockquote><p>在微服务架构中，业务都会被拆分成一个独立的服务，服务与服务的通讯都是HTTP RESTful的。Spring cloud有两种服务调用方式，一种是ribbon+restTemplate，另一种是feign。</p><p>Spring Cloud Ribbon是基于Netflix Ribbon实现的一套客户端负载均衡的工具。它是一个基于HTTP和TCP的客户端负载均衡器。它可以通过在客户端中配置ribbonServerList来设置服务端列表去轮询访问以达到均衡负载的作用。</p><p>当Ribbon与Eureka联合使用时，ribbonServerList会被DiscoveryEnabledNIWSServerList重写，扩展成从Eureka注册中心中获取服务实例列表。同时它也会用NIWSDiscoveryPing来取代IPing，它将职责委托给Eureka来确定服务端是否已经启动。</p><p>而当Ribbon与Consul联合使用时，ribbonServerList会被ConsulServerList来扩展成从Consul获取服务实例列表。同时由ConsulPing来作为IPing接口的实现。</p><p>我们在使用Spring Cloud Ribbon的时候，不论是与Eureka还是Consul结合，都会在引入Spring Cloud Eureka或Spring Cloud Consul依赖的时候通过自动化配置来加载上述所说的配置内容，所以我们可以快速在Spring Cloud中实现服务间调用的负载均衡。</p></blockquote><h3 id="二、service-consumer-ribbon"><a href="#二、service-consumer-ribbon" class="headerlink" title="二、service-consumer-ribbon"></a>二、service-consumer-ribbon</h3><blockquote><p>新建消费者模块</p><p>new -&gt;moudle -&gt;service-consumer-ribbon</p></blockquote><h4 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h4><blockquote><p>修改pom.xml添加ribbon依赖：</p></blockquote><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modelVersion</span><span class="token punctuation">></span></span>4.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modelVersion</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-parent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.1.6.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>relativePath</span><span class="token punctuation">/></span></span> <span class="token comment" spellcheck="true">&lt;!-- lookup parent from repository --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.springcloud.ribbon<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>ribbon<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>0.0.1-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>ribbon<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>description</span><span class="token punctuation">></span></span>springcloud-ribbon<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>description</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>java.version</span><span class="token punctuation">></span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>java.version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-netflix-eureka-client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.1.1.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-netflix-ribbon<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.1.1.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencyManagement</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-dependencies<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>type</span><span class="token punctuation">></span></span>pom<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>type</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>import<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencyManagement</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-maven-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">></span></span></code></pre><h4 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml"></a>application.yml</h4><p>resource目录下新建application.yml修改配置信息如下：</p><pre class=" language-yml"><code class="language-yml">server:  port: 8096spring:  application:    name: service-consumer-ribboneureka:  client:    service-url:      defaultZone: http://localhost:8090/eureka/</code></pre><h4 id="启动类："><a href="#启动类：" class="headerlink" title="启动类："></a>启动类：</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @author zongman */</span><span class="token annotation punctuation">@SpringBootApplication</span><span class="token punctuation">(</span>exclude <span class="token operator">=</span> <span class="token punctuation">{</span>DataSourceAutoConfiguration<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token annotation punctuation">@EnableEurekaClient</span><span class="token annotation punctuation">@EnableDiscoveryClient</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RibbonApplication</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>RibbonApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token annotation punctuation">@LoadBalanced</span>    RestTemplate <span class="token function">restTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RestTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>   <span class="token punctuation">}</span></code></pre><h4 id="新建具体的消费服务实现，利用RestTemplate完成消费服务"><a href="#新建具体的消费服务实现，利用RestTemplate完成消费服务" class="headerlink" title="新建具体的消费服务实现，利用RestTemplate完成消费服务"></a>新建具体的消费服务实现，利用RestTemplate完成消费服务</h4><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RibbonServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">RibbonService</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    RestTemplate restTemplate<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">hello</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> restTemplate<span class="token punctuation">.</span><span class="token function">getForObject</span><span class="token punctuation">(</span><span class="token string">"http://service-producer/hello?name="</span><span class="token operator">+</span>name<span class="token punctuation">,</span>String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>这里注意<a href="http://service-producer/hello中的service-producer对应注册中心注册的服务者，hello指明需要的服务。" target="_blank" rel="noopener">http://service-producer/hello中的service-producer对应注册中心注册的服务者，hello指明需要的服务。</a></p></blockquote><h4 id="新建调用入口ConsumerController-java"><a href="#新建调用入口ConsumerController-java" class="headerlink" title="新建调用入口ConsumerController.java"></a>新建调用入口ConsumerController.java</h4><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RestController</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConsumerController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    RibbonServiceImpl ribbonService<span class="token punctuation">;</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/hello/{name}"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> String <span class="token function">index</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span> String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> ribbonService<span class="token punctuation">.</span><span class="token function">hello</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="启动工程-再次访问-localhost-8090"><a href="#启动工程-再次访问-localhost-8090" class="headerlink" title="启动工程      再次访问 localhost:8090"></a><strong>启动工程</strong>      再次访问 localhost:8090</h4><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/19/springcloud-si/001.png" alt></p><h4 id="测试服务调用"><a href="#测试服务调用" class="headerlink" title="测试服务调用"></a>测试服务调用</h4><blockquote><p>访问<a href="http://localhost:8096/hello/ZongMan" target="_blank" rel="noopener">http://localhost:8096/hello/ZongMan</a></p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/19/springcloud-si/003.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> springcloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> eureka </tag>
            
            <tag> ribbon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx全面解析</title>
      <link href="/2019/06/18/nginx-quan-mian-jie-xi/"/>
      <url>/2019/06/18/nginx-quan-mian-jie-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="Nginx全面解析"><a href="#Nginx全面解析" class="headerlink" title="Nginx全面解析"></a>Nginx全面解析</h1><h4 id="一、什么是ngnix"><a href="#一、什么是ngnix" class="headerlink" title="一、什么是ngnix"></a>一、什么是ngnix</h4><blockquote><p>Nginx是一个http服务器。是一个使用c语言开发的高性能的http 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。nginx能够支撑5万并发链接，并且cpu、内存等资源消耗却非常低，运行非常稳定，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。</p></blockquote><h4 id="二、NGINX可以用来做什么"><a href="#二、NGINX可以用来做什么" class="headerlink" title="二、NGINX可以用来做什么"></a>二、NGINX可以用来做什么</h4><blockquote><p>1、反向代理：反向代理（ReverseProxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端,简单来说就是真实的服务器不能直接被外部网络访问,想要访问必须通过代理。</p></blockquote><blockquote><p>2、动静分离：运用Nginx的反向代理功能分发请求：所有动态资源的请求交给应用服务器，而静态资源的请求（例如图片、视频、CSS、JavaScript文件等）则直接由Nginx返回到浏览器，这样能大大减轻应用服务器的压力</p></blockquote><blockquote><p>3、负载均衡：负载均衡也是 Nginx常用的一个功能，当一台服务器的单位时间内的访问量越大时，服务器压力就越大，大到超过自身承受能力时，服务器就会崩溃。为了避免服务器崩溃，让用户有更好的体验，我们通过负载均衡的方式来分担服务器压力。我们可以建立很多很多服务器，组成一个服务器集群，当用户访问网站时，先访问一个中间服务器，在让这个中间服务器在服务器集群中选择一个压力较小的服务器，然后将该访问请求引入该服务器。如此以来，用户的每次访问，都会保证服务器集群中的每个服务器压力趋于平衡，分担了服务器压力，避免了服务器崩溃的情况。负载均衡配置一般都需要同时配置反向代理，通过反向代理跳转到负载均衡。</p></blockquote><h4 id="三、常见问题"><a href="#三、常见问题" class="headerlink" title="三、常见问题"></a>三、常见问题</h4><h5 id="1-nginx负载均衡是如何实现的"><a href="#1-nginx负载均衡是如何实现的" class="headerlink" title="1.nginx负载均衡是如何实现的"></a>1.nginx负载均衡是如何实现的</h5><blockquote><p>nginx负载均衡要两台或以上的应用服务器 ， 并且在nginx.conf中写入相关配置，主要是对proxy_pass,upstream的使用</p></blockquote><h5 id="2-nginx的upstream常见的几种方式的分发策略"><a href="#2-nginx的upstream常见的几种方式的分发策略" class="headerlink" title="2.nginx的upstream常见的几种方式的分发策略"></a>2.nginx的upstream常见的几种方式的分发策略</h5><blockquote><p>1.轮询（默认）——每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。</p><p>2.weight ——指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。</p><p>3.ip_hash ——每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器。</p><p>4.backup——其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。</p><p>5.down——表示单前的server暂时不参与负载</p><p>6.fair（第三方）按后端服务器的响应时间来分配请求，响应时间短的优先分配。与weight分配策略类似。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> 负载均衡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud（三）</title>
      <link href="/2019/06/17/springcloud-san/"/>
      <url>/2019/06/17/springcloud-san/</url>
      
        <content type="html"><![CDATA[<h1 id="Eureka-Producer（服务提供者）"><a href="#Eureka-Producer（服务提供者）" class="headerlink" title="Eureka Producer（服务提供者）"></a>Eureka Producer（服务提供者）</h1><h4 id="新建moudel-service-producer"><a href="#新建moudel-service-producer" class="headerlink" title="新建moudel(service-producer)"></a>新建moudel(service-producer)</h4><h4 id="Pom-xml"><a href="#Pom-xml" class="headerlink" title="Pom.xml"></a>Pom.xml</h4><blockquote><p>修改pom依赖</p></blockquote><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modelVersion</span><span class="token punctuation">></span></span>4.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modelVersion</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-parent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.1.6.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>relativePath</span><span class="token punctuation">/></span></span> <span class="token comment" spellcheck="true">&lt;!-- lookup parent from repository --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.zms.producer<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>eureka-producer<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>0.0.1-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>eureka-producer<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>description</span><span class="token punctuation">></span></span>服务提供者<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>description</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>java.version</span><span class="token punctuation">></span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>java.version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-netflix-eureka-client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.1.1.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencyManagement</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-dependencies<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>type</span><span class="token punctuation">></span></span>pom<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>type</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>import<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencyManagement</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-maven-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">></span></span></code></pre><h4 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml"></a>application.yml</h4><blockquote><p>resource目录下新建application.yml配置文件，配置一下信息：</p></blockquote><pre class=" language-xml"><code class="language-xml">server:  port: 8095spring:  application:    name: service-producereureka:  client:    service-url:      defaultZone: http://localhost:8091/eureka,http://localhost:8092/eureka,http://localhost:8093/eureka,</code></pre><h4 id="EurekaProducerApplication-java"><a href="#EurekaProducerApplication-java" class="headerlink" title="EurekaProducerApplication.java"></a>EurekaProducerApplication.java</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>zms<span class="token punctuation">.</span>producer<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>SpringApplication<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>SpringBootApplication<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>cloud<span class="token punctuation">.</span>client<span class="token punctuation">.</span>discovery<span class="token punctuation">.</span>EnableDiscoveryClient<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author zongman */</span><span class="token annotation punctuation">@SpringBootApplication</span><span class="token annotation punctuation">@EnableDiscoveryClient</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EurekaProducerApplication</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>EurekaProducerApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>添加@EnableDiscoveryClient注解后，项目就具有了服务注册的功能。启动工程后，就可以在注册中心的页面看到SERVICE-PRODUCER服务。</p></blockquote><p>启动之后再次访问注册中心：</p><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/17/springcloud-san/001.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> springcloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Eureka </tag>
            
            <tag> Producer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud（二）</title>
      <link href="/2019/06/16/springcloud-er/"/>
      <url>/2019/06/16/springcloud-er/</url>
      
        <content type="html"><![CDATA[<h1 id="eureka注册中心（Greenwich版本）"><a href="#eureka注册中心（Greenwich版本）" class="headerlink" title="eureka注册中心（Greenwich版本）"></a>eureka注册中心（Greenwich版本）</h1><h4 id="eureka"><a href="#eureka" class="headerlink" title="eureka"></a>eureka</h4><blockquote><p>Eureka 是一个基于 REST 的服务，主要在 AWS 云中使用, 定位服务来进行中间层服务器的负载均衡和故障转移。</p><p>Spring Cloud 封装了 Netflix 公司开发的 Eureka 模块来实现服务注册和发现。Eureka 采用了 C-S 的设计架构。Eureka Server 作为服务注册功能的服务器，它是服务注册中心。而系统中的其他微服务，使用 Eureka 的客户端连接到 Eureka Server，并维持心跳连接。这样系统的维护人员就可以通过 Eureka Server 来监控系统中各个微服务是否正常运行。Spring Cloud 的一些其他模块（比如Zuul）就可以通过 Eureka Server 来发现系统中的其他微服务，并执行相关的逻辑。</p><p>Eureka由两个组件组成：Eureka server和Eureka client。Eureka server用作服务注册服务器。Eureka client是一个java客户端，用来简化与服务器的交互、作为轮询负载均衡器，并提供服务的故障切换支持。Netflix在其生产环境中使用的是另外的客户端，它提供基于流量、资源利用率以及出错状态的加权负载均衡。</p><p>最简单的微服务架构图：</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/16/springcloud-er/001.png" alt></p><blockquote><p>Eureka Server(注册中心):提供服务注册和发现</p><p>Service Provider(服务提供方):将自身服务注册到Eureka中心，从而使服务消费方能够找到</p><p>Service Consumer(服务消费方)：从Eureka注册中心获取注册服务列表，从而能够消费服务</p></blockquote><blockquote><p>为了给大家演示完整的SpringCloud，我们把我们当前的工程构建为SpringBoot聚合工程，我这里的聚合工程取名为SpringCloud</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/16/springcloud-er/002.png" alt></p><pre><code>EurekaApplication.java</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>springcloud<span class="token punctuation">.</span>eureka<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>SpringApplication<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>SpringBootApplication<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>cloud<span class="token punctuation">.</span>netflix<span class="token punctuation">.</span>eureka<span class="token punctuation">.</span>server<span class="token punctuation">.</span>EnableEurekaServer<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author zongman */</span><span class="token annotation punctuation">@SpringBootApplication</span><span class="token annotation punctuation">@EnableEurekaServer</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EurekaApplication</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>EurekaApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>那么最简单的eureka-server注册中心已经完成。</p><p>启动SpringBoot Application</p><p>访问 localhost:8090</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/16/springcloud-er/003.png" alt></p><h4 id="eureka集群使用"><a href="#eureka集群使用" class="headerlink" title="eureka集群使用"></a>eureka集群使用</h4><blockquote><p>在一个分布式系统中，服务注册中心是最重要的基础部分，理应随时处于可以提供服务的状态。如果是单点部署，如果注册中心出现故障，将会出现毁灭性的灾难。为了维持其可用性，使用集群是很好的解决方案。Eureka通过互相注册的方式来实现高可用的部署，所以我们只需要将Eureke Server配置其他可用的serviceUrl就能实现高可用部署。</p><p>新建集群配置profiles：application-peer1.yml/application-peer2.yml/application-peer3.yml</p></blockquote><h5 id="application-peer1-yml"><a href="#application-peer1-yml" class="headerlink" title="application-peer1.yml"></a>application-peer1.yml</h5><pre class=" language-xml"><code class="language-xml">spring:  application:    name: spring-cloud-eureka  profiles: peer1server:  port: 8091eureka:  instance:    hostname: peer1  client:    serviceUrl:      defaultZone: http://peer2:8092/eureka/,http://peer3:8093/eureka/    fetch-registry: true    register-with-eureka: true</code></pre><h5 id="application-peer2-yml"><a href="#application-peer2-yml" class="headerlink" title="application-peer2.yml"></a>application-peer2.yml</h5><pre class=" language-xml"><code class="language-xml">spring:  application:    name: spring-cloud-eureka  profiles: peer2server:  port: 8092eureka:  instance:    hostname: peer2  client:    serviceUrl:      defaultZone: http://peer1:8091/eureka/,http://peer3:8093/eureka/    fetch-registry: true    register-with-eureka: true</code></pre><p>application-peer3.yml</p><pre class=" language-xml"><code class="language-xml">spring:  application:    name: spring-cloud-eureka  profiles: peer3server:  port: 8093eureka:  instance:    hostname: peer3  client:    serviceUrl:      defaultZone: http://peer1:8091/eureka/,http://peer2:8092/eureka/    fetch-registry: true    register-with-eureka: true</code></pre><blockquote><p>以上配置中标红的代码段很重要，在此进行说明：</p><p>　　1、fetch-registry：表示是否从eureka server获取注册信息，如果是单一节点，不需要同步其他eureka server节点，则可以设置为false，但此处为集群，应该设置为true，默认为true，可不设置。</p><p>　　2、register-with-eureka：表示是否将自己注册到eureka server，因为要构建集群环境，需要将自己注册到及群众，所以应该开启。默认为true，可不显式设置。</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/16/springcloud-er/006.png" alt></p><blockquote><p>运行：</p></blockquote><pre class=" language-java"><code class="language-java">java <span class="token operator">-</span>jar eureka <span class="token number">0.0</span><span class="token punctuation">.</span><span class="token number">1</span><span class="token operator">-</span>SNAPSHOT <span class="token operator">--</span>spring<span class="token punctuation">.</span>profiles<span class="token punctuation">.</span>active<span class="token operator">=</span>peer1java <span class="token operator">-</span>jar eureka <span class="token number">0.0</span><span class="token punctuation">.</span><span class="token number">1</span><span class="token operator">-</span>SNAPSHOT <span class="token operator">--</span>spring<span class="token punctuation">.</span>profiles<span class="token punctuation">.</span>active<span class="token operator">=</span>peer2java <span class="token operator">-</span>jar eureka <span class="token number">0.0</span><span class="token punctuation">.</span><span class="token number">1</span><span class="token operator">-</span>SNAPSHOT <span class="token operator">--</span>spring<span class="token punctuation">.</span>profiles<span class="token punctuation">.</span>active<span class="token operator">=</span>peer3</code></pre><blockquote><p>访问localhost:8090</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/16/springcloud-er/005.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> springcloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringfCloud，eureka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springcloud（一）</title>
      <link href="/2019/06/15/springcloud-yi/"/>
      <url>/2019/06/15/springcloud-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringCloud（一）"><a href="#SpringCloud（一）" class="headerlink" title="SpringCloud（一）"></a>SpringCloud（一）</h1><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/15/springcloud-yi/001.png" alt></p><blockquote><p>开发web程序的最早期时间，最被广泛使用的企业程序架构是将程序的服务器端组件打包为单个单元。例如很多企业将Java应用程序打包为单个WAR完整运行。单体架构在很多小型的Web服务中很常见，因为其优点很明显：</p><p>服务量级较小，开发人员协调型不高，只需要少数开发配合。</p><p>开发简单直接，集中式管理, 基本不会重复开发。</p><p>功能都在本地，没有分布式的管理开销和调用开销。</p><p>但是随着业务的衍生与扩展，服务量增加的时候，它的缺点也很明显：</p><p>开发效率低：所有的开发人员在一个项目改代码，耦合依赖性太高，提交代码相互等待，功能互相依赖。</p><p>代码维护难：代码功能耦合在一起，新人不知道何从下手</p><p>部署不灵活：构建时间长，任何小修改必须重新构建整个项目，这个过程往往很长</p><p>稳定性不高：一个微不足道的小问题，可以导致整个应用挂掉，或者最常见为了更新一个小服务需要重新打包整个应用。</p><p>-扩展性不够：无法满足高并发情况下的业务需求</p></blockquote><h4 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h4><blockquote><p>微服务最早由Martin Fowler与James Lewis于2014年共同提出，微服务是指开发一个个(或一系列)单个小型的但有业务功能的服务，每个服务都有自己的处理和轻量通讯机制，可以部署在单个或多个服务器上。微服务也指一种松耦合的、有一定的有界上下文的面向服务架构。也就是说，如果每个服务都要同时修改，那么它们就不是微服务，因为它们紧耦合在一起；如果你需要掌握一个服务太多的上下文场景使用条件，那么它就是一个有上下文边界的服务，这个定义来自DDD领域驱动设计。</p><p>相对于单体架构和SOA，它的主要特点是组件化、松耦合、自治、去中心化，体现在以下几个方面：</p><p>一组小的服务 : 服务粒度要小，而每个服务是针对一个单一职责的业务能力的封装，专注做好一件事情。</p><p>独立部署运行和扩展 :每个服务能够独立被部署并运行在一个进程内。这种运行和部署方式能够赋予系统灵活的代码组织方式和发布节奏，使得快速交付和应对变化成为可能。</p><p>独立开发和演化 :技术选型灵活，不受遗留系统技术约束。合适的业务问题选择合适的技术可以独立演化。服务与服务之间采取与语言无关的API进行集成。相对单体架构，微服务架构是更面向业务创新的一种架构模式。</p><p>独立团队和自治 : 团队对服务的整个生命周期负责，工作在独立的上下文中，自己决策自己治理，而不需要统一的指挥中心。团队和团队之间通过松散的社区部落进行衔接。</p><p>我们可以看到整个微服务的思想就如我们现在面对信息爆炸、知识爆炸是一样的：通过解耦我们所做的事情，分而治之以减少不必要的损耗，使得整个复杂的系统和组织能够快速的应对变化。</p></blockquote><h4 id="为什么采用微服务呢？"><a href="#为什么采用微服务呢？" class="headerlink" title="为什么采用微服务呢？"></a>为什么采用微服务呢？</h4><blockquote><p>“让我们的系统尽可能快地响应变化” - Rebecca Parson</p><p>让我们的系统尽可能快地去响应变化.其实几十年来我们一直在尝试解决这个问题。如果一定要在前面加个限制的话，那就是低成本的快速响应变化。上世纪90年代Kent Beck提出要拥抱变化，在同期出现了诸多轻量级开发方法（诸如 XP、Scrum）；2001年敏捷宣言诞生，之后又出现了精益、看板等新的管理方式。如果说，这些是为了尽快的响应变化，在软件开发流程和实践方面提出的解决方案，那么微服务架构就是在软件技术和架构层面提出的应对之道。</p></blockquote><h4 id="服务注册、发现、负载均衡和健康检查"><a href="#服务注册、发现、负载均衡和健康检查" class="headerlink" title="服务注册、发现、负载均衡和健康检查"></a>服务注册、发现、负载均衡和健康检查</h4><blockquote><p>和单体 (Monolithic) 架构的结构不同，微服务架构是由一系列职责单一的细粒度服务构成的分布式网状结构，服务之间通过轻量机制进行通信，这时候必然引入一个服务注册发现问题，也就是说服务提供方要注册通告服务地址，服务的调用方要能发现目标服务，同时服务提供方一般以集群方式提供服务，也就引入了负载均衡和健康检查问题。根据负载均衡 LB 所在位置的不同，目前主要的服务注册、发现和负载均衡方案有三种：</p></blockquote><h5 id="集中式-LB-方案"><a href="#集中式-LB-方案" class="headerlink" title="集中式 LB 方案"></a>集中式 LB 方案</h5><blockquote><p>集中式 LB 方案,在服务消费者和服务提供者之间有一个独立的 LoadBalance(后面简称LB)，LB 通常是专门的硬件设备如 F5，或者基于软件如 LVS，HAproxy 等实现。LB 上有所有服务的地址映射表，通常由运维配置注册，当服务消费方调用某个目标服务时，它向 LB 发起请求，由 LB 以某种策略（比如 Round-Robin）做负载均衡后将请求转发到目标服务。LB 一般具备健康检查能力，能自动摘除不健康的服务实例。服务消费方如何发现 LB 呢？通常的做法是通过 DNS，运维人员为服务配置一个 DNS 域名，这个域名指向 LB。</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/15/springcloud-yi/002.png" alt></p><blockquote><p>集中式LB方案实现简单，在LB上也容易做集中式的访问控制，这一方案目前还是业界主流。集中式LB的主要问题是单点问题，所有服务调用流量都经过LB，当服务数量和调用量大的时候，LB容易成为瓶颈，且一旦LB发生故障对整个系统的影响是灾难性的。另外，LB在服务消费方和服务提供方之间增加了一跳(hop)，有一定性能开销。</p></blockquote><h5 id="进程内LB方案"><a href="#进程内LB方案" class="headerlink" title="进程内LB方案"></a>进程内LB方案</h5><blockquote><p>针对集中式LB的不足，进程内LB方案将LB的功能以库的形式集成到服务消费方进程里头，该方案也被称为软负载(Soft Load Balancing)或者客户端负载方案，如图展示了这种方案的工作原理。这一方案需要一个服务注册表(Service Registry)配合支持服务自注册和自发现，服务提供方启动时，首先将服务地址注册到服务注册表（同时定期报心跳到服务注册表以表明服务的存活状态，相当于健康检查），服务消费方要访问某个服务时，它通过内置的LB组件向服务注册表查询（同时缓存并定期刷新）目标服务地址列表，然后以某种负载均衡策略选择一个目标服务地址，最后向目标服务发起请求。这一方案对服务注册表的可用性(Availability)要求很高，一般采用能满足高可用分布式一致的组件（例如Zookeeper, Consul, Etcd等）来实现。</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/15/springcloud-yi/003.png" alt></p><blockquote><p>进程内LB方案是一种分布式方案，LB和服务发现能力被分散到每一个服务消费者的进程内部，同时服务消费方和服务提供方之间是直接调用，没有额外开销，性能比较好。但是，该方案以客户库(Client Library)的方式集成到服务调用方进程里头，如果企业内有多种不同的语言栈，就要配合开发多种不同的客户端，有一定的研发和维护成本。另外，一旦客户端跟随服务调用方发布到生产环境中，后续如果要对客户库进行升级，势必要求服务调用方修改代码并重新发布，所以该方案的升级推广有不小的阻力。</p><p>进程内LB的案例是Netflix的开源服务框架，对应的组件分别是：Eureka服务注册表，Karyon服务端框架支持服务自注册和健康检查，Ribbon客户端框架支持服务自发现和软路由。另外，阿里开源的服务框架Dubbo也是采用类似机制。</p></blockquote><h5 id="主机独立LB进程方案"><a href="#主机独立LB进程方案" class="headerlink" title="主机独立LB进程方案"></a>主机独立LB进程方案</h5><blockquote><p>主机独立LB进程方案是针对第二种方案的不足而提出的一种折中方案，原理和第二种方案基本类似，不同之处是，他将LB和服务发现功能从进程内移出来，变成主机上的一个独立进程，主机上的一个或者多个服务要访问目标服务时，他们都通过同一主机上的独立LB进程做服务发现和负载均衡，见下图</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/15/springcloud-yi/004.png" alt></p><blockquote><p>该方案也是一种分布式方案，没有单点问题，一个LB进程挂了只影响该主机上的服务调用方，服务调用方和LB之间是进程内调用，性能好，同时，该方案还简化了服务调用方，不需要为不同语言开发客户库，LB的升级不需要服务调用方改代码。该方案的不足是部署较复杂，环节多，出错调试排查问题不方便。</p><p>该方案的典型案例是Airbnb的SmartStack服务发现框架，对应组件分别是：Zookeeper作为服务注册表，Nerve独立进程负责服务注册和健康检查，Synapse/HAproxy独立进程负责服务发现和负载均衡。Google最新推出的基于容器的PaaS平台Kubernetes，其内部服务发现采用类似的机制。</p></blockquote><h4 id="服务前端路由"><a href="#服务前端路由" class="headerlink" title="服务前端路由"></a>服务前端路由</h4><blockquote><p>微服务除了内部相互之间调用和通信之外，最终要以某种方式暴露出去，才能让外界系统（例如客户的浏览器、移动设备等等）访问到，这就涉及服务的前端路由，对应的组件是服务网关(Service Gateway)，见下图，网关是连接企业内部和外部系统的一道门，有如下关键作用：</p><p>服务反向路由，网关要负责将外部请求反向路由到内部具体的微服务，这样虽然企业内部是复杂的分布式微服务结构，但是外部系统从网关上看到的就像是一个统一的完整服务，网关屏蔽了后台服务的复杂性，同时也屏蔽了后台服务的升级和变化。</p><p>安全认证和防爬虫，所有外部请求必须经过网关，网关可以集中对访问进行安全控制，比如用户认证和授权，同时还可以分析访问模式实现防爬虫功能，网关是连接企业内外系统的安全之门。</p><p>限流和容错，在流量高峰期，网关可以限制流量，保护后台系统不被大流量冲垮，在内部系统出现故障时，网关可以集中做容错，保持外部良好的用户体验。</p><p>监控，网关可以集中监控访问量，调用延迟，错误计数和访问模式，为后端的性能优化或者扩容提供数据支持。</p><p>日志，网关可以收集所有的访问日志，进入后台系统做进一步分析。</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/15/springcloud-yi/005.png" alt></p><blockquote><p>除以上基本能力外，网关还可以实现线上引流，线上压测，线上调试(Surgical debugging)，金丝雀测试(Canary Testing)，数据中心双活(Active-Active HA)等高级功能。</p><p>网关通常工作在7层，有一定的计算逻辑，一般以集群方式部署，前置LB进行负载均衡。</p><p>开源的网关组件有Netflix的Zuul，特点是动态可热部署的过滤器(filter)机制，其它如HAproxy，Nginx等都可以扩展作为网关使用。</p><p>在介绍过服务注册表和网关等组件之后，我们可以通过一个简化的微服务架构图来更加直观地展示整个微服务体系内的服务注册发现和路由机制，该图假定采用进程内LB服务发现和负载均衡机制。在下图的微服务架构中，服务简化为两层，后端通用服务（也称中间层服务Middle Tier Service）和前端服务（也称边缘服务Edge Service，前端服务的作用是对后端服务做必要的聚合和裁剪后暴露给外部不同的设备，如PC，Pad或者Phone）。后端服务启动时会将地址信息注册到服务注册表，前端服务通过查询服务注册表就可以发现然后调用后端服务；前端服务启动时也会将地址信息注册到服务注册表，这样网关通过查询服务注册表就可以将请求路由到目标前端服务，这样整个微服务体系的服务自注册自发现和软路由就通过服务注册表和网关串联起来了。如果以面向对象设计模式的视角来看，网关类似Proxy代理或者Façade门面模式，而服务注册表和服务自注册自发现类似IoC依赖注入模式，微服务可以理解为基于网关代理和注册表IoC构建的分布式系统。</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/15/springcloud-yi/006.png" alt></p><h4 id="服务容错"><a href="#服务容错" class="headerlink" title="服务容错"></a>服务容错</h4><blockquote><p>当企业微服务化以后，服务之间会有错综复杂的依赖关系，例如，一个前端请求一般会依赖于多个后端服务，技术上称为1 -&gt; N扇出(见下图1)。在实际生产环境中，服务往往不是百分百可靠，服务可能会出错或者产生延迟，如果一个应用不能对其依赖的故障进行容错和隔离，那么该应用本身就处在被拖垮的风险中。在一个高流量的网站中，某个单一后端一旦发生延迟，可能在数秒内导致所有应用资源(线程，队列等)被耗尽，造成所谓的雪崩效应(Cascading Failure，见下图2)，严重时可致整个网站瘫痪。</p><p>服务多依赖：</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/15/springcloud-yi/007.png" alt></p><blockquote><p>高峰期单个服务延迟致雪崩效应：</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/15/springcloud-yi/008.png" alt></p><blockquote><p>经过多年的探索和实践，业界在分布式服务容错一块探索出了一套有效的容错模式和最佳实践，主要包括：</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/15/springcloud-yi/009.png" alt></p><blockquote><p>电路熔断器模式(Circuit Breaker Patten), 该模式的原理类似于家里的电路熔断器，如果家里的电路发生短路，熔断器能够主动熔断电路，以避免灾难性损失。在分布式系统中应用电路熔断器模式后，当目标服务慢或者大量超时，调用方能够主动熔断，以防止服务被进一步拖垮；如果情况又好转了，电路又能自动恢复，这就是所谓的弹性容错，系统有自恢复能力。上图是一个典型的具备弹性恢复能力的电路保护器状态图，正常状态下，电路处于关闭状态(Closed)，如果调用持续出错或者超时，电路被打开进入熔断状态(Open)，后续一段时间内的所有调用都会被拒绝(Fail Fast)，一段时间以后，保护器会尝试进入半熔断状态(Half-Open)，允许少量请求进来尝试，如果调用仍然失败，则回到熔断状态，如果调用成功，则回到电路闭合状态。</p><p>舱壁隔离模式(Bulkhead Isolation Pattern)，顾名思义，该模式像舱壁一样对资源或失败单元进行隔离，如果一个船舱破了进水，只损失一个船舱，其它船舱可以不受影响 。线程隔离(Thread Isolation)就是舱壁隔离模式的一个例子，假定一个应用程序A调用了Svc1/Svc2/Svc3三个服务，且部署A的容器一共有120个工作线程，采用线程隔离机制，可以给对Svc1/Svc2/Svc3的调用各分配40个线程，当Svc2慢了，给Svc2分配的40个线程因慢而阻塞并最终耗尽，线程隔离可以保证给Svc1/Svc3分配的80个线程可以不受影响，如果没有这种隔离机制，当Svc2慢的时候，120个工作线程会很快全部被对Svc2的调用吃光，整个应用程序会全部慢下来。</p><p>限流(Rate Limiting/Load Shedder)，服务总有容量限制，没有限流机制的服务很容易在突发流量(秒杀，双十一)时被冲垮。限流通常指对服务限定并发访问量，比如单位时间只允许100个并发调用，对超过这个限制的请求要拒绝并回退。</p><p>回退(fallback)，在熔断或者限流发生的时候，应用程序的后续处理逻辑是什么？回退是系统的弹性恢复能力，常见的处理策略有，直接抛出异常，也称快速失败(Fail Fast)，也可以返回空值或缺省值，还可以返回备份数据，如果主服务熔断了，可以从备份服务获取数据。</p><p>Netflix将上述容错模式和最佳实践集成到一个称为Hystrix的开源组件中，凡是需要容错的依赖点(服务，缓存，数据库访问等)，开发人员只需要将调用封装在Hystrix Command里头，则相关调用就自动置于Hystrix的弹性容错保护之下。Hystrix组件已经在Netflix经过多年运维验证，是Netflix微服务平台稳定性和弹性的基石，正逐渐被社区接受为标准容错组件。</p></blockquote><h4 id="服务框架"><a href="#服务框架" class="headerlink" title="服务框架"></a>服务框架</h4><blockquote><p>微服务化以后，为了让业务开发人员专注于业务逻辑实现，避免冗余和重复劳动，规范研发提升效率，必然要将一些公共关注点推到框架层面。下图服务框架主要封装公共关注点逻辑，包括：</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/15/springcloud-yi/010.png" alt></p><blockquote><p>服务注册、发现、负载均衡和健康检查，假定采用进程内LB方案，那么服务自注册一般统一做在服务器端框架中，健康检查逻辑由具体业务服务定制，框架层提供调用健康检查逻辑的机制，服务发现和负载均衡则集成在服务客户端框架中。</p><p>监控日志，框架一方面要记录重要的框架层日志、metrics和调用链数据，还要将日志、metrics等接口暴露出来，让业务层能根据需要记录业务日志数据。在运行环境中，所有日志数据一般集中落地到企业后台日志系统，做进一步分析和处理。</p><p>REST/RPC和序列化，框架层要支持将业务逻辑以HTTP/REST或者RPC方式暴露出来，HTTP/REST是当前主流API暴露方式，在性能要求高的场合则可采用Binary/RPC方式。针对当前多样化的设备类型(浏览器、普通PC、无线设备等)，框架层要支持可定制的序列化机制，例如，对浏览器，框架支持输出Ajax友好的JSON消息格式，而对无线设备上的Native App，框架支持输出性能高的Binary消息格式。</p><p>配置，除了支持普通配置文件方式的配置，框架层还可集成动态运行时配置，能够在运行时针对不同环境动态调整服务的参数和配置。</p><p>限流和容错，框架集成限流容错组件，能够在运行时自动限流和容错，保护服务，如果进一步和动态配置相结合，还可以实现动态限流和熔断。</p><p>管理接口，框架集成管理接口，一方面可以在线查看框架和服务内部状态，同时还可以动态调整内部状态，对调试、监控和管理能提供快速反馈。Spring Boot微框架的Actuator模块就是一个强大的管理接口。</p><p>统一错误处理，对于框架层和服务的内部异常，如果框架层能够统一处理并记录日志，对服务监控和快速问题定位有很大帮助。</p><p>安全，安全和访问控制逻辑可以在框架层统一进行封装，可做成插件形式，具体业务服务根据需要加载相关安全插件。</p><p>文档自动生成，文档的书写和同步一直是一个痛点，框架层如果能支持文档的自动生成和同步，会给使用API的开发和测试人员带来极大便利。Swagger是一种流行Restful API的文档方案。</p><p>当前业界比较成熟的微服务框架有Netflix的Karyon/Ribbon，Spring的Spring Boot/Cloud，阿里的Dubbo等。</p><p><strong>运行期配置管理</strong></p><p>服务一般有很多依赖配置，例如访问数据库有连接字符串配置，连接池大小和连接超时配置，这些配置在不同环境(开发/测试/生产)一般不同，比如生产环境需要配连接池，而开发测试环境可能不配，另外有些参数配置在运行期可能还要动态调整，例如，运行时根据流量状况动态调整限流和熔断阀值。目前比较常见的做法是搭建一个运行时配置中心支持微服务的动态配置，简化架构如下图</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/15/springcloud-yi/011.png" alt></p><blockquote><p>动态配置存放在集中的配置服务器上，用户通过管理界面配置和调整服务配置，具体服务通过定期拉(Scheduled Pull)的方式或者服务器推(Server-side Push)的方式更新动态配置，拉方式比较可靠，但会有延迟同时有无效网络开销(假设配置不常更新)，服务器推方式能及时更新配置，但是实现较复杂，一般在服务和配置服务器之间要建立长连接。配置中心还要解决配置的版本控制和审计问题，对于大规模服务化环境，配置中心还要考虑分布式和高可用问题。</p><p>配置中心比较成熟的开源方案有百度的Disconf，360的QConf，Spring的Cloud Config和阿里的Diamond等。</p><p><strong>Netflix的微服务框架</strong></p><p>Netflix是一家成功实践微服务架构的互联网公司，几年前，Netflix就把它的几乎整个微服务框架栈开源贡献给了社区，这些框架和组件包括：</p><p>Eureka:　服务注册发现框架</p><p>Zuul:　服务网关</p><p>Karyon:　服务端框架</p><p>Ribbon:　客户端框架</p><p>Hystrix: 服务容错组件</p><p>Archaius: 服务配置组件</p><p>Servo: Metrics组件</p><p>Blitz4j: 日志组件</p><p>下图展示了基于这些组件构建的一个微服务框架体系，来自recipes-rss。</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/15/springcloud-yi/012.png" alt></p><blockquote><p>Netflix的开源框架组件已经在Netflix的大规模分布式微服务环境中经过多年的生产实战验证，正逐步被社区接受为构造微服务框架的标准组件。Pivotal去年推出的Spring Cloud开源产品，主要是基于对Netflix开源组件的进一步封装，方便Spring开发人员构建微服务基础框架。对于一些打算构建微服务框架体系的公司来说，充分利用或参考借鉴Netflix的开源微服务组件(或Spring Cloud)，在此基础上进行必要的企业定制，无疑是通向微服务架构的捷径。</p><p><strong>Spring Cloud</strong></p><p>Spring Cloud为开发人员提供了快速构建分布式系统中一些常见模式的工具（例如配置管理，服务发现注册、微代理、消息总线、负载均衡、断路器、数据监控等）。分布式系统的协调导致了样板模式, 使用Spring Cloud开发人员可以快速地支持实现这些模式的服务和应用程序。他们将在任何分布式环境中运行良好，包括开发人员自己的笔记本电脑，裸机数据中心，以及Cloud Foundry等托管平台。</p><p><strong>大道至简的分布式系统</strong></p><p>协调一切: 大道至简的分布式系统</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/15/springcloud-yi/013.png" alt></p><blockquote><p>构建分布式系统不需要复杂和容易出错。Spring Cloud为最常见的分布式系统模式提供了一个简单易访问的编程模型，帮助开发人员构建有弹性、可靠和协调的应用程序. Spring Cloud 是建立在Spring Boot之上使得开发者很容易开始和快速生产。</p><p><strong>特性</strong></p><p>Spring Cloud专注于提供良好的开箱即用经验的典型用例和可扩展性机制覆盖。</p><p>分布式/版本化配置</p><p>服务注册和发现</p><p>路由</p><p>service - to - service调用</p><p>负载均衡</p><p>断路器</p><p>分布式消息传递</p></blockquote><h4 id="SpringCloud-家族"><a href="#SpringCloud-家族" class="headerlink" title="SpringCloud 家族"></a>SpringCloud 家族</h4><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/15/springcloud-yi/014.png" alt></p><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/15/springcloud-yi/015.png" alt></p><h4 id="Spring-Cloud-Netflix"><a href="#Spring-Cloud-Netflix" class="headerlink" title="Spring Cloud Netflix"></a><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/15/springcloud-yi/016.png" alt><strong>Spring Cloud Netflix</strong></h4><blockquote><p>Spring Cloud Netflix 为Spring Boot 应用程序利用autoconfiguration绑定Spring上下文环境的方式或者其他的Spring系程序提供了 Netflix OSS 集成 。通过一些简单的注解，我们可以快速的在我们的应用程序内部启用和配置常用属性从而利用强悍的Netflix 组件构建我的分布式系统。 Netflix提供的组件包括服务发现（Eureka）、断路器（Hystrix）、智能路由（Zuul）和客户端负载平衡（Ribbon）。</p></blockquote><h4 id="Spring-Cloud-Netflix-特征"><a href="#Spring-Cloud-Netflix-特征" class="headerlink" title="Spring Cloud Netflix 特征:"></a>Spring Cloud Netflix 特征:</h4><blockquote><p>服务发现: Eureka 实例会被注册并且客户端可以通过Spring托管的beans发现Eureka 实例。</p><p>服务发现: 内嵌的 Eureka server 使用简单的Java申明式注解实现。</p><p>断路器: Hystrix 客户端可以使用一些简单注解装饰实现。</p><p>断路器: 内嵌的 Hystrix 控制台使用简单的Java申明式注解实现。</p><p>声明性REST客户端: Feign 用JAX-RS或Spring MVC注解创建可以实现的动态接口。</p><p>客户端负载均衡 ：Ribbon</p><p>外部配置: Spring 环境 和 Archaius (使用Spring Boot约定启用Netflix组件的本地配置)的桥梁。</p><p>路由器和过滤器: Zuul过滤器的自动重新定位，以及反向代理创建的配置方法上的简单约定。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> springcloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springcloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL——存储引擎</title>
      <link href="/2019/06/14/mysql-cun-chu-yin-qing/"/>
      <url>/2019/06/14/mysql-cun-chu-yin-qing/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL——存储引擎"><a href="#MySQL——存储引擎" class="headerlink" title="MySQL——存储引擎"></a>MySQL——存储引擎</h1><blockquote><pre><code>MySQL中的数据用不同的技术存储在文件或内存中。每一种技术都有自己不同的存储机制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力。选择不同的技术，你能够得到不同的速度或功能，从而改善你的应用的整体功能。这些技术以及配套的相关功能在MySQL中被称作存储引擎。</code></pre></blockquote><h4 id="存储引擎作用"><a href="#存储引擎作用" class="headerlink" title="存储引擎作用"></a>存储引擎作用</h4><blockquote><p>存储引擎说白了就是如何存储数据、如何为存储的数据建立索引和如何更新、查询数据等技术的实现方法。</p><p>因为在关系数据库中数据的存储是以表的形式存储的，所以存储引擎也可以称为表类型（即存储和操作此表的类型）。</p></blockquote><h4 id="存储引擎类型"><a href="#存储引擎类型" class="headerlink" title="存储引擎类型"></a>存储引擎类型</h4><blockquote><p>通过命令可以查看支持的引擎列表</p><p>show engines;</p></blockquote><p><img src="/Volumes/work/hexo/source/_posts/MySQL——存储引擎/001.png" alt></p><h4 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a>InnoDB存储引擎</h4><blockquote><p>InnoDB是MySQL的默认事务型引擎，它被设计用来处理大量的短期(short-lived)事务。除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎。</p><p>InnoDB采用MVCC来支持高并发，并且实现了四个标准的隔离级别。其默认级别是REPEATABLE READ(可重复读)，并且通过间隙锁(next-key locking)策略防止幻读的出现。</p><p>InnoDB是基于聚簇索引建立的，聚簇索引对主键查询有很高的性能。不过它的二级索引(secondary index，非主键索引)中必须包含主键列，所以如果主键列很大的话，其他的所有索引都会很大。因此表上的索引较多的话，主键应当尽可能的小。</p><p>InnoDB的存储格式是平台独立的，可以将数据和索引文件从Intel平台复制到Sun SPARC平台或其他平台。</p><p>InnoDB通过一些机制和工具支持真正的热备份，MySQL的其他存储引擎不支持热备份。</p></blockquote><h4 id="MyISAM存储引擎"><a href="#MyISAM存储引擎" class="headerlink" title="MyISAM存储引擎"></a>MyISAM存储引擎</h4><blockquote><p>MyISAM提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但MyISAM不支持事务和行级锁，有一个毫无疑问的缺陷就是崩溃后无法安全恢复。</p><p>MyISAM会将表存储在两个文件在中：数据文件和索引文件，分别是.MYD和.MYI为扩展名。</p><p>在MySQL5.0以前，只能处理4G的数据，5.0中可以处理256T的数据。</p><p>在数据不再进行修改操作时，可以对MyISAM表进行压缩，压缩后可以提高读能力，原因是减少了磁盘I/O。</p></blockquote><h4 id="Archive引擎"><a href="#Archive引擎" class="headerlink" title="Archive引擎"></a>Archive引擎</h4><blockquote><p>Archive存储引擎只支持INSERT和SELECT操作，在MySQL5.1之前不支持索引。</p><p>Archive表适合日志和数据采集类应用。</p><p>Archive引擎支持行级锁和专用的缓存区，所以可以实现高并发的插入，但它不是一个事物型的引擎，而是一个针对高速插入和压缩做了优化的简单引擎。</p></blockquote><h4 id="Blackhole引擎"><a href="#Blackhole引擎" class="headerlink" title="Blackhole引擎"></a>Blackhole引擎</h4><blockquote><p>Blackhole引擎没有实现任何存储机制，它会丢弃所有插入的数据，不做任何保存。但服务器会记录Blackhole表的日志，所以可以用于复制数据到备库，或者简单地记录到日志。但这种应用方式会碰到很多问题，因此并不推荐。</p></blockquote><h4 id="CSV引擎"><a href="#CSV引擎" class="headerlink" title="CSV引擎"></a>CSV引擎</h4><blockquote><p>CSV引擎可以将普通的SCV文件作为MySQL的表来处理，但不支持索引。</p><p>CSV引擎可以作为一种数据交换的机制，非常有用。</p></blockquote><h4 id="Federated引擎"><a href="#Federated引擎" class="headerlink" title="Federated引擎"></a>Federated引擎</h4><blockquote><p>Federated引擎是访问其他MySQL服务器的一个代理，尽管该引擎看起来提供了一种很好的跨服务器的灵活性，但也经常带来问题，因此默认是禁用的。</p></blockquote><h4 id="Memory引擎"><a href="#Memory引擎" class="headerlink" title="Memory引擎"></a>Memory引擎</h4><blockquote><p>如果需要快速地访问数据，并且这些数据不会被修改，重启以后丢失也没有关系，那么使用Memory表是非常有用。Memory表至少比MyISAM表要快一个数量级。</p><p>Memory表是表级锁，因此并发写入的性能较低。它不支持BLOB或TEXT类型的列，并且每行的长度是固定的，这可能呆滞部分内存的浪费。</p><p>临时表和Memory表不是一回事。临时表是指使用CREATE TEMPORARY TABLE语句创建的表，它可以使用任何存储引擎，只在单个连接中可见，当连接断开时，临时表也将不复存在。</p></blockquote><h4 id="MRG-MYISAM-MERGE-引擎"><a href="#MRG-MYISAM-MERGE-引擎" class="headerlink" title="MRG_MYISAM(MERGE)引擎"></a>MRG_MYISAM(MERGE)引擎</h4><blockquote><p>MERGE存储引擎是一组MyISAM表的组合，这些MyISAM表结构必须完全相同，尽管其使用不如其它引擎突出，但是在某些情况下非常有用。说白了，Merge表就是几个相同MyISAM表的聚合器；Merge表中并没有数据，对Merge类型的表可以进行查询、更新、删除操作，这些操作实际上是对内部的MyISAM表进行操作。</p></blockquote><h4 id="PERFORMANCE-SCHEMA"><a href="#PERFORMANCE-SCHEMA" class="headerlink" title="PERFORMANCE_SCHEMA"></a>PERFORMANCE_SCHEMA</h4><blockquote><p>主要用于收集数据库服务器性能参数。</p><p>MySQL用户是不能创建存储引擎为PERFORMANCE_SCHEMA的表，一般用于记录binlog做复制的中继。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySql </tag>
            
            <tag> 存储引擎 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8之lambda表达式</title>
      <link href="/2019/06/13/java8-zhi-lambda-biao-da-shi/"/>
      <url>/2019/06/13/java8-zhi-lambda-biao-da-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><h4 id="一、java重要的函数式接口"><a href="#一、java重要的函数式接口" class="headerlink" title="一、java重要的函数式接口"></a>一、java重要的函数式接口</h4><h5 id="1、什么是函数式接口"><a href="#1、什么是函数式接口" class="headerlink" title="1、什么是函数式接口"></a><strong>1、什么是函数式接口</strong></h5><pre><code>        函数接口是只有一个抽象方法的接口，用作 Lambda 表达式的类型。使用@FunctionalInterface注解修饰的类，编译器会检测该类是否只有一个抽象方法或接口，否则，会报错。可以有多个默认方法，静态方法。</code></pre><h5 id="2、Java8将函数式接口封装到流中如何高效的帮助我们处理集合。"><a href="#2、Java8将函数式接口封装到流中如何高效的帮助我们处理集合。" class="headerlink" title="2、Java8将函数式接口封装到流中如何高效的帮助我们处理集合。"></a>2、Java8将函数式接口封装到流中如何高效的帮助我们处理集合。</h5><pre><code>本篇所有示例都基于以下三个类。OutstandingClass：班级；Student：学生；SpecialityEnum：特长。</code></pre><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/13/java8-zhi-lambda-biao-da-shi/001.png" alt="001"></p><h6 id="2-1-惰性求值与及早求值"><a href="#2-1-惰性求值与及早求值" class="headerlink" title="2.1 惰性求值与及早求值"></a><strong>2.1 惰性求值与及早求值</strong></h6><pre><code>惰性求值：只描述Stream，操作的结果也是Stream，这样的操作称为惰性求值。惰性求值可以像建造者模式一样链式使用，最后再使用及早求值得到最终结果。及早求值：得到最终的结果而不是Stream，这样的操作称为及早求值</code></pre><h6 id="3、常用的流"><a href="#3、常用的流" class="headerlink" title="3、常用的流"></a>3、常用的流</h6><p>3.1 collect(Collectors.toList())</p><pre><code>将流转换为list。还有toSet()，toMap()等。及早求值。</code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019-06-17 * @Time: 21:26 * @Vsersion: 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestCase</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>Student<span class="token operator">></span> studentList <span class="token operator">=</span> Stream<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"路飞"</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">185</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"红发"</span><span class="token punctuation">,</span><span class="token number">34</span><span class="token punctuation">,</span><span class="token number">178</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"白胡子"</span><span class="token punctuation">,</span><span class="token number">32</span><span class="token punctuation">,</span><span class="token number">189</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>studentList<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>3.2 filter</p><pre><code>顾名思义，起过滤筛选的作用。内部就是Predicate接口。惰性求值。</code></pre><pre><code>比如我们筛选出出身高小于180的同学。</code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019-06-17 * @Time: 22:32 * @Vsersion: 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test02</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>Student<span class="token operator">></span> students <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        students<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"路飞"</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">175</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        students<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"红发"</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">180</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        students<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"白胡子"</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">185</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>Student<span class="token operator">></span> list <span class="token operator">=</span> students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>student <span class="token operator">-</span><span class="token operator">></span> student<span class="token punctuation">.</span><span class="token function">getStature</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token number">180</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>3.3 map</p><pre><code>转换功能，内部就是Function接口。惰性求值</code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019-06-17 * @Time: 22:47 * @Vsersion: 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test03</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>Student<span class="token operator">></span> students <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        students<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"路飞"</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">175</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        students<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"红发"</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">180</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        students<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"白胡子"</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">185</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>String<span class="token operator">></span> names <span class="token operator">=</span> students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>student <span class="token operator">-</span><span class="token operator">></span> student<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>names<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>3.4 flatMap</p><pre><code>将多个Stream合并为一个Stream。惰性求值</code></pre><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/13/java8-zhi-lambda-biao-da-shi/004.png" alt="004"></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019-06-17 * @Time: 22:51 * @Vsersion: 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test04</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>Student<span class="token operator">></span> students <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        students<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"路飞"</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">175</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        students<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"红发"</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">180</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        students<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"白胡子"</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">185</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>Student<span class="token operator">></span> studentList <span class="token operator">=</span> Stream<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>students<span class="token punctuation">,</span>                <span class="token function">asList</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"艾斯"</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">,</span> <span class="token number">183</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                        <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"雷利"</span><span class="token punctuation">,</span> <span class="token number">48</span><span class="token punctuation">,</span> <span class="token number">176</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span>students1 <span class="token operator">-</span><span class="token operator">></span> students1<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>studentList<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>调用Stream.of的静态方法将两个list转换为Stream，再通过flatMap将两个流合并为一个。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 日常学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lambda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/06/09/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/"/>
      <url>/2019/06/09/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL事务及ACID特性的实现原理"><a href="#MySQL事务及ACID特性的实现原理" class="headerlink" title="MySQL事务及ACID特性的实现原理"></a>MySQL事务及ACID特性的实现原理</h1><p>[TOC]</p><h4 id="一、MySQL-事务基础概念"><a href="#一、MySQL-事务基础概念" class="headerlink" title="一、MySQL 事务基础概念"></a>一、MySQL 事务基础概念</h4><blockquote><p>​    事务(Transaction)是访问和更新数据库的程序执行单元;事务中可能包含一个或多个 sql 语句，这些语句要么都执行，要么都不执行。</p></blockquote><blockquote><p>​    作为一个关系型数据库，MySQL 支持事务，本文介绍基于 MySQL 5.6。首先回顾一下 MySQL 事务的基础知识。</p></blockquote><h4 id="二、逻辑架构和存储引擎"><a href="#二、逻辑架构和存储引擎" class="headerlink" title="二、逻辑架构和存储引擎"></a>二、逻辑架构和存储引擎</h4><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/09/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/001.jpg" alt="001"></p><blockquote><p>如上图所示，MySQL 服务器逻辑架构从上往下可以分为三层：</p></blockquote><p>++++</p><ul><li>第一层：处理客户端连接、授权认证等。</li><li>第二层：服务器层，负责查询语句的解析、优化、缓存以及内置函数的实现、存储过程等。</li><li>第三层：存储引擎，负责 MySQL 中数据的存储和提取。MySQL 中服务器层不管理事务，事务是由存储引擎实现的。</li></ul><blockquote><p>MySQL 支持事务的存储引擎有 InnoDB、NDB Cluster 等，其中 InnoDB 的使用最为广泛;其他存储引擎不支持事务，如 MyIsam、Memory 等。</p></blockquote><blockquote><p>如无特殊说明，后文中描述的内容都是基于 InnoDB。</p></blockquote><h4 id="三、提交和回滚"><a href="#三、提交和回滚" class="headerlink" title="三、提交和回滚"></a>三、提交和回滚</h4><blockquote><p>典型的 MySQL 事务是如下操作的：</p></blockquote><pre class=" language-java"><code class="language-java">start transaction<span class="token punctuation">;</span> …… #一条或多条sql语句 commit<span class="token punctuation">;</span> </code></pre><blockquote><p>其中 start transaction 标识事务开始，commit 提交事务，将执行结果写入到数据库。</p></blockquote><blockquote><p>如果 sql 语句执行出现问题，会调用 rollback，回滚所有已经执行成功的 sql 语句。当然，也可以在事务中直接使用 rollback 语句进行回滚。</p></blockquote><h4 id="四、自动提交"><a href="#四、自动提交" class="headerlink" title="四、自动提交"></a>四、自动提交</h4><blockquote><p>MySQL 中默认采用的是自动提交(autocommit)模式，如下所示：</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/09/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/002.jpg" alt="002"></p><blockquote><p>在自动提交模式下，如果没有 start transaction 显式地开始一个事务，那么每个 sql 语句都会被当做一个事务执行提交操作。</p></blockquote><blockquote><p>通过如下方式，可以关闭 autocommit;需要注意的是，autocommit 参数是针对连接的，在一个连接中修改了参数，不会对其他连接产生影响。</p></blockquote><blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/09/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/003.jpg" alt="003"></p></blockquote><blockquote><p>如果关闭了 autocommit，则所有的 sql 语句都在一个事务中，直到执行了 commit 或 rollback，该事务结束，同时开始了另外一个事务。</p></blockquote><h4 id="五、特殊操作"><a href="#五、特殊操作" class="headerlink" title="五、特殊操作"></a>五、特殊操作</h4><blockquote><p>在 MySQL 中，存在一些特殊的命令，如果在事务中执行了这些命令，会马上强制执行 commit 提交事务;如 DDL 语句(create table/drop table/alter/table)、lock tables 语句等等。</p></blockquote><blockquote><p>不过，常用的 select、insert、update 和 delete 命令，都不会强制提交事务。</p></blockquote><h4 id="六、ACID-特性"><a href="#六、ACID-特性" class="headerlink" title="六、ACID 特性"></a>六、ACID 特性</h4><blockquote><p>ACID 是衡量事务的四个特性：</p></blockquote><ul><li><strong>原子性(Atomicity，或称不可分割性)</strong></li><li><strong>一致性(Consistency)</strong></li><li><strong>隔离性(Isolation)</strong></li><li><strong>持久性(Durability)</strong></li></ul><blockquote><p>按照严格的标准，只有同时满足 ACID 特性才是事务;但是在各大数据库厂商的实现中，真正满足 ACID 的事务少之又少。</p></blockquote><blockquote><p>例如 MySQL 的 NDB Cluster 事务不满足持久性和隔离性;InnoDB 默认事务隔离级别是可重复读，不满足隔离性;Oracle 默认的事务隔离级别为 READ COMMITTED，不满足隔离性……</p></blockquote><blockquote><p>因此与其说 ACID 是事务必须满足的条件，不如说它们是衡量事务的四个维度。</p></blockquote><blockquote><p>下面将详细介绍 ACID 特性及其实现原理，为了便于理解，介绍的顺序不是严格按照 A-C-I-D。</p></blockquote><h4 id="七、ACID-特性及其实现原理"><a href="#七、ACID-特性及其实现原理" class="headerlink" title="七、ACID 特性及其实现原理"></a>七、ACID 特性及其实现原理</h4><h5 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a><strong>原子性</strong></h5><p><strong>定义</strong></p><blockquote><p>原子性是指一个事务是一个不可分割的工作单位，其中的操作要么都做，要么都不做。</p></blockquote><blockquote><p>如果事务中一个 sql 语句执行失败，则已执行的语句也必须回滚，数据库退回到事务前的状态。</p></blockquote><p><strong>实现原理：undo log</strong></p><blockquote><p>在说明原子性原理之前，首先介绍一下 MySQL 的事务日志。MySQL 的日志有很多种，如二进制日志、错误日志、查询日志、慢查询日志等。</p></blockquote><blockquote><p>此外 InnoDB 存储引擎还提供了两种事务日志：</p></blockquote><ul><li><strong>redo log(重做日志)</strong></li><li><strong>undo log(回滚日志)</strong></li></ul><blockquote><p>其中 redo log 用于保证事务持久性;undo log 则是事务原子性和隔离性实现的基础。</p></blockquote><blockquote><p>下面说回 undo log。实现原子性的关键，是当事务回滚时能够撤销所有已经成功执行的 sql 语句。</p></blockquote><blockquote><p>InnoDB 实现回滚，靠的是 undo log：</p></blockquote><ul><li>当事务对数据库进行修改时，InnoDB 会生成对应的 undo log。</li><li>如果事务执行失败或调用了 rollback，导致事务需要回滚，便可以利用 undo log 中的信息将数据回滚到修改之前的样子。</li></ul><blockquote><p>undo log 属于逻辑日志，它记录的是 sql 执行相关的信息。当发生回滚时，InnoDB 会根据 undo log 的内容做与之前相反的工作：</p></blockquote><ul><li>对于每个 insert，回滚时会执行 delete。</li><li>对于每个 delete，回滚时会执行 insert。</li><li>对于每个 update，回滚时会执行一个相反的 update，把数据改回去。</li></ul><blockquote><p>以 update 操作为例：当事务执行 update 时，其生成的 undo log 中会包含被修改行的主键(以便知道修改了哪些行)、修改了哪些列、这些列在修改前后的值等信息，回滚时便可以使用这些信息将数据还原到 update 之前的状态。</p></blockquote><h5 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a><strong>持久性</strong></h5><p><strong>定义</strong></p><blockquote><p>持久性是指事务一旦提交，它对数据库的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。</p></blockquote><p><strong>实现原理：redo log</strong></p><blockquote><p>redo log 和 undo log 都属于 InnoDB 的事务日志。下面先聊一下 redo log 存在的背景。</p></blockquote><blockquote><p>InnoDB 作为 MySQL 的存储引擎，数据是存放在磁盘中的，但如果每次读写数据都需要磁盘 IO，效率会很低。</p></blockquote><blockquote><p>为此，InnoDB 提供了缓存(Buffer Pool)，Buffer Pool 中包含了磁盘中部分数据页的映射，作为访问数据库的缓冲：</p></blockquote><ul><li>当从数据库读取数据时，会首先从 Buffer Pool 中读取，如果 Buffer Pool 中没有，则从磁盘读取后放入 Buffer Pool。</li><li>当向数据库写入数据时，会首先写入 Buffer Pool，Buffer Pool 中修改的数据会定期刷新到磁盘中(这一过程称为刷脏)。</li></ul><blockquote><p>Buffer Pool 的使用大大提高了读写数据的效率，但是也带来了新的问题：如果 MySQL 宕机，而此时 Buffer Pool 中修改的数据还没有刷新到磁盘，就会导致数据的丢失，事务的持久性无法保证。</p></blockquote><blockquote><p>于是，redo log 被引入来解决这个问题：当数据修改时，除了修改 Buffer Pool 中的数据，还会在 redo log 记录这次操作;当事务提交时，会调用 fsync 接口对 redo log 进行刷盘。</p></blockquote><blockquote><p>如果 MySQL 宕机，重启时可以读取 redo log 中的数据，对数据库进行恢复。</p></blockquote><blockquote><p>redo log 采用的是 WAL(Write-ahead logging，预写式日志)，所有修改先写入日志，再更新到 Buffer Pool，保证了数据不会因 MySQL 宕机而丢失，从而满足了持久性要求。</p></blockquote><blockquote><p>既然 redo log 也需要在事务提交时将日志写入磁盘，为什么它比直接将 Buffer Pool 中修改的数据写入磁盘(即刷脏)要快呢?</p></blockquote><blockquote><p>主要有以下两方面的原因：</p></blockquote><ul><li>刷脏是随机 IO，因为每次修改的数据位置随机，但写 redo log 是追加操作，属于顺序 IO。</li><li>刷脏是以数据页(Page)为单位的，MySQL 默认页大小是 16KB，一个 Page 上一个小修改都要整页写入;而 redo log 中只包含真正需要写入的部分，无效 IO 大大减少。</li></ul><p><strong>redo log 与 binlog</strong></p><blockquote><p>我们知道，在 MySQL 中还存在 binlog(二进制日志)也可以记录写操作并用于数据的恢复，但二者是有着根本的不同的。</p></blockquote><blockquote><p>作用不同：</p></blockquote><ul><li>redo log 是用于 crash recovery 的，保证 MySQL 宕机也不会影响持久性;</li><li>binlog 是用于 point-in-time recovery 的，保证服务器可以基于时间点恢复数据，此外 binlog 还用于主从复制。</li></ul><blockquote><p>层次不同：</p></blockquote><ul><li>redo log 是 InnoDB 存储引擎实现的，</li><li>而 binlog 是 MySQL 的服务器层(可以参考文章前面对 MySQL 逻辑架构的介绍)实现的，同时支持 InnoDB 和其他存储引擎。</li></ul><blockquote><p>内容不同：</p></blockquote><ul><li>redo log 是物理日志，内容基于磁盘的 Page。</li><li>binlog 是逻辑日志，内容是一条条 sql。</li></ul><blockquote><p>写入时机不同：</p></blockquote><ul><li>redo log 的写入时机相对多元。前面曾提到，当事务提交时会调用 fsync 对 redo log 进行刷盘;这是默认情况下的策略，修改 innodb_flush_log_at_trx_commit 参数可以改变该策略，但事务的持久性将无法保证。</li></ul><blockquote><p>除了事务提交时，还有其他刷盘时机：如 master thread 每秒刷盘一次 redo log 等，这样的好处是不一定要等到 commit 时刷盘，commit 速度大大加快。</p></blockquote><ul><li>binlog 在事务提交时写入。</li></ul><h5 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a><strong>隔离性</strong></h5><p><strong>定义</strong></p><blockquote><p>与原子性、持久性侧重于研究事务本身不同，隔离性研究的是不同事务之间的相互影响。</p></blockquote><blockquote><p>隔离性是指事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p></blockquote><blockquote><p>严格的隔离性，对应了事务隔离级别中的 Serializable(可串行化)，但实际应用中出于性能方面的考虑很少会使用可串行化。</p></blockquote><blockquote><p>隔离性追求的是并发情形下事务之间互不干扰。简单起见，我们仅考虑最简单的读操作和写操作(暂时不考虑带锁读等特殊操作)。</p></blockquote><blockquote><p>那么隔离性的探讨，主要可以分为两个方面：</p></blockquote><ul><li>(一个事务)写操作对(另一个事务)写操作的影响：锁机制保证隔离性。</li><li>(一个事务)写操作对(另一个事务)读操作的影响：MVCC 保证隔离性。</li></ul><h5 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a><strong>锁机制</strong></h5><blockquote><p>首先来看两个事务的写操作之间的相互影响。隔离性要求同一时刻只能有一个事务对数据进行写操作，InnoDB 通过锁机制来保证这一点。</p></blockquote><blockquote><p>锁机制的基本原理可以概括为：</p></blockquote><ul><li>事务在修改数据之前，需要先获得相应的锁。</li><li>获得锁之后，事务便可以修改数据。</li><li>该事务操作期间，这部分数据是锁定的，其他事务如果需要修改数据，需要等待当前事务提交或回滚后释放锁。</li></ul><blockquote><p>行锁与表锁：按照粒度，锁可以分为表锁、行锁以及其他位于二者之间的锁。</p></blockquote><blockquote><p>表锁在操作数据时会锁定整张表，并发性能较差;行锁则只锁定需要操作的数据，并发性能好。</p></blockquote><blockquote><p>但是由于加锁本身需要消耗资源(获得锁、检查锁、释放锁等都需要消耗资源)，因此在锁定数据较多情况下使用表锁可以节省大量资源。</p></blockquote><blockquote><p>MySQL 中不同的存储引擎支持的锁是不一样的，例如 MyIsam 只支持表锁，而 InnoDB 同时支持表锁和行锁，且出于性能考虑，绝大多数情况下使用的都是行锁。</p></blockquote><blockquote><p>如何查看锁信息?有多种方法可以查看 InnoDB 中锁的情况，例如：</p></blockquote><pre class=" language-mysql"><code class="language-mysql">select * from information_schema.innodb_locks; #锁的概况 show engine innodb status; #InnoDB整体状态，其中包括锁的情况 </code></pre><p>下面来看一个例子：</p><pre class=" language-mysql"><code class="language-mysql">#在事务A中执行： start transaction; update account SET balance = 1000 where id = 1; 在事务B中执行： start transaction; update account SET balance = 2000 where id = 1; </code></pre><p>此时查看锁的情况：</p><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/09/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/004.jpg" alt="004"></p><p>show engine innodb status 查看锁相关的部分：</p><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/09/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/005.jpg" alt="005"></p><blockquote><p>通过上述命令可以查看事务 24052 和 24053 占用锁的情况;其中 lock_type 为 RECORD，代表锁为行锁(记录锁);lock_mode 为 X，代表排它锁(写锁)。</p></blockquote><blockquote><p>除了排它锁(写锁)之外，MySQL 中还有共享锁(读锁)的概念。由于本文重点是 MySQL 事务的实现原理，因此对锁的介绍到此为止。</p></blockquote><blockquote><p>介绍完写操作之间的相互影响，下面讨论写操作对读操作的影响。</p></blockquote><h5 id="脏读、不可重复读和幻读"><a href="#脏读、不可重复读和幻读" class="headerlink" title="脏读、不可重复读和幻读"></a><strong>脏读、不可重复读和幻读</strong></h5><blockquote><p>首先来看并发情况下，读操作可能存在的三类问题。</p></blockquote><blockquote><p>①脏读：当前事务(A)中可以读到其他事务(B)未提交的数据(脏数据)，这种现象是脏读。</p></blockquote><p>举例如下(以账户余额表为例)：</p><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/09/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/006.jpg" alt="006"></p><blockquote><p>②不可重复读：在事务 A 中先后两次读取同一个数据，两次读取的结果不一样，这种现象称为不可重复读。</p></blockquote><blockquote><p>脏读与不可重复读的区别在于：前者读到的是其他事务未提交的数据，后者读到的是其他事务已提交的数据。</p></blockquote><p>举例如下：</p><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/09/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/007.jpg" alt="007"></p><blockquote><p>③幻读：在事务 A 中按照某个条件先后两次查询数据库，两次查询结果的条数不同，这种现象称为幻读。</p></blockquote><blockquote><p>不可重复读与幻读的区别可以通俗的理解为：前者是数据变了，后者是数据的行数变了。</p></blockquote><p>举例如下：</p><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/09/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/008.jpg" alt="008"></p><h5 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a><strong>事务隔离级别</strong></h5><blockquote><p>sql 标准中定义了四种隔离级别，并规定了每种隔离级别下上述几个问题是否存在。</p></blockquote><blockquote><p>一般来说，隔离级别越低，系统开销越低，可支持的并发越高，但隔离性也越差。</p></blockquote><blockquote><p>隔离级别与读问题的关系如下：</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/09/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/009.jpg" alt="009"></p><blockquote><p>在实际应用中，读未提交在并发时会导致很多问题，而性能相对于其他隔离级别提高却很有限，因此使用较少。</p></blockquote><blockquote><p>可串行化强制事务串行，并发效率很低，只有当对数据一致性要求极高且可以接受没有并发时使用，因此使用也较少。</p></blockquote><blockquote><p>因此在大多数数据库系统中，默认的隔离级别是读已提交(如 Oracle)或可重复读(后文简称 RR)。</p></blockquote><blockquote><p>可以通过如下两个命令分别查看全局隔离级别和本次会话的隔离级别：</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/09/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/010.jpg" alt="010"></p><h4 id="八、MVCC"><a href="#八、MVCC" class="headerlink" title="八、MVCC"></a>八、MVCC</h4><blockquote><p>RR 解决脏读、不可重复读、幻读等问题，使用的是 MVCC：MVCC 全称 Multi-Version Concurrency Control，即多版本的并发控制协议。</p></blockquote><blockquote><p>下面的例子很好的体现了 MVCC 的特点：在同一时刻，不同的事务读取到的数据可能是不同的(即多版本)——在 T5 时刻，事务 A 和事务 C 可以读取到不同版本的数据。</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/09/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/011.jpg" alt="011"></p><blockquote><p>MVCC 最大的优点是读不加锁，因此读写不冲突，并发性能好。InnoDB 实现 MVCC，多个版本的数据可以共存，主要是依靠数据的隐藏列(也可以称之为标记位)和 undo log。</p></blockquote><blockquote><p>其中数据的隐藏列包括了该行数据的版本号、删除时间、指向 undo log 的指针等等。</p></blockquote><blockquote><p>当读取数据时，MySQL 可以通过隐藏列判断是否需要回滚并找到回滚需要的 undo log，从而实现 MVCC;隐藏列的详细格式不再展开。</p></blockquote><blockquote><p>下面结合前文提到的几个问题分别说明。</p></blockquote><h5 id="①脏读"><a href="#①脏读" class="headerlink" title="①脏读"></a><strong>①脏读</strong></h5><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/09/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/012.jpg" alt="012"></p><blockquote><p>当事务 A 在 T3 时间节点读取 zhangsan 的余额时，会发现数据已被其他事务修改，且状态为未提交。</p></blockquote><blockquote><p>此时事务 A 读取最新数据后，根据数据的 undo log 执行回滚操作，得到事务 B 修改前的数据，从而避免了脏读。</p></blockquote><h5 id="②不可重复读"><a href="#②不可重复读" class="headerlink" title="②不可重复读"></a>②不可重复读</h5><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/09/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/013.jpg" alt="013"></p><blockquote><p>当事务 A 在 T2 节点第一次读取数据时，会记录该数据的版本号(数据的版本号是以 row 为单位记录的)，假设版本号为 1;当事务 B 提交时，该行记录的版本号增加，假设版本号为 2。</p></blockquote><blockquote><p>当事务 A 在 T5 再一次读取数据时，发现数据的版本号(2)大于第一次读取时记录的版本号(1)，因此会根据 undo log 执行回滚操作，得到版本号为 1 时的数据，从而实现了可重复读。</p></blockquote><h5 id="③幻读"><a href="#③幻读" class="headerlink" title="③幻读"></a>③幻读</h5><blockquote><p>InnoDB 实现的 RR 通过 next-keylock 机制避免了幻读现象。</p></blockquote><blockquote><p>next-keylock 是行锁的一种，实现相当于 record lock(记录锁) + gap lock(间隙锁);其特点是不仅会锁住记录本身(record lock 的功能)，还会锁定一个范围(gap lock 的功能)。</p></blockquote><blockquote><p>当然，这里我们讨论的是不加锁读：此时的 next-key lock 并不是真的加锁，只是为读取的数据增加了标记(标记内容包括数据的版本号等);准确起见姑且称之为类 next-key lock 机制。</p></blockquote><blockquote><p>还是以前面的例子来说明：</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/09/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/014.jpg" alt="014"></p><blockquote><p>当事务 A 在 T2 节点第一次读取 0</p></blockquote><blockquote><p>这样当 T5 时刻再次读取 0</p></blockquote><blockquote><p>小结：概括来说，InnoDB 实现的 RR，通过锁机制、数据的隐藏列、undo log 和类 next-key lock，实现了一定程度的隔离性，可以满足大多数场景的需要。</p></blockquote><blockquote><p>不过需要说明的是，RR 虽然避免了幻读问题，但是毕竟不是 Serializable，不能保证完全的隔离。</p></blockquote><blockquote><p>下面是一个例子，大家可以自己验证一下：</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/06/09/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/015.jpg" alt="015"></p><p><strong>一致性</strong></p><p><strong>基本概念</strong></p><p>一致性是指事务执行结束后，数据库的完整性约束没有被破坏，事务执行的前后都是合法的数据状态。</p><p>数据库的完整性约束包括但不限于：</p><ul><li>实体完整性(如行的主键存在且唯一)</li><li>列完整性(如字段的类型、大小、长度要符合要求)</li><li>外键约束</li><li>用户自定义完整性(如转账前后，两个账户余额的和应该不变)</li></ul><p><strong>实现</strong></p><p>可以说，一致性是事务追求的最终目标：前面提到的原子性、持久性和隔离性，都是为了保证数据库状态的一致性。此外，除了数据库层面的保障，一致性的实现也需要应用层面进行保障。</p><p>实现一致性的措施包括：</p><ul><li>保证原子性、持久性和隔离性，如果这些特性无法保证，事务的一致性也无法保证。</li><li>数据库本身提供保障，例如不允许向整形列插入字符串值、字符串长度不能超过列的限制等。</li><li>应用层面进行保障，例如如果转账操作只扣除转账者的余额，而没有增加接收者的余额，无论数据库实现的多么完美，也无法保证状态的一致。</li></ul><p><strong>总结</strong></p><p>下面总结一下 ACID 特性及其实现原理：</p><ul><li>原子性：语句要么全执行，要么全不执行，是事务最核心的特性。事务本身就是以原子性来定义的;实现主要基于 undo log。</li><li>持久性：保证事务提交后不会因为宕机等原因导致数据丢失;实现主要基于 redo log。</li><li>隔离性：保证事务执行尽可能不受其他事务影响;InnoDB 默认的隔离级别是 RR，RR 的实现主要基于锁机制、数据的隐藏列、undo log 和类 next-key lock 机制。</li><li>一致性：事务追求的最终目标，一致性的实现既需要数据库层面的保障，也需要应用层面的保障。</li></ul><h4 id="九、参考文献："><a href="#九、参考文献：" class="headerlink" title="九、参考文献："></a>九、参考文献：</h4><ul><li>《MySQL 技术内幕：InnoDB 存储引擎》</li><li>《高性能 MySQL》</li><li>《MySQL 运维内参》</li><li><a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_acid" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_acid</a></li><li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-next-key-locking.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.6/en/innodb-next-key-locking.html</a></li><li><a href="http://blog.sina.com.cn/s/blog_499740cb0100ugs7.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_499740cb0100ugs7.html</a></li><li><a href="https://mp.weixin.qq.com/s/2dwGBTmu_da2x-HiHlN0vw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/2dwGBTmu_da2x-HiHlN0vw</a></li><li><a href="http://www.cnblogs.com/chenpingzhao/p/5065316.html" target="_blank" rel="noopener">http://www.cnblogs.com/chenpingzhao/p/5065316.html</a></li><li><a href="https://juejin.im/entry/5ba0a254e51d450e735e4a1f" target="_blank" rel="noopener">https://juejin.im/entry/5ba0a254e51d450e735e4a1f</a></li><li><a href="http://hedengcheng.com/?p=771" target="_blank" rel="noopener">http://hedengcheng.com/?p=771</a></li></ul><p>转发自：<a href="https://www.toutiao.com/i6651767011648995843/" target="_blank" rel="noopener">https://www.toutiao.com/i6651767011648995843/</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot（四）</title>
      <link href="/2019/05/12/springboot-si/"/>
      <url>/2019/05/12/springboot-si/</url>
      
        <content type="html"><![CDATA[<h1 id="Springboot整合Redis做缓存"><a href="#Springboot整合Redis做缓存" class="headerlink" title="Springboot整合Redis做缓存"></a>Springboot整合Redis做缓存</h1><h4 id="一、Redis是什么"><a href="#一、Redis是什么" class="headerlink" title="一、Redis是什么"></a>一、Redis是什么</h4><blockquote><p>Redis是一个key-value<a href="https://baike.baidu.com/item/存储系统" target="_blank" rel="noopener">存储系统</a>。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(<a href="https://baike.baidu.com/item/链表" target="_blank" rel="noopener">链表</a>)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。这些<a href="https://baike.baidu.com/item/数据类型" target="_blank" rel="noopener">数据类型</a>都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。</p><p>Redis 是一个高性能的key-value数据库。 redis的出现，很大程度补偿了<a href="https://baike.baidu.com/item/memcached" target="_blank" rel="noopener">memcached</a>这类key/value存储的不足，在部 分场合可以对关系数据库起到很好的补充作用。它提供了Java，C/C++，C#，PHP，JavaScript，Perl，Object-C，Python，Ruby，Erlang等客户端，使用很方便。 [1] </p><p>Redis支持主从同步。数据可以从主服务器向任意数量的从服务器上同步，从服务器可以是关联其他从服务器的主服务器。这使得Redis可执行单层树复制。存盘可以有意无意的对数据进行写操作。由于完全实现了发布/订阅机制，使得从数据库在任何地方同步树时，可订阅一个频道并接收主服务器完整的消息发布记录。同步对读取操作的可扩展性和数据冗余很有帮助。</p></blockquote><h3 id="二、创建Springboot工程"><a href="#二、创建Springboot工程" class="headerlink" title="二、创建Springboot工程"></a>二、创建Springboot工程</h3><h4 id="2-1、pom依赖"><a href="#2-1、pom依赖" class="headerlink" title="2.1、pom依赖"></a>2.1、pom依赖</h4><blockquote><p>最新版本的Mybatis-plus</p></blockquote><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modelVersion</span><span class="token punctuation">></span></span>4.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modelVersion</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-parent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.1.6.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>relativePath</span><span class="token punctuation">/></span></span> <span class="token comment" spellcheck="true">&lt;!-- lookup parent from repository --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.springboot.redis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>springboot-redis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>0.0.1-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>springboot-redis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>description</span><span class="token punctuation">></span></span>springboot整合redis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>description</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>java.version</span><span class="token punctuation">></span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>java.version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.alibaba<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>druid<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.1.10<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>mysql<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mysql-connector-java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>5.1.47<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.baomidou<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mybatis-plus-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.1.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-data-redis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-cache<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-devtools<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>runtime<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>optional</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>optional</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.projectlombok<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>lombok<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>optional</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>optional</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-maven-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">></span></span></code></pre><h4 id="2-2、application-yml"><a href="#2-2、application-yml" class="headerlink" title="2.2、application.yml"></a>2.2、application.yml</h4><pre class=" language-yml"><code class="language-yml">spring:  profiles:    active: native  application:    name: springboot-Redislogging:  level:    root: info</code></pre><h4 id="Application-native-yml"><a href="#Application-native-yml" class="headerlink" title="Application-native.yml"></a>Application-native.yml</h4><pre class=" language-yml"><code class="language-yml">#tomcat##server:  port: 8090spring:  #数据源配置  datasource:    url: jdbc:mysql://localhost:3306/redis?characterEncoding=UTF-8    username: root    password: root    type: com.alibaba.druid.pool.DruidDataSource    druid:      max-active: 20      initial-size: 5      min-idle: 5      max-wait: 60000      time-between-eviction-runs-millis: 60000      min-evictable-idle-time-millis: 300000      test-while-idle: true      test-on-borrow: false      test-on-return: false    driver-class-name: com.mysql.jdbc.Driver  ## Redis 配置  ## Redis数据库索引（默认为0）  redis:    database: 0    host: 127.0.0.1    ## Redis服务器连接端口    port: 6379    ## Redis服务器连接密码（默认为空）    password:    ## 连接池最大连接数（使用负值表示没有限制）    jedis:      pool:        max-active: 8        ## 连接池最大阻塞等待时间（使用负值表示没有限制）        max-wait: -1        ## 连接池中的最大空闲连接        max-idle: 8        ## 连接池中的最小空闲连接        min-idle: 0        ## 连接超时时间（毫秒）    timeout: 1200# Mybatis配置mybatis-plus:  mapper-locations: classpath*:UserMapper.xmlmybatis/mapper/**/*.xml  #  #实体扫描，多个package用逗号或者分号分隔  typeAliasesPackage: com.springboot.redis.entity  global-config:    #主键类型  0:"数据库ID自增", 1:"用户输入ID",2:"全局唯一ID (数字类型唯一ID)", 3:"全局唯一ID uuid";    id-type: 0    #字段策略 0:"忽略判断",1:"非 NULL 判断"),2:"非空判断"    field-strategy: 2    #驼峰下划线转换    db-column-underline: false    #刷新mapper 调试神器    refresh-mapper: false    #数据库大写下划线转换    capital-mode: false    #序列接口实现类配置    #key-generator: com.baomidou.springboot.xxx  configuration:    map-underscore-to-camel-case: false    cache-enabled: false</code></pre><h4 id="2-3、新建实体-mybatis-plus自动生成"><a href="#2-3、新建实体-mybatis-plus自动生成" class="headerlink" title="2.3、新建实体(mybatis-plus自动生成)"></a>2.3、新建实体(mybatis-plus自动生成)</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>springboot<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>entity<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>baomidou<span class="token punctuation">.</span>mybatisplus<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>IdType<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>baomidou<span class="token punctuation">.</span>mybatisplus<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>TableId<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>math<span class="token punctuation">.</span>BigDecimal<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * &lt;p> *  * &lt;/p> * * @author ZongMan123 * @since 2019-07-23 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 1L<span class="token punctuation">;</span>    <span class="token annotation punctuation">@TableId</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"uid"</span><span class="token punctuation">,</span> type <span class="token operator">=</span> IdType<span class="token punctuation">.</span>AUTO<span class="token punctuation">)</span>    <span class="token keyword">private</span> Integer uid<span class="token punctuation">;</span>    <span class="token keyword">private</span> String username<span class="token punctuation">;</span>    <span class="token keyword">private</span> String password<span class="token punctuation">;</span>    <span class="token keyword">private</span> BigDecimal salary<span class="token punctuation">;</span>    <span class="token keyword">public</span> Integer <span class="token function">getUid</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> uid<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setUid</span><span class="token punctuation">(</span>Integer uid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>uid <span class="token operator">=</span> uid<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getUsername</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> username<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setUsername</span><span class="token punctuation">(</span>String username<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>username <span class="token operator">=</span> username<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getPassword</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> password<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setPassword</span><span class="token punctuation">(</span>String password<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>password <span class="token operator">=</span> password<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> BigDecimal <span class="token function">getSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> salary<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setSalary</span><span class="token punctuation">(</span>BigDecimal salary<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>salary <span class="token operator">=</span> salary<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"User{"</span> <span class="token operator">+</span>        <span class="token string">"uid="</span> <span class="token operator">+</span> uid <span class="token operator">+</span>        <span class="token string">", username="</span> <span class="token operator">+</span> username <span class="token operator">+</span>        <span class="token string">", password="</span> <span class="token operator">+</span> password <span class="token operator">+</span>        <span class="token string">", salary="</span> <span class="token operator">+</span> salary <span class="token operator">+</span>        <span class="token string">"}"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="2-4、Dao"><a href="#2-4、Dao" class="headerlink" title="2.4、Dao"></a>2.4、Dao</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>springboot<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>dao<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>baomidou<span class="token punctuation">.</span>mybatisplus<span class="token punctuation">.</span>core<span class="token punctuation">.</span>mapper<span class="token punctuation">.</span>BaseMapper<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>springboot<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>entity<span class="token punctuation">.</span>User<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>ibatis<span class="token punctuation">.</span>annotations<span class="token punctuation">.</span>Mapper<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * &lt;p> *  Mapper 接口 * &lt;/p> * * @author ZongMan123 * @since 2019-07-23 */</span><span class="token annotation punctuation">@Mapper</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserMapper</span> <span class="token keyword">extends</span> <span class="token class-name">BaseMapper</span><span class="token operator">&lt;</span>User<span class="token operator">></span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><h4 id="2-5、Service"><a href="#2-5、Service" class="headerlink" title="2.5、Service"></a>2.5、Service</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>springboot<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>service<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>baomidou<span class="token punctuation">.</span>mybatisplus<span class="token punctuation">.</span>extension<span class="token punctuation">.</span>service<span class="token punctuation">.</span>IService<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>springboot<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>entity<span class="token punctuation">.</span>User<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>ibatis<span class="token punctuation">.</span>annotations<span class="token punctuation">.</span>Param<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span>Service<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>List<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * &lt;p> *  服务类 * &lt;/p> * * @author ZongMan123 * @since 2019-07-23 */</span><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserService</span> <span class="token keyword">extends</span> <span class="token class-name">IService</span><span class="token operator">&lt;</span>User<span class="token operator">></span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>User<span class="token operator">></span> <span class="token function">queryAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    User <span class="token function">findUserById</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">updateUser</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token string">"user"</span><span class="token punctuation">)</span> User user<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">deleteUserById</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>springboot<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>service<span class="token punctuation">.</span>impl<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>baomidou<span class="token punctuation">.</span>mybatisplus<span class="token punctuation">.</span>extension<span class="token punctuation">.</span>service<span class="token punctuation">.</span>impl<span class="token punctuation">.</span>ServiceImpl<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>springboot<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>dao<span class="token punctuation">.</span>UserMapper<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>springboot<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>entity<span class="token punctuation">.</span>User<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>springboot<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>service<span class="token punctuation">.</span>UserService<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Autowired<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>core<span class="token punctuation">.</span>RedisTemplate<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>core<span class="token punctuation">.</span>ValueOperations<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span>Service<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>List<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeUnit<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * &lt;p> * 服务实现类 * &lt;/p> * * @author ZongMan123 * @since 2019-07-23 */</span><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserServiceImpl</span> <span class="token keyword">extends</span> <span class="token class-name">ServiceImpl</span><span class="token operator">&lt;</span>UserMapper<span class="token punctuation">,</span> User<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">UserService</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> UserMapper userMapper<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> RedisTemplate redisTemplate<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>User<span class="token operator">></span> <span class="token function">queryAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> userMapper<span class="token punctuation">.</span><span class="token function">selectList</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 获取用户策略：先从缓存中获取用户，没有则取数据表中 数据，再将数据写入缓存     * @param id 用户id     * @return     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> User <span class="token function">findUserById</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String key <span class="token operator">=</span> <span class="token string">"user_"</span> <span class="token operator">+</span> id<span class="token punctuation">;</span>        ValueOperations<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> User<span class="token operator">></span> operations <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> hasKey <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">hasKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>hasKey<span class="token punctuation">)</span> <span class="token punctuation">{</span>            User user <span class="token operator">=</span> operations<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"==========从缓存中获得数据========="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">getUsername</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"=============================="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> user<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            User user <span class="token operator">=</span> userMapper<span class="token punctuation">.</span><span class="token function">selectById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"==========从数据表中获得数据========="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">getUsername</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"=============================="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 写入缓存</span>            operations<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> user<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>HOURS<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> user<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 更新用户策略：先更新数据表，成功之后，删除原来的缓存，再更新缓存     * @param user 用户实体     * @return     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">updateUser</span><span class="token punctuation">(</span>User user<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ValueOperations<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> User<span class="token operator">></span> operations <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> userMapper<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            String key <span class="token operator">=</span> <span class="token string">"user_"</span> <span class="token operator">+</span> user<span class="token punctuation">.</span><span class="token function">getUid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">boolean</span> haskey <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">hasKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>haskey<span class="token punctuation">)</span> <span class="token punctuation">{</span>                redisTemplate<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"删除缓存中的key=========>"</span> <span class="token operator">+</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 再将更新后的数据加入缓存</span>            User userNew <span class="token operator">=</span> userMapper<span class="token punctuation">.</span><span class="token function">selectById</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">getUid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>userNew <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                operations<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> userNew<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>HOURS<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">deleteUserById</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> userMapper<span class="token punctuation">.</span><span class="token function">deleteById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>        String key <span class="token operator">=</span> <span class="token string">"user_"</span> <span class="token operator">+</span> id<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">boolean</span> hasKey <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">hasKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>hasKey<span class="token punctuation">)</span> <span class="token punctuation">{</span>                redisTemplate<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"删除了缓存中的key:"</span> <span class="token operator">+</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="2-6、Controller"><a href="#2-6、Controller" class="headerlink" title="2.6、Controller"></a>2.6、Controller</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>springboot<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>controller<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>springboot<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>entity<span class="token punctuation">.</span>User<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>springboot<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>service<span class="token punctuation">.</span>UserService<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Autowired<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span>Controller<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>List<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * &lt;p> * 前端控制器 * &lt;/p> * * @author ZongMan123 * @since 2019-07-23 */</span><span class="token annotation punctuation">@Controller</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/user"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserCacheController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> UserService userService<span class="token punctuation">;</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"queryAll"</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@ResponseBody</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>User<span class="token operator">></span> <span class="token function">queryAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> userService<span class="token punctuation">.</span><span class="token function">queryAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/findUserById/{id}"</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@ResponseBody</span>    <span class="token keyword">public</span> User <span class="token function">findUserById</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span> Integer id<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> userService<span class="token punctuation">.</span><span class="token function">findUserById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="三、项目启动"><a href="#三、项目启动" class="headerlink" title="三、项目启动"></a>三、项目启动</h3><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/05/12/springboot-si/001.png" alt></p><blockquote><p>访问接口：<a href="http://localhost:8090/user/findUserById/2" target="_blank" rel="noopener">http://localhost:8090/user/findUserById/2</a></p><p>控制台输出：</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/05/12/springboot-si/002.png" alt></p><blockquote><p>第一次访问从数据库中取</p><p>再次访问这个接口，从redis中取数据</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/05/12/springboot-si/003.png" alt></p><h3 id="四、源码地址"><a href="#四、源码地址" class="headerlink" title="四、源码地址"></a>四、源码地址</h3><p><a href="https://gitee.com/zongmansheng/springboot-zms.git" target="_blank" rel="noopener">https://gitee.com/zongmansheng/springboot-zms.git</a></p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> springboot2.0 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot（三）</title>
      <link href="/2019/05/11/springboot-san/"/>
      <url>/2019/05/11/springboot-san/</url>
      
        <content type="html"><![CDATA[<h1 id="Springboot整合Kafka"><a href="#Springboot整合Kafka" class="headerlink" title="Springboot整合Kafka"></a>Springboot整合Kafka</h1><h4 id="一、Kafka是什么"><a href="#一、Kafka是什么" class="headerlink" title="一、Kafka是什么"></a>一、Kafka是什么</h4><blockquote><p><strong>Kafka</strong>是由<a href="https://baike.baidu.com/item/Apache软件基金会" target="_blank" rel="noopener">Apache软件基金会</a>开发的一个开源流处理平台，由<a href="https://baike.baidu.com/item/Scala" target="_blank" rel="noopener">Scala</a>和<a href="https://baike.baidu.com/item/Java/85979" target="_blank" rel="noopener">Java</a>编写。Kafka是一种高吞吐量的<a href="https://baike.baidu.com/item/分布式/19276232" target="_blank" rel="noopener">分布式</a>发布订阅消息系统，它可以处理消费者在网站中的所有动作流数据。 这种动作（网页浏览，搜索和其他用户的行动）是在现代网络上的许多社会功能的一个关键因素。 这些数据通常是由于吞吐量的要求而通过处理日志和日志聚合来解决。 对于像<a href="https://baike.baidu.com/item/Hadoop" target="_blank" rel="noopener">Hadoop</a>一样的<a href="https://baike.baidu.com/item/日志/2769135" target="_blank" rel="noopener">日志</a>数据和离线分析系统，但又要求实时处理的限制，这是一个可行的解决方案。Kafka的目的是通过<a href="https://baike.baidu.com/item/Hadoop" target="_blank" rel="noopener">Hadoop</a>的并行加载机制来统一线上和离线的消息处理，也是为了通过<a href="https://baike.baidu.com/item/集群/5486962" target="_blank" rel="noopener">集群</a>来提供实时的消息。</p><p>Kafka是一种高吞吐量的分布式发布订阅消息系统，有如下特性：</p><ul><li>通过O(1)的磁盘数据结构提供消息的持久化，这种结构对于即使数以TB的消息存储也能够保持长时间的稳定性能。</li><li>高吞吐量：即使是非常普通的硬件Kafka也可以支持每秒数百万的消息。</li><li>支持通过Kafka服务器和消费机集群来分区消息。</li><li>支持Hadoop并行数据加载。</li></ul></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/05/11/springboot-san/001.png" alt></p><h4 id="术语介绍"><a href="#术语介绍" class="headerlink" title="术语介绍"></a>术语介绍</h4><blockquote><p>Broker<br>Kafka集群包含一个或多个服务器，这种服务器被称为broker</p><p>Topic<br>每条发布到Kafka集群的消息都有一个类别，这个类别被称为Topic。（物理上不同Topic的消息分开存储，逻辑上一个Topic的消息虽然保存于一个或多个broker上但用户只需指定消息的Topic即可生产或消费数据而不必关心数据存于何处）</p><p>Partition<br>Partition是物理上的概念，每个Topic包含一个或多个Partition.</p><p>Producer<br>负责发布消息到Kafka broker</p><p>Consumer<br>消息消费者，向Kafka broker读取消息的客户端。</p><p>Consumer Group<br>每个Consumer属于一个特定的Consumer Group（可为每个Consumer指定group name，若不指定group name则属于默认的group）。</p></blockquote><h3 id="二、创建Springboot工程"><a href="#二、创建Springboot工程" class="headerlink" title="二、创建Springboot工程"></a>二、创建Springboot工程</h3><h4 id="2-1、pom依赖"><a href="#2-1、pom依赖" class="headerlink" title="2.1、pom依赖"></a>2.1、pom依赖</h4><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modelVersion</span><span class="token punctuation">></span></span>4.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modelVersion</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-parent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.1.6.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>relativePath</span><span class="token punctuation">/></span></span> <span class="token comment" spellcheck="true">&lt;!-- lookup parent from repository --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.springboot.kafka<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>springboot-kafka<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>0.0.1-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>springboot-kafka<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>description</span><span class="token punctuation">></span></span>springboot整合kafka<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>description</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>java.version</span><span class="token punctuation">></span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>java.version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.alibaba<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>fastjson<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.2.58<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.kafka<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-kafka<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.2.6.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-devtools<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>runtime<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>optional</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>optional</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.projectlombok<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>lombok<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>optional</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>optional</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-maven-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">></span></span></code></pre><h4 id="2-2、application-yml"><a href="#2-2、application-yml" class="headerlink" title="2.2、application.yml"></a>2.2、application.yml</h4><pre class=" language-yml"><code class="language-yml">spring:  profiles:    active: native  application:    name: kafka-userlogging:  level:    root: info</code></pre><h4 id="Application-native-yml"><a href="#Application-native-yml" class="headerlink" title="Application-native.yml"></a>Application-native.yml</h4><pre class=" language-yml"><code class="language-yml">server:  port: 8080  #============== kafka ===================  # 指定kafka 代理地址，可以多个spring:  kafka:    bootstrap-servers: localhost:9092  #=============== provider  =======================    producer:      retries: 0  # 每次批量发送消息的数量      batch-size: 16384      buffer-memory: 33554432  # 指定消息key和消息体的编解码方式      key-serializer: org.apache.kafka.common.serialization.StringSerializer      value-serializer: org.apache.kafka.common.serialization.StringSerializer  #=============== consumer  =======================  # 指定默认消费者group id    consumer:      group-id: user-log-group      auto-offset-reset: earliest      enable-auto-commit: true      auto-commit-interval: 100  # 指定消息key和消息体的编解码方式      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer      value-deserializer: org.apache.kafka.common.serialization.StringDeserializer</code></pre><h4 id="2-3、创建一个实体"><a href="#2-3、创建一个实体" class="headerlink" title="2.3、创建一个实体"></a>2.3、创建一个实体</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>springboot<span class="token punctuation">.</span>kafka<span class="token punctuation">.</span>entity<span class="token punctuation">;</span><span class="token keyword">import</span> lombok<span class="token punctuation">.</span>Data<span class="token punctuation">;</span><span class="token keyword">import</span> lombok<span class="token punctuation">.</span>experimental<span class="token punctuation">.</span>Accessors<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019-07-23 * @Time: 08:15 * @Vsersion: 1.0 **/</span><span class="token annotation punctuation">@Data</span><span class="token annotation punctuation">@Accessors</span><span class="token punctuation">(</span>chain <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserLog</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String username<span class="token punctuation">;</span>    <span class="token keyword">private</span> String userId<span class="token punctuation">;</span>    <span class="token keyword">private</span> String state<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="2-4、定义消息的发送者"><a href="#2-4、定义消息的发送者" class="headerlink" title="2.4、定义消息的发送者"></a>2.4、定义消息的发送者</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>springboot<span class="token punctuation">.</span>kafka<span class="token punctuation">.</span>producer<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>alibaba<span class="token punctuation">.</span>fastjson<span class="token punctuation">.</span>JSON<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>springboot<span class="token punctuation">.</span>kafka<span class="token punctuation">.</span>entity<span class="token punctuation">.</span>UserLog<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Autowired<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>kafka<span class="token punctuation">.</span>core<span class="token punctuation">.</span>KafkaTemplate<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span>Component<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019-07-23 * @Time: 08:17 * @Vsersion: 1.0 **/</span><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserLogProducer</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> KafkaTemplate kafkaTemplate<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sendLog</span><span class="token punctuation">(</span>String userId<span class="token punctuation">)</span><span class="token punctuation">{</span>        UserLog userLog <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UserLog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        userLog<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span><span class="token string">"ZongMan"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setUserId</span><span class="token punctuation">(</span>userId<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token string">"0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"发送用户日志数据:"</span><span class="token operator">+</span>userLog<span class="token punctuation">)</span><span class="token punctuation">;</span>        kafkaTemplate<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">"user-log"</span><span class="token punctuation">,</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>userLog<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>消息的发送直接使用KafkaTemplate模板即可,都封装好了,直接使用</p></blockquote><h4 id="2-5、定义消息的消费者"><a href="#2-5、定义消息的消费者" class="headerlink" title="2.5、定义消息的消费者"></a>2.5、定义消息的消费者</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>springboot<span class="token punctuation">.</span>kafka<span class="token punctuation">.</span>consumer<span class="token punctuation">;</span><span class="token keyword">import</span> lombok<span class="token punctuation">.</span>extern<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span>Slf4j<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>kafka<span class="token punctuation">.</span>clients<span class="token punctuation">.</span>consumer<span class="token punctuation">.</span>ConsumerRecord<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>kafka<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>KafkaListener<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span>Component<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Optional<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019-07-23 * @Time: 08:19 * @Vsersion: 1.0 **/</span><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserLogConsumer</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@KafkaListener</span><span class="token punctuation">(</span>topics <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"user-log"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">consumer</span><span class="token punctuation">(</span>ConsumerRecord<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span> <span class="token operator">?</span><span class="token operator">></span> consumerRecord<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//判断是否为null</span>        Optional<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> kafkaMessage <span class="token operator">=</span> Optional<span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span>consumerRecord<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">">>>>>>>>>> record ="</span> <span class="token operator">+</span> kafkaMessage<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>kafkaMessage<span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//得到Optional实例中的值</span>            Object message <span class="token operator">=</span> kafkaMessage<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消费消息:"</span> <span class="token operator">+</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>消费机制是通过监听器实现的,直接使用@KafkaListener(topics={“user-log”})这个注解接口,它可以根据指定的条件进行消息的监听:</p></blockquote><h4 id="2-6、启动应用类"><a href="#2-6、启动应用类" class="headerlink" title="2.6、启动应用类"></a>2.6、启动应用类</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>springboot<span class="token punctuation">.</span>kafka<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>springboot<span class="token punctuation">.</span>kafka<span class="token punctuation">.</span>producer<span class="token punctuation">.</span>UserLogProducer<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Autowired<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>SpringApplication<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>SpringBootApplication<span class="token punctuation">;</span><span class="token keyword">import</span> javax<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>PostConstruct<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author zongman */</span><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringbootKafkaApplication</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> UserLogProducer kafkaSender<span class="token punctuation">;</span>    <span class="token annotation punctuation">@PostConstruct</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//调用消息发送类中的消息发送方法</span>            kafkaSender<span class="token punctuation">.</span><span class="token function">sendLog</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>SpringbootKafkaApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="2-7、控制台输出"><a href="#2-7、控制台输出" class="headerlink" title="2.7、控制台输出"></a>2.7、控制台输出</h4><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/05/11/springboot-san/001.png" alt></p><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/05/11/springboot-san/002.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kafka </tag>
            
            <tag> springboot2.0 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>建造者模式</title>
      <link href="/2019/05/10/jian-zao-zhe-mo-shi/"/>
      <url>/2019/05/10/jian-zao-zhe-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><p>[TOC]</p><h4 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h4><blockquote><p><strong>意图：</strong>将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</p><p><strong>主要解决：</strong>主要解决在软件系统中，有时候面临着”一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。</p><p><strong>何时使用：</strong>一些基本部件不会变，而其组合经常变化的时候。</p><p><strong>如何解决：</strong>将变与不变分离开。</p><p><strong>关键代码：</strong>建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。</p><p><strong>应用实例：</strong> 1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的”套餐”。</p></blockquote><h4 id="二、JAVA-中的-StringBuilder"><a href="#二、JAVA-中的-StringBuilder" class="headerlink" title="二、JAVA 中的 StringBuilder"></a>二、JAVA 中的 StringBuilder</h4><blockquote><p><strong>优点：</strong> 1、建造者独立，易扩展。 2、便于控制细节风险。 </p><p><strong>缺点：</strong> 1、产品必须有共同点，范围有限制。 2、如内部变化复杂，会有很多的建造类。 </p><p><strong>使用场景：</strong> 1、需要生成的对象具有复杂的内部结构。 2、需要生成的对象内部属性本身相互依赖。 </p><p><strong>注意事项：</strong>与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。</p></blockquote><h4 id="三、实现"><a href="#三、实现" class="headerlink" title="三、实现"></a>三、实现</h4><blockquote><p>我们假设一个快餐店的商业案例，其中，一个典型的套餐可以是一个汉堡（Burger）和一杯冷饮（Cold drink）。汉堡（Burger）可以是素食汉堡（Veg Burger）或鸡肉汉堡（Chicken Burger），它们是包在纸盒中。冷饮（Cold drink）可以是可口可乐（coke）或百事可乐（pepsi），它们是装在瓶子中。</p><p>我们将创建一个表示食物条目（比如汉堡和冷饮）的 <em>Item</em> 接口和实现 <em>Item</em> 接口的实体类，以及一个表示食物包装的 <em>Packing</em> 接口和实现 <em>Packing</em> 接口的实体类，汉堡是包在纸盒中，冷饮是装在瓶子中。</p><p>然后我们创建一个 <em>Meal</em> 类，带有 <em>Item</em> 的 <em>ArrayList</em> 和一个通过结合 <em>Item</em> 来创建不同类型的 <em>Meal</em> 对象的 <em>MealBuilder</em>。<em>BuilderPatternDemo</em>，我们的演示类使用 <em>MealBuilder</em> 来创建一个 <em>Meal</em>。</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/05/10/jian-zao-zhe-mo-shi/001.jpg" alt="001"></p><h5 id="步骤1"><a href="#步骤1" class="headerlink" title="步骤1"></a>步骤1</h5><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>desigpattern<span class="token punctuation">.</span>builderpattern<span class="token punctuation">.</span>dao<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author ZongMan * 食物条目接口 */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Item</span> <span class="token punctuation">{</span>    String <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Packing <span class="token function">packing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">float</span> <span class="token function">price</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 食物包装接口 */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Packing</span> <span class="token punctuation">{</span>    String <span class="token function">pack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h5 id="步骤2"><a href="#步骤2" class="headerlink" title="步骤2"></a>步骤2</h5><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @author ZongMan * 创建实现 Packing 接口的实体类。 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Wrapper</span> <span class="token keyword">implements</span> <span class="token class-name">Packing</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">pack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"Wrapper"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Bottle</span> <span class="token keyword">implements</span> <span class="token class-name">Packing</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">pack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"Bottle"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="步骤3"><a href="#步骤3" class="headerlink" title="步骤3"></a>步骤3</h5><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Burger</span> <span class="token keyword">implements</span> <span class="token class-name">Item</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"------->Burger"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Packing <span class="token function">packing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Wrapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">float</span> <span class="token function">price</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ColdDrink</span> <span class="token keyword">implements</span> <span class="token class-name">Item</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"--------->ColdDrink"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Packing <span class="token function">packing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Bottle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">float</span> <span class="token function">price</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="步骤4"><a href="#步骤4" class="headerlink" title="步骤4"></a>步骤4</h5><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @author ZongMan * 创建扩展了 Burger 和 ColdDrink 的实体类。 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VegBurger</span> <span class="token keyword">extends</span> <span class="token class-name">Burger</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"Veg Burger"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">float</span> <span class="token function">price</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">25.0f</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Pepsi</span> <span class="token keyword">extends</span> <span class="token class-name">ColdDrink</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"Pepsi"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">float</span> <span class="token function">price</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">35.0f</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Coke</span> <span class="token keyword">extends</span> <span class="token class-name">ColdDrink</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"Coke"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">float</span> <span class="token function">price</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">30.0f</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ChickenBurger</span> <span class="token keyword">extends</span> <span class="token class-name">Burger</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"Chicken Burger"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">float</span> <span class="token function">price</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">50.5f</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="步骤5"><a href="#步骤5" class="headerlink" title="步骤5"></a>步骤5</h5><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @author ZongMan * 创建一个 Meal 类，带有上面定义的 Item 对象。 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Meal</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> List<span class="token operator">&lt;</span>Item<span class="token operator">></span> items <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addItem</span><span class="token punctuation">(</span>Item item<span class="token punctuation">)</span> <span class="token punctuation">{</span>        items<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">float</span> <span class="token function">getCost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">float</span> cost <span class="token operator">=</span> <span class="token number">0.0f</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Item item <span class="token operator">:</span> items<span class="token punctuation">)</span> <span class="token punctuation">{</span>            cost <span class="token operator">+=</span> item<span class="token punctuation">.</span><span class="token function">price</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> cost<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">showItems</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Item item <span class="token operator">:</span> items<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Item : "</span><span class="token operator">+</span>item<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">", Packing : "</span><span class="token operator">+</span>item<span class="token punctuation">.</span><span class="token function">packing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">pack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">", Price : "</span><span class="token operator">+</span>item<span class="token punctuation">.</span><span class="token function">price</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="步骤6"><a href="#步骤6" class="headerlink" title="步骤6"></a>步骤6</h5><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @author ZongMan * 创建一个 MealBuilder 类，实际的 builder 类负责创建 Meal 对象。 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MealBuilder</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> Meal <span class="token function">prepareVegMeal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Meal meal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Meal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        meal<span class="token punctuation">.</span><span class="token function">addItem</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">VegBurger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        meal<span class="token punctuation">.</span><span class="token function">addItem</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Coke</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> meal<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> Meal <span class="token function">prepareNonVegMeal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Meal meal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Meal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        meal<span class="token punctuation">.</span><span class="token function">addItem</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChickenBurger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        meal<span class="token punctuation">.</span><span class="token function">addItem</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Pepsi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> meal<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="步骤7"><a href="#步骤7" class="headerlink" title="步骤7"></a>步骤7</h5><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @author ZongMan * BuiderPatternDemo 使用 MealBuider 来演示建造者模式（Builder Pattern） */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BuiderPatternDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        MealBuilder mealBuilder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MealBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Meal vegMeal <span class="token operator">=</span> mealBuilder<span class="token punctuation">.</span><span class="token function">prepareVegMeal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Veg Meal"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vegMeal<span class="token punctuation">.</span><span class="token function">showItems</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Total Cost: "</span> <span class="token operator">+</span> vegMeal<span class="token punctuation">.</span><span class="token function">getCost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Meal nonVegMeal <span class="token operator">=</span> mealBuilder<span class="token punctuation">.</span><span class="token function">prepareNonVegMeal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"\n\nNon-Veg Meal"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        nonVegMeal<span class="token punctuation">.</span><span class="token function">showItems</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Total Cost: "</span> <span class="token operator">+</span> nonVegMeal<span class="token punctuation">.</span><span class="token function">getCost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="步骤-8"><a href="#步骤-8" class="headerlink" title="步骤 8"></a>步骤 8</h5><p>​    执行程序，输出结果：</p><pre class=" language-java"><code class="language-java"><span class="token string">"C:\Program Files\Java\jdk1.8.0_181\bin\java.exe"</span> "<span class="token operator">-</span>javaagent<span class="token operator">:</span>I<span class="token operator">:</span>\Program Veg MealItem <span class="token operator">:</span> Veg Burger<span class="token punctuation">,</span> Packing <span class="token operator">:</span> Wrapper<span class="token punctuation">,</span> Price <span class="token operator">:</span> <span class="token number">25.0</span>Item <span class="token operator">:</span> Coke<span class="token punctuation">,</span> Packing <span class="token operator">:</span> Bottle<span class="token punctuation">,</span> Price <span class="token operator">:</span> <span class="token number">30.0</span>Total Cost<span class="token operator">:</span> <span class="token number">55.0</span>Non<span class="token operator">-</span>Veg MealItem <span class="token operator">:</span> Chicken Burger<span class="token punctuation">,</span> Packing <span class="token operator">:</span> Wrapper<span class="token punctuation">,</span> Price <span class="token operator">:</span> <span class="token number">50.5</span>Item <span class="token operator">:</span> Pepsi<span class="token punctuation">,</span> Packing <span class="token operator">:</span> Bottle<span class="token punctuation">,</span> Price <span class="token operator">:</span> <span class="token number">35.0</span>Total Cost<span class="token operator">:</span> <span class="token number">85.5</span>Process finished with exit code <span class="token number">0</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Builder Pattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池底层</title>
      <link href="/2019/05/09/xian-cheng-chi-di-ceng/"/>
      <url>/2019/05/09/xian-cheng-chi-di-ceng/</url>
      
        <content type="html"><![CDATA[<h1 id="线程池底层"><a href="#线程池底层" class="headerlink" title="线程池底层"></a>线程池底层</h1><h4 id="一、ThreadPoolExecutor"><a href="#一、ThreadPoolExecutor" class="headerlink" title="一、ThreadPoolExecutor"></a>一、ThreadPoolExecutor</h4><blockquote><p>在深入源码之前先来看看J.U.C包中的线程池类图：</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/05/09/xian-cheng-chi-di-ceng/001.jpg" alt="001"></p><blockquote><p>它们的最顶层是一个Executor接口，它只有一个方法：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Executor</span> <span class="token punctuation">{</span>     <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span>Runnable command<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>​    它提供了一个运行新任务的简单方法，Java线程池也称之为Executor框架。</p><p>ExecutorService扩展了Executor，添加了操控线程池生命周期的方法，如shutDown()，shutDownNow()等。</p><p>​    此外，它扩展了可异步跟踪执行任务生成返回值Future的方法，如submit()等方法。</p><p>​    ThreadPoolExecutor继承自AbstractExecutorService，同时实现了ExecutorService接口，也是Executor框架默认的线程池实现类，也是这篇文章重点分析的对象</p><p>​    一般我们使用线程池，如没有特殊要求，直接创建ThreadPoolExecutor，初始化一个线程池</p><p>​    如果需要特殊的线程池，则直接继承ThreadPoolExecutor，并实现特定的功能。</p><p>​    比如ScheduledThreadPoolExecutor，它是一个具有定时执行任务的线程池。</p><p>​    接下来，我们就开始ThreadPoolExecutor的源码分析（以下源码为JDK8版本）</p></blockquote><h4 id="二、ctl变量"><a href="#二、ctl变量" class="headerlink" title="二、ctl变量"></a>二、ctl变量</h4><blockquote><p>​    ctl是一个Integer值，它是对线程池运行状态和线程池中有效线程数量进行控制的字段</p><p>Integer值一共有32位，<strong>其中高3位表示”线程池状态”，低29位表示”线程池中的任务数量”</strong></p><p>我们看看Doug Lea大神是如何实现的：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> AtomicInteger ctl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token function">ctlOf</span><span class="token punctuation">(</span>RUNNING<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> COUNT_BITS <span class="token operator">=</span> Integer<span class="token punctuation">.</span>SIZE <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CAPACITY <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// runState is stored in the high-order bits</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> RUNNING <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SHUTDOWN <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> STOP <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TIDYING <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TERMINATED <span class="token operator">=</span> <span class="token number">3</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Packing and unpacking ctl</span><span class="token comment" spellcheck="true">// 通过位运算获取线程池运行状态</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> c <span class="token operator">&amp;</span> <span class="token operator">~</span>CAPACITY<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 通过位运算获取线程池中有效的工作线程数</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> c <span class="token operator">&amp;</span> CAPACITY<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 初始化ctl变量值</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">ctlOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> rs<span class="token punctuation">,</span> <span class="token keyword">int</span> wc<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> rs <span class="token operator">|</span> wc<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><blockquote><p>线程池一共有状态5种状态，分别是：</p><p>1.<strong>Running</strong>：线程池初始化时默认的状态，表示线程正处于运行状态，能够接受新提交的任务，同时也能够处理阻塞队列中的任务；</p><p>2.<strong>SHUTDOWN</strong>：调用shutdown()方法会使线程池进入到该状态，该状态下不再继续接受新提交的任务，但是还会处理阻塞队列中的任务；</p><p>3.<strong>STOP</strong>：调用shutdownNow()方法会使线程池进入到该状态，该状态下不再继续接受新提交的任务，同时不再处理阻塞队列中的任务；</p><p>4.<strong>TIDYING</strong>：如果线程池中workerCount=0，即有效线程数量为0时，会进入该状态；</p><p>5.<strong>TERMINATED</strong>：在terminated()方法执行完后进入该状态，只不过terminated()方法需要我们自行实现。</p></blockquote><blockquote><p>我们再来看看位运算：</p><ul><li><strong>COUNT_BITS</strong>表示ctl变量中表示有效线程数量的位数，这里COUNT_BITS=29；</li><li><strong>CAPACITY</strong>表示最大有效线程数，根据位运算得出；</li><li><strong>COUNT_MASK</strong>=11111111111111111111111111111，折算成十进制大约是5亿，在设计之初就已经想到不会开启超过5亿条线程，所以完全够用了；</li></ul><p>线程池状态的位运算得到以下值：</p><p><strong>RUNNING</strong>：高三位值1112.</p><p><strong>SHUTDOWN</strong>：高三位值0003.</p><p><strong>STOP</strong>：高三位值0014.</p><p><strong>TIDYING：</strong>高三位值0105.</p><p><strong>TERMINATED：</strong>高三位值011</p><p>这里简单解释一下Doug Lea大神为什么使用一个Integer变量表示两个值：很多人会想，一个变量表示两个值，就节省了存储空间。</p><p>但是这里很显然不是为了节省空间而设计的，即使将这两个值拆分成两个Integer值，一个线程池也就多了4个字节而已</p><p>为了这4个字节而去大费周章地设计一通，显然不是Doug Lea大神的初衷。</p><p>在多线程的环境下，运行状态和有效线程数量往往需要保证统一，不能出现一个改而另一个没有改的情况。</p><p>如果将他们放在同一个AtomicInteger中，利用AtomicInteger的原子操作，就可以保证这两个值始终是统一的。</p><p><strong>Worker</strong></p><p>Worker类继承了AQS，并实现了Runnable接口，它有两个重要的成员变量：<strong>firstTask</strong>和<strong>thread</strong></p><p>​    firstTask用于保存第一次新建的任务；thread是在调用构造方法时通过ThreadFactory来创建的线程，是用来处理任务的线程。</p></blockquote><h4 id="三、如何在线程池中添加任务？"><a href="#三、如何在线程池中添加任务？" class="headerlink" title="三、如何在线程池中添加任务？"></a>三、如何在线程池中添加任务？</h4><blockquote><p>​    线程池要执行任务，那么必须先添加任务，execute()虽说是执行任务的意思，但里面也包含了添加任务的步骤在里面。</p><p>来看下面源码：</p><p>java.util.concurrent.ThreadPoolExecutor#execute：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span>Runnable command<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果添加订单任务为空，则空指针异常</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>command <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 获取ctl值</span> <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1.如果当前有效线程数小于核心线程数，调用addWorker执行任务（即创建一条线程执行该任务）</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&lt;</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 2.如果当前有效线程大于等于核心线程数，并且当前线程池状态为运行状态，则将任务添加到阻塞队列中，等待空闲线程取出队列执行</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRunning</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> workQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">int</span> recheck <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> <span class="token function">isRunning</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">remove</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">addWorker</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 3.如果阻塞队列已满，则调用addWorker执行任务（即创建一条线程执行该任务）</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 如果创建线程失败，则调用线程拒绝策略</span> <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="四、execute执行任务的流程图"><a href="#四、execute执行任务的流程图" class="headerlink" title="四、execute执行任务的流程图"></a>四、execute执行任务的流程图</h4><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/05/09/xian-cheng-chi-di-ceng/002.jpg" alt="002"></p><blockquote><p>​    继续往下看，addWorker添加任务，方法源码有点长，我按照逻辑拆分成两部分讲解：</p><p>java.util.concurrent.ThreadPoolExecutor#addWorker：</p></blockquote><pre class=" language-java"><code class="language-java">retry<span class="token operator">:</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 获取线程池当前运行状态</span> <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果rs大于SHUTDOWN，则说明此时线程池不在接受新任务了</span> <span class="token comment" spellcheck="true">// 如果rs等于SHUTDOWN，同时满足firstTask为空，且阻塞队列如果有任务，则继续执行任务</span> <span class="token comment" spellcheck="true">// 也就说明了如果线程池处于SHUTDOWN状态时，可以继续执行阻塞队列中的任务，但不能继续往线程池中添加任务了</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">>=</span> SHUTDOWN <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span> <span class="token punctuation">(</span>rs <span class="token operator">==</span> SHUTDOWN <span class="token operator">&amp;&amp;</span> firstTask <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 获取有效线程数量</span> <span class="token keyword">int</span> wc <span class="token operator">=</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果有效线程数大于等于线程池所容纳的最大线程数（基本不可能发生），不能添加任务</span> <span class="token comment" spellcheck="true">// 或者有效线程数大于等于当前限制的线程数，也不能添加任务</span> <span class="token comment" spellcheck="true">// 限制线程数量有任务是否要核心线程执行决定，core=true使用核心线程执行任务</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>wc <span class="token operator">>=</span> CAPACITY <span class="token operator">||</span> wc <span class="token operator">>=</span> <span class="token punctuation">(</span>core <span class="token operator">?</span> corePoolSize <span class="token operator">:</span> maximumPoolSize<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 使用AQS增加有效线程数量</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndIncrementWorkerCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">break</span> retry<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果再次获取ctl变量值</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Re-read ctl</span> <span class="token comment" spellcheck="true">// 再次对比运行状态，如果不一致，再次循环执行</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">!=</span> rs<span class="token punctuation">)</span> <span class="token keyword">continue</span> retry<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// else CAS failed due to workerCount change; retry inner loop</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p><strong>    这里特别强调：</strong>firstTask是开启线程执行的首个任务，之后常驻在线程池中的线程执行的任务都是从阻塞队列中取出的，需要注意。</p><p>以上for循环代码主要作用是判断 ctl 变量当前的状态是否可以添加任务，特别说明了如果线程池处于SHUTDOWN状态时，可以继续执行阻塞队列中的任务，但不能继续往线程池中添加任务了；</p><p>同时增加工作线程数量使用了AQS作同步，如果同步失败，则继续循环执行。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 任务是否已执行</span><span class="token keyword">boolean</span> workerStarted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 任务是否已添加</span><span class="token keyword">boolean</span> workerAdded <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 任务包装类，我们的任务都需要添加到Worker中</span>Worker w <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 创建一个Worker</span> w <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span>firstTask<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 获取Worker中的Thread值</span> <span class="token keyword">final</span> Thread t <span class="token operator">=</span> w<span class="token punctuation">.</span>thread<span class="token punctuation">;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 操作workers HashSet 数据结构需要同步加锁</span> <span class="token keyword">final</span> ReentrantLock mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span> mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">try</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// Recheck while holding lock.</span> <span class="token comment" spellcheck="true">// Back out on ThreadFactory failure or if</span> <span class="token comment" spellcheck="true">// shut down before lock acquired.</span> <span class="token comment" spellcheck="true">// 获取当前线程池的运行状态</span> <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// rs &lt; SHUTDOWN表示是RUNNING状态；</span> <span class="token comment" spellcheck="true">// 如果rs是RUNNING状态或者rs是SHUTDOWN状态并且firstTask为null，向线程池中添加线程。</span> <span class="token comment" spellcheck="true">// 因为在SHUTDOWN时不会在添加新的任务，但还是会执行workQueue中的任务</span> <span class="token comment" spellcheck="true">// rs是RUNNING状态时，直接创建线程执行任务</span> <span class="token comment" spellcheck="true">// 当rs等于SHUTDOWN时，并且firstTask为空，也可以创建线程执行任务，也说说明了SHUTDOWN状态时不再接受新任务</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">&lt;</span> SHUTDOWN <span class="token operator">||</span> <span class="token punctuation">(</span>rs <span class="token operator">==</span> SHUTDOWN <span class="token operator">&amp;&amp;</span> firstTask <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// precheck that t is startable</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalThreadStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> workers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">int</span> s <span class="token operator">=</span> workers<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">></span> largestPoolSize<span class="token punctuation">)</span> largestPoolSize <span class="token operator">=</span> s<span class="token punctuation">;</span> workerAdded <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span> mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 启动线程执行任务</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>workerAdded<span class="token punctuation">)</span> <span class="token punctuation">{</span> t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> workerStarted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> workerStarted<span class="token punctuation">)</span> <span class="token function">addWorkerFailed</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> workerStarted<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>以上源码主要的作用是创建一个Worker对象，并将新的任务装进Worker中，开启同步将Worker添加进workers中</p><p><strong>这里需要注意workers的数据结构为HashSet，非线程安全，所以操作workers需要加同步锁</strong>。</p><p>添加步骤做完后就启动线程来执行任务了，继续往下看。</p><p>如何执行任务？</p><p>我们注意到上面的代码中：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 启动线程执行任务</span><span class="token keyword">if</span> <span class="token punctuation">(</span>workerAdded<span class="token punctuation">)</span> <span class="token punctuation">{</span> t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> workerStarted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>​    这里的t是w.thread得到的，即是Worker中用于执行任务的线程，该线程由ThreadFactory创建，我们再看看生成Worker的构造方法：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token function">Worker</span><span class="token punctuation">(</span>Runnable firstTask<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token function">setState</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// inhibit interrupts until runWorker</span>     <span class="token keyword">this</span><span class="token punctuation">.</span>firstTask <span class="token operator">=</span> firstTask<span class="token punctuation">;</span>     <span class="token keyword">this</span><span class="token punctuation">.</span>thread <span class="token operator">=</span> <span class="token function">getThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newThread</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p><strong>    newThread传的参数是Worker本身，而Worker实现了Runnable接口</strong></p><p><strong>所以当我们执行t.start()时，执行的是Worker的run()方法</strong>，找到入口了：</p><p>java.util.concurrent.ThreadPoolExecutor.Worker#run：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token function">runWorker</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>java.util.concurrent.ThreadPoolExecutor#runWorker：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">runWorker</span><span class="token punctuation">(</span>Worker w<span class="token punctuation">)</span> <span class="token punctuation">{</span> Thread wt <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> Runnable task <span class="token operator">=</span> w<span class="token punctuation">.</span>firstTask<span class="token punctuation">;</span> w<span class="token punctuation">.</span>firstTask <span class="token operator">=</span> null<span class="token punctuation">;</span> w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// allow interrupts</span> <span class="token keyword">boolean</span> completedAbruptly <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token keyword">try</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 循环从workQueue阻塞队列中获取任务并执行</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>task <span class="token operator">!=</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>task <span class="token operator">=</span> <span class="token function">getTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 加同步锁的目的是为了防止同一个任务出现多个线程执行的问题</span> w<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果线程池正在关闭，须确保中断当前线程</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> STOP<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> STOP<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>wt<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> wt<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">try</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 执行任务前可以做一些操作</span> <span class="token function">beforeExecute</span><span class="token punctuation">(</span>wt<span class="token punctuation">,</span> task<span class="token punctuation">)</span><span class="token punctuation">;</span> Throwable thrown <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token keyword">try</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 执行任务</span> task<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RuntimeException</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span> thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Error</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span> thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span> thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 执行任务后可以做一些操作</span> <span class="token function">afterExecute</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> thrown<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 将task置为空，让线程自行调用getTask()方法从workQueue阻塞队列中获取任务</span> task <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 记录Worker执行了多少次任务</span> w<span class="token punctuation">.</span>completedTasks<span class="token operator">++</span><span class="token punctuation">;</span> w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span> completedAbruptly <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 线程回收过程</span> <span class="token function">processWorkerExit</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> completedAbruptly<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>​    这一步是执行任务的核心方法，首次执行不为空的firstTask任务，之后便一直从workQueue阻塞队列中获取任务并执行</p><p>​    如果你想在任务执行前后做点啥不可告人的小动作，你可以实现ThreadPoolExecutor以下两个方法：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">beforeExecute</span><span class="token punctuation">(</span>Thread t<span class="token punctuation">,</span> Runnable r<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">afterExecute</span><span class="token punctuation">(</span>Runnable r<span class="token punctuation">,</span> Throwable t<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span></code></pre><blockquote><p>这样一来，我们就可以对任务的执行进行实时监控了。</p><p>这里还需要注意，在finally块中，将task置为空，目的是为了让线程自行调用getTask()方法从workQueue阻塞队列中获取任务。</p><p>如何保证核心线程不被销毁？</p><p>我们之前已经知道线程池中可维持corePoolSize数量的常驻核心线程，那么它们是如何保证执行完任务而不被线程池回收的呢？</p><p><strong>在前面的章节中你可能已经会从workQueue队列中阻塞式地获取任务，如果没有获取任务，那么就会一直阻塞下去</strong></p><p>很聪明，你已经知道答案了，现在我们来看Doug Lea大神是如何实现的。</p><p>java.util.concurrent.ThreadPoolExecutor#getTask：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> Runnable <span class="token function">getTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 超时标记，默认为false，如果调用workQueue.poll()方法超时了，会标记为true</span> <span class="token comment" spellcheck="true">// 这个标记非常之重要，下面会说到</span> <span class="token keyword">boolean</span> timedOut <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 获取ctl变量值</span> <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果当前状态大于等于SHUTDOWN，并且workQueue中的任务为空或者状态大于等于STOP</span> <span class="token comment" spellcheck="true">// 则操作AQS减少工作线程数量，并且返回null，线程被回收</span> <span class="token comment" spellcheck="true">// 也说明假设状态为SHUTDOWN的情况下，如果workQueue不为空，那么线程池还是可以继续执行剩下的任务</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">>=</span> SHUTDOWN <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>rs <span class="token operator">>=</span> STOP <span class="token operator">||</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 操作AQS将线程池中的线程数量减一</span> <span class="token function">decrementWorkerCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> null<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 获取线程池中的有效线程数量</span> <span class="token keyword">int</span> wc <span class="token operator">=</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果开发者主动开启allowCoreThreadTimeOut并且获取当前工作线程大于corePoolSize，那么该线程是可以被超时回收的</span> <span class="token comment" spellcheck="true">// allowCoreThreadTimeOut默认为false，即默认不允许核心线程超时回收</span> <span class="token comment" spellcheck="true">// 这里也说明了在核心线程以外的线程都为“临时”线程，随时会被线程池回收</span> <span class="token keyword">boolean</span> timed <span class="token operator">=</span> allowCoreThreadTimeOut <span class="token operator">||</span> wc <span class="token operator">></span> corePoolSize<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 这里说明了两点销毁线程的条件：</span> <span class="token comment" spellcheck="true">// 1.原则上线程池数量不可能大于maximumPoolSize，但可能会出现并发时操作了setMaximumPoolSize方法，如果此时将最大线程数量调少了，很可能会出现当前工作线程大于最大线程的情况，这时就需要线程超时回收，以维持线程池最大线程小于maximumPoolSize，</span> <span class="token comment" spellcheck="true">// 2.timed &amp;&amp; timedOut 如果为true，表示当前操作需要进行超时控制，这里的timedOut为true，说明该线程已经从workQueue.poll()方法超时了</span> <span class="token comment" spellcheck="true">// 以上两点满足其一，都可以触发线程超时回收</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>wc <span class="token operator">></span> maximumPoolSize <span class="token operator">||</span> <span class="token punctuation">(</span>timed <span class="token operator">&amp;&amp;</span> timedOut<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>wc <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">||</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 尝试用AQS将线程池线程数量减一</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndDecrementWorkerCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 减一成功后返回null，线程被回收</span> <span class="token keyword">return</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 否则循环重试</span> <span class="token keyword">continue</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">try</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果timed为true，阻塞超时获取任务，否则阻塞获取任务</span> Runnable r <span class="token operator">=</span> timed <span class="token operator">?</span> workQueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span>keepAliveTime<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>NANOSECONDS<span class="token punctuation">)</span> <span class="token operator">:</span> workQueue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> r<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果poll超时获取任务超时了, 将timeOut设置为true</span> <span class="token comment" spellcheck="true">// 继续循环执行，如果碰巧开发者开启了allowCoreThreadTimeOut，那么该线程就满足超时回收了</span> timedOut <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> retry<span class="token punctuation">)</span> <span class="token punctuation">{</span> timedOut <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>我把我对 getTask() 方法源码的深度解析写在源码对应的地方了，该方法就是实现默认的情况下核心线程不被销毁的核心实现，其实现思路大致是：</p><p><strong>1.将timedOut超时标记默认设置为false；</strong></p><p><strong>2.计算timed的值，该值决定了线程的生死大权</strong></p><p>(timed &amp;&amp; timedOut) 即是线程超时回收的条件之一，需要注意的是第一次(timed &amp;&amp; timedOut) 为false，因为timedOut默认值为false，此时还没到poll超时获取的操作；</p><p><strong>3.根据timed值来决定是用阻塞超时获取任务还是阻塞获取任务</strong></p><p>如果用阻塞超时获取任务，超时后timedOut会被设置为true，接着继续循环，若 (timed &amp;&amp; timedOut) 为true，满足线程超时回收。</p></blockquote><blockquote><p>转自：<a href="https://www.toutiao.com/a6686773038484029955/" target="_blank" rel="noopener">https://www.toutiao.com/a6686773038484029955/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ThreadPool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot（二）</title>
      <link href="/2019/05/08/springboot-er/"/>
      <url>/2019/05/08/springboot-er/</url>
      
        <content type="html"><![CDATA[<h1 id="Springboot整合JPA"><a href="#Springboot整合JPA" class="headerlink" title="Springboot整合JPA"></a>Springboot整合JPA</h1><h3 id="一、JPA是什么"><a href="#一、JPA是什么" class="headerlink" title="一、JPA是什么"></a>一、JPA是什么</h3><blockquote><p>JPA(java persistence api)，它并不是一个框架，而是一组规范。我觉得对于任何一个开发人员来说，理解“规范”这个词应该不在话下。其中，Hibernate就实现了这个规范，而且呢是相当成功的（其实TopLink和OpenJPA也都实现了JPA规范，不过它们被Hinernate的光环笼罩了）。所以呢，当我们说到JPA的时候，好多人首先想到的就是Hibernate。</p></blockquote><h3 id="二、创建Springboot工程"><a href="#二、创建Springboot工程" class="headerlink" title="二、创建Springboot工程"></a>二、创建Springboot工程</h3><h4 id="2-1、pom依赖"><a href="#2-1、pom依赖" class="headerlink" title="2.1、pom依赖"></a>2.1、pom依赖</h4><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modelVersion</span><span class="token punctuation">></span></span>4.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modelVersion</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-parent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.1.6.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>relativePath</span><span class="token punctuation">/></span></span> <span class="token comment" spellcheck="true">&lt;!-- lookup parent from repository --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.springboot.jpa<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>springboot-jpa<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>0.0.1-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>springboot-jpa<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>description</span><span class="token punctuation">></span></span>Demo project for Spring Boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>description</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>java.version</span><span class="token punctuation">></span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>java.version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-data-jpa<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-devtools<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>runtime<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>optional</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>optional</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>mysql<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mysql-connector-java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>5.1.47<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>runtime<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.projectlombok<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>lombok<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>optional</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>optional</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-maven-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">></span></span></code></pre><h4 id="2-2、application-yml"><a href="#2-2、application-yml" class="headerlink" title="2.2、application.yml"></a>2.2、application.yml</h4><pre class=" language-yml"><code class="language-yml">spring:  devtools:    restart:      enabled: false  datasource:    driver-class-name: com.mysql.jdbc.Driver    url: jdbc:mysql://localhost:3306/db1    hikari: # springboot 2.0 整合了hikari ,据说这是目前性能最好的java数据库连接池      username: root      password: root  jpa:    hibernate:      ddl-auto: update  # 第一次建表create  后面用update，要不然每次重启都会新建表    show-sql: true</code></pre><h4 id="2-3、创建一个实体"><a href="#2-3、创建一个实体" class="headerlink" title="2.3、创建一个实体"></a>2.3、创建一个实体</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>springboot<span class="token punctuation">.</span>jpa<span class="token punctuation">.</span>entity<span class="token punctuation">;</span><span class="token keyword">import</span> lombok<span class="token punctuation">.</span>Data<span class="token punctuation">;</span><span class="token keyword">import</span> javax<span class="token punctuation">.</span>persistence<span class="token punctuation">.</span>Entity<span class="token punctuation">;</span><span class="token keyword">import</span> javax<span class="token punctuation">.</span>persistence<span class="token punctuation">.</span>GeneratedValue<span class="token punctuation">;</span><span class="token keyword">import</span> javax<span class="token punctuation">.</span>persistence<span class="token punctuation">.</span>Id<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019-07-22 * @Time: 08:00 * @Vsersion: 1.0 **/</span><span class="token annotation punctuation">@Data</span><span class="token annotation punctuation">@Entity</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Id</span>    <span class="token annotation punctuation">@GeneratedValue</span>    <span class="token keyword">private</span> Long id<span class="token punctuation">;</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="2-4、创建DAO"><a href="#2-4、创建DAO" class="headerlink" title="2.4、创建DAO"></a>2.4、创建DAO</h4><pre class=" language-JAVA"><code class="language-JAVA">package com.springboot.jpa.dao;import com.springboot.jpa.entity.User;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.stereotype.Component;/** * @Author: ZongMan * @Date: 2019-07-22 * @Time: 08:02 * @Vsersion: 1.0 * 我们在这里直接继承 JpaRepository * 这里面已经有很多现场的方法了 * 这也是JPA的一大优点 **/@Componentpublic interface UserDAO extends JpaRepository<User,Long> {}</code></pre><h4 id="JpaRepository里面有许多封装好的方法"><a href="#JpaRepository里面有许多封装好的方法" class="headerlink" title="JpaRepository里面有许多封装好的方法"></a>JpaRepository里面有许多封装好的方法</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>jpa<span class="token punctuation">.</span>repository<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>List<span class="token punctuation">;</span><span class="token keyword">import</span> javax<span class="token punctuation">.</span>persistence<span class="token punctuation">.</span>EntityManager<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>domain<span class="token punctuation">.</span>Example<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>domain<span class="token punctuation">.</span>Sort<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>repository<span class="token punctuation">.</span>NoRepositoryBean<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>repository<span class="token punctuation">.</span>PagingAndSortingRepository<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>repository<span class="token punctuation">.</span>query<span class="token punctuation">.</span>QueryByExampleExecutor<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * JPA specific extension of {@link org.springframework.data.repository.Repository}. * * @author Oliver Gierke * @author Christoph Strobl * @author Mark Paluch */</span><span class="token annotation punctuation">@NoRepositoryBean</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">JpaRepository</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span> ID<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">PagingAndSortingRepository</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span> ID<span class="token operator">></span><span class="token punctuation">,</span> QueryByExampleExecutor<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">findAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">findAll</span><span class="token punctuation">(</span>Sort sort<span class="token punctuation">)</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">findAllById</span><span class="token punctuation">(</span>Iterable<span class="token operator">&lt;</span>ID<span class="token operator">></span> ids<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&lt;</span>S <span class="token keyword">extends</span> <span class="token class-name">T</span><span class="token operator">></span> List<span class="token operator">&lt;</span>S<span class="token operator">></span> <span class="token function">saveAll</span><span class="token punctuation">(</span>Iterable<span class="token operator">&lt;</span>S<span class="token operator">></span> entities<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&lt;</span>S <span class="token keyword">extends</span> <span class="token class-name">T</span><span class="token operator">></span> S <span class="token function">saveAndFlush</span><span class="token punctuation">(</span>S entity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">deleteInBatch</span><span class="token punctuation">(</span>Iterable<span class="token operator">&lt;</span>T<span class="token operator">></span> entities<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">deleteAllInBatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    T <span class="token function">getOne</span><span class="token punctuation">(</span>ID id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token operator">&lt;</span>S <span class="token keyword">extends</span> <span class="token class-name">T</span><span class="token operator">></span> List<span class="token operator">&lt;</span>S<span class="token operator">></span> <span class="token function">findAll</span><span class="token punctuation">(</span>Example<span class="token operator">&lt;</span>S<span class="token operator">></span> example<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token operator">&lt;</span>S <span class="token keyword">extends</span> <span class="token class-name">T</span><span class="token operator">></span> List<span class="token operator">&lt;</span>S<span class="token operator">></span> <span class="token function">findAll</span><span class="token punctuation">(</span>Example<span class="token operator">&lt;</span>S<span class="token operator">></span> example<span class="token punctuation">,</span> Sort sort<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="2-5、创建service"><a href="#2-5、创建service" class="headerlink" title="2.5、创建service"></a>2.5、创建service</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>springboot<span class="token punctuation">.</span>jpa<span class="token punctuation">.</span>service<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>springboot<span class="token punctuation">.</span>jpa<span class="token punctuation">.</span>entity<span class="token punctuation">.</span>User<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>List<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019-07-22 * @Time: 08:04 * @Vsersion: 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserService</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 查询所有     * @return     */</span>    List<span class="token operator">&lt;</span>User<span class="token operator">></span> <span class="token function">findAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>springboot<span class="token punctuation">.</span>jpa<span class="token punctuation">.</span>service<span class="token punctuation">.</span>impl<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>springboot<span class="token punctuation">.</span>jpa<span class="token punctuation">.</span>dao<span class="token punctuation">.</span>UserDAO<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>springboot<span class="token punctuation">.</span>jpa<span class="token punctuation">.</span>entity<span class="token punctuation">.</span>User<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>springboot<span class="token punctuation">.</span>jpa<span class="token punctuation">.</span>service<span class="token punctuation">.</span>UserService<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Autowired<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span>Service<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>List<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019-07-22 * @Time: 08:06 * @Vsersion: 1.0 **/</span><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">UserService</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> UserDAO userDAO<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>User<span class="token operator">></span> <span class="token function">findAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> userDAO<span class="token punctuation">.</span><span class="token function">findAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="2-6、创建controller"><a href="#2-6、创建controller" class="headerlink" title="2.6、创建controller"></a>2.6、创建controller</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>springboot<span class="token punctuation">.</span>jpa<span class="token punctuation">.</span>controller<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>springboot<span class="token punctuation">.</span>jpa<span class="token punctuation">.</span>entity<span class="token punctuation">.</span>User<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>springboot<span class="token punctuation">.</span>jpa<span class="token punctuation">.</span>service<span class="token punctuation">.</span>UserService<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Autowired<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>GetMapping<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>RestController<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>List<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019-07-22 * @Time: 08:08 * @Vsersion: 1.0 **/</span><span class="token annotation punctuation">@RestController</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> UserService userService<span class="token punctuation">;</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/list"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>User<span class="token operator">></span> <span class="token function">findAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> userService<span class="token punctuation">.</span><span class="token function">findAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="三、启动项目"><a href="#三、启动项目" class="headerlink" title="三、启动项目"></a>三、启动项目</h3><blockquote><p>控制输出</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/05/08/springboot-er/001.png" alt></p><blockquote><p>数据表会自动创建，此时我们查看数据库</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/05/08/springboot-er/002.png" alt></p><blockquote><p>添加两条数据，访问 <a href="http://localhost:8080/list" target="_blank" rel="noopener">http://localhost:8080/list</a></p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/05/08/springboot-er/003.png" alt></p><h3 id="四、源码地址"><a href="#四、源码地址" class="headerlink" title="四、源码地址"></a>四、源码地址</h3><p><a href="https://gitee.com/zongmansheng/springboot-zms.git" target="_blank" rel="noopener">https://gitee.com/zongmansheng/springboot-zms.git</a></p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Springboot2.0 </tag>
            
            <tag> JPA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot（一）</title>
      <link href="/2019/05/07/springboot-yi/"/>
      <url>/2019/05/07/springboot-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot2-0-整合-JWT-框架，解决Token跨域验证问题"><a href="#SpringBoot2-0-整合-JWT-框架，解决Token跨域验证问题" class="headerlink" title="SpringBoot2.0 整合 JWT 框架，解决Token跨域验证问题"></a>SpringBoot2.0 整合 JWT 框架，解决Token跨域验证问题</h1><p>[TOC]</p><h2 id="一、传统Session认证"><a href="#一、传统Session认证" class="headerlink" title="一、传统Session认证"></a>一、传统Session认证</h2><h3 id="1、认证过程"><a href="#1、认证过程" class="headerlink" title="1、认证过程"></a>1、认证过程</h3><blockquote><p>1、用户向服务器发送用户名和密码。</p><p>2、服务器验证后在当前对话（session）保存相关数据。</p><p>3、服务器向返回sessionId，写入客户端 Cookie。</p><p>4、客户端每次请求，需要通过 Cookie，将 sessionId 回传服务器。</p><p>5、服务器收到 sessionId，验证客户端。</p></blockquote><h3 id="2、存在问题"><a href="#2、存在问题" class="headerlink" title="2、存在问题"></a>2、存在问题</h3><blockquote><p>1、session保存在服务端，客户端访问高并发时，服务端压力大。</p><p>2、扩展性差，服务器集群，就需要 session 数据共享。</p></blockquote><h2 id="二、JWT简介"><a href="#二、JWT简介" class="headerlink" title="二、JWT简介"></a>二、JWT简介</h2><blockquote><p>JWT(全称：JSON Web Token)，在基于HTTP通信过程中，进行身份认证。</p><p>Json web token (JWT)，是为了在网络应用环境间传递声明而执行的一种基于<code>JSON</code>的开放标准（(RFC 7519)。定义了一种简洁的，自包含的方法用于通信双方之间以JSON对象的形式安全的传递信息。因为数字签名的存在，这些信息是可信的，JWT可以使用HMAC算法或者是RSA的公私秘钥对进行签名。</p></blockquote><h3 id="1、认证流程"><a href="#1、认证流程" class="headerlink" title="1、认证流程"></a>1、认证流程</h3><blockquote><p>1、客户端通过用户名和密码登录服务器;</p><p>2、服务端对客户端身份进行验证；</p><p>3、服务器认证以后，生成一个 JSON 对象，发回客户端；</p><p>4、客户端与服务端通信的时候，都要发回这个 JSON 对象；</p><p>5、服务端解析该JSON对象，获取用户身份；</p><p>6、服务端可以不必存储该JSON（Token）对象，身份信息都可以解析出来。</p></blockquote><h3 id="2、JWT结构说明"><a href="#2、JWT结构说明" class="headerlink" title="2、JWT结构说明"></a>2、JWT结构说明</h3><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"msg"</span><span class="token operator">:</span> <span class="token string">"验证成功"</span><span class="token punctuation">,</span>    <span class="token property">"code"</span><span class="token operator">:</span> <span class="token number">200</span><span class="token punctuation">,</span>    <span class="token property">"token"</span><span class="token operator">:</span> <span class="token string">"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzUxMiJ9. eyJzdWIiOiJhZG1pbiCI6iZEIj3fQ. uEJSJagJf1j7A55Wwr1bGsB5YQoAyz5rbFtF"</span><span class="token punctuation">}</span></code></pre><blockquote><p>上面的Token被手动格式化了，实际上是用”.”分隔的一个完整的长字符串。</p></blockquote><h3 id="JWT结构"><a href="#JWT结构" class="headerlink" title="JWT结构"></a>JWT结构</h3><blockquote><h4 id="1、头部（header-声明类型以及加密算法；"><a href="#1、头部（header-声明类型以及加密算法；" class="headerlink" title="1、头部（header) 声明类型以及加密算法；"></a>1、头部（header) 声明类型以及加密算法；</h4><h5 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h5><p><strong>JWT的头部承载两部分信息：token类型和采用的加密算法。</strong></p><pre><code>{  &quot;alg&quot;: &quot;HS256&quot;,  &quot;typ&quot;: &quot;JWT&quot;} </code></pre><p><strong>声明类型:这里是jwt声明加密的算法:通常直接使用 HMAC SHA256</strong></p><p><strong>加密算法是单向函数散列算法，常见的有MD5、SHA、HAMC。</strong><br><strong>MD5(message-digest algorithm 5)</strong> （信息-摘要算法）缩写，广泛用于加密和解密技术，常用于文件校验。校验？不管文件多大，经过MD5后都能生成唯一的MD5值<br><strong>SHA (Secure Hash Algorithm，安全散列算法）</strong>，数字签名等密码学应用中重要的工具，安全性高于MD5<br><strong>HMAC (Hash Message Authentication Code)</strong>，散列消息鉴别码，基于密钥的Hash算法的认证协议。用公开函数和密钥产生一个固定长度的值作为认证标识，用这个标识鉴别消息的完整性。常用于接口签名验证</p><h4 id="2、负载（payload-携带一些用户身份信息；"><a href="#2、负载（payload-携带一些用户身份信息；" class="headerlink" title="2、负载（payload) 携带一些用户身份信息；"></a>2、负载（payload) 携带一些用户身份信息；</h4><p>载荷就是存放有效信息的地方。<br><strong>有效信息包含三个部分1.标准中注册的声明2.公共的声明3.私有的声明</strong></p><h5 id="标准中注册的声明-建议但不强制使用-："><a href="#标准中注册的声明-建议但不强制使用-：" class="headerlink" title="标准中注册的声明 (建议但不强制使用) ："></a>标准中注册的声明 (建议但不强制使用) ：</h5><p>iss: jwt签发者sub: 面向的用户(jwt所面向的用户)aud: 接收jwt的一方exp: 过期时间戳(jwt的过期时间，这个过期时间必须要大于签发时间)nbf: 定义在什么时间之前，该jwt都是不可用的.iat: jwt的签发时间jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。</p><h5 id="公共的声明-："><a href="#公共的声明-：" class="headerlink" title="公共的声明 ："></a>公共的声明 ：</h5><p>公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密.</p><h5 id="私有的声明-："><a href="#私有的声明-：" class="headerlink" title="私有的声明 ："></a>私有的声明 ：</h5><p>私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。</p><h4 id="3、签名（signature-签名信息。"><a href="#3、签名（signature-签名信息。" class="headerlink" title="3、签名（signature) 签名信息。"></a>3、签名（signature) 签名信息。</h4><p>jwt的第三部分是一个签证信息，这个签证信息由三部分组成：header (base64后的)payload (base64后的)secret<br>这个部分需要base64加密后的header和base64加密后的payload使用.连接组成的字符串，然后通过header中声明的加密方式进行加盐secret组合加密，然后就构成了jwt的第三部分。<br>密钥secret是保存在服务端的，服务端会根据这个密钥进行生成token和进行验证，所以需要保护好。</p></blockquote><h3 id="JWT请求流程"><a href="#JWT请求流程" class="headerlink" title="JWT请求流程"></a>JWT请求流程</h3><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/05/07/springboot-yi/001.png" alt></p><blockquote><ol><li>用户使用账号和面发出post请求；</li><li>服务器使用私钥创建一个jwt；</li><li>服务器返回这个jwt给浏览器；</li><li>浏览器将该jwt串在请求头中像服务器发送请求；</li><li>服务器验证该jwt；</li><li>返回响应的资源给浏览器。</li></ol></blockquote><h3 id="3、JWT使用方式"><a href="#3、JWT使用方式" class="headerlink" title="3、JWT使用方式"></a>3、JWT使用方式</h3><blockquote><p>通常推荐的做法是客户端在 HTTP 请求的头信息Authorization字段里面。</p></blockquote><pre class=" language-xml"><code class="language-xml">Authorization: Bearer <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>token</span><span class="token punctuation">></span></span></code></pre><blockquote><p>服务端获取JWT方式</p></blockquote><pre class=" language-java"><code class="language-java">String token <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getHeader</span><span class="token punctuation">(</span><span class="token string">"token"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="4、JWT的主要应用场景"><a href="#4、JWT的主要应用场景" class="headerlink" title="4、JWT的主要应用场景"></a>4、JWT的主要应用场景</h3><blockquote><p>身份认证在这种场景下，一旦用户完成了登陆，在接下来的每个请求中包含JWT，可以用来验证用户身份以及对路由，服务和资源的访问权限进行验证。由于它的开销非常小，可以轻松的在不同域名的系统中传递，所有目前在<strong>单点登录（SSO）</strong>中比较广泛的使用了该技术。 信息交换在通信的双方之间使用JWT对数据进行编码是一种非常安全的方式，由于它的信息是经过签名的，可以确保发送者发送的信息是没有经过伪造的。</p></blockquote><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><blockquote><p>1.简洁(Compact): 可以通过URL，POST参数或者在HTTP header发送，因为数据量小，传输速度也很快</p><p>2.自包含(Self-contained)：负载中包含了所有用户所需要的信息，避免了多次查询数据库</p><p>3.因为Token是以JSON加密的形式保存在客户端的，所以JWT是跨语言的，原则上任何web形式都支持。</p><p>4.不需要在服务端保存会话信息，特别适用于分布式微服务。</p></blockquote><h3 id="三、与SpringBoot2整合"><a href="#三、与SpringBoot2整合" class="headerlink" title="三、与SpringBoot2整合"></a>三、与SpringBoot2整合</h3><h4 id="1、pom依赖文件"><a href="#1、pom依赖文件" class="headerlink" title="1、pom依赖文件"></a>1、pom依赖文件</h4><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modelVersion</span><span class="token punctuation">></span></span>4.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modelVersion</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-parent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.1.6.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>relativePath</span><span class="token punctuation">/></span></span> <span class="token comment" spellcheck="true">&lt;!-- lookup parent from repository --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.springboot.jwt<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>springboot-jwt<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>0.0.1-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>springboot-jwt<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>description</span><span class="token punctuation">></span></span>SpringBoot整合JWT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>description</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>java.version</span><span class="token punctuation">></span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>java.version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.mybatis.spring.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mybatis-spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.0.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-devtools<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>runtime<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>optional</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>optional</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.projectlombok<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>lombok<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>optional</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>optional</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>io.jsonwebtoken<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>jjwt<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>0.9.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.auth0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>java-jwt<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.4.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.alibaba<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>fastjson<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.2.58<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-maven-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">></span></span></code></pre><h4 id="2、配置文件"><a href="#2、配置文件" class="headerlink" title="2、配置文件"></a>2、配置文件</h4><h5 id="Application-yml"><a href="#Application-yml" class="headerlink" title="Application.yml"></a>Application.yml</h5><pre class=" language-yml"><code class="language-yml">spring:  profiles:    active: native  application:    name: ZMS-JWT-TOKEN</code></pre><h5 id="Application-native-yml"><a href="#Application-native-yml" class="headerlink" title="Application-native.yml"></a>Application-native.yml</h5><pre class=" language-java"><code class="language-java">server<span class="token operator">:</span>  port<span class="token operator">:</span> <span class="token number">8888</span>spring<span class="token operator">:</span>  datasource<span class="token operator">:</span>    driver<span class="token operator">-</span><span class="token keyword">class</span><span class="token operator">-</span>name<span class="token operator">:</span> com<span class="token punctuation">.</span>mysql<span class="token punctuation">.</span>jdbc<span class="token punctuation">.</span>Driver    url<span class="token operator">:</span> jdbc<span class="token operator">:</span>mysql<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>localhost<span class="token operator">:</span><span class="token number">3306</span><span class="token operator">/</span>springboot<span class="token operator">-</span>zms<span class="token operator">?</span>useSSL<span class="token operator">=</span><span class="token boolean">false</span>    username<span class="token operator">:</span> root    password<span class="token operator">:</span> root    type<span class="token operator">:</span> com<span class="token punctuation">.</span>alibaba<span class="token punctuation">.</span>druid<span class="token punctuation">.</span>pool<span class="token punctuation">.</span>DruidDataSourcemybatis<span class="token operator">:</span>  config<span class="token operator">-</span>location<span class="token operator">:</span>    classpath<span class="token operator">*</span><span class="token operator">:</span> mybatis<span class="token punctuation">.</span>xml#  mapper<span class="token operator">-</span>locations<span class="token operator">:</span>#    classpath<span class="token operator">*</span><span class="token operator">:</span> com<span class="token operator">/</span>springboot<span class="token operator">/</span>jwt<span class="token operator">/</span>mapper<span class="token operator">/</span><span class="token operator">*</span><span class="token punctuation">.</span>xml#  type<span class="token operator">-</span>aliases<span class="token operator">-</span><span class="token keyword">package</span><span class="token operator">:</span> com<span class="token punctuation">.</span>springboot<span class="token punctuation">.</span>jwt<span class="token punctuation">.</span>entitydebug<span class="token operator">:</span> <span class="token boolean">true</span></code></pre><h4 id="3、编写程序"><a href="#3、编写程序" class="headerlink" title="3、编写程序"></a>3、编写程序</h4><h5 id="需要自定义两个注解"><a href="#需要自定义两个注解" class="headerlink" title="需要自定义两个注解"></a>需要自定义两个注解</h5><p><strong>用来跳过验证的PassToken</strong></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span>ElementType<span class="token punctuation">.</span>METHOD<span class="token punctuation">,</span> ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">PassToken</span> <span class="token punctuation">{</span>    <span class="token keyword">boolean</span> <span class="token function">required</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>需要登录才能进行操作的注解UserLoginToken</strong></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span>ElementType<span class="token punctuation">.</span>METHOD<span class="token punctuation">,</span> ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">UserLoginToken</span> <span class="token punctuation">{</span>    <span class="token keyword">boolean</span> <span class="token function">required</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><h5 id="Target-注解的作用目标"><a href="#Target-注解的作用目标" class="headerlink" title="@Target:注解的作用目标"></a><code>@Target</code>:注解的作用目标</h5><p>@Target(ElementType.TYPE)——接口、类、枚举、注解</p><p>@Target(ElementType.FIELD)——字段、枚举的常量</p><p>@Target(ElementType.METHOD)——方法</p><p>@Target(ElementType.PARAMETER)——方法参数</p><p>@Target(ElementType.CONSTRUCTOR) ——构造函数</p><p>@Target(ElementType.LOCAL_VARIABLE)——局部变量</p><p>@Target(ElementType.ANNOTATION_TYPE)——注解</p><p>@Target(ElementType.PACKAGE)——包</p><h5 id="Retention：注解的保留位置"><a href="#Retention：注解的保留位置" class="headerlink" title="@Retention：注解的保留位置"></a><code>@Retention</code>：注解的保留位置</h5><p>RetentionPolicy.SOURCE:这种类型的Annotations只在源代码级别保留,编译时就会被忽略,在class字节码文件中不包含。RetentionPolicy.CLASS:这种类型的Annotations编译时被保留,默认的保留策略,在class文件中存在,但JVM将会忽略,运行时无法获得。RetentionPolicy.RUNTIME:这种类型的Annotations将被JVM保留,所以他们能在运行时被JVM或其他使用反射机制的代码所读取和使用。<br>@Document：说明该注解将被包含在javadoc中@Inherited：说明子类可以继承父类中的该注解</p></blockquote><h5 id="简单自定义一个实体类User-使用lombok简化实体类的编写"><a href="#简单自定义一个实体类User-使用lombok简化实体类的编写" class="headerlink" title="简单自定义一个实体类User,使用lombok简化实体类的编写"></a>简单自定义一个实体类User,使用lombok简化实体类的编写</h5><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token annotation punctuation">@AllArgsConstructor</span><span class="token annotation punctuation">@NoArgsConstructor</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    String Id<span class="token punctuation">;</span>    String username<span class="token punctuation">;</span>    String password<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h5 id="需要写token的生成方法"><a href="#需要写token的生成方法" class="headerlink" title="需要写token的生成方法"></a>需要写token的生成方法</h5><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TokenService</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String <span class="token function">getToken</span><span class="token punctuation">(</span>User user<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String token<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 将user id保存到token里面</span>        token<span class="token operator">=</span> JWT<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">withAudience</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">//以 password 作为token的密钥</span>                <span class="token punctuation">.</span><span class="token function">sign</span><span class="token punctuation">(</span>Algorithm<span class="token punctuation">.</span><span class="token function">HMAC256</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">getPassword</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> token<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>Algorithm.HMAC256():使用HS256生成token,密钥则是用户的密码，唯一密钥的话可以保存在服务端。withAudience()存入需要保存在token的信息，这里我把用户ID存入token中</p></blockquote><h5 id="拦截器去获取token并验证token"><a href="#拦截器去获取token并验证token" class="headerlink" title="拦截器去获取token并验证token"></a>拦截器去获取<code>token</code>并验证<code>token</code></h5><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AuthenticationInterceptor</span> <span class="token keyword">implements</span> <span class="token class-name">HandlerInterceptor</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    UserService userService<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">preHandle</span><span class="token punctuation">(</span>HttpServletRequest httpServletRequest<span class="token punctuation">,</span> HttpServletResponse httpServletResponse<span class="token punctuation">,</span> Object object<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 从http请求头中取出 token</span>        String token <span class="token operator">=</span> httpServletRequest<span class="token punctuation">.</span><span class="token function">getHeader</span><span class="token punctuation">(</span><span class="token string">"token"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果不是映射到方法直接通过</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>object <span class="token keyword">instanceof</span> <span class="token class-name">HandlerMethod</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        HandlerMethod handlerMethod<span class="token operator">=</span><span class="token punctuation">(</span>HandlerMethod<span class="token punctuation">)</span>object<span class="token punctuation">;</span>        Method method<span class="token operator">=</span>handlerMethod<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//检查是否有passtoken注释，有则跳过认证</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">isAnnotationPresent</span><span class="token punctuation">(</span>PassToken<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            PassToken passToken <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">getAnnotation</span><span class="token punctuation">(</span>PassToken<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>passToken<span class="token punctuation">.</span><span class="token function">required</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//检查有没有需要用户权限的注解</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">isAnnotationPresent</span><span class="token punctuation">(</span>UserLoginToken<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            UserLoginToken userLoginToken <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">getAnnotation</span><span class="token punctuation">(</span>UserLoginToken<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>userLoginToken<span class="token punctuation">.</span><span class="token function">required</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 执行认证</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>token <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"无token，请重新登录"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// 获取 token 中的 user id</span>                String userId<span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    userId <span class="token operator">=</span> JWT<span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getAudience</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">JWTDecodeException</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"401"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                User user <span class="token operator">=</span> userService<span class="token punctuation">.</span><span class="token function">findUserById</span><span class="token punctuation">(</span>userId<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>user <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"用户不存在，请重新登录"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// 验证 token</span>                JWTVerifier jwtVerifier <span class="token operator">=</span> JWT<span class="token punctuation">.</span><span class="token function">require</span><span class="token punctuation">(</span>Algorithm<span class="token punctuation">.</span><span class="token function">HMAC256</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">getPassword</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    jwtVerifier<span class="token punctuation">.</span><span class="token function">verify</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">JWTVerificationException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"401"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">postHandle</span><span class="token punctuation">(</span>HttpServletRequest httpServletRequest<span class="token punctuation">,</span> HttpServletResponse httpServletResponse<span class="token punctuation">,</span> Object o<span class="token punctuation">,</span> ModelAndView modelAndView<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterCompletion</span><span class="token punctuation">(</span>HttpServletRequest httpServletRequest<span class="token punctuation">,</span> HttpServletResponse httpServletResponse<span class="token punctuation">,</span> Object o<span class="token punctuation">,</span> Exception e<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p><strong>实现一个拦截器就需要实现HandlerInterceptor接口</strong></p><p><strong>HandlerInterceptor接口主要定义了三个方法</strong><br>1.boolean preHandle ()：预处理回调方法,实现处理器的预处理，第三个参数为响应的处理器,自定义Controller,返回值为true表示继续流程（如调用下一个拦截器或处理器）或者接着执行postHandle()和afterCompletion()；false表示流程中断，不会继续调用其他的拦截器或处理器，中断执行。</p><p>2.void postHandle()：后处理回调方法，实现处理器的后处理（DispatcherServlet进行视图返回渲染之前进行调用），此时我们可以通过modelAndView（模型和视图对象）对模型数据进行处理或对视图进行处理，modelAndView也可能为null。</p><p>3.void afterCompletion():整个请求处理完毕回调方法,该方法也是需要当前对应的Interceptor的preHandle()的返回值为true时才会执行，也就是在DispatcherServlet渲染了对应的视图之后执行。用于进行资源清理。整个请求处理完毕回调方法。如性能监控中我们可以在此记录结束时间并输出消耗时间，还可以进行一些资源清理，类似于try-catch-finally中的finally，但仅调用处理器执行链中</p><h4 id="主要流程"><a href="#主要流程" class="headerlink" title="主要流程:"></a>主要流程:</h4><p>1.从 http 请求头中取出 token，2.判断是否映射到方法3.检查是否有passtoken注释，有则跳过认证4.检查有没有需要用户登录的注解，有则需要取出并验证5.认证通过则可以访问，不通过会报相关错误信息</p></blockquote><h5 id="配置拦截器"><a href="#配置拦截器" class="headerlink" title="配置拦截器"></a>配置拦截器</h5><blockquote><p>在配置类上添加了注解@Configuration，标明了该类是一个配置类并且会将该类作为一个SpringBean添加到IOC容器内</p></blockquote><blockquote><p>WebMvcConfigurerAdapter该抽象类其实里面没有任何的方法实现，只是空实现了接口WebMvcConfigurer内的全部方法，并没有给出任何的业务逻辑处理，这一点设计恰到好处的让我们不必去实现那些我们不用的方法，都交由WebMvcConfigurerAdapter抽象类空实现,如果我们需要针对具体的某一个方法做出逻辑处理,仅仅需要在WebMvcConfigurerAdapter子类中@Override对应方法就可以了。</p><p>注：在SpringBoot2.0及Spring 5.0中WebMvcConfigurerAdapter已被废弃网上有说改为继承WebMvcConfigurationSupport()，不过试了下，还是过期的</p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法:"></a>解决方法:</h4><p>直接实现WebMvcConfigurer （官方推荐）</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InterceptorConfig</span> <span class="token keyword">implements</span> <span class="token class-name">WebMvcConfigurer</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addInterceptors</span><span class="token punctuation">(</span>InterceptorRegistry registry<span class="token punctuation">)</span> <span class="token punctuation">{</span>        registry<span class="token punctuation">.</span><span class="token function">addInterceptor</span><span class="token punctuation">(</span><span class="token function">authenticationInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">// 拦截所有请求，通过判断是否有 @LoginRequired 注解 决定是否需要登录</span>                <span class="token punctuation">.</span><span class="token function">addPathPatterns</span><span class="token punctuation">(</span><span class="token string">"/**"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> AuthenticationInterceptor <span class="token function">authenticationInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">AuthenticationInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>InterceptorRegistry内的addInterceptor需要一个实现HandlerInterceptor接口的拦截器实例，addPathPatterns方法用于设置拦截器的过滤路径规则。<br>这里我拦截所有请求，通过判断是否有@LoginRequired注解 决定是否需要登录</p></blockquote><h5 id="在数据访问接口中加入登录操作注解"><a href="#在数据访问接口中加入登录操作注解" class="headerlink" title="在数据访问接口中加入登录操作注解"></a>在数据访问接口中加入登录操作注解</h5><pre class=" language-java"><code class="language-java">RestController<span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"api"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserApi</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> UserService userService<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> TokenService tokenService<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//登录</span>    <span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">"/login"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Object <span class="token function">login</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestBody</span> User user<span class="token punctuation">)</span><span class="token punctuation">{</span>        JSONObject jsonObject<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">JSONObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        User userForBase<span class="token operator">=</span>userService<span class="token punctuation">.</span><span class="token function">findByUsername</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>userForBase<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>            jsonObject<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"message"</span><span class="token punctuation">,</span><span class="token string">"登录失败,用户不存在"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> jsonObject<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>userForBase<span class="token punctuation">.</span><span class="token function">getPassword</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">getPassword</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                jsonObject<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"message"</span><span class="token punctuation">,</span><span class="token string">"登录失败,密码错误"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> jsonObject<span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>                String token <span class="token operator">=</span> tokenService<span class="token punctuation">.</span><span class="token function">getToken</span><span class="token punctuation">(</span>userForBase<span class="token punctuation">)</span><span class="token punctuation">;</span>                jsonObject<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"token"</span><span class="token punctuation">,</span> token<span class="token punctuation">)</span><span class="token punctuation">;</span>                jsonObject<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"user"</span><span class="token punctuation">,</span> userForBase<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> jsonObject<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@UserLoginToken</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/getMessage"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> String <span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"你已通过验证"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>不加注解的话默认不验证，登录接口一般是不验证的。在getMessage()中我加上了登录注解，说明该接口必须登录获取token后，在请求头中加上token并通过验证才可以访问</p></blockquote><h5 id="在没token的情况下访问api-getMessage接口"><a href="#在没token的情况下访问api-getMessage接口" class="headerlink" title="在没token的情况下访问api/getMessage接口"></a>在没token的情况下访问api/getMessage接口</h5><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/05/07/springboot-yi/002.png" alt></p><blockquote><p>使用了统一异常处理，所以只看到错误message</p><p>下面进行登录，从而获取token</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/05/07/springboot-yi/003.png" alt></p><blockquote><p>把token加在请求头中，再次访问api/getMessage接口</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/05/07/springboot-yi/004.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JWT </tag>
            
            <tag> Springboot2.0 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Mac上使用Markdown</title>
      <link href="/2019/05/06/zai-mac-shang-shi-yong-markdown/"/>
      <url>/2019/05/06/zai-mac-shang-shi-yong-markdown/</url>
      
        <content type="html"><![CDATA[<h1 id="在Mac上使用Markdown"><a href="#在Mac上使用Markdown" class="headerlink" title="在Mac上使用Markdown"></a>在Mac上使用Markdown</h1><h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>MarkDown是一种轻量级的标记语言，他的开发者为John Gruber。通过简单的标记语法，它可以使普通文本具有一定的格式</p><p>​        最近入手一台macbook  pro，已经把这个博客从windows迁移到mac上来了！！！</p></blockquote><h4 id="一、常用语法及快捷键"><a href="#一、常用语法及快捷键" class="headerlink" title="一、常用语法及快捷键"></a>一、常用语法及快捷键</h4><h5 id="1-1标题"><a href="#1-1标题" class="headerlink" title="1.1标题"></a>1.1标题</h5><blockquote><p>##一级标题</p><p>####二级标题</p><p>######三级标题</p><p>########四级标题</p><p>##########五级标题</p><p>############六级标题</p><p>快捷键为cmd+X（X为几级标题就写数字几，如二级标题为：cmd+2）</p></blockquote><h5 id="1-2引用"><a href="#1-2引用" class="headerlink" title="1.2引用"></a>1.2引用</h5><blockquote><p>当你需要引用别人的话时，可以在引用的文字前面添加引用标记 <strong>&gt;</strong>，<br>即表示此后的内容为引用，这时候，文字的背景色也会改变。</p><p>如：&gt;这是一段引用</p></blockquote><h5 id="1-3链接"><a href="#1-3链接" class="headerlink" title="1.3链接"></a>1.3链接</h5><blockquote><p>链接分为图片链接和网址链接。</p><p><strong>图片链接</strong></p><pre><code>![图片描述] (图片地址)</code></pre><p>快捷键为：shift + cmd + I</p><p><strong>网页链接</strong></p><pre><code>[网页描述](网页地址)</code></pre><p>快捷键为 sihft + cmd + k</p></blockquote><h5 id="1-4代码"><a href="#1-4代码" class="headerlink" title="1.4代码"></a>1.4代码</h5><blockquote><p>使用两个 <strong>`</strong>符号把单行代码包裹起来。</p><p>多行代码两个用<strong><code>`</code></strong>包起来。</p></blockquote><h5 id="1-5表格"><a href="#1-5表格" class="headerlink" title="1.5表格"></a>1.5表格</h5><blockquote><p>| 1 | 2 | 3 |</p><p>| —- |:—-:| —:|</p><p>| a | d | g |</p><p>| b | e | h |</p><p>| c | f | I |</p><p><strong>| —- |:—-:| —:|</strong>表示对其方式。:—表示左对齐；—:表示右对齐；:—-:表示中间对齐。</p></blockquote><p>效果为：</p><table><thead><tr><th>1</th><th style="text-align:center">2</th><th style="text-align:right">3</th></tr></thead><tbody><tr><td>a</td><td style="text-align:center">d</td><td style="text-align:right">g</td></tr><tr><td>b</td><td style="text-align:center">e</td><td style="text-align:right">h</td></tr><tr><td>c</td><td style="text-align:center">f</td><td style="text-align:right">I</td></tr></tbody></table><h5 id="1-6其他"><a href="#1-6其他" class="headerlink" title="1.6其他"></a>1.6其他</h5><pre><code>加粗 :**Bold**斜体字 :*Italics*高亮 :==text==段落 : 段落之间空一行画水平线 (HR) :--------方框：- [ ] -</code></pre>]]></content>
      
      
      <categories>
          
          <category> 皮一下 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列的高可用</title>
      <link href="/2019/05/05/xiao-xi-dui-lie-de-gao-ke-yong/"/>
      <url>/2019/05/05/xiao-xi-dui-lie-de-gao-ke-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="消息队列的高可用"><a href="#消息队列的高可用" class="headerlink" title="消息队列的高可用"></a>消息队列的高可用</h1><h4 id="一、RabbitMQ-的高可用性"><a href="#一、RabbitMQ-的高可用性" class="headerlink" title="一、RabbitMQ 的高可用性"></a>一、RabbitMQ 的高可用性</h4><blockquote><p>​    RabbitMQ 是比较有代表性的，因为是基于主从（非分布式）做高可用性的，我们就以 RabbitMQ 为例子讲解第一种 MQ 的高可用性怎么实现。</p><p>RabbitMQ 有三种模式：单机模式、普通集群模式、镜像集群模式。</p></blockquote><h5 id="1-1、单机模式"><a href="#1-1、单机模式" class="headerlink" title="1.1、单机模式"></a>1.1、单机模式</h5><blockquote><p>单机模式，就是 Demo 级别的，一般就是你本地启动了玩玩儿的，没人生产用单机模式。</p><p>普通集群模式（无高可用性）</p><p>普通集群模式，意思就是在多台机器上启动多个 RabbitMQ 实例，每个机器启动一个。你创建的 queue，只会放在一个 RabbitMQ 实例上，但是每个实例都同步 queue 的元数据（元数据可以认为是 queue 的一些配置信息，通过元数据，可以找到 queue 所在实例）。你消费的时候，实际上如果连接到了另外一个实例，那么那个实例会从 queue 所在实例上拉取数据过来。</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/05/05/xiao-xi-dui-lie-de-gao-ke-yong/001.jpg" alt="001"></p><h4 id="二、Kafka-的高可用性"><a href="#二、Kafka-的高可用性" class="headerlink" title="二、Kafka 的高可用性"></a>二、Kafka 的高可用性</h4><blockquote><p>​    Kafka 一个最基本的架构认识：由多个 broker 组成，每个 broker 是一个节点；你创建一个 topic，这个 topic 可以划分为多个 partition，每个 partition 可以存在于不同的 broker 上，每个 partition 就放一部分数据。</p><p>​    这就是天然的分布式消息队列，就是说一个 topic 的数据，是分散放在多个机器上的，每个机器就放一部分数据。</p><p>​    实际上 RabbmitMQ 之类的，并不是分布式消息队列，它就是传统的消息队列，只不过提供了一些集群、HA(High Availability, 高可用性) 的机制而已，因为无论怎么玩儿，RabbitMQ 一个 queue 的数据都是放在一个节点里的，镜像集群下，也是每个节点都放这个 queue 的完整数据。</p><p>​    Kafka 0.8 以前，是没有 HA 机制的，就是任何一个 broker 宕机了，那个 broker 上的 partition 就废了，没法写也没法读，没有什么高可用性可言。</p><p>​    比如说，我们假设创建了一个 topic，指定其 partition 数量是 3 个，分别在三台机器上。但是，如果第二台机器宕机了，会导致这个 topic 的 1/3 的数据就丢了，因此这个是做不到高可用的。</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/05/05/xiao-xi-dui-lie-de-gao-ke-yong/002.jpg" alt="002"></p><blockquote><p>​    这么搞，就有所谓的高可用性了，因为如果某个 broker 宕机了，没事儿，那个 broker上面的 partition 在其他机器上都有副本的，如果这上面有某个 partition 的 leader，那么此时会从 follower 中重新选举一个新的 leader 出来，大家继续读写那个新的 leader 即可。这就有所谓的高可用性了。</p><p>​    写数据的时候，生产者就写 leader，然后 leader 将数据落地写本地磁盘，接着其他 follower 自己主动从 leader 来 pull 数据。一旦所有 follower 同步好数据了，就会发送 ack 给 leader，leader 收到所有 follower 的 ack 之后，就会返回写成功的消息给生产者。（当然，这只是其中一种模式，还可以适当调整这个行为）</p><p>​    消费的时候，只会从 leader 去读，但是只有当一个消息已经被所有 follower 都同步成功返回 ack 的时候，这个消息才会被消费者读到。</p><p>​    看到这里，相信你大致明白了 Kafka 是如何保证高可用机制的了，对吧？不至于一无所知，现场还能给面试官画画图。要是遇上面试官确实是 Kafka 高手，深挖了问，那你只能说不好意思，太深入的你没研究过。</p><p>​    这种方式确实很麻烦，也不怎么好，没做到所谓的分布式，就是个普通集群。因为这导致你要么消费者每次随机连接一个实例然后拉取数据，要么固定连接那个 queue 所在实例消费数据，前者有数据拉取的开销，后者导致单实例性能瓶颈。</p><p>​    而且如果那个放 queue 的实例宕机了，会导致接下来其他实例就无法从那个实例拉取，如果你开启了消息持久化，让 RabbitMQ 落地存储消息的话，消息不一定会丢，得等这个实例恢复了，然后才可以继续从这个 queue 拉取数据。</p><p>​    所以这个事儿就比较尴尬了，这就没有什么所谓的高可用性，这方案主要是提高吞吐量的，就是说让集群中多个节点来服务某个 queue 的读写操作。</p><p>镜像集群模式（高可用性）</p><p>​    这种模式，才是所谓的 RabbitMQ 的高可用模式。跟普通集群模式不一样的是，在镜像集群模式下，你创建的 queue，无论元数据还是 queue 里的消息都会存在于多个实例上，就是说，每个 RabbitMQ 节点都有这个 queue 的一个完整镜像，包含 queue 的全部数据的意思。然后每次你写消息到 queue 的时候，都会自动把消息同步到多个实例的 queue 上。</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/05/05/xiao-xi-dui-lie-de-gao-ke-yong/003.jpg" alt="003"></p><blockquote><p>​    那么如何开启这个镜像集群模式呢？其实很简单，RabbitMQ 有很好的管理控制台，就是在后台新增一个策略，这个策略是镜像集群模式的策略，指定的时候是可以要求数据同步到所有节点的，也可以要求同步到指定数量的节点，再次创建 queue 的时候，应用这个策略，就会自动将数据同步到其他的节点上去了。</p><p>这样的话，好处在于，你任何一个机器宕机了，没事儿，其它机器（节点）还包含了这个 queue 的完整数据，别的 consumer 都可以到其它节点上去消费数据。坏处在于，第一，这个性能开销也太大了吧，消息需要同步到所有机器上，导致网络带宽压力和消耗很重！第二，这么玩儿，不是分布式的，就没有扩展性可言了，如果某个 queue 负载很重，你加机器，新增的机器也包含了这个 queue 的所有数据，并没有办法线性扩展你的 queue。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式，MQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx惊群</title>
      <link href="/2019/04/28/nginx-liang-qun/"/>
      <url>/2019/04/28/nginx-liang-qun/</url>
      
        <content type="html"><![CDATA[<h1 id="nginx惊群"><a href="#nginx惊群" class="headerlink" title="nginx惊群"></a>nginx惊群</h1><h4 id="一、什么是惊群"><a href="#一、什么是惊群" class="headerlink" title="一、什么是惊群"></a>一、什么是惊群</h4><blockquote><p>​        多线程/多进程（linux下线程进程也没多大区别）等待同一个socket事件，当这个事件发生时，这些线程/进程被同时唤醒，就是惊群。可以想见，效率很低下，许多进程被内核重新调度唤醒，同时去响应这一个事件，当然只有一个进程能处理事件成功，其他的进程在处理该事件失败后重新休眠（也有其他选择）。这种性能浪费现象就是惊群。</p></blockquote><blockquote><p>​        惊群通常发生在server 上，当父进程绑定一个端口监听socket，然后fork出多个子进程，子进程们开始循环处理（比如accept）这个socket。每当用户发起一个TCP连接时，多个子进程同时被唤醒，然后其中一个子进程accept新连接成功，余者皆失败，重新休眠。</p></blockquote><h4 id="二、如何解决惊群问题-post事件处理机制"><a href="#二、如何解决惊群问题-post事件处理机制" class="headerlink" title="二、如何解决惊群问题-post事件处理机制"></a>二、如何解决惊群问题-post事件处理机制</h4><blockquote><p>​        很多操作系统的最新版本的内核已经在事件驱动机制中解决了惊群问题，但Nginx作为可移植性极高的web服务器，还是在自身的应用层面上较好的解决了这一问题。<br>Nginx规定了同一时刻只有唯一一个worker子进程监听web端口，这一就不会发生惊群了，此时新连接事件只能唤醒唯一的正在监听端口的worker子进程。</p><p>​        如何限制在某一时刻是有一个子进程监听web端口呢？在打开accept_mutex锁的情况下，只有调用ngx_trylock_accept_mutex方法后，当前的worker进程才会去试着监听web端口。</p><p>那么，什么时候释放ngx_accept_mutex锁呢？<br>       显然不能等到这批事件全部执行完。因为这个worker进程上可能有许多活跃的连接，处理这些连接上的事件会占用很长时间，其他worker进程很难得到处理新连接的机会。</p><p>​    如何解决长时间占用ngx_accept_mutex的问题呢？</p><p>​    这就要依靠post事件处理机制，Nginx设计了两个队列：ngx_posted_accept_events队列（存放新连接事件的队列）和ngx_posted_events队列（存放普通事件的队列）。这两个队列都是ngx_event_t类型的双链表。定义如下：</p></blockquote><pre class=" language-java"><code class="language-java">ngx_thread_volatile ngx_event_t  <span class="token operator">*</span>ngx_posted_accept_events<span class="token punctuation">;</span>ngx_thread_volatile ngx_event_t  <span class="token operator">*</span>ngx_posted_events<span class="token punctuation">;</span></code></pre><blockquote><p>​    下面结合具体代码进行分析惊群问题的解决。</p><p>​    首先看worker进程中ngx_process_events_and_timers事件处理函数（src/event/ngx.event.c），它处于worker进程的ngx_worker_process_cycle方法中，循环处理时间，是事件驱动机制的核心，既会处理普通的网络事件，也会处理定时器事件。ngx_process_events_and_timers是Nginx实际处理web业务的方法，所有业务的执行都是由它开始的，它涉及Nginx完整的事件驱动机制！！特别重要~</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span><span class="token function">ngx_process_events_and_timers</span><span class="token punctuation">(</span>ngx_cycle_t <span class="token operator">*</span>cycle<span class="token punctuation">)</span><span class="token punctuation">{</span>    ngx_uint_t  flags<span class="token punctuation">;</span>    ngx_msec_t  timer<span class="token punctuation">,</span> delta<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ngx_timer_resolution<span class="token punctuation">)</span> <span class="token punctuation">{</span>        timer <span class="token operator">=</span> NGX_TIMER_INFINITE<span class="token punctuation">;</span>        flags <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        timer <span class="token operator">=</span> <span class="token function">ngx_event_find_timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        flags <span class="token operator">=</span> NGX_UPDATE_TIME<span class="token punctuation">;</span>#<span class="token keyword">if</span> <span class="token punctuation">(</span>NGX_THREADS<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>timer <span class="token operator">==</span> NGX_TIMER_INFINITE <span class="token operator">||</span> timer <span class="token operator">></span> <span class="token number">500</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            timer <span class="token operator">=</span> <span class="token number">500</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>#endif    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*ngx_use_accept_mutex表示是否需要通过对accept加锁来解决惊群问题。当使用了master模式，nginx worker进程数>1时且配置文件中打开accept_mutex时，这个标志置为1     它在函数ngx_event_process_int中被设置，源代码为：    if (ccf->master &amp;&amp; ccf->worker_processes > 1 &amp;&amp; ecf->accept_mutex) {        ngx_use_accept_mutex = 1;        ngx_accept_mutex_held = 0;        ngx_accept_mutex_delay = ecf->accept_mutex_delay;    } else {        ngx_use_accept_mutex = 0;    }*/</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ngx_use_accept_mutex<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//负载均衡处理</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ngx_accept_disabled <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            ngx_accept_disabled<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//调用ngx_trylock_accept_mutex方法，尝试获取accept锁</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ngx_trylock_accept_mutex</span><span class="token punctuation">(</span>cycle<span class="token punctuation">)</span> <span class="token operator">==</span> NGX_ERROR<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//拿到锁</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ngx_accept_mutex_held<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">/*给flags增加标记NGX_POST_EVENTS，这个标记作为处理时间核心函数ngx_process_events的一个参数，这个函数中所有事件将延后处理。会把accept事件都放到ngx_posted_accept_events链表中，epollin|epollout普通事件都放到ngx_posted_events链表中 */</span>                flags <span class="token operator">|=</span> NGX_POST_EVENTS<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">/*获取锁失败，意味着既不能让当前worker进程频繁的试图抢锁，也不能让它经过太长事件再去抢锁                下面的代码：即使开启了timer_resolution时间精度，牙需要让ngx_process_change方法在没有新事件的时候至少等待ngx_accept_mutex_delay毫秒之后再去试图抢锁                而没有开启时间精度时，如果最近一个定时器事件的超时时间距离现在超过了ngx_accept_mutex_delay毫秒，也要把timer设置为ngx_accept_mutex_delay毫秒，这是因为当前进程虽然没有抢到accept_mutex锁，但也不能让ngx_process_change方法在没有新事件的时候等待的时间超过ngx_accept_mutex_delay，这会影响整个负载均衡机制*/</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>timer <span class="token operator">==</span> NGX_TIMER_INFINITE                    <span class="token operator">||</span> timer <span class="token operator">></span> ngx_accept_mutex_delay<span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    timer <span class="token operator">=</span> ngx_accept_mutex_delay<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//计算ngx_process_events消耗的时间</span>    delta <span class="token operator">=</span> ngx_current_msec<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//事件处理核心函数</span>    <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token function">ngx_process_events</span><span class="token punctuation">(</span>cycle<span class="token punctuation">,</span> timer<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>    delta <span class="token operator">=</span> ngx_current_msec <span class="token operator">-</span> delta<span class="token punctuation">;</span>    <span class="token function">ngx_log_debug1</span><span class="token punctuation">(</span>NGX_LOG_DEBUG_EVENT<span class="token punctuation">,</span> cycle<span class="token operator">-</span><span class="token operator">></span>log<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>                   <span class="token string">"timer delta: %M"</span><span class="token punctuation">,</span> delta<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//ngx_posted_accept_events链表有数据，开始accept新连接</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ngx_posted_accept_events<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">ngx_event_process_posted</span><span class="token punctuation">(</span>cycle<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ngx_posted_accept_events<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//释放锁后再处理ngx_posted_events链表中的普通事件</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ngx_accept_mutex_held<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">ngx_shmtx_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ngx_accept_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//如果ngx_process_events消耗的时间大于0，那么这是可能有新的定时器事件触发</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>delta<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//处理定时器事件</span>        <span class="token function">ngx_event_expire_timers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">ngx_log_debug1</span><span class="token punctuation">(</span>NGX_LOG_DEBUG_EVENT<span class="token punctuation">,</span> cycle<span class="token operator">-</span><span class="token operator">></span>log<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>                   <span class="token string">"posted events %p"</span><span class="token punctuation">,</span> ngx_posted_events<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//ngx_posted_events链表中有数据，进行处理</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ngx_posted_events<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ngx_threaded<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">ngx_wakeup_worker_thread</span><span class="token punctuation">(</span>cycle<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token function">ngx_event_process_posted</span><span class="token punctuation">(</span>cycle<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ngx_posted_events<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>​        上面代码中要进行说明的是，flags被设置后作为函数ngx_process_events方法的一个参数，在epoll模块中这个接口的实现方法是ngx_epoll_process_events（其具体代码见<a href="http://blog.csdn.net/xiajun07061225/article/details/9250341）。当falgs标志位含有nGX_POST_EVENTS时是不会立即调用事件的handler回调方法的，代码如下所示：" target="_blank" rel="noopener">http://blog.csdn.net/xiajun07061225/article/details/9250341）。当falgs标志位含有nGX_POST_EVENTS时是不会立即调用事件的handler回调方法的，代码如下所示：</a></p></blockquote><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//事件需要延后处理</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> NGX_POST_EVENTS<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">/*如果要在post队列中延后处理该事件，首先要判断它是新连接时间还是普通事件                以确定是把它加入到ngx_posted_accept_events队列或者ngx_posted_events队列中。*/</span>                queue <span class="token operator">=</span> <span class="token punctuation">(</span>ngx_event_t <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>rev<span class="token operator">-</span><span class="token operator">></span>accept <span class="token operator">?</span>                               <span class="token operator">&amp;</span>ngx_posted_accept_events <span class="token operator">:</span> <span class="token operator">&amp;</span>ngx_posted_events<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//将该事件添加到相应的延后队列中</span>                <span class="token function">ngx_locked_post_event</span><span class="token punctuation">(</span>rev<span class="token punctuation">,</span> queue<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//立即调用事件回调方法来处理这个事件</span>                rev<span class="token operator">-</span><span class="token operator">></span><span class="token function">handler</span><span class="token punctuation">(</span>rev<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span></code></pre><blockquote><p>通过上面的代码可以看出，先处理ngx_posted_accept_events队列中的事件，处理完毕后立即释放ngx_accept_mutex锁，接着再处理ngx_posted_events队列中事件。这样大大减少了ngx_accept_mutex锁占用的时间</p><p>下面看看ngx_trylock_accept_mutex的具体实现（src/event/ngx_event_accept.c）：</p></blockquote><pre class=" language-java"><code class="language-java">ngx_int_t<span class="token function">ngx_trylock_accept_mutex</span><span class="token punctuation">(</span>ngx_cycle_t <span class="token operator">*</span>cycle<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//尝试获取accept_mutex锁。注意是非阻塞的。返回1表示成功，返回0表示失败。</span>    <span class="token comment" spellcheck="true">//ngx_accept_mutex 定义：ngx_shmtx_t    ngx_accept_mutex;（ngx_shmtx_t是Nginx封装的互斥锁，用于经常间同步）</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ngx_shmtx_trylock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ngx_accept_mutex<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">ngx_log_debug0</span><span class="token punctuation">(</span>NGX_LOG_DEBUG_EVENT<span class="token punctuation">,</span> cycle<span class="token operator">-</span><span class="token operator">></span>log<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>                       <span class="token string">"accept mutex locked"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//获取到锁，但是标志位ngx_accept_mutex_held为1，表示当前进程已经获取到锁了，立即返回。</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ngx_accept_mutex_held            <span class="token operator">&amp;&amp;</span> ngx_accept_events <span class="token operator">==</span> <span class="token number">0</span>            <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>ngx_event_flags <span class="token operator">&amp;</span> NGX_USE_RTSIG_EVENT<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">return</span> NGX_OK<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//将所有监听事件添加到当前的epoll等事件驱动模块中</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ngx_enable_accept_events</span><span class="token punctuation">(</span>cycle<span class="token punctuation">)</span> <span class="token operator">==</span> NGX_ERROR<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//添加失败，必须释放互斥锁</span>            <span class="token function">ngx_shmtx_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ngx_accept_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> NGX_ERROR<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//标志位设置</span>        ngx_accept_events <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//当前进程已经获取到锁</span>        ngx_accept_mutex_held <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> NGX_OK<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">ngx_log_debug1</span><span class="token punctuation">(</span>NGX_LOG_DEBUG_EVENT<span class="token punctuation">,</span> cycle<span class="token operator">-</span><span class="token operator">></span>log<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>                   <span class="token string">"accept mutex lock failed: %ui"</span><span class="token punctuation">,</span> ngx_accept_mutex_held<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//获取锁失败，但是标志位ngx_accept_mutex_held仍然为1，即当前进程还处在获取到锁的状态，这是不正确的</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ngx_accept_mutex_held<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//将所有监听事件从事件驱动模块中移除</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ngx_disable_accept_events</span><span class="token punctuation">(</span>cycle<span class="token punctuation">)</span> <span class="token operator">==</span> NGX_ERROR<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> NGX_ERROR<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//没有获取到锁，设置标志位</span>        ngx_accept_mutex_held <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> NGX_OK<span class="token punctuation">;</span></code></pre><blockquote><p>​    调用这个方法的结果是，要么唯一获取到锁且其epoll等事件驱动模块开始监控web端口上的新连接事件。这种情况下调用process_events方法时就会既处理已有连接上的事件，也处理新连接的事件。要么没有获取到锁，当前进程不会收到新连接事件。这种情况下process_events只处理已有连接上的事件。</p></blockquote><h4 id="三、参考资料"><a href="#三、参考资料" class="headerlink" title="三、参考资料"></a>三、参考资料</h4><blockquote><p><a href="http://russelltao.iteye.com/blog/1405352" target="_blank" rel="noopener">http://russelltao.iteye.com/blog/1405352</a></p><p>《深入理解Nginx》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入XSS和CSRF</title>
      <link href="/2019/04/25/sql-zhu-ru-xss-he-csrf/"/>
      <url>/2019/04/25/sql-zhu-ru-xss-he-csrf/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL注入、XSS和CSRF"><a href="#SQL注入、XSS和CSRF" class="headerlink" title="SQL注入、XSS和CSRF"></a>SQL注入、XSS和CSRF</h1><h4 id="一、SQL注入"><a href="#一、SQL注入" class="headerlink" title="一、SQL注入"></a>一、SQL注入</h4><pre><code>SQL注入是属于注入式攻击，这种攻击是因为在项目中没有将代码与数据（比如用户敏感数据）隔离，在读取数据的时候，错误的将数据作为代码的一部分执行而导致的。典型的例子就是当对SQL语句进行字符串拼接的时候，直接使用未转义的用户输入内容作为变量。这时，只要在sql语句的中间做修改，比如加上drop、delete等关键字，执行之后后果不堪设想。说到这里，那么该怎么处理这种情况呢？三个方面：1、过滤用户输入参数中的特殊字符，降低风险。2、禁止通过字符串拼接sql语句，要严格使用参数绑定来传入参数。3、合理使用数据库框架提供的机制。就比如Mybatis提供的传入参数的方式 #{}，禁止使用${}，后者相当于是字符串拼接sql，要使用参数化的语句。总结下，就是要正确使用参数化绑定sql变量。</code></pre><h4 id="二、XSS"><a href="#二、XSS" class="headerlink" title="二、XSS"></a>二、XSS</h4><p>​    </p><blockquote><p>​       XSS：跨站脚本攻击，Cross-Site Scripting，为了和前端的css避免重名，简称为XSS，是指通过技术手段，向正常用户请求的HTML页面中插入恶意脚本，执行。</p></blockquote><blockquote><p>​    这种攻击主要是用于信息窃取和破坏等目的。比如2011年的微博XSS攻击事件，攻击者利用了微博发布功能中未对action-data漏洞做有效的过滤，在发布微博信息的时候带上了包含攻击脚本的URL，用户访问就会加载恶意脚本，导致大量用户被攻击。</p></blockquote><blockquote><p>​    关于防范XSS上，主要就是通过对用户输入的数据做过滤或者是转义，可以使用框架提供的工具类HtmlUtil。另外前端在浏览器展示数据的时候，要使用安全的API展示数据。比如使用innerText而不是innerHTML。</p></blockquote><h4 id="三、CSRF"><a href="#三、CSRF" class="headerlink" title="三、CSRF"></a>三、CSRF</h4><blockquote><p>​    跨站请求伪造，在用户并不知情的情况下，冒充用户发送请求，在当前已经登录的web网站上执行恶意操作，比如恶意发帖，修改密码等。</p></blockquote><blockquote><p>​    大致来看，与XSS有重合的地方，前者是黑客盗用用户浏览器中的登录信息，冒充用户去执行操作。后者是在正常用户请求的HTML中放入恶意代码，</p></blockquote><blockquote><p>​    XSS问题出在用户数据没有转义，过滤；CSRF问题出现在HTTP接口没有防范不守信用的调用。</p></blockquote><blockquote><p>防范CSRF的漏洞方式：</p></blockquote><blockquote><p>​    1、CSRF Token验证，利用浏览器的同源限制，在HTTP接口执行前验证Cookie中的Token，验证通过才会继续执行请求。</p></blockquote><blockquote><p>​    2、人机交互，例如短信验证码、界面的滑块。</p></blockquote><blockquote><p>之前在会议上也有一个思考，在人机验证这块，如果不用验证码的方式，用界面上的滑块这种方式，而且滑块还是第三方的。在APP的注册、登录使用这种人机验证的方式的话，如果第三方出现了问题，那么自己的APP就完全崩掉了，发版之后的APP什么也改不了。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 日常学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
            <tag> XSS </tag>
            
            <tag> CSRF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一致性Hash</title>
      <link href="/2019/04/24/yi-zhi-xing-hash/"/>
      <url>/2019/04/24/yi-zhi-xing-hash/</url>
      
        <content type="html"><![CDATA[<h1 id="一致性Hash"><a href="#一致性Hash" class="headerlink" title="一致性Hash"></a>一致性Hash</h1><blockquote><p>一致性Hash是分布式架构最重要最基础的东西，作为一个后端必须要了解，这里以分布式图片缓存服务器为例进行讲述。</p></blockquote><p><strong>原始问题：假设我们需要对一堆图片做缓存，缓存的图片放在了2台服务器上，当到来一个请求，应该如何知道请求的图片在哪台上面呢？</strong></p><blockquote><p>暴力遍历就不要去想了，否则缓存就没有意义了。一个自然的想法就是根据图片的名字做一个映射（Hash），将图片名字映射到0，1两个数字上面，例如有这样的映射函数：</p></blockquote><blockquote><p>f(图片名称) = md5(图片名称) % 2</p></blockquote><blockquote><p>md5是一个典型的哈希函数，会产生128bit的值，模2后只可能是0或1，那么我们就根据这个值把图片存入0、1两台服务器，当请求过来，根据图片名称计算出值，就可以知道图片缓存放在第几号服务器了：</p></blockquote><p><img src="/一致性Hash\001.jpg" alt="001"></p><blockquote><p>但假设现在我们图片太多了，需要再增加一台服务器分担压力，哈希函数必须更改成0、1、2映射，我们改为：</p></blockquote><blockquote><p>f(图片名称) = md5(图片名称) % 3</p></blockquote><blockquote><p>理论上讲，会有(N-1)/N的缓存会失效，其中N是服务器的数量，例如上述图片缓存，除了0图片、1图片，其余图片的存放位置都变了，失效的缓存有 2/3 * 6 = 4张图片：</p></blockquote><p><img src="/一致性Hash\002.jpg" alt="002"></p><p>减少图片服务器数量造成的后果亦是如此——在同一个时刻将会有大量缓存同时失效，称为“缓存雪崩”。失效了就会直接去后端服务器取，大量的请求直接透过缓存打到后端服务器，后端服务器极有可能承受不住压力而接连崩溃，最终造成整个系统瘫痪。</p><p><strong>所以出现进阶问题：当缓存服务器数量发生变化时，如何尽可能避免大量缓存同时失效？</strong></p><p>答案就是一致性Hash。</p><h4 id="一、一致性Hash原理"><a href="#一、一致性Hash原理" class="headerlink" title="一、一致性Hash原理"></a>一、一致性Hash原理</h4><h5 id="1、放置服务器"><a href="#1、放置服务器" class="headerlink" title="1、放置服务器"></a><strong>1、放置服务器</strong></h5><blockquote><p>我们将服务器像图片一样也进行哈希，服务器的“图片名称”一般就使用固定IP地址，Hash取模也不再是服务器数量，而是2^32，Hash的方法也不局限于md5，用一个抽象的函数表示：</p></blockquote><blockquote><p>f(服务器IP地址) = Hash(服务器IP地址) % 2^32</p></blockquote><blockquote><p>于是服务器被放置到了0~2^32-1某个数字对应的位置上去：</p></blockquote><p><img src="/一致性Hash\003.jpg" alt="003"></p><blockquote><p>为什么是2^32-1呢？因为第一次提出一致性Hash的论文是1997年发表的，那时候32位机器还是主流，2^32-1是最大的Integer。而现在64位早就普及了，完全可以将这个值扩大到2^64-1。</p></blockquote><h5 id="2、放置数据"><a href="#2、放置数据" class="headerlink" title="2、放置数据"></a><strong>2、放置数据</strong></h5><blockquote><p>我们将数据也按照相同的方式放到0~2^32-1的某个数字上去：</p></blockquote><blockquote><p>f(图片名称) = Hash(图片名称) % 2^32</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/04/24/yi-zhi-xing-hash/004.jpg" alt="004"></p><h5 id="3、把数据放到服务器上"><a href="#3、把数据放到服务器上" class="headerlink" title="3、把数据放到服务器上"></a><strong>3、把数据放到服务器上</strong></h5><blockquote><p>对于每个数据，从映射的位置开始，顺时针行走，放置到碰到的第一个服务器上。例如3、230将会放到0号图片服务器，232将会放到1号图片服务器，4175556547将会放到2号图片服务器：</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/04/24/yi-zhi-xing-hash/005.jpg" alt="005"></p><blockquote><p>这样一致性Hash就完成了。查找数据也是先映射、再顺时针行走找到第一台服务器。</p></blockquote><h4 id="二、一致性Hash如何缓解数据失效问题"><a href="#二、一致性Hash如何缓解数据失效问题" class="headerlink" title="二、一致性Hash如何缓解数据失效问题"></a>二、一致性Hash如何缓解数据失效问题</h4><blockquote><p>假设现在1号服务器崩溃，图片232找不到1号服务器，顺时针行走的第一台服务器是2号服务器，于是232的缓存位置发生了改变，变为了2号：</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/04/24/yi-zhi-xing-hash/006.jpg" alt="006"></p><blockquote><p>而对于其他图片来说，缓存位置并没有发生变化，影响的数据量从（N-1）/ N 降为了 M，其中M是0号图片服务器到1号图片服务器之间的图片数量。需要重新获取的缓存数据量降低了，雪崩问题自然也就能够得到缓解。</p></blockquote><h4 id="三、Hash环偏斜和虚拟节点"><a href="#三、Hash环偏斜和虚拟节点" class="headerlink" title="三、Hash环偏斜和虚拟节点"></a>三、Hash环偏斜和虚拟节点</h4><blockquote><p>前面讨论得太理想了，实际的服务器分布和数据分布很可能是这样的：</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/04/24/yi-zhi-xing-hash/007.jpg" alt="007"></p><blockquote><p>0、1、2三台服务器并没有均匀分布在环上，大量的图片数据都被放到了0号服务器上，而很少数据放到1、2号等其他图片服务器上，这种情况称之为Hash环偏斜。如果存放的是缓存则0号服务器崩溃就会引起缓存雪崩，如果存放的是数据则0号服务器就可能单点故障。</p></blockquote><blockquote><p>很自然可以想到，增加多台服务器就好了嘛。我们在Hash环上生成0、1、2三台服务器的虚拟节点：</p></blockquote><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/04/24/yi-zhi-xing-hash/008.jpg" alt="008"></p><blockquote><p>具体的做法是，在服务器IP后面增加编号，每一台服务器产生多个Hash值，就能放置在0~2^32-1的多个位置上了。这样一来，顺时针行走能找到不同的服务器概率将会大大提高，避免了偏斜问题。虚拟的服务器节点数越多，偏斜出现的概率就越低。通常都需要设置32或以上的虚拟节点数目，我见过甚至有设置500的。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> Hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三次握手和四次挥手</title>
      <link href="/2019/04/20/san-ci-wo-shou-he-si-ci-hui-shou/"/>
      <url>/2019/04/20/san-ci-wo-shou-he-si-ci-hui-shou/</url>
      
        <content type="html"><![CDATA[<h1 id="三次握手和四次挥手"><a href="#三次握手和四次挥手" class="headerlink" title="三次握手和四次挥手"></a>三次握手和四次挥手</h1><p>[TOC]</p><h4 id="常用的熟知端口号"><a href="#常用的熟知端口号" class="headerlink" title="常用的熟知端口号"></a>常用的熟知端口号</h4><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/04/20/san-ci-wo-shou-he-si-ci-hui-shou/004.jpg" alt="004"></p><h4 id="TCP的概述"><a href="#TCP的概述" class="headerlink" title="TCP的概述"></a>TCP的概述</h4><pre><code>TCP把连接作为最基本的对象，每一条TCP连接都有两个端点，这种断点我们叫作套接字（socket），它的定义为端口号拼接到IP地址即构成了套接字，例如，若IP地址为192.3.4.16 而端口号为80，那么得到的套接字为192.3.4.16:80。</code></pre><h4 id="TCP报文首部"><a href="#TCP报文首部" class="headerlink" title="TCP报文首部"></a>TCP报文首部</h4><pre><code>1、源端口和目的端口，各占2个字节，分别写入源端口和目的端口；2、序号，占4个字节，TCP连接中传送的字节流中的每个字节都按顺序编号。例如，一段报文的序号字段值是 301 ，而携带的数据共有100字段，显然下一个报文段（如果还有的话）的数据序号应该从401开始；3、确认号，占4个字节，是期望收到对方下一个报文的第一个数据字节的序号。例如，B收到了A发送过来的报文，其序列号字段是501，而数据长度是200字节，这表明B正确的收到了A发送的到序号700为止的数据。因此，B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701；4、数据偏移，占4位，它指出TCP报文的数据距离TCP报文段的起始处有多远；5、保留，占6位，保留今后使用，但目前应都位0；6、紧急URG，当URG=1，表明紧急指针字段有效。告诉系统此报文段中有紧急数据；7、确认ACK，仅当ACK=1时，确认号字段才有效。TCP规定，在连接建立后所有报文的传输都必须把ACK置1；8、推送PSH，当两个应用进程进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应，这时候就将PSH=1；9、复位RST，当RST=1，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立连接；10、同步SYN，在连接建立时用来同步序号。当SYN=1，ACK=0，表明是连接请求报文，若同意连接，则响应报文中应该使SYN=1，ACK=1；11、终止FIN，用来释放连接。当FIN=1，表明此报文的发送方的数据已经发送完毕，并且要求释放；12、窗口，占2字节，指的是通知接收方，发送本报文你需要有多大的空间来接受；13、检验和，占2字节，校验首部和数据这两部分；14、紧急指针，占2字节，指出本报文段中的紧急数据的字节数；15、选项，长度可变，定义一些其他的可选的参数。</code></pre><pre><code>为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。漫画图解：图片来源：《图解HTTP》</code></pre><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/04/20/san-ci-wo-shou-he-si-ci-hui-shou/001.jpg" alt="001"></p><p>简单示意图：</p><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/04/20/san-ci-wo-shou-he-si-ci-hui-shou/002.jpg" alt="002"></p><p>动图：</p><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/04/20/san-ci-wo-shou-he-si-ci-hui-shou/005.gif" alt="005"></p><pre><code>- 客户端–发送带有 SYN 标志的数据包–一次握手–服务端- 服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端- 客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端</code></pre><pre><code>最开始的时候客户端和服务器都是处于CLOSED状态。主动打开连接的为客户端，被动打开连接的是服务器</code></pre><pre><code>1、TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态；2、TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。3、TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。4、TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。5、当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。</code></pre><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/04/20/san-ci-wo-shou-he-si-ci-hui-shou/006.png" alt="006"></p><h4 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h4><pre><code>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。第一次握手：Client 什么都不能确认；Server 确认了对方发送正常第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己接收正常，对方发送正常第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送接收正常所以三次握手就能确认双发收发功能都正常，缺一不可。</code></pre><h4 id="为什么要传回-SYN"><a href="#为什么要传回-SYN" class="headerlink" title="为什么要传回 SYN"></a>为什么要传回 SYN</h4><pre><code>接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。SYN 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement[汉译：确认字符 ,在数据通信传输中，接收站发给发送站的一种传输控制字符。它表示确认发来的数据已经接受无误。 ]）消息响应。这样在客户机和服务器之间才能建立起可靠的TCP连接，数据才可以在客户机和服务器之间传递。</code></pre><h4 id="传了-SYN-为啥还要传-ACK"><a href="#传了-SYN-为啥还要传-ACK" class="headerlink" title="传了 SYN,为啥还要传 ACK"></a>传了 SYN,为啥还要传 ACK</h4><pre><code>双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证。</code></pre><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/04/20/san-ci-wo-shou-he-si-ci-hui-shou/003.jpg" alt="003"></p><pre><code>断开一个 TCP 连接则需要“四次挥手”：- 客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送- 服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号- 服务器-关闭与客户端的连接，发送一个FIN给客户端- 客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1</code></pre><h4 id="TCP连接的释放（四次挥手）"><a href="#TCP连接的释放（四次挥手）" class="headerlink" title="TCP连接的释放（四次挥手）"></a>TCP连接的释放（四次挥手）</h4><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/04/20/san-ci-wo-shou-he-si-ci-hui-shou/007.gif" alt="007"></p><pre><code>数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于ESTABLISHED状态，然后客户端主动关闭，服务器被动关闭。</code></pre><pre><code>1、客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。2、服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。3、客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。4、服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。5、客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗ *∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。6、服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</code></pre><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/04/20/san-ci-wo-shou-he-si-ci-hui-shou/008.png" alt="008"></p><h4 id="为什么客户端最后还要等待2MSL？"><a href="#为什么客户端最后还要等待2MSL？" class="headerlink" title="为什么客户端最后还要等待2MSL？"></a>为什么客户端最后还要等待2MSL？</h4><pre><code>MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</code></pre><h4 id="为什么建立连接是三次握手，关闭连接确是四次挥手呢？"><a href="#为什么建立连接是三次握手，关闭连接确是四次挥手呢？" class="headerlink" title="为什么建立连接是三次握手，关闭连接确是四次挥手呢？"></a>为什么建立连接是三次握手，关闭连接确是四次挥手呢？</h4><pre><code>建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。</code></pre><h4 id="为什么要四次挥手"><a href="#为什么要四次挥手" class="headerlink" title="为什么要四次挥手"></a>为什么要四次挥手</h4><pre><code>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。</code></pre><h4 id="如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办？</h4><pre><code>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型模式</title>
      <link href="/2019/04/19/yuan-xing-mo-shi/"/>
      <url>/2019/04/19/yuan-xing-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><h4 id="一-原型模式介绍"><a href="#一-原型模式介绍" class="headerlink" title="一 原型模式介绍"></a>一 原型模式介绍</h4><pre><code>在面向对象系统中，使用原型模式来复制一个对象自身，从而克隆出多个与原型对象一模一样的对象。另外在软件系统中，有些对象的创建过程较为复杂，而且有时候需要频繁创建，原型模式通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的办法创建出更多同类型的对象，这就是原型模式的意图所在。</code></pre><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/04/19/yuan-xing-mo-shi/001.jpg" alt="001"></p><h5 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h5><p>GOF给出的原型模式定义如下：</p><pre class=" language-java"><code class="language-java">Specify the kind of objects to create using a prototypical instance<span class="token punctuation">,</span> and create <span class="token keyword">new</span> <span class="token class-name">objects</span> by copying <span class="token keyword">this</span> prototype<span class="token punctuation">.</span> （使用原型实例指定将要创建的对象类型，通过复制这个实例创建新的对象。）</code></pre><h5 id="1-2-原型模式适用场景"><a href="#1-2-原型模式适用场景" class="headerlink" title="1.2 原型模式适用场景"></a>1.2 原型模式适用场景</h5><pre><code>我们现在一般会使用new关键字指定类名生成类的实例（PS：我们以前使用java.lang.Cloneable的一个很大原因是使用new创建对象的速度相对来说会慢一些，随着JVM性能的提升，new的速度和Object的clone（）方法的速度差不多了。）。使用new关键字创建类的时候必须指定类名，但是在开发过程中也会有“在不指定类名的前提下生成实例”的需求。例如，在下面这些情况下，就需要根据现有的实例来生成新的实例。1) 对象种类繁多，无法将他们整合到一个类的时候；2) 难以根据类生成实例时；3) 想解耦框架与生成的实例时。如果想要让生成实例的框架不再依赖于具体的类，这时，不能指定类名来生成实例，而要事先“注册”一个“原型”实例，然后通过复制该实例来生成新的实例。</code></pre><h5 id="1-3-模式分析"><a href="#1-3-模式分析" class="headerlink" title="1.3 模式分析"></a>1.3 模式分析</h5><pre><code>在原型模式结构中定义了一个抽象原型类，所有的Java类都继承自java.lang.Object，而Object类提供一个clone()方法，可以将一个Java对象复制一份。因此在Java中可以直接使用Object提供的clone()方法来实现对象的克隆，Java语言中的原型模式实现很简单。能够实现克隆的Java类必须实现一个标识接口Cloneable，表示这个Java类支持复制。如果一个类没有实现这个接口但是调用了clone()方法，Java编译器将抛出一个CloneNotSupportedException异常。注意： `java.lang.Cloneable 只是起到告诉程序可以调用clone方法的作用，它本身并没有定义任何方法。在使用原型模式克隆对象时，根据其成员对象是否也克隆，原型模式可以分为两种形式：深克隆 和 浅克隆 。</code></pre><h5 id="1-4-模式优缺点分析"><a href="#1-4-模式优缺点分析" class="headerlink" title="1.4 模式优缺点分析"></a>1.4 模式优缺点分析</h5><p>原型模式的优点：</p><pre><code>1、当创建新的对象实例较为复杂时，使用原型模式可以简化对象的创建过程，通过一个已有实例可以提高新实例的创建效率。2、可以动态增加或减少产品类。3、原型模式提供了简化的创建结构。4、可以使用深克隆的方式保存对象的状态。</code></pre><p>原型模式的缺点：</p><pre><code>1、需要为每一个类配备一个克隆方法，而且这个克隆方法需要对类的功能进行通盘考虑，这对全新的类来说不是很难，但对已有的类进行改造时，不一定是件容易的事，必须修改其源代码，违背了“开闭原则”。2、在实现深克隆时需要编写较为复杂的代码。</code></pre><h4 id="二-示例程序"><a href="#二-示例程序" class="headerlink" title="二 示例程序"></a>二 示例程序</h4><p>下面示例程序的作用是将字符串放入方框中显示出来或者是加了下划线显示出来。</p><p>类和接口一览表：</p><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/04/19/yuan-xing-mo-shi/002.jpg" alt="002"></p><p>示例程序类图：</p><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/04/19/yuan-xing-mo-shi/003.jpg" alt="003"></p><h5 id="2-1-Product接口-（Prototype）"><a href="#2-1-Product接口-（Prototype）" class="headerlink" title="2.1 Product接口 （Prototype）"></a>2.1 Product接口 （Prototype）</h5><pre><code>    Product接口是复制功能接口，该接口继承了java.lang.Cloneable(只有实现了该接口的类的实例才可以调用clone()方法复制实例,否则会抛出异常).     另外需要注意：`java.lang.Cloneable 只是起到告诉程序可以调用clone方法的作用，它本身并没有定义任何方法。</code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @author ZongMan */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Product</span> <span class="token keyword">extends</span> <span class="token class-name">Cloneable</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//use方法是用于“使用”的方法，具体怎么“使用”，则被交给子类去实现</span>    <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">use</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//creatClone方法是用于复制实例的方法</span>    <span class="token keyword">abstract</span> Product <span class="token function">creatClone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h5 id="2-2-Manager类（Client）"><a href="#2-2-Manager类（Client）" class="headerlink" title="2.2 Manager类（Client）"></a>2.2 Manager类（Client）</h5><pre><code>Manager类使用Product接口来复制实例。Product接口以及Manager类的代码完全没有出现在MessageBox类和UnderlinePen类的名字，因此这意味着我们可以独立地修改Product接口以及Manager类，不受MessageBox类和UnderlinePen类的影响。这是非常重要的，因为 一旦在类中使用到了别的类名，就意味着该类与其他类紧密的地耦合在了一起 。在Manager类中，并没有写明具体的类名， 仅仅使用了Product这个接口名。也就是说，Product接口成为了连接Manager类与其他具体类之间的桥梁。</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>HashMap<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author ZongMan */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Manager</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//保存实例的“名字”和“实例”之间的对应关系</span>    <span class="token keyword">private</span> HashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Product<span class="token operator">></span> showcase <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*    register方法将接收到的一组“名字”和“Product接口”注册到showcase中。    这里Product是实现Product接口的实例，具体还未确定     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">register</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> Product product<span class="token punctuation">)</span> <span class="token punctuation">{</span>        showcase<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> product<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> Product <span class="token function">create</span><span class="token punctuation">(</span>String productname<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Product p <span class="token operator">=</span> showcase<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>productname<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> p<span class="token punctuation">.</span><span class="token function">creatClone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="2-3-MessageBox类（ConcreteProtorype）"><a href="#2-3-MessageBox类（ConcreteProtorype）" class="headerlink" title="2.3 MessageBox类（ConcreteProtorype）"></a>2.3 MessageBox类（ConcreteProtorype）</h5><p>装饰方框样式的具体原型，实现了Product接口，实现复制现有实例并生成新实例的方法。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @author ZongMan */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MessageBox</span> <span class="token keyword">implements</span> <span class="token class-name">Product</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//保存的是装饰方框使用的字符样式</span>    <span class="token keyword">private</span> <span class="token keyword">char</span> decochar<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">MessageBox</span><span class="token punctuation">(</span><span class="token keyword">char</span> decochar<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>decochar <span class="token operator">=</span> decochar<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">use</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> length <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"--------->"</span> <span class="token operator">+</span> decochar<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>decochar <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> str <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> decochar<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>decochar<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 该方法用于复制自己     * @return     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Product <span class="token function">creatClone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Product p <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            p <span class="token operator">=</span> <span class="token punctuation">(</span>Product<span class="token punctuation">)</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">CloneNotSupportedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> p<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>只有类自己（或是它的子类）能够调用Java语言中定义的clone方法。当其他类要求复制实例时，必须先调用createClone这样的方法，然后在该方法内部在调用clone方法。</code></pre><h5 id="2-4-UnderlinePen类（ConcreteProtorype）"><a href="#2-4-UnderlinePen类（ConcreteProtorype）" class="headerlink" title="2.4 UnderlinePen类（ConcreteProtorype）"></a>2.4 UnderlinePen类（ConcreteProtorype）</h5><pre><code>    下划线样式的具体原型，实现了Product接口，用于实现复制现有实例并生成新实例的方法。UnderlinePen类的实现几乎和MessageBox类一样，不同的可能只是use方法的实现。</code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @author ZongMan */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UnderlinePen</span> <span class="token keyword">implements</span> <span class="token class-name">Product</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">char</span> ulchar<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">UnderlinePen</span><span class="token punctuation">(</span><span class="token keyword">char</span> ulchar<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>ulchar <span class="token operator">=</span> ulchar<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">use</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> length <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"\""</span> <span class="token operator">+</span> str <span class="token operator">+</span> <span class="token string">"\""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>ulchar<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Product <span class="token function">creatClone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Product p <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            p <span class="token operator">=</span> <span class="token punctuation">(</span>Product<span class="token punctuation">)</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">CloneNotSupportedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> p<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span></code></pre><h5 id="2-5-Main类"><a href="#2-5-Main类" class="headerlink" title="2.5 Main类"></a>2.5 Main类</h5><pre><code>Main类首先生成Manager实例。接着，在Manager实例中通过`register方法注册了UnderlinePen类的实例（带名字）和MessageBox类的实例（带名字）。</code></pre><pre><code>package clone;/** * @author ZongMan */public class Main {    public static void main(String[] args) {        Manager manager = new Manager();        UnderlinePen underlinePen=new UnderlinePen(&#39;~&#39;);        MessageBox mbox=new MessageBox(&#39;*&#39;);        MessageBox sbox=new MessageBox(&#39;#&#39;);        manager.register(&quot;Strong message&quot;, underlinePen);        manager.register(&quot;Waring Box&quot;, mbox);        manager.register(&quot;Slash Box&quot;, sbox);        Product p1=manager.create(&quot;Strong message&quot;);        p1.use(&quot;hello world&quot;);        Product p2=manager.create(&quot;Waring Box&quot;);        p2.use(&quot;hello world&quot;);        Product p3=manager.create(&quot;Slash Box&quot;);        p3.use(&quot;hello world&quot;);    }}</code></pre><p>运行结果：</p><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/04/19/yuan-xing-mo-shi/004.jpg" alt="004"></p><h4 id="三-原型模式的角色分析"><a href="#三-原型模式的角色分析" class="headerlink" title="三 原型模式的角色分析"></a>三 原型模式的角色分析</h4><h5 id="3-1-Prototype（抽象原型类）"><a href="#3-1-Prototype（抽象原型类）" class="headerlink" title="3.1 Prototype（抽象原型类）"></a>3.1 Prototype（抽象原型类）</h5><pre><code>Product角色负责定义用于复制现有实例来生成新实例的方法。在示例程序中的Product接口就是该角色。</code></pre><h5 id="3-2-ConcretePrototype（具体原型类）"><a href="#3-2-ConcretePrototype（具体原型类）" class="headerlink" title="3.2 ConcretePrototype（具体原型类）"></a>3.2 ConcretePrototype（具体原型类）</h5><pre><code>ConcretePrototype角色负责实现复制现有实例并生成新实例的方法。在示例程序中，MessageBox和UnderlinePen都是该角色。</code></pre><h5 id="3-3-Client（客户类-使用者）"><a href="#3-3-Client（客户类-使用者）" class="headerlink" title="3.3 Client（客户类/使用者）"></a>3.3 Client（客户类/使用者）</h5><pre><code>Client角色负责使用复制实例的方法生成新的实例。在示例程序中，Manager类扮演的就是该角色。</code></pre><p>Prototype模式的类图：</p><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/04/19/yuan-xing-mo-shi/005.jpg" alt="005"></p><h4 id="四-原型模式的实际应用案例"><a href="#四-原型模式的实际应用案例" class="headerlink" title="四 原型模式的实际应用案例"></a>四 原型模式的实际应用案例</h4><pre><code>(1) 原型模式应用于很多软件中，如果每次创建一个对象要花大量时间，原型模式是最好的解决方案。很多软件提供的复制(Ctrl + C)和粘贴(Ctrl + V)操作就是原型模式的应用，复制得到的对象与原型对象是两个类型相同但内存地址不同的对象，通过原型模式可以大大提高对象的创建效率。(2) 在Struts2中为了保证线程的安全性，Action对象的创建使用了原型模式，访问一个已经存在的`Action对象时将通过克隆的方式创建出一个新的对象，从而保证其中定义的变量无须进行加锁实现同步，每一个Action中都有自己的成员变量，避免Struts1因使用单例模式而导致的并发和同步问题。(3) 在Spring中，用户也可以采用原型模式来创建新的bean实例，从而实现每次获取的是通过克隆生成的新实例，对其进行修改时对原有实例对象不造成任何影响。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原型，复制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode</title>
      <link href="/2019/04/18/leetcode/"/>
      <url>/2019/04/18/leetcode/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode上的算法题"><a href="#LeetCode上的算法题" class="headerlink" title="LeetCode上的算法题"></a>LeetCode上的算法题</h1><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><pre><code>/** * @author ZongMan * @version 1.0 * @date 2019/4/18 0018 8:31 * 在给定的整数数组中，总有一个最大的元素。查找数组中的最大元素是否至少是数组中每个其他数字的两倍。 * 如果是，则返回最大元素的索引，否则返回-1。例如： * 输入：nums = [3,6,1,0] * 输出：1 * 说明：6是最大的整数，对于数组x中的每个其他数字，6是x的两倍多。 值6的索引是1，所以我们返回1。 * 输入：nums = [1,2,3,4] * 输出：-1 * 说明：4至少不是3的值的两倍，所以我们返回-1。 */</code></pre><h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo01</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">dominantIndex</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"----------------------------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">dominantIndex2</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 题目的要求是返回最大数的索引，所以需要先将最大数找出来，并记录下其索引。     * 然后在次遍历数组中的元素，将最大数之外的其他数都乘以2和最大数比较(在此处我是使用位移处理)，     * 如果大于就返回-1，如果其他元素都满足条件，就返回之前记录的最大数的索引。     *     * @param nums 数组     * @return 相对应的结果     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">dominantIndex</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> max<span class="token punctuation">)</span> <span class="token punctuation">{</span>                max <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                index <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> max <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span> <span class="token operator">></span> max<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> index<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 我们还可以只使用一次循环来解决。并非需要使用每一个元素乘以2后再去和最大元素比较，     * 只需要用第二大的数去比较就行，如果第二大的数不能满足条件，就可以直接做判断了。     * 比如[2,3,4]，3乘以2等于6大于4，不符合题目要求，就不需要比较2了。     * @param nums 数组     * @return 对应结果     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">dominantIndex2</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> second <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> max<span class="token punctuation">)</span> <span class="token punctuation">{</span>                second <span class="token operator">=</span> max<span class="token punctuation">;</span>                max <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                index <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> second<span class="token punctuation">)</span> <span class="token punctuation">{</span>                second <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> second <span class="token operator">&lt;&lt;</span> <span class="token number">1</span> <span class="token operator">&lt;=</span> max <span class="token operator">?</span> index <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h4><blockquote><p>给定一个没有重复数字的序列，返回其所有可能的全排列。</p><p>示例:</p><p>输入: [1,2,3]</p><p>输出:</p><p>[ [1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</p></blockquote><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>可以使用回溯的方法来实现，实现过程中定义一个bool类型的数组来标识数组中的元素是否已经被使用。</p></blockquote><h4 id="代码实现：-1"><a href="#代码实现：-1" class="headerlink" title="代码实现："></a>代码实现：</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019-07-19 * @Time: 08:26 * @Vsersion: 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FullPermutation</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> result<span class="token punctuation">,</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> temp<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span><span class="token keyword">boolean</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> used<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>temp<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>            result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>used<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                used<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                temp<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">solve</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span>temp<span class="token punctuation">,</span>nums<span class="token punctuation">,</span>used<span class="token punctuation">)</span><span class="token punctuation">;</span>                temp<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>temp<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                used<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> <span class="token function">permute</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span><span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>null <span class="token operator">==</span> nums <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> result<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">solve</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>nums<span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">boolean</span> <span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><blockquote><p>数组，将元素存储到内存的连续位置中，是最基本的数据结构。在任何和编程相关的面试中，都会被问到和数组相关的问题，可以说是非常热门的考题之一。比如：将数组反转、对数组进行排序、搜索数组中的元素等。</p><p>数组数据结构的主要优点是如果知道索引就可以通过 O(l) 进行快速搜索，但是在数组中添加和删除元素的速度会很慢，因为数组一旦被创建，就无法更改其大小。如果需要创建更长或更短的数组，得先创建一个新数组，再把原数组中的所有元素复制到新创建的数组中。</p></blockquote><h4 id="1-给定一个-1-100-的整数数组，请找到其中缺少的数字。"><a href="#1-给定一个-1-100-的整数数组，请找到其中缺少的数字。" class="headerlink" title="1.给定一个 1-100 的整数数组，请找到其中缺少的数字。"></a>1.给定一个 1-100 的整数数组，请找到其中缺少的数字。</h4>]]></content>
      
      
      <categories>
          
          <category> 每日算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DNS劫持投毒解析</title>
      <link href="/2019/04/17/dns-jie-chi-tou-du-jie-xi/"/>
      <url>/2019/04/17/dns-jie-chi-tou-du-jie-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="DNS劫持投毒解析"><a href="#DNS劫持投毒解析" class="headerlink" title="DNS劫持投毒解析"></a>DNS劫持投毒解析</h1><p>本文以第一人称来讲述：</p><h4 id="一、什么是URL和IP"><a href="#一、什么是URL和IP" class="headerlink" title="一、什么是URL和IP"></a>一、什么是URL和IP</h4><pre><code>    我的冒险，要从一张“羊皮卷”说起。那天，浏览器大叔神秘兮兮招呼我过去，告诉我CPU下达了一个命令：派遣使者访问外邦。而我是大叔最得力的门生，也是这类任务最合适的人选。大叔为我准备了一张羊皮卷，上面记录了我这次冒险需要用到的必要信息。当仁不让地，我接过了它，即刻启程。我缓缓展开羊皮卷，第一行赫然写着：URL: https://mail.google.com    什么是“URL”？我在脑中快速回忆着，对了！URL即 Uniform Resource Locator的缩写，翻译成中文便是“统一资源定位符”。因为互联网世界存在着不计其数的资源，每一处资源都需要有一个标记来定位它，正如人类城市中的门牌号。    有人可能会认为，既然有了门牌号，找到指定地点不是轻而易举吗？朋友们，我也希望如此，但现实往往没有这么简单。    即使有了URL，恕我愚笨，我还是无法直接理解它所指向的目的地。因为这是人类的语言，我无法翻译解读。（其实是人类太笨了，记不住IP地址，需要用方便记忆的域名来代替）    对我来说，IP地址才是唯一的坐标。什么是IP？IP即Internet Protocol的缩写，中文译为“互联网协议”，一个如雷贯耳的名字，互联网的基石之一，一切依赖互联网通信的软件都得遵循这个协议。那么，如何才能将域名转换为IP地址呢？    浏览器大叔在平日工作之余，十分细心，他将用户访问过的站点整理了一份“域名-IP对应清单”。假如是一个已被记录的IP地址，那么他会直接告诉我，我可以立即向着目标IP地址出发，这就是浏览器缓存的作用。    假如用户输入的URL不在浏览器的记录范围之内，那么操作系统会查找一个名为“hosts”的文件。它是一份文本，记录了域名和IP地址的映射。如果“hosts”能够告诉我目标IP地址，那也能节省我不少工夫。这就是系统缓存。此外，还有路由器缓存，相信不用我多介绍了，即保存在路由器中的域名-IP映射。    这些缓存都能有效帮助我以最快的速度找到相应的IP地址。但是，互联网世界日新月异，各种资源层出不穷。在很多情况下，用户会想要访问一个全新的、任何缓存都没有记录过的域名。    为此，人类专门设计了DNS。在这次任务中，我的第一站，就是赶往DNS。为了更短的响应时间与更好的用户体验，我快马加鞭。</code></pre><h4 id="二、关于DNS劫持的记忆"><a href="#二、关于DNS劫持的记忆" class="headerlink" title="二、关于DNS劫持的记忆"></a>二、关于DNS劫持的记忆</h4><h5 id="DNS是什么？"><a href="#DNS是什么？" class="headerlink" title="DNS是什么？"></a>DNS是什么？</h5><pre><code>全称Domain Name System，是一个将域名和IP相互映射的分布式数据库。    全球有很多家DNS服务中心，假如你关心过你的计算机，你会发现，在你的网卡上，有着一项“DNS服务器”的配置项，它设定了我将要抵达的目的地。</code></pre><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/04/17/dns-jie-chi-tou-du-jie-xi/001.png" alt="001"></p><pre><code>一转眼的工夫，我来到了114.114.114.114DNS中心。    这个地方我来过很多次，表面上风平浪静，实则暗流涌动。我小心翼翼地来到办事大厅，不禁想起了我第一次被DNS劫持的经历。那天，我来到办事窗口，柜员热情地接待了我。    “先生，请问你想要查询哪个地址？”当时我还是一位新晋的网络请求，涉世尚浅，不知晓一些不可说的条例，于是毫不避讳地回答：“你好，我要去大名鼎鼎的mail.google.com！”    柜员的表情一下子凝固了，他上下打量了我一番，然后硬挤出一丝微笑，“好的先生，请稍等。”说完，他便向旁边的同事使了个眼色。我正纳闷呢，突然两边窜出身材魁梧的警卫，架着我强行往一处拖拽。我这才意识到大事不妙，“这是怎么回事？！你们凭什么劫持我？”我发疯了一般嘶吼着。    “你好，根据本ISP（电信运营商）颁布的条例，世界上不存在你所说的站点，现怀疑你是一个不合规的网络请求，将把你转发至baidu.com的IP地址。你有权保持沉默！”警卫冷漠地望着我。我知道，现在无论如何解释、挣扎都没有用了，只怪自己太年轻。无奈，我只好乖乖就范。</code></pre><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/04/17/dns-jie-chi-tou-du-jie-xi/002.png" alt="002"></p><pre><code>    还好当时正在使用计算机的用户有一些网络知识，当他发现自己输入的是google，返回的是baidu的页面时，并没有怪罪于我，大概是他心中已经猜到了原因。于是他将网卡的DNS配置为：8.8.8.8，这是一个国际上“不存在”的公司提供的DNS服务中心。仅仅这样就能畅通无阻地访问互联网了吗？经历了被DNS劫持，我依然不敢放松。</code></pre><h4 id="三、我遇到过DNS投毒"><a href="#三、我遇到过DNS投毒" class="headerlink" title="三、我遇到过DNS投毒"></a>三、我遇到过DNS投毒</h4><pre><code>还未休息片刻，浏览器大叔再一次地给我分配了任务：继续尝试请求mail.google.com的资源。    人类出国要坐飞机，要办护照。我们网络请求也是这样，全国只有在几个主要城市才会部署国际出口，所有访问境外资源的网络请求，都得经过这儿接受检查。与上次不同，因为这次我要访问的DNS服务器位于海外，所以我首先来到了大中华局域网的上海国际出口。我一路奔波到上海真的是又累又乏，正当我火急火燎地准备过安检，通道附近有一位穿着制服的小伙迎了上来。    还没等我开口，他热情地迎了上来：“远道而来的朋友，一定是十分疲惫了吧？天气这么热，先喝杯水吧！”我悄悄地打量着他，看他的打扮应该是一位服务人员。    “国际出口就是不一样啊，服务真到位！”由于确实是太渴了，我放松了警惕。“啊，真清凉，谢……”我一边感叹着，一边接过了小伙递给我的水。可当我第二个“谢”字还没说出口，立即感到一阵头晕目眩。    “不好！遇上了黑客，这是DNS投毒！”我的视线渐渐模糊，小伙的微笑也渐渐似乎变成了狞笑。我尽力搜索着脑海中和这一切有关的知识，想要知道寻求的办法。</code></pre><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/04/17/dns-jie-chi-tou-du-jie-xi/003.png" alt="003"></p><pre><code> DNS投毒，英文叫DNS cache poisoning，也叫做DNS污染。从客户端向DNS服务器发出查询IP的请求，到响应返回到客户端的这段时间里，如果有黑客或者其他一些不可说的设施伪造返回了一个错误的DNS应答，那么用户将不能访问到真正的资源。想到这里，我已经明显感觉难以控制自己的身体了，眼前一黑，就什么都不知道了。</code></pre><h4 id="四、DNS正常解析"><a href="#四、DNS正常解析" class="headerlink" title="四、DNS正常解析"></a>四、DNS正常解析</h4><pre><code>以前发生过的险情历历在目，如今想起来，我依旧心有余悸。这次，为了确保万无一失，我打起了十二分精神。这次，我已经顺利来到8.8.8.8 DNS服务中心。“你好亲，有什么可以帮到您的嘛”办事窗口内传来了软妹子的声音。“我想查询域名mail.google.com的IP地址。”我试探性地问，依然不敢松懈。“好的呢亲，这边通过树状检索，在顶级域名com下，查询到google目录，在google目录下查询到mail,IP地址是xx.xxx.xx.xx呢。”</code></pre><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/04/17/dns-jie-chi-tou-du-jie-xi/004.png" alt="004"></p><pre><code>    我松了口气，谢天谢地，终于拿到了结果。可我知道作为一次完整的网络请求，这刚刚开始，这才是万里长征第一步，我得赶紧将这个解析结果带回去，等会还得马不停蹄往返三次建立连接。</code></pre><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/04/17/dns-jie-chi-tou-du-jie-xi/005.png" alt="005"></p>]]></content>
      
      
      <categories>
          
          <category> 进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DNS，劫持，投毒，解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ConcurrentHashMap</title>
      <link href="/2019/04/16/concurrenthashmap/"/>
      <url>/2019/04/16/concurrenthashmap/</url>
      
        <content type="html"><![CDATA[<h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><pre><code>JDK8 对ConcurrentHashMap 进行了脱胎换骨式的改造，使用了大量的lock-free 技术来减轻因锁的竞争而对性能造成的影响。ConcurrentHashMap 被Segment 分成了很多小区，Segment 就相当于小区保安，HashEntry 列表相当于小区业主，小区保安通过加锁的方式，保证每个Segment 内都不发生冲突。</code></pre><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/04/16/concurrenthashmap/001.png" alt="001"></p><pre><code>通过分析Hashtable就知道，synchronized是针对整张Hash表的，即每次锁住整张表让线程独占，ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术。它使用了多个锁来控制对hash表的不同部分进行的修改。ConcurrentHashMap内部使用段(Segment)来表示这些不同的部分，每个段其实就是一个小的hash table，它们有自己的锁。只要多个修改操作发生在不同的段上，它们就可以并发进行。有些方法需要跨段，比如size()和containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁。这里“按顺序”是很重要的，否则极有可能出现死锁，在ConcurrentHashMap内部，段数组是final的，并且其成员变量实际上也是final的，但是，仅仅是将数组声明为final的并不保证数组成员也是final的，这需要实现上的保证。这可以确保不会出现死锁，因为获得锁的顺序是固定的。</code></pre><pre><code>数据存储结构分为2种：            链表            红黑树</code></pre><pre><code>当某个槽内的元素个数增加到超过8个，且table的容量大于或者等于64时，由链表转为红黑树；当某个槽内的元素个数减少到6个时，由红黑树重新转回链表。</code></pre><pre><code>table 扩容：当table需要进行扩容时，依次遍历当前table 中的每一个槽位，如果不为null，则需要把其中所有的元素根据 hash 值放入扩容后的 nextTable 中，而元table的槽内会放置一个 ForwardingNode 节点。此节点会把 find() 请求转发到扩容后的 nextTable 上。而执行 put() 方法的线程，如果碰到此节点，也会协助进行迁移。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 基础底层 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ConcurrentHashMap </tag>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sort排序原理</title>
      <link href="/2019/04/15/sort-pai-xu-yuan-li/"/>
      <url>/2019/04/15/sort-pai-xu-yuan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="java-sort排序原理"><a href="#java-sort排序原理" class="headerlink" title="java sort排序原理"></a>java sort排序原理</h1><pre><code>    事实上Collections.sort方法底层就是调用的Arrays.sort方法，而Arrays.sort使用了两种排序方法，快速排序和优化的归并排序。快速排序主要是对那些基本类型数据（int,short,long等）排序， 而归并排序用于对Object类型进行排序。    使用不同类型的排序算法主要是由于快速排序是不稳定的，而归并排序是稳定的。这里的稳定是指比较相等的数据在排序之后仍然按照排序之前的前后顺序排列。对于基本数据类型，稳定性没有意义，而对于Object类型，稳定性是比较重要的，因为对象相等的判断可能只是判断关键属性，最好保持相等对象的非关键属性的顺序与排序前一致；另外一个原因是由于归并排序相对而言比较次数比快速排序少，移动（对象引用的移动）次数比快速排序多，而对于对象来说，比较一般比移动耗时。    此外，对大数组排序。快速排序的sort()采用递归实现，数组规模太大时会发生堆栈溢出，而归并排序sort()采用非递归实现，不存在此问题。</code></pre><pre><code>总结：首先先判断需要排序的数据量是否大于60。小于60：使用插入排序，插入排序是稳定的大于60的数据量会根据数据类型选择排序方式：基本类型：使用快速排序。因为基本类型。1、2都是指向同一个常量池不需要考虑稳定性。Object类型：使用归并排序。因为归并排序具有稳定性。注意：不管是快速排序还是归并排序。在二分的时候小于60的数据量依旧会使用插入排序</code></pre>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring中AOP的两种代理</title>
      <link href="/2019/04/14/spring-zhong-aop-de-liang-chong-dai-li/"/>
      <url>/2019/04/14/spring-zhong-aop-de-liang-chong-dai-li/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring中AOP的两种代理"><a href="#Spring中AOP的两种代理" class="headerlink" title="Spring中AOP的两种代理"></a>Spring中AOP的两种代理</h1><h2 id="方式动态代理和CGLIB详解"><a href="#方式动态代理和CGLIB详解" class="headerlink" title="方式动态代理和CGLIB详解"></a>方式动态代理和CGLIB详解</h2><h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><h5 id="1、什么是代理"><a href="#1、什么是代理" class="headerlink" title="1、什么是代理"></a>1、什么是代理</h5><pre><code>    代理的概念容易理解，比如：微商，简单来说微商就是替厂家卖商品。当我们从微商(代理)那里买东西时通常不知道背后的商家究竟是谁，也就是说，委托者对我们来说是不可见的。作为微商，有其自己的目标客户，这也相当于为厂家做了一次过滤。把微商和厂家进一步抽象，微商可以抽象为代理类，厂家可抽象为委托类(被代理类)。通过微商和厂家特点可知，通过使用代理，通常有两个优点：其一:可以隐藏委托类的实现;其二:可以实现客户与委托类间的解耦，在不修改委托类代码的情况下能够做一些额外的处理。</code></pre><h5 id="2、静态代理"><a href="#2、静态代理" class="headerlink" title="2、静态代理"></a>2、静态代理</h5><pre><code>若代理类在程序运行前就已经存在，那么这种代理方式被成为静态代理。这种情况下的代理类通常都是我们在Java代码中定义的。 通常情况下，静态代理中的代理类和委托类会实现同一接口或是派生自相同的父类。 下面我们用Vendor类代表生产厂家，BusinessAgent类代表微商代理，来介绍下静态代理的简单实现。委托类和代理类都实现了Sell接口，Sell接口的定义如下：</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> test<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author ZongMan * @version 1.0 * @date 2019/4/14 0014 21:29 */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Sell</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">sell</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>Vendor类的定义如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> test<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author ZongMan * @version 1.0 * @date 2019/4/14 0014 22:06 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Vendor</span> <span class="token keyword">implements</span> <span class="token class-name">Sell</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sell</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"sell method"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"add method"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>BusinessAgent类的定义如下:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> test<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author ZongMan * @version 1.0 * @date 2019/4/14 0014 22:07 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BusinessAgent</span> <span class="token keyword">implements</span> <span class="token class-name">Sell</span> <span class="token punctuation">{</span>    Vendor vendor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vendor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sell</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isCollegeStudent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            vendor<span class="token punctuation">.</span><span class="token function">sell</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isCollegeStudent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>    从BusinessAgent类的定义我们可以了解到，静态代理可以通过聚合来实现，让代理类持有一个委托类的引用即可。    如果需要增加一个需求：给Vendor类增加一个过滤功能，不可以卖给学生。通过静态代理，我们无需修改Vendor类的代码就可以实现，只需在BusinessAgent类中的sell方法中添加一个判断即可。如上图可以。    这对应着我们上面提到的使用代理的第二个优点：可以实现客户与委托类间的解耦，在不修改委托类代码的情况下能够做一些额外的处理。静态代理的局限在于运行前必须编写好代理类，下面我们重点来介绍下运行时生成代理类的动态代理方式，即动态代理机制。</code></pre><h4 id="二、动态代理"><a href="#二、动态代理" class="headerlink" title="二、动态代理"></a>二、动态代理</h4><pre><code>    代理类在程序运行时创建的代理方式被成为 动态代理。 也就是说，这种情况下，代理类并不是在Java代码中定义的，而是在运行时根据我们在Java代码中的“指示”动态生成的。相比于静态代理， 动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类的函数。 这么说比较抽象，下面我们结合一个实例来介绍一下动态代理的这个优势是怎么体现的。    现在，假设我们要实现这样一个需求：在执行委托类中的方法之前输出“before”，在执行完毕后输出“after”。我们还是以上面例子中的Vendor类作为委托类，BusinessAgent类作为代理类来进行介绍。首先我们来使用静态代理来实现这一需求，相关代码如下：</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> test<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author ZongMan * @version 1.0 * @date 2019/4/14 0014 22:07 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BusinessAgent</span> <span class="token keyword">implements</span> <span class="token class-name">Sell</span> <span class="token punctuation">{</span>    Vendor vendor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vendor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sell</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"before"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isCollegeStudent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            vendor<span class="token punctuation">.</span><span class="token function">sell</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isCollegeStudent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"before"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vendor<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>    从以上代码中我们可以了解到，通过静态代理实现我们的需求需要我们在每个方法中都添加相应的逻辑，这里只存在两个方法所以工作量还不算大，假如Sell接口中包含上百个方法呢?这时候使用静态代理就会编写许多冗余代码。通过使用动态代理，我们可以做一个“统一指示”，从而对所有代理类的方法进行统一处理，而不用逐一修改每个方法。下面我们来具体介绍下如何使用动态代理方式实现我们的需求。</code></pre><h5 id="使用动态代理"><a href="#使用动态代理" class="headerlink" title="使用动态代理"></a>使用动态代理</h5><pre><code>(1)InvocationHandler接口在使用动态代理时，我们需要定义一个位于代理类与委托类之间的中介类，这个中介类被要求实现InvocationHandler接口，这个接口的定义如下：</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> test<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Method<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author ZongMan * @version 1.0 * @date 2019/4/14 0014 22:13 */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">InvocationHandler</span> <span class="token punctuation">{</span>    Object <span class="token function">invoke</span><span class="token punctuation">(</span>Object proxy<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span>Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre><code>从InvocationHandler这个名称我们就可以知道，实现了这个接口的中介类用做“调用处理器”。当我们调用代理类对象的方法时，这个“调用”会转送到invoke方法中，代理类对象作为proxy参数传入，参数method标识了我们具体调用的是代理类的哪个方法，args为这个方法的参数。这样一来，我们对代理类中的所有方法的调用都会变为对invoke的调用，这样我们可以在invoke方法中添加统一的处理逻辑(也可以根据method参数对不同的代理类方法做不同的处理)。因此我们只需在中介类的invoke方法实现中输出“before”，然后调用委托类的invoke方法，再输出“after”。下面我们来一步一步具体实现它。(2)委托类的定义动态代理方式下，要求委托类必须实现某个接口，这里我们实现的是Sell接口。委托类Vendor类的定义如下：</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> test<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author ZongMan * @version 1.0 * @date 2019/4/14 0014 22:06 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Vendor</span> <span class="token keyword">implements</span> <span class="token class-name">Sell</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sell</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"sell method"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"add method"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>(3)中介类上面我们提到过，中介类必须实现InvocationHandler接口，作为调用处理器”拦截“对代理类方法的调用。中介类的定义如下：</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> test<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Method<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author ZongMan * @version 1.0 * @date 2019/4/14 0014 22:17 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DynamicProxy</span> <span class="token keyword">implements</span> <span class="token class-name">InvocationHandler</span><span class="token punctuation">,</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>InvocationHandler <span class="token punctuation">{</span>    <span class="token keyword">private</span> Object object<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">DynamicProxy</span><span class="token punctuation">(</span>Object object<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>object <span class="token operator">=</span> object<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Object <span class="token function">invoke</span><span class="token punctuation">(</span>Object proxy<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"before"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Object result <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>object<span class="token punctuation">,</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>从以上代码中我们可以看到，中介类持有一个委托类对象引用，在invoke方法中调用了委托类对象的相应方法，通过聚合方式持有委托类对象引用，把外部对invoke的调用最终都转为对委托类对象的调用。下面我们来介绍一下如何”指示“以动态生成代理类。(4)动态生成代理类动态生成代理类的相关代码如下：</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> test<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Proxy<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author ZongMan * @version 1.0 * @date 2019/4/14 0014 22:20 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//创建中介类实例</span>        DynamicProxy inter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DynamicProxy</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Vendor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//获取代理类实例sell</span>        Sell sell <span class="token operator">=</span> <span class="token punctuation">(</span>Sell<span class="token punctuation">)</span> Proxy<span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span>Sell<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>Sell<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">,</span>inter<span class="token punctuation">)</span><span class="token punctuation">;</span>        sell<span class="token punctuation">.</span><span class="token function">sell</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sell<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>在以上代码中，我们调用Proxy类的newProxyInstance方法来获取一个代理类实例。这个代理类实现了我们指定的接口并且会把方法调用分发到指定的调用处理器。这个方法的声明如下：</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> Object <span class="token function">newProxyInstance</span><span class="token punctuation">(</span>ClassLoader loader<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> interfaces<span class="token punctuation">,</span> InvocationHandler h<span class="token punctuation">)</span> <span class="token keyword">throws</span> IllegalArgumentException</code></pre><pre><code>方法的三个参数含义分别如下：loader：定义了代理类的ClassLoder;interfaces：代理类实现的接口列表h：调用处理器，也就是我们上面定义的实现了InvocationHandler接口的类实例这里再简单的总结下：首先通过newProxyInstance方法获取代理类实例，而后我们便可以通过这个代理类实例调用代理类的方法，对代理类的方法的调用实际上都会调用中介类(调用处理器)的invoke方法，在invoke方法中我们调用委托类的相应方法，并且可以添加自己的处理逻辑。如上将上面代理、静态代理，动态代理都理解，下面讲解Spring中AOP的两种代理方式（Java动态代理和CGLIB代理）</code></pre><h5 id="1、动态代理"><a href="#1、动态代理" class="headerlink" title="1、动态代理"></a>1、动态代理</h5><pre><code>相关概念及用法上面已经讲到，其具体有如下四步骤：1、通过实现 InvocationHandler 接口创建自己的调用处理器；2、通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来创建动态代理类；3、通过反射机制获得动态代理类的构造函数，其唯一参数类型是调用处理器接口类型；4、通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入。</code></pre><h5 id="2、GCLIB代理"><a href="#2、GCLIB代理" class="headerlink" title="2、GCLIB代理"></a>2、GCLIB代理</h5><pre><code>cglib（Code Generation Library）是一个强大的,高性能,高质量的Code生成类库。它可以在运行期扩展Java类与实现Java接口。cglib封装了asm，可以在运行期动态生成新的class。cglib用于AOP，jdk中的proxy必须基于接口，cglib却没有这个限制。</code></pre><h5 id="3、原理区别："><a href="#3、原理区别：" class="headerlink" title="3、原理区别："></a>3、原理区别：</h5><pre><code>java动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。而cglib动态代理是利用asm开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。1、如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP 2、如果目标对象实现了接口，可以强制使用CGLIB实现AOP 3、如果目标对象没有实现了接口，必须采用CGLIB库，spring会自动在JDK动态代理和CGLIB之间转换Spring自己的CGLIB的实现方式,他是生成了一个被代理类的子类,你也可以在子类中增加父类没有的功能.如何强制使用CGLIB实现AOP？ * 添加CGLIB库，SPRING_HOME/cglib/*.jar * 在spring配置文件中加入&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt;4、JDK动态代理和CGLIB字节码生成的区别？ * JDK动态代理只能对实现了接口的类生成代理，而不能针对类 * CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法 因为是继承，所以该类或方法最好不要声明成final。*要将CGLIB的二进制发行包放在classpath下。5、Spring AOP里面的代理实现方式spring用代理类包裹切面，把他们织入到Spring管理的bean中。也就是说代理类伪装成目标类，它会截取对目标类中方法的调用，让调用者对目标类的调用都先变成调用伪装类，伪装类中就先执行了切面，再把调用转发给真正的目标bean。现在可以自己想一想，怎么搞出来这个伪装类，才不会被调用者发现（过JVM的检查，JAVA是强类型检查，哪里都要检查类型）。1.实现和目标类相同的接口，我也实现和你一样的接口，反正上层都是接口级别的调用，这样我就伪装成了和目标类一样的类（实现了同一接口，咱是兄弟了），也就逃过了类型检查，到java运行期的时候，利用多态的后期绑定（所以spring采用运行时），伪装类（代理类）就变成了接口的真正实现，而他里面包裹了真实的那个目标类，最后实现具体功能的还是目标类，只不过伪装类在之前干了点事情（写日志，安全检查，事物等）。2.生成子类调用，这次用子类来做为伪装类，当然这样也能逃过JVM的强类型检查，我继承的吗，当然查不出来了，子类重写了目标类的所有方法，当然在这些重写的方法中，不仅实现了目标类的功能，还在这些功能之前，实现了一些其他的（写日志，安全检查，事物等）。前一种兄弟模式，spring会使用JDK的java.lang.reflect.Proxy类，它允许Spring动态生成一个新类来实现必要的接口，织入通知，并且把对这些接口的任何调用都转发到目标类。后一种父子模式，spring使用CGLIB库生成目标类的一个子类，在创建这个子类的时候，spring织入通知，并且把对这个子类的调用委托到目标类。相比之下，还是兄弟模式好些，他能更好的实现松耦合，尤其在今天都高喊着面向接口编程的情况下，父子模式只是在没有实现接口的时候，也能织入通知，应当做一种例外。</code></pre><h4 id="三、spring-aop的使用方式："><a href="#三、spring-aop的使用方式：" class="headerlink" title="三、spring aop的使用方式："></a>三、spring aop的使用方式：</h4><h5 id="使用aop的目的："><a href="#使用aop的目的：" class="headerlink" title="使用aop的目的："></a>使用aop的目的：</h5><pre><code>1就是为了方便，看一个国外很有名的大师说，编程的人都是“懒人”，因为他把自己做的事情都让程序做了。用了aop能让你少写很多代码，这点就够充分了吧2就是为了更清晰的逻辑，可以让你的业务逻辑去关注自己本身的业务，而不去想一些其他的事情，这些其他的事情包括：安全，事物，日志等。</code></pre><h5 id="第一种实现方式：使用AspectJ提供的注解package-test-mine-spring-bean"><a href="#第一种实现方式：使用AspectJ提供的注解package-test-mine-spring-bean" class="headerlink" title="第一种实现方式：使用AspectJ提供的注解package test.mine.spring.bean;"></a>第一种实现方式：使用AspectJ提供的注解package test.mine.spring.bean;</h5><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> org<span class="token punctuation">.</span>aspectj<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>AfterReturning<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>aspectj<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Aspect<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>aspectj<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Before<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>aspectj<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Pointcut<span class="token punctuation">;</span><span class="token annotation punctuation">@Aspect</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SleepHelper</span> <span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token function">SleepHelper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Pointcut</span><span class="token punctuation">(</span><span class="token string">"execution(* *.sleep())"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sleeppoint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Before</span><span class="token punctuation">(</span><span class="token string">"sleeppoint()"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">beforeSleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"睡觉前要脱衣服!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@AfterReturning</span><span class="token punctuation">(</span><span class="token string">"sleeppoint()"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterSleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"睡醒了要穿衣服！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>用@Aspect的注解来标识切面,注意不要把它漏了，否则Spring创建代理的时候会找不到它,@Pointcut注解指定了切点，@Before和@AfterReturning指定了运行时的通知，注意的是要在注解中传入切点的名称。然后我们在Spring配置文件上下点功夫,首先是增加AOP的XML命名空间和声明相关schema命名空间:xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;schema声明:http://www.springframework.org/schema/aophttp://www.springframework.org/schema/aop/spring-aop-2.0.xsd然后加上这个标签:&lt;aop:aspectj-autoproxy/&gt; 有了这个Spring就能够自动扫描被@Aspect标注的切面了最后是运行，很简单方便了：</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>ApplicationContext appCtx <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">"applicationContext.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Sleepable human <span class="token operator">=</span> <span class="token punctuation">(</span>Sleepable<span class="token punctuation">)</span>appCtx<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"human"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>human<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="第二种使用方式："><a href="#第二种使用方式：" class="headerlink" title="第二种使用方式："></a>第二种使用方式：</h5><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sleepHelper<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>test.spring.aop.bean.SleepHelper<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">aop:</span>config</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">aop:</span>aspect</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sleepHelper<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">aop:</span>before</span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>beforeSleep<span class="token punctuation">"</span></span> <span class="token attr-name">pointcut</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>execution(* *.sleep(..))<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">aop:</span>after</span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>afterSleep<span class="token punctuation">"</span></span> <span class="token attr-name">pointcut</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>execution(* *.sleep(..))<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">aop:</span>aspect</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">aop:</span>config</span><span class="token punctuation">></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 </tag>
            
            <tag> AOP </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>30道java面试题</title>
      <link href="/2019/04/13/30-dao-java-mian-shi-ti/"/>
      <url>/2019/04/13/30-dao-java-mian-shi-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="30道java面试题"><a href="#30道java面试题" class="headerlink" title="30道java面试题"></a>30道java面试题</h1><h4 id="1、Spring-DAO-中最常用的类是（）"><a href="#1、Spring-DAO-中最常用的类是（）" class="headerlink" title="1、Spring DAO 中最常用的类是（）"></a>1、Spring DAO 中最常用的类是（）</h4><pre><code>A，JdbcTemplate ，SimpleJdbcTemplateB，SimpleJdbcInsert，SimpleJdbcProcedureC，SimpleJdbcInsert ，SimpleJdbcStoredProcD，SimpleJdbcQuery ，SimpleJdbcExec正确答案：A</code></pre><h4 id="2、Spring-AOP-中，-织入（Weaving）-可以在下面什么时间完成（）"><a href="#2、Spring-AOP-中，-织入（Weaving）-可以在下面什么时间完成（）" class="headerlink" title="2、Spring AOP 中， 织入（Weaving） 可以在下面什么时间完成（）"></a>2、Spring AOP 中， 织入（Weaving） 可以在下面什么时间完成（）</h4><pre><code>A，全部选项B，Run timeC，Load timeD，Compile time正确答案：A</code></pre><h4 id="3、下面关于Spring-MVC-描述正确的是（）"><a href="#3、下面关于Spring-MVC-描述正确的是（）" class="headerlink" title="3、下面关于Spring MVC 描述正确的是（）"></a>3、下面关于Spring MVC 描述正确的是（）</h4><pre><code>A，DispatcherServlet在 Spring MVC 中是核心servlet , 它负责接收请求并将请求分发给适合的控制器B，在Spring MVC 中,可以配置多个DispatcherServletC，全部选项D，要使Spring MVC可用，DispatcherServlet需要在web.xml中配置正确答案：C</code></pre><h4 id="4、下面哪项是Spring自动装载模式（）"><a href="#4、下面哪项是Spring自动装载模式（）" class="headerlink" title="4、下面哪项是Spring自动装载模式（）"></a>4、下面哪项是Spring自动装载模式（）</h4><pre><code>A，autodetectB，全部选项C，constructorD，byname, byType正确答案：B</code></pre><h4 id="5、Spring-中，下面哪一项不是使用事务的方法（）"><a href="#5、Spring-中，下面哪一项不是使用事务的方法（）" class="headerlink" title="5、Spring 中，下面哪一项不是使用事务的方法（）"></a>5、Spring 中，下面哪一项不是使用事务的方法（）</h4><pre><code>A，proxiesB，declarativelyC，programmaticly正确答案：A</code></pre><h4 id="6、Spring提供了JMS层的抽象，正确吗（）"><a href="#6、Spring提供了JMS层的抽象，正确吗（）" class="headerlink" title="6、Spring提供了JMS层的抽象，正确吗（）"></a>6、Spring提供了JMS层的抽象，正确吗（）</h4><pre><code>A，正确B，错误正确答案：A</code></pre><h4 id="7、关于”-Order”注解，最正确的描述是（）"><a href="#7、关于”-Order”注解，最正确的描述是（）" class="headerlink" title="7、关于”@Order”注解，最正确的描述是（）"></a>7、关于”@Order”注解，最正确的描述是（）</h4><pre><code>A，实现org.springframework.core.Ordered接口B，指定一个bean的范围C，通常用于注入域对象的属性D，全不正确正确答案：A</code></pre><h4 id="8、如何在Spring应用中使用SLF4J（）"><a href="#8、如何在Spring应用中使用SLF4J（）" class="headerlink" title="8、如何在Spring应用中使用SLF4J（）"></a>8、如何在Spring应用中使用SLF4J（）</h4><pre><code>A，作为日志框架B，全不正确C，作为一个beanD，作为JDBC框架正确答案：A</code></pre><h4 id="9、Spring-bean-的默认作用范围是（）"><a href="#9、Spring-bean-的默认作用范围是（）" class="headerlink" title="9、Spring bean 的默认作用范围是（）"></a>9、Spring bean 的默认作用范围是（）</h4><pre><code>A，全不正确B，SingletonC，PrototypeD，SessionE， Abstract正确答案：B</code></pre><h4 id="10、Spring中，单例意味着每-只有一个实例（）"><a href="#10、Spring中，单例意味着每-只有一个实例（）" class="headerlink" title="10、Spring中，单例意味着每_只有一个实例（）"></a>10、Spring中，单例意味着每<strong>_</strong>只有一个实例（）</h4><pre><code>A，ContextB， JVMC，Thread正确答案：A</code></pre><h4 id="11、使用Spring-MVC-处理普通页面请求，-下面哪个排序是正确的（）"><a href="#11、使用Spring-MVC-处理普通页面请求，-下面哪个排序是正确的（）" class="headerlink" title="11、使用Spring MVC 处理普通页面请求， 下面哪个排序是正确的（）"></a>11、使用Spring MVC 处理普通页面请求， 下面哪个排序是正确的（）</h4><pre><code>1.请求：请求提交给服务器2.分发：分发器通过web 应用配置信息 ， 将请求分发至适当的控制器3.服务调用：控制器与业务层交互4.响应：控制器更新模型，将执行结果返回给客户端展现A，1-2-3-4B，1-4-3-2C，1-4-2-3D，1-3-2-4正确答案：A</code></pre><h4 id="12、以下哪个不是-Spring-AOP-的注解（）"><a href="#12、以下哪个不是-Spring-AOP-的注解（）" class="headerlink" title="12、以下哪个不是 Spring AOP 的注解（）"></a>12、以下哪个不是 Spring AOP 的注解（）</h4><pre><code>A，@BeforeB，@AroundC，@BeforeReturningD，@AfterThrowing正确答案：C</code></pre><h4 id="13、”-RequestMapping是Spring中的哪一部分（）"><a href="#13、”-RequestMapping是Spring中的哪一部分（）" class="headerlink" title="13、”@RequestMapping是Spring中的哪一部分（）"></a>13、”@RequestMapping是Spring中的哪一部分（）</h4><pre><code>A，DAOB，SecurityC，Web MVCD，Web正确答案：C</code></pre><h4 id="14、下面关于spring和struts2的描述，错误的是（）"><a href="#14、下面关于spring和struts2的描述，错误的是（）" class="headerlink" title="14、下面关于spring和struts2的描述，错误的是（）"></a>14、下面关于spring和struts2的描述，错误的是（）</h4><pre><code>A，spring mvc的入口是filter，而struts2是servletB，spring mvc是基于方法的设计，而struts2是基于类的设计C，struts2有以自己的interceptor机制，spring mvc用的是独立的AOP方式D， spring mvc的方法之间基本上独立的，独享request response数据，struts2所有Action变量是共享的正确答案：A</code></pre><h4 id="15、Spring中，下面哪个选项支持ORM（）"><a href="#15、Spring中，下面哪个选项支持ORM（）" class="headerlink" title="15、Spring中，下面哪个选项支持ORM（）"></a>15、Spring中，下面哪个选项支持ORM（）</h4><pre><code>A，OJBB，TopLinkC，全部选项D，Java Data Objects(JDO)E，iBatis正确答案：C</code></pre><h4 id="16、Spring和Hibernate的集成中，下面哪项是SessionFactory-正确的实现（）"><a href="#16、Spring和Hibernate的集成中，下面哪项是SessionFactory-正确的实现（）" class="headerlink" title="16、Spring和Hibernate的集成中，下面哪项是SessionFactory 正确的实现（）"></a>16、Spring和Hibernate的集成中，下面哪项是SessionFactory 正确的实现（）</h4><pre><code>A，LocalSessionFactoryBeanB，LocalFactoryBeanC，SessionFactoryD，SessionFactoryBean正确答案：A</code></pre><h4 id="17、下面哪个是Spring最核心的servlet（）"><a href="#17、下面哪个是Spring最核心的servlet（）" class="headerlink" title="17、下面哪个是Spring最核心的servlet（）"></a>17、下面哪个是Spring最核心的servlet（）</h4><pre><code>A，WebServletB，SpringServletC，DispatcherServletD，IoCServlet正确答案：C</code></pre><h4 id="18、Spring-test-用什么约定在测试中使用HTTP会话和HTTP-请求对象（）"><a href="#18、Spring-test-用什么约定在测试中使用HTTP会话和HTTP-请求对象（）" class="headerlink" title="18、Spring-test 用什么约定在测试中使用HTTP会话和HTTP 请求对象（）"></a>18、Spring-test 用什么约定在测试中使用HTTP会话和HTTP 请求对象（）</h4><pre><code>A，MVCB，Open-closed principleC，DAOsD，Mock objects正确答案：D</code></pre><h4 id="19、Spring-中，”-Cacheable”的key生成方式，以下哪个是正确的（）"><a href="#19、Spring-中，”-Cacheable”的key生成方式，以下哪个是正确的（）" class="headerlink" title="19、Spring 中，”@Cacheable”的key生成方式，以下哪个是正确的（）"></a>19、Spring 中，”@Cacheable”的key生成方式，以下哪个是正确的（）</h4><pre><code>A，可以是方法参数及其成员变量的任意表达式B，只能使用所有方法参数，但可以调整次序C，只能使用所有方法参数，且不能调整次序D，只能指定方法参数是否参与key的生成，不能控制参数的成员变量正确答案：A</code></pre><h4 id="20、使用-Required但不关联bean-来注解setter方法，将会发生（）"><a href="#20、使用-Required但不关联bean-来注解setter方法，将会发生（）" class="headerlink" title="20、使用@Required但不关联bean 来注解setter方法，将会发生（）"></a>20、使用@Required但不关联bean 来注解setter方法，将会发生（）</h4><pre><code>A，bean被设置为nullB，启动异常C，Spring 将创建beanD，什么也不发生正确答案：B</code></pre><h4 id="21，有关线程的哪些叙述是对的（-）"><a href="#21，有关线程的哪些叙述是对的（-）" class="headerlink" title="21，有关线程的哪些叙述是对的（ ）"></a>21，有关线程的哪些叙述是对的（ ）</h4><pre><code>A，一旦一个线程被创建，它就立即开始运行。B，使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。C，当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。D，一个线程可能因为不同的原因停止并进入就绪状态。答案：BCD在抢占式线程模型中，操作系统可以在任何时候打断线程。通常会在它运行了一段时间（就是所谓的一个时间片）后才打断它。这样的结果自然是没有线程能够不公平地长时间霸占处理器。</code></pre><hr><h4 id="22，哪个关键字可以对对象加互斥锁-（）"><a href="#22，哪个关键字可以对对象加互斥锁-（）" class="headerlink" title="22，哪个关键字可以对对象加互斥锁 （）"></a>22，哪个关键字可以对对象加互斥锁 （）</h4><pre><code>A，serializeB，synchronizedC，transientD，static答案：BA是对象串行化、C是关键字transient修饰的属性将不被串行化、D是静态的</code></pre><h4 id="23，下列关于线程优先级的说法中，正确的是（）"><a href="#23，下列关于线程优先级的说法中，正确的是（）" class="headerlink" title="23，下列关于线程优先级的说法中，正确的是（）"></a>23，下列关于线程优先级的说法中，正确的是（）</h4><pre><code>A、线程的优先级是不能改变的B、线程的优先级是在创建线程时设置的C、在创建线程后的任何时候都可以设置D、B和C答案：C    Java语言中线程的优先级是用一个介于MIN_PRIORITY和MAX_PRIORITY之间的整数来表示的。可以在创建线程后的任何时候修改线程的优先级。</code></pre><h4 id="24，为了使模块尽可能独立，要求"><a href="#24，为了使模块尽可能独立，要求" class="headerlink" title="24，为了使模块尽可能独立，要求( )"></a>24，为了使模块尽可能独立，要求( )</h4><pre><code>A．模块的内聚程度要尽量高，且耦合程度要尽量强B．模块的内聚程度要尽量高，且耦合程度要尽量弱C．模块的内聚程度要尽量低，且耦合程度要尽量弱D．模块的内聚程度要尽量低，且耦合程度要尽量强答案：B    系统设计的质量主要反映在模块的独立性上。评价模块独立性的主要标准有两个：一是模块之间的耦合，它表明两个模块之间互相独立的程度；二是模块内部之间的关系是否紧密，称为内聚。一般来说，要求模块之间的耦合尽可能地弱，即模块尽可能独立，而要求模块的内聚程度尽量高。</code></pre><h4 id="25，下列对于线性链表的描述中正确的是（）"><a href="#25，下列对于线性链表的描述中正确的是（）" class="headerlink" title="25，下列对于线性链表的描述中正确的是（）"></a>25，下列对于线性链表的描述中正确的是（）</h4><pre><code>A．存储空间不一定是连续，且各元素的存储顺序是任意的B．存储空间不一定是连续，且前件元素一定存储在后件元素的前面C．存储空间必须连续，且前件元素一定存储在后件元素的前面D．存储空间必须连续，且各元素的存储顺序是任意的答案：A在链式存储结构中，存储数据结构的存储空间可以不连续，各数据结点的存储顺序与数据元素之间 的逻辑关系可以不一致，而数据元素之间的逻辑关系是由指针域来确定的。</code></pre><h4 id="26，下列叙述中错误的是"><a href="#26，下列叙述中错误的是" class="headerlink" title="26，下列叙述中错误的是( )"></a>26，下列叙述中错误的是( )</h4><pre><code>A.线性表是由n个元素组成的一个有限序列B.线性表是一种线性结构C.线性表的所有结点有且仅有一个前件和后件D.线性表可以是空表答案：C线性表是一种线性结构，由n(n≥0)个元素组成，所以线性表可以是空表。但是在线性表中，第一个结点没有前驱，最后一个结点没有后继，其他结点有且只有一个前驱和后继，所以选项C是错误的。</code></pre><h4 id="27，已知一棵二叉树前序遍历和中序遍历分别为ABDEGCFH和DBGEACHF，则该二叉树的后序遍历为"><a href="#27，已知一棵二叉树前序遍历和中序遍历分别为ABDEGCFH和DBGEACHF，则该二叉树的后序遍历为" class="headerlink" title="27，已知一棵二叉树前序遍历和中序遍历分别为ABDEGCFH和DBGEACHF，则该二叉树的后序遍历为( )"></a>27，已知一棵二叉树前序遍历和中序遍历分别为ABDEGCFH和DBGEACHF，则该二叉树的后序遍历为( )</h4><pre><code>A.GEDHFBCAB.DGEBHFCAC.ABCDEFGHD.ACBFEDHG答案：B二叉树的遍历有3种：前序、中序和后序。先序：先访问根结点、左结点、右结点中序：先访问左结点、根结点、右结点后序：先访问左结点、右结点、根结点本题根据前序遍历和中序遍历的结果可以得出二叉树的结构，然后再对其进行后序遍历。</code></pre><h4 id="28，面向对象方法中，继承是指"><a href="#28，面向对象方法中，继承是指" class="headerlink" title="28，面向对象方法中，继承是指( )"></a>28，面向对象方法中，继承是指( )</h4><pre><code>A.一组对象所具有的相似性质B.一个对象具有另一个对象的性质C.各对象之间的共同性质D.类之间共享属性和操作的机制答案：D继承：在程序设计中，继承是指子类自动享用父类的属性和方法，并可以增加新的属性和方法的一种机制。它是实现代码共享的重要手段，可以使软件更具有开放性、可扩充性，这是信息组织与分类的行之有效的方法，也是面向对象的主要优点之一。继承又分为单重继承和多重继承，单重继承是指子类只能继承一个父类的属性和操作；而多重继承是指子类可以继承了多个父类的属性和操作。扩展：Java是一种单重继承语言，而C++是一种多重继承语言。</code></pre><h4 id="29，栈和队列的共同点是"><a href="#29，栈和队列的共同点是" class="headerlink" title="29，栈和队列的共同点是( )"></a>29，栈和队列的共同点是( )</h4><pre><code>A.都是先进先出B.都是先进后出C.只允许在端点处插入和删除元素D.没有共同特点答案：C栈是只允许在表的一端进行插入和删除的操作，队列是允许在表的一端进行插入，另一端进行删除的操作。</code></pre><h4 id="30，下列关于修饰符混用的说法，错误的是（）"><a href="#30，下列关于修饰符混用的说法，错误的是（）" class="headerlink" title="30，下列关于修饰符混用的说法，错误的是（）"></a>30，下列关于修饰符混用的说法，错误的是（）</h4><pre><code>A.abstract不能与final并列修饰同一个类B.abstract类中不可以有private的成员C.abstract方法必须在abstract类中D.static方法中能处理非static的数据答案：D静态方法是属于类的，而普通方法是属于对象的。属于类的静态方法可以在对象不存在的时候就能访问到，而普通方法必须先new一个对象才能用这个对象访问。当我们访问调用静态方法的时候（使用类名.静态方法名）这个时候就没有对象创建，所以普通方法是访问不到的。为了避免这种错误，所以java就不允许在静态方法中访问非静态方法。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySql中锁的理解</title>
      <link href="/2019/04/12/mysql-zhong-suo-de-li-jie/"/>
      <url>/2019/04/12/mysql-zhong-suo-de-li-jie/</url>
      
        <content type="html"><![CDATA[<p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/04/12/mysql-zhong-suo-de-li-jie/001.png" alt="001"></p><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><pre><code>注：MySQL是一个支持插件式存储引擎的数据库系统。本文下面的所有介绍，都是基于InnoDB存储引擎，其他引擎的表现，会有较大的区别。</code></pre><h4 id="存储引擎查看"><a href="#存储引擎查看" class="headerlink" title="存储引擎查看"></a>存储引擎查看</h4><pre><code>MySQL给开发者提供了查询存储引擎的功能，我这里使用的是MySQL5.6.4，可以使用：SHOW ENGINES</code></pre><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/04/12/mysql-zhong-suo-de-li-jie/002.png" alt="002"></p><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/04/12/mysql-zhong-suo-de-li-jie/003.png" alt="003"></p><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><pre><code>    用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加1。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。</code></pre><h5 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h5><h6 id="1、数据库表设计"><a href="#1、数据库表设计" class="headerlink" title="1、数据库表设计"></a>1、数据库表设计</h6><pre><code>三个字段，分别是id,value、version</code></pre><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> id<span class="token punctuation">,</span><span class="token keyword">value</span><span class="token punctuation">,</span>version <span class="token keyword">from</span> <span class="token keyword">TABLE</span> <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token comment" spellcheck="true">#{id}</span></code></pre><h6 id="2、每次更新表中的value字段时，为了防止发生冲突，需要这样操作"><a href="#2、每次更新表中的value字段时，为了防止发生冲突，需要这样操作" class="headerlink" title="2、每次更新表中的value字段时，为了防止发生冲突，需要这样操作"></a>2、每次更新表中的value字段时，为了防止发生冲突，需要这样操作</h6><pre class=" language-sql"><code class="language-sql"><span class="token keyword">update</span> <span class="token keyword">TABLE</span> <span class="token keyword">set</span> <span class="token keyword">value</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span>version<span class="token operator">=</span>version<span class="token operator">+</span><span class="token number">1</span> <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token comment" spellcheck="true">#{id} and version=#{version};</span></code></pre><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><pre><code>    与乐观锁相对应的就是悲观锁了。悲观锁就是在操作数据时，认为此操作会出现数据冲突，所以在进行每次操作时都要通过获取锁才能进行对相同数据的操作，这点跟java中的synchronized很相似，所以悲观锁需要耗费较多的时间。另外与乐观锁相对应的，悲观锁是由数据库自己实现了的，要用的时候，我们直接调用数据库的相关语句就可以了。    说到这里，由悲观锁涉及到的另外两个锁概念就出来了，它们就是共享锁与排它锁。共享锁和排它锁是悲观锁的不同的实现，它俩都属于悲观锁的范畴。使用，排它锁 举例    要使用悲观锁，我们必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。我们可以使用命令设置MySQL为非autocommit模式：</code></pre><pre class=" language-sql"><code class="language-sql"><span class="token keyword">set</span> autocommit<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"># 设置完autocommit后，我们就可以执行我们的正常业务了。具体如下：</span><span class="token comment" spellcheck="true"># 1. 开始事务</span><span class="token keyword">begin</span><span class="token punctuation">;</span><span class="token operator">/</span><span class="token keyword">begin</span> <span class="token keyword">work</span><span class="token punctuation">;</span><span class="token operator">/</span><span class="token keyword">start</span> <span class="token keyword">transaction</span><span class="token punctuation">;</span> <span class="token punctuation">(</span>三者选一就可以<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 2. 查询表信息</span><span class="token keyword">select</span> <span class="token keyword">status</span> <span class="token keyword">from</span> <span class="token keyword">TABLE</span> <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token number">1</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"># 3. 插入一条数据</span><span class="token keyword">insert</span> <span class="token keyword">into</span> <span class="token keyword">TABLE</span> <span class="token punctuation">(</span>id<span class="token punctuation">,</span><span class="token keyword">value</span><span class="token punctuation">)</span> <span class="token keyword">values</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"># 4. 修改数据为</span><span class="token keyword">update</span> <span class="token keyword">TABLE</span> <span class="token keyword">set</span> <span class="token keyword">value</span><span class="token operator">=</span><span class="token number">2</span> <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"># 5. 提交事务</span><span class="token keyword">commit</span><span class="token punctuation">;</span><span class="token operator">/</span><span class="token keyword">commit</span> <span class="token keyword">work</span><span class="token punctuation">;</span></code></pre><h4 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h4><pre><code>共享锁又称读锁 read lock，是读取操作创建的锁。其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排他锁。获得共享锁的事务只能读数据，不能修改数据打开第一个查询窗口</code></pre><pre class=" language-sql"><code class="language-sql"><span class="token keyword">begin</span><span class="token punctuation">;</span><span class="token operator">/</span><span class="token keyword">begin</span> <span class="token keyword">work</span><span class="token punctuation">;</span><span class="token operator">/</span><span class="token keyword">start</span> <span class="token keyword">transaction</span><span class="token punctuation">;</span> <span class="token punctuation">(</span>三者选一就可以<span class="token punctuation">)</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">TABLE</span> <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span> <span class="token keyword">lock</span> <span class="token operator">in</span> <span class="token keyword">share mode</span><span class="token punctuation">;</span></code></pre><p>然后在另一个查询窗口中，对id为1的数据进行更新</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">update</span> <span class="token keyword">TABLE</span> <span class="token keyword">set</span> name<span class="token operator">=</span><span class="token string">"www.souyunku.com"</span> <span class="token keyword">where</span> id <span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span></code></pre><pre><code>此时，操作界面进入了卡顿状态，过了超时间，提示错误信息如果在超时前，执行 commit，此更新语句就会成功。</code></pre><pre class=" language-sql"><code class="language-sql"><span class="token punctuation">[</span>SQL<span class="token punctuation">]</span><span class="token keyword">update</span> test_one <span class="token keyword">set</span> name<span class="token operator">=</span><span class="token string">"www.souyunku.com"</span> <span class="token keyword">where</span> id <span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">[</span>Err<span class="token punctuation">]</span> <span class="token number">1205</span> <span class="token operator">-</span> <span class="token keyword">Lock</span> wait timeout exceeded<span class="token punctuation">;</span> try restarting <span class="token keyword">transaction</span></code></pre><p>加上共享锁后，也提示错误信息</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">update</span> test_one <span class="token keyword">set</span> name<span class="token operator">=</span><span class="token string">"www.souyunku.com"</span> <span class="token keyword">where</span> id <span class="token operator">=</span><span class="token number">1</span> <span class="token keyword">lock</span> <span class="token operator">in</span> <span class="token keyword">share mode</span><span class="token punctuation">;</span><span class="token punctuation">[</span>SQL<span class="token punctuation">]</span><span class="token keyword">update</span> test_one <span class="token keyword">set</span> name<span class="token operator">=</span><span class="token string">"www.souyunku.com"</span> <span class="token keyword">where</span> id <span class="token operator">=</span><span class="token number">1</span> <span class="token keyword">lock</span> <span class="token operator">in</span> <span class="token keyword">share mode</span><span class="token punctuation">;</span><span class="token punctuation">[</span>Err<span class="token punctuation">]</span> <span class="token number">1064</span> <span class="token operator">-</span> You have an error <span class="token operator">in</span> your SQL syntax<span class="token punctuation">;</span> <span class="token keyword">check</span> the manual that corresponds <span class="token keyword">to</span> your MySQL server version <span class="token keyword">for</span> the <span class="token keyword">right</span> syntax <span class="token keyword">to</span> <span class="token keyword">use</span> near <span class="token string">'lock in share mode'</span> at line <span class="token number">1</span></code></pre><pre><code>    在查询语句后面增加 LOCK IN SHARE MODE，Mysql会对查询结果中的每行都加共享锁，当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请共享锁，否则会被阻塞。其他线程也可以读取使用了共享锁的表，而且这些线程读取的是同一个版本的数据。加上共享锁后，对于update,insert,delete语句会自动加排它锁。</code></pre><h4 id="排它锁"><a href="#排它锁" class="headerlink" title="排它锁"></a>排它锁</h4><pre><code>排他锁 exclusive lock（也叫writer lock）又称写锁。排它锁是悲观锁的一种实现，在上面悲观锁也介绍过。若事务 1 对数据对象A加上X锁，事务 1 可以读A也可以修改A，其他事务不能再对A加任何锁，直到事物 1 释放A上的锁。这保证了其他事务在事物 1 释放A上的锁之前不能再读取和修改A。排它锁会阻塞所有的排它锁和共享锁读取为什么要加读锁呢：防止数据在被读取的时候被别的线程加上写锁，使用方式：在需要执行的语句后面加上for update就可以了</code></pre><h4 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h4><pre><code>行锁又分共享锁和排他锁,由字面意思理解，就是给某一行加上锁，也就是一条记录加上锁。注意：行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁。共享锁：名词解释：共享锁又叫做读锁，所有的事务只能对其进行读操作不能写操作，加上共享锁后在事务结束之前其他事务只能再加共享锁，除此之外其他任何类型的锁都不能再加了。</code></pre><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">TABLE</span> <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token string">"1"</span> <span class="token keyword">lock</span> <span class="token operator">in</span> <span class="token keyword">share mode</span><span class="token punctuation">;</span> 结果集的数据都会加共享锁</code></pre><h4 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h4><pre><code>如何加表锁innodb 的行锁是在有索引的情况下,没有索引的表是锁定全表的.</code></pre><h4 id="Innodb中的行锁与表锁"><a href="#Innodb中的行锁与表锁" class="headerlink" title="Innodb中的行锁与表锁"></a>Innodb中的行锁与表锁</h4><pre><code>前面提到过，在Innodb引擎中既支持行锁也支持表锁，那么什么时候会锁住整张表，什么时候或只锁住一行呢？只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！在实际应用中，要特别注意InnoDB行锁的这一特性，不然的话，可能导致大量的锁冲突，从而影响并发性能。行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁。行级锁的缺点是：由于需要请求大量的锁资源，所以速度慢，内存消耗大。</code></pre><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><pre><code>死锁（Deadlock） 所谓死锁：是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。由于资源占用是互斥的，当某个进程提出申请资源后，使得有关进程在无外力协助下，永远分配不到必需的资源而无法继续运行，这就产生了一种特殊现象死锁。解除正在死锁的状态有两种方法：</code></pre><p><strong>第一种</strong>：</p><p>1.查询是否锁表</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">show</span> <span class="token keyword">OPEN</span> <span class="token keyword">TABLES</span> <span class="token keyword">where</span> In_use <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span></code></pre><p>2.查询进程（如果您有SUPER权限，您可以看到所有线程。否则，您只能看到您自己的线程）</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">show</span> processlist</code></pre><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/04/12/mysql-zhong-suo-de-li-jie/004.png" alt="004"></p><p>3.杀死进程id（就是上面命令的id列）</p><pre><code>kill id</code></pre><p><strong>第二种</strong>：</p><p>1：查看当前的事务</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> INFORMATION_SCHEMA<span class="token punctuation">.</span>INNODB_TRX<span class="token punctuation">;</span></code></pre><p>2：查看当前锁定的事务</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> INFORMATION_SCHEMA<span class="token punctuation">.</span>INNODB_LOCKS<span class="token punctuation">;</span></code></pre><p>3：查看当前等锁的事务</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> INFORMATION_SCHEMA<span class="token punctuation">.</span>INNODB_LOCK_WAITS<span class="token punctuation">;</span></code></pre><p>杀死进程</p><pre><code>kill 进程ID</code></pre><pre><code>如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。其次，进程运行推进顺序与速度不同，也可能产生死锁。产生死锁的四个必要条件：（1） 互斥条件：一个资源每次只能被一个进程使用。（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。（3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。虽然不能完全避免死锁，但可以使死锁的数量减至最少。将死锁减至最少可以增加事务的吞吐量并减少系统开销，因为只有很少的事务回滚，而回滚会取消事务执行的所有工作。由于死锁时回滚而由应用程序重新提交。下列方法有助于最大限度地降低死锁：（1）按同一顺序访问对象。（2）避免事务中的用户交互。（3）保持事务简短并在一个批处理中。（4）使用低隔离级别。（5）使用绑定连接。</code></pre><p>原文：<a href="https://segmentfault.com/a/1190000015815061" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015815061</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 乐观锁，悲观锁，共享锁，排它锁，行锁，表锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swagger使用指南</title>
      <link href="/2019/04/11/swagger-shi-yong-zhi-nan/"/>
      <url>/2019/04/11/swagger-shi-yong-zhi-nan/</url>
      
        <content type="html"><![CDATA[<h1 id="Swagger"><a href="#Swagger" class="headerlink" title="Swagger"></a>Swagger</h1><h4 id="1：认识Swagger"><a href="#1：认识Swagger" class="headerlink" title="1：认识Swagger"></a>1：认识Swagger</h4><pre><code>    Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。总体目标是使客户端和文件系统作为服务器以同样的速度来更新。文件的方法，参数和模型紧密集成到服务器端的代码，允许API来始终保持同步。</code></pre><h4 id="2：Maven依赖"><a href="#2：Maven依赖" class="headerlink" title="2：Maven依赖"></a>2：Maven依赖</h4><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>io.springfox<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>springfox-swagger2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.7.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>io.springfox<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>springfox-swagger-ui<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.7.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><h4 id="3：创建Swagger2配置类（springboot搭建）"><a href="#3：创建Swagger2配置类（springboot搭建）" class="headerlink" title="3：创建Swagger2配置类（springboot搭建）"></a>3：创建Swagger2配置类（springboot搭建）</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>zms<span class="token punctuation">.</span>cmsdemo<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>SpringApplication<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>SpringBootApplication<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Bean<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>EnableMBeanExport<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>jmx<span class="token punctuation">.</span>support<span class="token punctuation">.</span>RegistrationPolicy<span class="token punctuation">;</span><span class="token keyword">import</span> springfox<span class="token punctuation">.</span>documentation<span class="token punctuation">.</span>builders<span class="token punctuation">.</span>ApiInfoBuilder<span class="token punctuation">;</span><span class="token keyword">import</span> springfox<span class="token punctuation">.</span>documentation<span class="token punctuation">.</span>builders<span class="token punctuation">.</span>PathSelectors<span class="token punctuation">;</span><span class="token keyword">import</span> springfox<span class="token punctuation">.</span>documentation<span class="token punctuation">.</span>builders<span class="token punctuation">.</span>RequestHandlerSelectors<span class="token punctuation">;</span><span class="token keyword">import</span> springfox<span class="token punctuation">.</span>documentation<span class="token punctuation">.</span>service<span class="token punctuation">.</span>ApiInfo<span class="token punctuation">;</span><span class="token keyword">import</span> springfox<span class="token punctuation">.</span>documentation<span class="token punctuation">.</span>spi<span class="token punctuation">.</span>DocumentationType<span class="token punctuation">;</span><span class="token keyword">import</span> springfox<span class="token punctuation">.</span>documentation<span class="token punctuation">.</span>spring<span class="token punctuation">.</span>web<span class="token punctuation">.</span>plugins<span class="token punctuation">.</span>Docket<span class="token punctuation">;</span><span class="token keyword">import</span> springfox<span class="token punctuation">.</span>documentation<span class="token punctuation">.</span>swagger2<span class="token punctuation">.</span>annotations<span class="token punctuation">.</span>EnableSwagger2<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author ZongMan */</span><span class="token annotation punctuation">@EnableSwagger2</span><span class="token annotation punctuation">@SpringBootApplication</span><span class="token annotation punctuation">@EnableMBeanExport</span><span class="token punctuation">(</span>registration <span class="token operator">=</span> RegistrationPolicy<span class="token punctuation">.</span>IGNORE_EXISTING<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CmsDemoApplication</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>CmsDemoApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> Docket <span class="token function">cmsApi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Docket</span><span class="token punctuation">(</span>DocumentationType<span class="token punctuation">.</span>SWAGGER_2<span class="token punctuation">)</span>               <span class="token punctuation">.</span><span class="token function">apiInfo</span><span class="token punctuation">(</span><span class="token function">testApiInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>               <span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span>               <span class="token punctuation">.</span><span class="token function">apis</span><span class="token punctuation">(</span>RequestHandlerSelectors<span class="token punctuation">.</span><span class="token function">basePackage</span><span class="token punctuation">(</span><span class="token string">"com.zms.cmsdemo.controller"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>               <span class="token punctuation">.</span><span class="token function">paths</span><span class="token punctuation">(</span>PathSelectors<span class="token punctuation">.</span><span class="token function">any</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>               <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> ApiInfo <span class="token function">testApiInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ApiInfoBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">title</span><span class="token punctuation">(</span><span class="token string">"咨询信息模块"</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">description</span><span class="token punctuation">(</span><span class="token string">"公共平台接口，主要用于测试."</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">termsOfServiceUrl</span><span class="token punctuation">(</span><span class="token string">"http:127.0.0.1:8080/cms"</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">version</span><span class="token punctuation">(</span><span class="token string">"1.0"</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="4：添加文档内容"><a href="#4：添加文档内容" class="headerlink" title="4：添加文档内容"></a>4：添加文档内容</h4><pre><code>Swagger使用的注解及其说明：@Api：用在类上，说明该类的作用。@ApiOperation：注解来给API增加方法说明。@ApiImplicitParams : 用在方法上包含一组参数说明。@ApiImplicitParam：用来注解来给方法入参增加说明。@ApiResponses：用于表示一组响应@ApiResponse：用在@ApiResponses中，一般用于表达一个错误的响应信息   code：数字，例如400   message：信息，例如&quot;请求参数没填好&quot;   response：抛出异常的类   @ApiModel：描述一个Model的信息（一般用在请求参数无法使用@ApiImplicitParam注解进行描述的时候）   @ApiModelProperty：描述一个model的属性</code></pre><p>注意：@ApiImplicitParam的参数说明：</p><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/04/11/swagger-shi-yong-zhi-nan/001.png" alt="001"></p><h5 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h5><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>zms<span class="token punctuation">.</span>cmsdemo<span class="token punctuation">.</span>controller<span class="token punctuation">;</span><span class="token keyword">import</span> io<span class="token punctuation">.</span>swagger<span class="token punctuation">.</span>annotations<span class="token punctuation">.</span>Api<span class="token punctuation">;</span><span class="token keyword">import</span> io<span class="token punctuation">.</span>swagger<span class="token punctuation">.</span>annotations<span class="token punctuation">.</span>ApiImplicitParam<span class="token punctuation">;</span><span class="token keyword">import</span> io<span class="token punctuation">.</span>swagger<span class="token punctuation">.</span>annotations<span class="token punctuation">.</span>ApiOperation<span class="token punctuation">;</span><span class="token keyword">import</span> io<span class="token punctuation">.</span>swagger<span class="token punctuation">.</span>annotations<span class="token punctuation">.</span>ApiResponse<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span>Logger<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span>LoggerFactory<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span>Controller<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>PathVariable<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>RequestMapping<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>RequestMethod<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>ResponseBody<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author ZongMan * @version 1.0 * @date 2019/4/12 0012 11:30 */</span><span class="token annotation punctuation">@Api</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/750p"</span><span class="token punctuation">,</span>description <span class="token operator">=</span> <span class="token string">"咨询信息的Controller"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Controller</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"750/p"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CmsController</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Logger LOGGER <span class="token operator">=</span> LoggerFactory<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span>CmsController<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 添加咨询信息     * @return     */</span>    <span class="token annotation punctuation">@ApiOperation</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"添加咨询信息"</span><span class="token punctuation">,</span>notes <span class="token operator">=</span> <span class="token string">"添加咨询信息"</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@ApiImplicitParam</span><span class="token punctuation">(</span>paramType<span class="token operator">=</span><span class="token string">"xxx"</span><span class="token punctuation">,</span>name <span class="token operator">=</span> <span class="token string">"咨询信息实体"</span><span class="token punctuation">,</span>value <span class="token operator">=</span> <span class="token string">"咨询信息实体"</span><span class="token punctuation">,</span>required <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">,</span>dataType <span class="token operator">=</span> <span class="token string">"实体类型"</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@ApiResponse</span><span class="token punctuation">(</span>code <span class="token operator">=</span> <span class="token number">001</span><span class="token operator">-</span><span class="token number">000</span><span class="token operator">-</span><span class="token number">001</span><span class="token punctuation">,</span>message <span class="token operator">=</span> <span class="token string">"添加咨询信息失败"</span><span class="token punctuation">,</span>response <span class="token operator">=</span> CmsController<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"addConOne"</span><span class="token punctuation">,</span>method <span class="token operator">=</span> RequestMethod<span class="token punctuation">.</span>POST<span class="token punctuation">)</span>    <span class="token annotation punctuation">@ResponseBody</span>    <span class="token keyword">public</span> String <span class="token function">addConOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"添加成功"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"deleteConOne/{id}"</span><span class="token punctuation">,</span>method <span class="token operator">=</span> RequestMethod<span class="token punctuation">.</span>DELETE<span class="token punctuation">)</span>    <span class="token annotation punctuation">@ResponseBody</span>    <span class="token keyword">public</span> String <span class="token function">deleteConOne</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span> String id<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token string">"删除成功"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>启动Spring Boot程序，访问：<a href="http://localhost:8080/swagger-ui.html" target="_blank" rel="noopener">http://localhost:8080/swagger-ui.html</a></p><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/04/11/swagger-shi-yong-zhi-nan/002.png" alt="002"></p>]]></content>
      
      
      <categories>
          
          <category> 日常学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swagger </tag>
            
            <tag> 在线文档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>装饰者设计模式</title>
      <link href="/2019/04/10/zhuang-shi-zhe-she-ji-mo-shi/"/>
      <url>/2019/04/10/zhuang-shi-zhe-she-ji-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="装饰者设计模式"><a href="#装饰者设计模式" class="headerlink" title="装饰者设计模式"></a>装饰者设计模式</h1><h4 id="一、装饰者模式的概念"><a href="#一、装饰者模式的概念" class="headerlink" title="一、装饰者模式的概念"></a>一、装饰者模式的概念</h4><p>​    装饰者模式又名包装(Wrapper)模式。装饰者模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案。</p><h4 id="二、装饰者模式的结构"><a href="#二、装饰者模式的结构" class="headerlink" title="二、装饰者模式的结构"></a>二、装饰者模式的结构</h4><p>​    装饰者模式以对客户透明的方式动态地给一个对象附加上更多的责任。换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。装饰者模式可以在不使用创造更多子类的情况下，将对象的功能加以扩展。<img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/04/10/zhuang-shi-zhe-she-ji-mo-shi/个人学习文档\装饰者设计模式\Snipaste_2019-01-14_22-44-24.png" alt="Snipaste_2019-01-14_22-44-24"></p><p>在装饰模式中的角色有：</p><p>●　　抽象构件(Component)角色：给出一个抽象接口，以规范准备接收附加责任的对象。</p><p>●　　具体构件(ConcreteComponent)角色：定义一个将要接收附加责任的类。</p><p>●　　装饰(Decorator)角色：持有一个构件(Component)对象的实例，并定义一个与抽象构件接口一致的接口。</p><p>●　　具体装饰(ConcreteDecorator)角色：负责给构件对象“贴上”附加的责任。</p><h4 id="三、装饰者模式实例演示"><a href="#三、装饰者模式实例演示" class="headerlink" title="三、装饰者模式实例演示"></a>三、装饰者模式实例演示</h4><h5 id="齐天大圣的例子"><a href="#齐天大圣的例子" class="headerlink" title="齐天大圣的例子"></a>齐天大圣的例子</h5><p>​    孙悟空有七十二般变化，他的每一种变化都给他带来一种附加的本领。他变成鱼儿时，就可以到水里游泳；他变成鸟儿时，就可以在天上飞行。</p><p>​    本例中，Component的角色便由鼎鼎大名的齐天大圣扮演；ConcreteComponent的角色属于大圣的本尊，就是猢狲本人；Decorator的角色由大圣的七十二变扮演。而ConcreteDecorator的角色便是鱼儿、鸟儿等七十二般变化</p><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/04/10/zhuang-shi-zhe-she-ji-mo-shi/Snipaste_2019-01-14_22-47-58.png" alt="Snipaste_2019-01-14_22-47-58"></p><h4 id="四、装饰者模式的优缺点"><a href="#四、装饰者模式的优缺点" class="headerlink" title="四、装饰者模式的优缺点"></a>四、装饰者模式的优缺点</h4><h5 id="装饰模式的优点"><a href="#装饰模式的优点" class="headerlink" title="装饰模式的优点"></a>装饰模式的优点</h5><p>（1）装饰模式与继承关系的目的都是要扩展对象的功能，但是装饰模式可以提供比继承更多的灵活性。装    饰模式允许系统动态决定“贴上”一个需要的“装饰”，或者除掉一个不需要的“装饰”。继承关系则不同，继承关系是静态的，它在系统运行前就决定了。</p><p>（2）通过使用不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的组合。</p><h5 id="装饰模式的缺点"><a href="#装饰模式的缺点" class="headerlink" title="装饰模式的缺点"></a>装饰模式的缺点</h5><p>由于使用装饰模式，可以比使用继承关系需要较少数目的类。使用较少的类，当然使设计比较易于进行。但是，在另一方面，使用装饰模式会产生比使用继承关系更多的对象。更多的对象会使得查错变得困难，特别是这些对象看上去都很相像。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Wrapper，装饰者 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例设计模式</title>
      <link href="/2019/04/09/dan-li-she-ji-mo-shi/"/>
      <url>/2019/04/09/dan-li-she-ji-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="单例的几种写法"><a href="#单例的几种写法" class="headerlink" title="单例的几种写法"></a>单例的几种写法</h1><p>[TOC]</p><h4 id="第一种写法（饿汉式-可用）"><a href="#第一种写法（饿汉式-可用）" class="headerlink" title="第一种写法（饿汉式 可用）"></a>第一种写法（饿汉式 可用）</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019/1/23 0023 * @Time: 8:42 * @Vsersion: 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingletonDemo01</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 单例模式第一种写法：     * 饿汉式（静态常量）     */</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> SingletonDemo01 INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingletonDemo01</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">SingletonDemo01</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> SingletonDemo01 <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> INSTANCE<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>优点：写法比较简单，在类装载的时候就进行实例化，避免了线程同步的问题缺点：在类装载的时候就完成实例化，没有达到Lazy Loading的效果，如果从始至终都没有使用这个实例，就会造成内存的浪费。</code></pre><h4 id="第二种写法（饿汉式-可用）"><a href="#第二种写法（饿汉式-可用）" class="headerlink" title="第二种写法（饿汉式 可用）"></a>第二种写法（饿汉式 可用）</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019/1/23 0023 * @Time: 8:52 * @Vsersion: 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingletonDemo02</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 单例模式第二种写法：     * 静态代码块     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> SingletonDemo02 instance<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingletonDemo02</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">SingletonDemo02</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> SingletonDemo02 <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>优缺点同上</code></pre><h4 id="第三种写法（懒汉式-线程不安全、不可用）"><a href="#第三种写法（懒汉式-线程不安全、不可用）" class="headerlink" title="第三种写法（懒汉式 线程不安全、不可用）"></a>第三种写法（懒汉式 线程不安全、不可用）</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019/1/23 0023 * @Time: 8:56 * @Vsersion: 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingletonDemo03</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 单例模式的第三种写法     * 懒汉式（线程不安全）     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> SingletonDemo03 singleton<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">SingletonDemo03</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> SingletonDemo03 <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>            singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingletonDemo03</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>这种写法起到了Lazy Loading的效果，但是只能在单线程下使用。如果在多线程下，一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式。</code></pre><h4 id="第四种写法（懒汉式-线程安全、同步方法）"><a href="#第四种写法（懒汉式-线程安全、同步方法）" class="headerlink" title="第四种写法（懒汉式 线程安全、同步方法）"></a>第四种写法（懒汉式 线程安全、同步方法）</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019/1/23 0023 * @Time: 9:01 * @Vsersion: 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingletonDemo04</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 单例的第四种写法     * 线程安全 同步方法     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> SingletonDemo04 singleton<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">SingletonDemo04</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> SingletonDemo04 <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingletonDemo04</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>    解决上面第三种实现方式的线程不安全问题，做个线程同步就可以了，于是就对getInstance()方法进行了线程同步。缺点：效率太低了，每个线程在想获得类的实例时候，执行getInstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接return就行了。方法进行同步效率太低要改进。</code></pre><h4 id="第五种写法（懒汉式-线程安全、同步代码块）"><a href="#第五种写法（懒汉式-线程安全、同步代码块）" class="headerlink" title="第五种写法（懒汉式 线程安全、同步代码块）"></a>第五种写法（懒汉式 线程安全、同步代码块）</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019/1/23 0023 * @Time: 9:04 * @Vsersion: 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingletonDemo05</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 第五种：懒汉式     * 线程安全 同步代码块 不可用     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> SingletonDemo05 singleton<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">SingletonDemo05</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> SingletonDemo05 <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>SingletonDemo05<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingletonDemo05</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>    由于第四种实现方式同步效率太低，所以摒弃同步方法，改为同步产生实例化的的代码块。但是这种同步并不能起到线程同步的作用。跟第3种实现方式遇到的情形一致，假如一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。</code></pre><h4 id="第六种写法（双重检查-推荐使用）"><a href="#第六种写法（双重检查-推荐使用）" class="headerlink" title="第六种写法（双重检查  推荐使用）"></a>第六种写法（双重检查  推荐使用）</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019/1/23 0023 * @Time: 9:08 * @Vsersion: 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingletonDemo06</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 第六种：双重检查     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> SingletonDemo06 singleton<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">SingletonDemo06</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> SingletonDemo06 <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>SingletonDemo06<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingletonDemo06</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>    Double-Check概念对于多线程开发者来说不会陌生，如代码中所示，我们进行了两次if (singleton == null)检查，这样就可以保证线程安全了。这样，实例化代码只用执行一次，后面再次访问时，判断if (singleton == null)，直接return实例化对象。优点：线程安全；延迟加载；效率较高。</code></pre><h4 id="第七种写法（静态内部类-推荐使用）"><a href="#第七种写法（静态内部类-推荐使用）" class="headerlink" title="第七种写法（静态内部类    推荐使用）"></a>第七种写法（静态内部类    推荐使用）</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019/1/23 0023 * @Time: 9:11 * @Vsersion: 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingletonDemo07</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 静态内部类     */</span>    <span class="token keyword">private</span> <span class="token function">SingletonDemo07</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SingletonInstance</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> SingletonDemo07 INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingletonDemo07</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> SingletonDemo07 <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> SingletonInstance<span class="token punctuation">.</span>INSTANCE<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>    这种方式跟饿汉式方式采用的机制类似，但又有不同。两者都是采用了类装载的机制来保证初始化实例时只有一个线程。不同的地方在饿汉式方式是只要Singleton类被装载就会实例化，没有Lazy-Loading的作用，而静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化时，调用getInstance方法，才会装载SingletonInstance类，从而完成Singleton的实例化。    类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。优点：避免了线程不安全，延迟加载，效率高。</code></pre><h4 id="第八种写法（枚举-推荐用）"><a href="#第八种写法（枚举-推荐用）" class="headerlink" title="第八种写法（枚举 推荐用）"></a>第八种写法（枚举 推荐用）</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019/1/23 0023 * @Time: 9:14 * @Vsersion: 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingletonDemo08</span> <span class="token punctuation">{</span>    INSTANCE<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">whateverMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。可能是因为枚举在JDK1.5中才添加，所以在实际项目开发中，很少见人这么写过。优点系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能。缺点当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用new，可能会给其他开发人员造成困扰，特别是看不到源码的时候。适用场合需要频繁的进行创建和销毁的对象；创建对象时耗时过多或耗费资源过多，但又经常用到的对象；工具类对象；频繁访问数据库或文件的对象。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式，singleton </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http的各种状态</title>
      <link href="/2019/04/08/http-de-ge-chong-zhuang-tai/"/>
      <url>/2019/04/08/http-de-ge-chong-zhuang-tai/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h1><pre><code>HTTP状态码（HTTP Status Code）是用以表示网页服务器HTTP响应状态的3位数字代码。我们可以通过查看HTTP状态码来判断服务器状态，常见的有404 、502等；但是其他不是很常见的状态码都代表什么状态呢？下面有两张有趣的图片，让你瞬间都能理解了。</code></pre><p><img src="http的各种状态\Snipaste_2019-01-18_08-34-19.png" alt="Snipaste_2019-01-18_08-34-19"></p><pre><code>301—永久移动。被请求的资源已被永久移动位置；302—请求的资源现在临时从不同的 URI 响应请求；305—使用代理。被请求的资源必须通过指定的代理才能被访问；307—临时跳转。被请求的资源在临时从不同的URL响应请求；400—错误请求；402—需要付款。该状态码是为了将来可能的需求而预留的，用于一些数字货币或者是微支付；403—禁止访问。服务器已经理解请求，但是拒绝执行它；404—找不到对象。请求失败，资源不存在；406—不可接受的。请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体；</code></pre><p><img src="http的各种状态\Snipaste_2019-01-18_08-36-12.png" alt="Snipaste_2019-01-18_08-36-12"></p><pre><code>408—请求超时；409—冲突。由于和被请求的资源的当前状态之间存在冲突，请求无法完成；410—遗失的。被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址；413—响应实体太大。服务器拒绝处理当前请求，请求超过服务器所能处理和允许的最大值。417—期望失败。在请求头 Expect 中指定的预期内容无法被服务器满足；418—我是一个茶壶。超文本咖啡罐控制协议，但是并没有被实际的HTTP服务器实现；420—方法失效。422—不可处理的实体。请求格式正确，但是由于含有语义错误，无法响应；500—服务器内部错误。服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理；</code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> 状态码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty相关知识</title>
      <link href="/2019/04/08/netty-xiang-guan-zhi-shi/"/>
      <url>/2019/04/08/netty-xiang-guan-zhi-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="Netty相关知识"><a href="#Netty相关知识" class="headerlink" title="Netty相关知识"></a>Netty相关知识</h1><h4 id="1-Netty简介"><a href="#1-Netty简介" class="headerlink" title="1.Netty简介"></a>1.Netty简介</h4><pre><code>Netty是由JBOSS提供的一个java开源框架。    Netty是一个高性能、异步事件驱动的NIO框架，它提供了对TCP、UDP和文件传输的支持。作为当前最流行的NIO框架，Netty在互联网领域、大数据分布式计算领域、游戏行业、通信行业等获得了广泛的应用，一些业界著名的开源组件也基于Netty的NIO框架构建</code></pre><h4 id="2-Netty的特点"><a href="#2-Netty的特点" class="headerlink" title="2.Netty的特点"></a>2.Netty的特点</h4><h5 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h5><pre><code>Netty是一款基于NIO（Nonblocking I/O，非阻塞IO）开发的网络通信框架，对比于BIO（Blocking I/O，阻塞IO），他的并发性能得到了很大提高 。</code></pre><h5 id="传输快"><a href="#传输快" class="headerlink" title="传输快"></a>传输快</h5><pre><code>Netty的传输快其实也是依赖了NIO的一个特性——零拷贝。</code></pre><h5 id="封装好"><a href="#封装好" class="headerlink" title="封装好"></a>封装好</h5><pre><code>Netty封装了NIO操作的很多细节，提供易于使用的API。</code></pre><h4 id="3-为什么选择Netty"><a href="#3-为什么选择Netty" class="headerlink" title="3.为什么选择Netty"></a>3.为什么选择Netty</h4><pre><code>JDK 原生也有一套网络应用程序 API，但是存在一系列问题，主要如下：1）NIO 的类库和 API 繁杂，使用麻烦：你需要熟练掌握 Selector、ServerSocketChannel、SocketChannel、ByteBuffer 等。2）需要具备其他的额外技能做铺垫：例如熟悉 Java 多线程编程，因为 NIO 编程涉及到 Reactor 模式，你必须对多线程和网路编程非常熟悉，才能编写出高质量的 NIO 程序。3）可靠性能力补齐，开发工作量和难度都非常大：例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常码流的处理等等。NIO 编程的特点是功能开发相对容易，但是可靠性能力补齐工作量和难度都非常大。4）JDK NIO 的 Bug：例如臭名昭著的 Epoll Bug，它会导致 Selector 空轮询，最终导致 CPU 100%。官方声称在 JDK 1.6 版本的 update 18 修复了该问题，但是直到 JDK 1.7 版本该问题仍旧存在，只不过该 Bug 发生概率降低了一些而已，它并没有被根本解决。</code></pre><h4 id="4-Netty框架的优势"><a href="#4-Netty框架的优势" class="headerlink" title="4.Netty框架的优势"></a>4.Netty框架的优势</h4><pre><code>API使用简单，开发门槛低；功能强大，预置了多种编解码功能，支持多种主流协议；定制能力强，可以通过ChannelHandler对通信框架进行灵活地扩展；性能高，通过与其他业界主流的NIO框架对比，Netty的综合性能最优；成熟、稳定，Netty修复了已经发现的所有JDK NIO BUG，业务开发人员不需要再为NIO的BUG而烦恼；社区活跃，版本迭代周期短，发现的BUG可以被及时修复，同时，更多的新功能会加入；经历了大规模的商业应用考验，质量得到验证。在互联网、大数据、网络游戏、企业应用、电信软件等众多行业得到成功商用，证明了它已经完全能够满足不同行业的商业应用了。</code></pre><h4 id="5-Netty的架构设计"><a href="#5-Netty的架构设计" class="headerlink" title="5.Netty的架构设计"></a>5.Netty的架构设计</h4><h5 id="总体结构"><a href="#总体结构" class="headerlink" title="总体结构"></a>总体结构</h5><p>Netty 采用了比较典型的三层网络架构进行设计，逻辑架构图如下所示：</p><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/04/08/netty-xiang-guan-zhi-shi/002.png" alt="002"></p><pre><code>1）传输服务：支持 BIO 和 NIO；2）容器集成：支持 OSGI、JBossMC、Spring、Guice 容器；3）协议支持：HTTP、Protobuf、二进制、文本、WebSocket 等一系列常见协议都支持。还支持通过实行编码解码逻辑来实现自定义协议；4）Core 核心：可扩展事件模型、通用通信 API、支持零拷贝的 ByteBuf 缓冲对象。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 日常学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap</title>
      <link href="/2019/04/07/hashmap/"/>
      <url>/2019/04/07/hashmap/</url>
      
        <content type="html"><![CDATA[<h1 id="HashMap简介"><a href="#HashMap简介" class="headerlink" title="HashMap简介"></a>HashMap简介</h1><pre><code>HashMap 主要用来存放键值对，它基于哈希表的Map接口实现&lt;/font&gt;，是常用的Java集合之一。 JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树，以减少搜索时间。</code></pre><h2 id="底层数据结构分析"><a href="#底层数据结构分析" class="headerlink" title="底层数据结构分析"></a>底层数据结构分析</h2><h4 id="JDK1-8之前"><a href="#JDK1-8之前" class="headerlink" title="JDK1.8之前"></a>JDK1.8之前</h4><pre><code>JDK1.8 之前 HashMap 底层是 数组和链表 结合在一起使用也就是 链表散列。HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash  值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。JDK 1.8 HashMap 的 hash 方法源码:JDK 1.8 的 hash方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。</code></pre><pre class=" language-java"><code class="language-java">  <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> h<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// key.hashCode()：返回散列值也就是hashcode</span>        <span class="token comment" spellcheck="true">// ^ ：按位异或</span>        <span class="token comment" spellcheck="true">// >>>:无符号右移，忽略符号位，空位都以0补齐</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>对比一下 JDK1.7的 HashMap 的 hash 方法源码.</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// This function ensures that hashCodes that differ only by</span>    <span class="token comment" spellcheck="true">// constant multiples at each bit position have a bounded</span>    <span class="token comment" spellcheck="true">// number of collisions (approximately 8 at default load factor).</span>    h <span class="token operator">^=</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> h <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre><code>相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。所谓 “拉链法” 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</code></pre><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/04/07/hashmap/001.png" alt="001"></p><h4 id="JDK1-8之后"><a href="#JDK1-8之后" class="headerlink" title="JDK1.8之后"></a>JDK1.8之后</h4><pre><code>    相比于之前的版本，jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</code></pre><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/04/07/hashmap/002.png" alt="002"></p><p>类的属性：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractMap</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Map</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">,</span> Cloneable<span class="token punctuation">,</span> Serializable <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 序列号</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 362498820763181265L<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 默认的初始容量是16</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_INITIAL_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 最大容量</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAXIMUM_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 默认的填充因子</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">float</span> DEFAULT_LOAD_FACTOR <span class="token operator">=</span> <span class="token number">0.75f</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 当桶(bucket)上的结点数大于这个值时会转成红黑树</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 当桶(bucket)上的结点数小于这个值时树转链表</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> UNTREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 桶中结构转化为红黑树对应的table的最小大小</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MIN_TREEIFY_CAPACITY <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 存储元素的数组，总是2的幂次倍</span>    <span class="token keyword">transient</span> Node<span class="token operator">&lt;</span>k<span class="token punctuation">,</span>v<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 存放具体元素的集</span>    <span class="token keyword">transient</span> Set<span class="token operator">&lt;</span>map<span class="token punctuation">.</span>entry<span class="token operator">&lt;</span>k<span class="token punctuation">,</span>v<span class="token operator">>></span> entrySet<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 存放元素的个数，注意这个不等于数组的长度。</span>    <span class="token keyword">transient</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 每次扩容和更改map结构的计数器</span>    <span class="token keyword">transient</span> <span class="token keyword">int</span> modCount<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容</span>    <span class="token keyword">int</span> threshold<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 填充因子</span>    <span class="token keyword">final</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre><code>- loadFactor加载因子  loadFactor加载因子是控制数组存放数据的疏密程度，loadFactor越趋近于1，那么   数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，load   Factor越小，也就是趋近于0，  loadFactor太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor的默认值为0.75f是官方给出的一个比较好的临界值。   给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 = 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。- threshold  threshold = capacity * loadFactor，当Size&gt;=threshold的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是 衡量数组是否需要扩增的一个标准。</code></pre><p>Node节点类源码:</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 继承自 Map.Entry&lt;K,V></span><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token punctuation">{</span>       <span class="token keyword">final</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 哈希值，存放元素到hashmap中时用来与其他元素hash值比较</span>       <span class="token keyword">final</span> K key<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//键</span>       V value<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//值</span>       <span class="token comment" spellcheck="true">// 指向下一个节点</span>       Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">;</span>       <span class="token function">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>hash <span class="token operator">=</span> hash<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> K <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span> <span class="token keyword">return</span> key<span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> V <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span> <span class="token keyword">return</span> value<span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> key <span class="token operator">+</span> <span class="token string">"="</span> <span class="token operator">+</span> value<span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 重写hashCode()方法</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> Objects<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">^</span> Objects<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> V <span class="token function">setValue</span><span class="token punctuation">(</span>V newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>            V oldValue <span class="token operator">=</span> value<span class="token punctuation">;</span>            value <span class="token operator">=</span> newValue<span class="token punctuation">;</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 重写 equals() 方法</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token keyword">this</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token keyword">instanceof</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token operator">></span> e <span class="token operator">=</span> <span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">)</span>o<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>Objects<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                    Objects<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>树节点类源码:</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">TreeNode</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token punctuation">{</span>        TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> parent<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 父</span>        TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> left<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 左</span>        TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> right<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 右</span>        TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> prev<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// needed to unlink next upon deletion</span>        <span class="token keyword">boolean</span> red<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 判断颜色</span>        <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V val<span class="token punctuation">,</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">super</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 返回根节点</span>        <span class="token keyword">final</span> TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">root</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> r <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">,</span> p<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> r<span class="token punctuation">.</span>parent<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>                    <span class="token keyword">return</span> r<span class="token punctuation">;</span>                r <span class="token operator">=</span> p<span class="token punctuation">;</span>       <span class="token punctuation">}</span></code></pre><h2 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="HashMap源码分析"></a>HashMap源码分析</h2><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/04/07/hashmap/003.png" alt="003"></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 默认构造函数。</span>    <span class="token keyword">public</span> More <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> DEFAULT_LOAD_FACTOR<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// all   other fields defaulted</span>     <span class="token punctuation">}</span>     <span class="token comment" spellcheck="true">// 包含另一个“Map”的构造函数</span>     <span class="token keyword">public</span> More <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">HashMap</span><span class="token punctuation">(</span>Map<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token operator">></span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> DEFAULT_LOAD_FACTOR<span class="token punctuation">;</span>         <span class="token function">putMapEntries</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//下面会分析到这个方法</span>     <span class="token punctuation">}</span>     <span class="token comment" spellcheck="true">// 指定“容量大小”的构造函数</span>     <span class="token keyword">public</span> More <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">this</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">,</span> DEFAULT_LOAD_FACTOR<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token comment" spellcheck="true">// 指定“容量大小”和“加载因子”的构造函数</span>     <span class="token keyword">public</span> More <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>             <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal initial capacity: "</span> <span class="token operator">+</span> initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">></span> MAXIMUM_CAPACITY<span class="token punctuation">)</span>             initialCapacity <span class="token operator">=</span> MAXIMUM_CAPACITY<span class="token punctuation">;</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>loadFactor <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> Float<span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span>loadFactor<span class="token punctuation">)</span><span class="token punctuation">)</span>             <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal load factor: "</span> <span class="token operator">+</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> loadFactor<span class="token punctuation">;</span>         <span class="token keyword">this</span><span class="token punctuation">.</span>threshold <span class="token operator">=</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span></code></pre><p>putMapEntries方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">putMapEntries</span><span class="token punctuation">(</span>Map<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token operator">></span> m<span class="token punctuation">,</span> <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> s <span class="token operator">=</span> m<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 判断table是否已经初始化</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>table <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// pre-size</span>            <span class="token comment" spellcheck="true">// 未初始化，s为m的实际元素个数</span>            <span class="token keyword">float</span> ft <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>s <span class="token operator">/</span> loadFactor<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1.0F</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ft <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token operator">?</span>                    <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>ft <span class="token operator">:</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 计算得到的t大于阈值，则初始化阈值</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">></span> threshold<span class="token punctuation">)</span>                threshold <span class="token operator">=</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 已初始化，并且m元素个数大于阈值，进行扩容处理</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">></span> threshold<span class="token punctuation">)</span>            <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 将m中的所有元素添加至HashMap中</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token operator">></span> e <span class="token operator">:</span> m<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            K key <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            V value <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> evict<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h4><pre><code>HashMap只提供了put用于添加元素，putVal方法只是给put方法调用的一个方法，并没有提供给用户使用。对putVal方法添加元素的分析如下：    - ①如果定位到的数组位置没有元素 就直接插入。    - ②如果定位到的数组位置有元素就和要插入的key比较，如果key相同就直接覆盖，如果key不相同，就判断p是否是一个树节点，如果是就调用e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)将元素添加进入。如果不是就遍历链表插入。</code></pre><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/04/07/hashmap/004.png" alt="004"></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">final</span> V <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span>                   <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// table未初始化或者长度为0，进行扩容</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>        tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 桶中已经存在元素</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span> K k<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">// 将第一个元素赋值给e，用e来记录</span>                e <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// hash值不相等，即key不相等；为红黑树结点</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// 放入树中</span>            e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 为链表结点</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 在链表最末插入结点</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 到达链表的尾部</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 在尾部插入新结点</span>                    p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 结点数量达到阈值，转化为红黑树</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">>=</span> TREEIFY_THRESHOLD <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// -1 for 1st</span>                        <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 跳出循环</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// 判断链表中结点的key值与插入的元素的key值是否相等</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token comment" spellcheck="true">// 相等，跳出循环</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span>                p <span class="token operator">=</span> e<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 表示在桶中找到key值、hash值与插入元素相等的结点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token comment" spellcheck="true">// 记录e的value</span>            V oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// onlyIfAbsent为false或者旧值为null</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> null<span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">//用新值替换旧值</span>                e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 访问后回调</span>            <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 返回旧值</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 结构性修改</span>    <span class="token operator">++</span>modCount<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 实际大小大于阈值则扩容</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">></span> threshold<span class="token punctuation">)</span>        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 插入后回调</span>    <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span> </code></pre><p><strong>我们再来对比一下 JDK1.7 put方法的代码</strong></p><p><strong>对于put方法的分析如下：</strong></p><ul><li>①如果定位到的数组位置没有元素 就直接插入。</li><li>②如果定位到的数组位置有元素，遍历以这个元素为头结点的链表，依次和插入的key比较，如果key相同就直接覆盖，不同就采用头插法插入元素。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>table <span class="token operator">==</span> EMPTY_TABLE<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token function">inflateTable</span><span class="token punctuation">(</span>threshold<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token function">putForNullKey</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> null<span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 先遍历</span>        Object k<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            V oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">recordAccess</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>         <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token function">addEntry</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 再插入</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">get</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">?</span> null <span class="token operator">:</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">final</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> first<span class="token punctuation">,</span> e<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span> K k<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>        <span class="token punctuation">(</span>first <span class="token operator">=</span> tab<span class="token punctuation">[</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 数组元素相等</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>first<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token comment" spellcheck="true">// always check first node</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> first<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> first<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 桶中不止一个节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> first<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 在树中get</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>first<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTreeNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 在链表中get</span>            <span class="token keyword">do</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> e<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="resize方法"><a href="#resize方法" class="headerlink" title="resize方法"></a>resize方法</h4><pre><code>    进行扩容，会伴随着一次重新hash分配，并且会遍历hash表中所有的元素，是非常耗时的。在编写程序中，要尽量避免resize。</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> oldTab <span class="token operator">=</span> table<span class="token punctuation">;</span>    <span class="token keyword">int</span> oldCap <span class="token operator">=</span> <span class="token punctuation">(</span>oldTab <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> oldTab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> oldThr <span class="token operator">=</span> threshold<span class="token punctuation">;</span>    <span class="token keyword">int</span> newCap<span class="token punctuation">,</span> newThr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">>=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token punctuation">{</span>            threshold <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>            <span class="token keyword">return</span> oldTab<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 没超过最大值，就扩充为原来的2倍</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newCap <span class="token operator">=</span> oldCap <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span> oldCap <span class="token operator">>=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span>            newThr <span class="token operator">=</span> oldThr <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// double threshold</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldThr <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// initial capacity was placed in threshold</span>        newCap <span class="token operator">=</span> oldThr<span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>         signifies using defaults        newCap <span class="token operator">=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">;</span>        newThr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>DEFAULT_LOAD_FACTOR <span class="token operator">*</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 计算新的resize上限</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newThr <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">float</span> ft <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>newCap <span class="token operator">*</span> loadFactor<span class="token punctuation">;</span>        newThr <span class="token operator">=</span> <span class="token punctuation">(</span>newCap <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span> ft <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>MAXIMUM_CAPACITY <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>ft <span class="token operator">:</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    threshold <span class="token operator">=</span> newThr<span class="token punctuation">;</span>    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"rawtypes"</span><span class="token punctuation">,</span><span class="token string">"unchecked"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTab <span class="token operator">=</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span>newCap<span class="token punctuation">]</span><span class="token punctuation">;</span>    table <span class="token operator">=</span> newTab<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldTab <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 把每个bucket都移动到新的buckets中</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> oldCap<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span>                    newTab<span class="token punctuation">[</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> <span class="token punctuation">(</span>newCap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>e<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> newTab<span class="token punctuation">,</span> j<span class="token punctuation">,</span> oldCap<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token punctuation">{</span>                     Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> loHead <span class="token operator">=</span> null<span class="token punctuation">,</span> loTail <span class="token operator">=</span> null<span class="token punctuation">;</span>                    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> hiHead <span class="token operator">=</span> null<span class="token punctuation">,</span> hiTail <span class="token operator">=</span> null<span class="token punctuation">;</span>                    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">;</span>                    <span class="token keyword">do</span> <span class="token punctuation">{</span>                        next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 原索引</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> oldCap<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">==</span> null<span class="token punctuation">)</span>                                loHead <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token keyword">else</span>                                loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>                            loTail <span class="token operator">=</span> e<span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        <span class="token comment" spellcheck="true">// 原索引+oldCap</span>                        <span class="token keyword">else</span> <span class="token punctuation">{</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">==</span> null<span class="token punctuation">)</span>                                hiHead <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token keyword">else</span>                                hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>                            hiTail <span class="token operator">=</span> e<span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 原索引放到bucket里</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>                        newTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> loHead<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token comment" spellcheck="true">// 原索引+oldCap放到bucket里</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>                        newTab<span class="token punctuation">[</span>j <span class="token operator">+</span> oldCap<span class="token punctuation">]</span> <span class="token operator">=</span> hiHead<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> newTab<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="HashMap常用方法测试"><a href="#HashMap常用方法测试" class="headerlink" title="HashMap常用方法测试"></a>HashMap常用方法测试</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> map<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Collection<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>HashMap<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Set<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashMapDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        HashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 键不能重复，值可以重复</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"san"</span><span class="token punctuation">,</span> <span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"si"</span><span class="token punctuation">,</span> <span class="token string">"李四"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"wu"</span><span class="token punctuation">,</span> <span class="token string">"王五"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"wang"</span><span class="token punctuation">,</span> <span class="token string">"老王"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"wang"</span><span class="token punctuation">,</span> <span class="token string">"老王2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 老王被覆盖</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"lao"</span><span class="token punctuation">,</span> <span class="token string">"老王"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"-------直接输出hashmap:-------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/**         * 遍历HashMap         */</span>        <span class="token comment" spellcheck="true">// 1.获取Map中的所有键</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"-------foreach获取Map中所有的键:------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Set<span class="token operator">&lt;</span>String<span class="token operator">></span> keys <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>String key <span class="token operator">:</span> keys<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>key<span class="token operator">+</span><span class="token string">"  "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//换行</span>        <span class="token comment" spellcheck="true">// 2.获取Map中所有值</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"-------foreach获取Map中所有的值:------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Collection<span class="token operator">&lt;</span>String<span class="token operator">></span> values <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>String value <span class="token operator">:</span> values<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>value<span class="token operator">+</span><span class="token string">"  "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//换行</span>        <span class="token comment" spellcheck="true">// 3.得到key的值的同时得到key所对应的值</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"-------得到key的值的同时得到key所对应的值:-------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Set<span class="token operator">&lt;</span>String<span class="token operator">></span> keys2 <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>String key <span class="token operator">:</span> keys2<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>key <span class="token operator">+</span> <span class="token string">"："</span> <span class="token operator">+</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"   "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">/**         * 另外一种不常用的遍历方式         */</span>        <span class="token comment" spellcheck="true">// 当我调用put(key,value)方法的时候，首先会把key和value封装到</span>        <span class="token comment" spellcheck="true">// Entry这个静态内部类对象中，把Entry对象再添加到数组中，所以我们想获取</span>        <span class="token comment" spellcheck="true">// map中的所有键值对，我们只要获取数组中的所有Entry对象，接下来</span>        <span class="token comment" spellcheck="true">// 调用Entry对象中的getKey()和getValue()方法就能获取键值对了</span>        Set<span class="token operator">&lt;</span>java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">>></span> entrys <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> entry <span class="token operator">:</span> entrys<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"--"</span> <span class="token operator">+</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">/**         * HashMap其他常用方法         */</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after map.size()："</span><span class="token operator">+</span>map<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after map.isEmpty()："</span><span class="token operator">+</span>map<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">"san"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after map.remove()："</span><span class="token operator">+</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after map.get(si)："</span><span class="token operator">+</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"si"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after map.containsKey(si)："</span><span class="token operator">+</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span><span class="token string">"si"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after containsValue(李四)："</span><span class="token operator">+</span>map<span class="token punctuation">.</span><span class="token function">containsValue</span><span class="token punctuation">(</span><span class="token string">"李四"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">"si"</span><span class="token punctuation">,</span> <span class="token string">"李四2"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after map.replace(si, 李四2):"</span><span class="token operator">+</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 日常学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆向工程</title>
      <link href="/2019/04/06/ni-xiang-gong-cheng/"/>
      <url>/2019/04/06/ni-xiang-gong-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="逆向工程"><a href="#逆向工程" class="headerlink" title="逆向工程"></a>逆向工程</h1><pre><code>日常开发中，逆向工程在我们的工作中用的非常普遍</code></pre><h4 id="generatorConfig-xml"><a href="#generatorConfig-xml" class="headerlink" title="generatorConfig.xml"></a>generatorConfig.xml</h4><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token doctype">&lt;!DOCTYPE generatorConfiguration        PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"        "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>generatorConfiguration</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>context</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>testTables<span class="token punctuation">"</span></span> <span class="token attr-name">targetRuntime</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>MyBatis3<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.mybatis.generator.plugins.SerializablePlugin<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>commentGenerator</span><span class="token punctuation">></span></span>            <span class="token comment" spellcheck="true">&lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>suppressAllComments<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>commentGenerator</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>jdbcConnection</span> <span class="token attr-name">driverClass</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.mysql.jdbc.Driver<span class="token punctuation">"</span></span>                        <span class="token attr-name">connectionURL</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jdbc:mysql://localhost:3306/shucangdb<span class="token punctuation">"</span></span> <span class="token attr-name">userId</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span>                        <span class="token attr-name">password</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>jdbcConnection</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- &lt;jdbcConnection driverClass="oracle.jdbc.OracleDriver"            connectionURL="jdbc:oracle:thin:@127.0.0.1:1521:yycg"            userId="yycg"            password="yycg">        &lt;/jdbcConnection> --></span>        <span class="token comment" spellcheck="true">&lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和            NUMERIC 类型解析为java.math.BigDecimal --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>javaTypeResolver</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>forceBigDecimals<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>javaTypeResolver</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- targetProject:生成PO类的位置 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>javaModelGenerator</span> <span class="token attr-name">targetPackage</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.xxxxxxxx<span class="token punctuation">"</span></span>                            <span class="token attr-name">targetProject</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>generator/src/main/java<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token comment" spellcheck="true">&lt;!-- enableSubPackages:是否让schema作为包的后缀 --></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>enableSubPackages<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>            <span class="token comment" spellcheck="true">&lt;!-- 从数据库返回的值被清理前后的空格 --></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>trimStrings<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>javaModelGenerator</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- targetProject:mapper映射文件生成的位置 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>sqlMapGenerator</span> <span class="token attr-name">targetPackage</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.xxxxxxxxxx<span class="token punctuation">"</span></span>                         <span class="token attr-name">targetProject</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>generator/src/main/java<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token comment" spellcheck="true">&lt;!-- enableSubPackages:是否让schema作为包的后缀 --></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>enableSubPackages<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>sqlMapGenerator</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- targetPackage：mapper接口生成的位置 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>javaClientGenerator</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>XMLMAPPER<span class="token punctuation">"</span></span>                             <span class="token attr-name">targetPackage</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.xxxxxxxx<span class="token punctuation">"</span></span>                             <span class="token attr-name">targetProject</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>generator/src/main/java<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token comment" spellcheck="true">&lt;!-- enableSubPackages:是否让schema作为包的后缀 --></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>enableSubPackages<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>javaClientGenerator</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 指定数据库表 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">tableName</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>xxxx<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>table</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">tableName</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>xxxx<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>table</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 有些表的字段需要指定java类型         &lt;table schema="" tableName="">            &lt;columnOverride column="" javaType="" />        &lt;/table> --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>context</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>generatorConfiguration</span><span class="token punctuation">></span></span></code></pre><h4 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h4><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0         http://maven.apache.org/xsd/maven-4.0.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modelVersion</span><span class="token punctuation">></span></span>4.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modelVersion</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.zms<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>generator<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.0-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span>                <span class="token comment" spellcheck="true">&lt;!-- 逆向工程--></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.mybatis.generator<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mybatis-generator-maven-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.3.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>mysql<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mysql-connector-java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>5.1.45<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>runtime<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.mybatis.generator<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mybatis-generator-core<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.3.7<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>                        <span class="token comment" spellcheck="true">&lt;!--配置文件的路径--></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configurationFile</span><span class="token punctuation">></span></span>${basedir}/src/main/resources/generatorConfig.xml<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configurationFile</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>overwrite</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>overwrite</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>verbose</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>verbose</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resources</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resource</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>directory</span><span class="token punctuation">></span></span>src/main/java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>directory</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--mapper--></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>includes</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span><span class="token punctuation">></span></span>**/*.properties<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>include</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span><span class="token punctuation">></span></span>**/*.xml<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>include</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>includes</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filtering</span><span class="token punctuation">></span></span>false<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filtering</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resource</span><span class="token punctuation">></span></span>                <span class="token comment" spellcheck="true">&lt;!-- 上面的配置导致src/main/resources的所有文件都不能被扫描，因此还要配多一个 --></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resource</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>directory</span><span class="token punctuation">></span></span>src/main/resources<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>directory</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>includes</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span><span class="token punctuation">></span></span>**/*.properties<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>include</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span><span class="token punctuation">></span></span>**/*.xml<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>include</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span><span class="token punctuation">></span></span>**/static/**<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>include</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span><span class="token punctuation">></span></span>**/*.js<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>include</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span><span class="token punctuation">></span></span>**/*.css<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>include</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span><span class="token punctuation">></span></span>**/*.json<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>include</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>includes</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filtering</span><span class="token punctuation">></span></span>false<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filtering</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resource</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resources</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>mysql<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mysql-connector-java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>5.1.46<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.mybatis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mybatis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.4.4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 日常学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis，mysql，generator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jdbc和mybatis的区别</title>
      <link href="/2019/04/05/jdbc-he-mybatis-de-qu-bie/"/>
      <url>/2019/04/05/jdbc-he-mybatis-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<h1 id="jdbc和mybatis的区别"><a href="#jdbc和mybatis的区别" class="headerlink" title="jdbc和mybatis的区别"></a>jdbc和mybatis的区别</h1><pre><code>mybatis也是基于JDBC的。Java与数据库操作仅能通过JDBC完成。 mybatis也要通过JDBC完成数据查询、更新这些动作。mybatis仅仅是在JDBC基础上做了，OO化、封装事务管理接口这些东西。</code></pre><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/04/05/jdbc-he-mybatis-de-qu-bie/001.png" alt="001"></p><pre><code>JDBC是地基,mybatis/Hibernate 是两栋外形各自有特点的楼房，楼房之间可以比较！地基就这一种。</code></pre><h4 id="传统JDBC操作数据"><a href="#传统JDBC操作数据" class="headerlink" title="传统JDBC操作数据"></a>传统JDBC操作数据</h4><pre><code>1.使用JDBC编程需要连接数据库，注册驱动和数据库信息2.操作Connection，打开 Statement 对象 。3.通过Statement执行SQL， 返回结果到ResultSet对象。4.使用ResultSet读取数据，然后通过代码转化为具体的POJO对象。5.关闭数据库的相关资源。</code></pre><h5 id="jdbc存在弊端："><a href="#jdbc存在弊端：" class="headerlink" title="jdbc存在弊端："></a>jdbc存在弊端：</h5><pre><code>1.工作量相对较大，每次都要去创建，关闭，获取2.JDBC编程可能产生的异常进行捕捉处理并正确关闭资源</code></pre><h4 id="对象关系映射（Object-Relational-Mapping）简称-ORM"><a href="#对象关系映射（Object-Relational-Mapping）简称-ORM" class="headerlink" title="对象关系映射（Object Relational Mapping）简称 ORM"></a>对象关系映射（Object Relational Mapping）简称 ORM</h4><pre><code>ORM模型就是数据库的表和简单Java对象（Plain Ordinary Java Object，简称POJO）的映射关系模型。</code></pre><pre><code>ORM模型提供了统一的规则使得数据库的数据通过配置便可轻易的映射到POJO上</code></pre><h4 id="常见的有两种"><a href="#常见的有两种" class="headerlink" title="常见的有两种"></a>常见的有两种</h4><h5 id="mybatis"><a href="#mybatis" class="headerlink" title="mybatis"></a>mybatis</h5><pre><code>1.易于上手和掌握。2.sql写在xml里，便于统一管理和优化。3.解除sql与程序代码的耦合。4.提供映射标签，支持对象与数据库的orm字段关系映射5.提供对象关系映射标签，支持对象关系组建维护6.提供xml标签，支持编写动态sql。</code></pre><h5 id="hibernate"><a href="#hibernate" class="headerlink" title="hibernate"></a>hibernate</h5><pre><code>1.消除了代码的映射规则，它全部被分离到XML或者注解里面去配置。2.无需再管理数据库连接，它也配置到XML里面。3.一个会话中，不要操作多个对象，只要操作Sesison即可。4.关闭资源只需要关闭一个Session即可。</code></pre><h4 id="Mybatis常见的面试题"><a href="#Mybatis常见的面试题" class="headerlink" title="Mybatis常见的面试题"></a>Mybatis常见的面试题</h4><h5 id="1-和-的区别是什么？"><a href="#1-和-的区别是什么？" class="headerlink" title="1. #{}和${}的区别是什么？"></a>1. #{}和${}的区别是什么？</h5><pre><code>#{}是预编译处理，${}是字符串替换。Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；Mybatis在处理${}时，就是把${}替换成变量的值。使用#{}可以有效的防止SQL注入，提高系统安全性。在我们日常开发中，能用#的地方都尽量用#。</code></pre><h5 id="2-通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？"><a href="#2-通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？" class="headerlink" title="2. 通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？"></a>2. 通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？</h5><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/04/05/jdbc-he-mybatis-de-qu-bie/002.png" alt="002"></p><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/04/05/jdbc-he-mybatis-de-qu-bie/003.png" alt="003"></p><pre><code>    Dao接口，就是人们常说的Mapper接口，接口的全限名，就是映射文件中的namespace的值，接口的方法名，就是映射文件中MappedStatement的id值，接口方法内的参数，就是传递给sql的参数。Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MappedStatement，举例：com.mybatis3.mappers.StudentDao.findStudentById，可以唯一找到namespace为com.mybatis3.mappers.StudentDao下面id = findStudentById的MappedStatement。在Mybatis中，每一个&lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;标签，都会被解析为一个MappedStatement对象。Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。    Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。</code></pre><h4 id="3-Mybatis是如何进行分页的？分页插件的原理是什么？"><a href="#3-Mybatis是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="3. Mybatis是如何进行分页的？分页插件的原理是什么？"></a>3. Mybatis是如何进行分页的？分页插件的原理是什么？</h4><pre><code>    Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页，可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。    分页插件(pagehelper)的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。</code></pre><h5 id="4-Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"><a href="#4-Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？" class="headerlink" title="4. Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"></a>4. Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？</h5><pre><code>    第一种是使用&lt;resultMap&gt;标签，逐一定义列名和对象属性名之间的映射关系。第二种是使用sql列的别名功能，将列别名书写为对象属性名，比如T_NAME AS NAME，对象属性名一般是name，小写，但是列名不区分大小写，Mybatis会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成T_NAME AS NaMe，Mybatis一样可以正常工作。    有了列名与属性名的映射关系后，Mybatis通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</code></pre><h5 id="5-Xml映射文件中，除了常见的select-insert-update-delete标签之外，还有哪些标签？"><a href="#5-Xml映射文件中，除了常见的select-insert-update-delete标签之外，还有哪些标签？" class="headerlink" title="5. Xml映射文件中，除了常见的select|insert|update|delete标签之外，还有哪些标签？"></a>5. Xml映射文件中，除了常见的select|insert|update|delete标签之外，还有哪些标签？</h5><pre><code>还有很多其他的标签，加上动态sql的9个标签，trim|where|set|foreach|if|choose|when|otherwise|bind等，其中为sql片段标签，通过标签引入sql片段，为不支持自增的主键生成策略标签。</code></pre><h5 id="6-简述Mybatis的插件运行原理，以及如何编写一个插件"><a href="#6-简述Mybatis的插件运行原理，以及如何编写一个插件" class="headerlink" title="6. 简述Mybatis的插件运行原理，以及如何编写一个插件"></a>6. 简述Mybatis的插件运行原理，以及如何编写一个插件</h5><pre><code>    Mybatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler、Executor这4种接口的插件，Mybatis使用JDK的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是InvocationHandler的invoke()方法，当然，只会拦截那些你指定需要拦截的方法。实现Mybatis的Interceptor接口并复写intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，还需要在配置文件中配置你编写的插件。</code></pre><h5 id="7-一级、二级缓存"><a href="#7-一级、二级缓存" class="headerlink" title="7. 一级、二级缓存"></a>7. 一级、二级缓存</h5><pre><code>1）一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空。2）二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。要开启二级缓存，你需要在你的 SQL 映射文件中添加一行：&lt;cache/&gt;3）对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</code></pre><h5 id="8-Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#8-Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="8. Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？"></a>8. Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？</h5><pre><code>    Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。    它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。</code></pre><h5 id="9-Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？"><a href="#9-Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？" class="headerlink" title="9. Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？"></a>9. Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？</h5><pre><code>    虽然Mybatis解析Xml映射文件是按照顺序解析的，但是，被引用的B标签依然可以定义在任何地方，Mybatis都可以正确识别。    原理是，Mybatis解析A标签，发现A标签引用了B标签，但是B标签尚未解析到，尚不存在，此时，Mybatis会将A标签标记为未解析状态，然后继续解析余下的标签，包含B标签，待所有标签解析完毕，Mybatis会重新解析那些被标记为未解析的标签，此时再解析A标签时，B标签已经存在，A标签也就可以正常解析完成了。</code></pre><h5 id="10-简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？"><a href="#10-简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？" class="headerlink" title="10. 简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？"></a>10. 简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？</h5><pre><code>    Mybatis将所有Xml配置信息都封装到All-In-One重量级对象Configuration内部。在Xml映射文件中，&lt;parameterMap&gt;标签会被解析为ParameterMap对象，其每个子元素会被解析为ParameterMapping对象。&lt;resultMap&gt;标签会被解析为ResultMap对象，其每个子元素会被解析为ResultMapping对象。每一个&lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;标签均会被解析为MappedStatement对象，标签内的sql会被解析为BoundSql对象。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 日常学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jdbc </tag>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解JDK、JRE、JVM</title>
      <link href="/2019/04/02/xiang-jie-jdk-jre-jvm/"/>
      <url>/2019/04/02/xiang-jie-jdk-jre-jvm/</url>
      
        <content type="html"><![CDATA[<h1 id="详解JDK-JRE-JVM之间的区别与联系"><a href="#详解JDK-JRE-JVM之间的区别与联系" class="headerlink" title="详解JDK JRE JVM之间的区别与联系"></a>详解JDK JRE JVM之间的区别与联系</h1><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/04/02/xiang-jie-jdk-jre-jvm/001.png" alt="001"></p><h4 id="一、JDK（Java-Development-ToolKit）Java开发工具"><a href="#一、JDK（Java-Development-ToolKit）Java开发工具" class="headerlink" title="一、JDK（Java Development ToolKit）Java开发工具"></a>一、JDK（Java Development ToolKit）Java开发工具</h4><pre><code>    JDK包含了jre，它除了包含jre之外还包含了一些javac的工具类，把java源文件编译成class文件，java文件是用来运行这个程序的。除此之外，里边还包含了java源生的API等。</code></pre><h5 id="JDK常用的包："><a href="#JDK常用的包：" class="headerlink" title="JDK常用的包："></a>JDK常用的包：</h5><pre><code>java.lang：这个是系统的基础类，比如：String，Math,Integer,system,thread提供常用的功能。Java.io这里面是所用输入输出有关的类，比如:文件操作。java.net:这里面是与网络有关的类，比如URL,URLVonnection等。Java.util：这个是系统辅助类，特别是集合类conllection,list,map等。Java.sql:这个是数据操作的类，connection，statememt,resultset等。JDK有以下三种版本：J2SE，standard edition，标准版；J2EE，enterpsise edtion，企业版；J2ME，micro edtion，主要用于移动设备上的java应用程序总之，JDK是整个JAVA的核心，包括了Java运行环境（Java Runtime Envirnment），一堆Java工具（javac/java/jdb等）和Java基础的类库（即Java API 包括rt.jar）。</code></pre><h4 id="二、JRE（Java-Runtime-Enviroment）Java运行环境"><a href="#二、JRE（Java-Runtime-Enviroment）Java运行环境" class="headerlink" title="二、JRE（Java Runtime Enviroment）Java运行环境"></a>二、JRE（Java Runtime Enviroment）Java运行环境</h4><pre><code>JRE包含JVMJRE，是为了保证java程序能够运行时，所必备的一基础环境，也就是它只是保证java程序运行的，不能用来开发，而jdk才是用来开发的，而想要开发Java，必须包含能够运行的环境，因此，JDK是包含JVM的。并且所有的Java程序都要在JRE下才能运行。</code></pre><pre><code>JDK包括JVM和JAVA核心类库和支持文件。与JDK相比，它不包含开发工具——编译器、调试器和其它工具。</code></pre><h4 id="三、JVM（Java-Virtual-Mechine）Java虚拟机"><a href="#三、JVM（Java-Virtual-Mechine）Java虚拟机" class="headerlink" title="三、JVM（Java Virtual Mechine）Java虚拟机"></a>三、JVM（Java Virtual Mechine）Java虚拟机</h4><pre><code>    JRE是Java运行时环境，Java运行靠的就是底层的依赖于JVM，即java虚拟机，Java虚拟机用来加载类文件，Java中之所以有跨平台的作用，JVM是按照不同的平台所写的，因此，Java具有跨平台性，但是JVM确实依赖于平台的。</code></pre><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/04/02/xiang-jie-jdk-jre-jvm/002.png" alt="002"></p><pre><code>    JVM是JRE的一部分，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。JVM 的主要工作是解释自己的指令集（即字节码）并映射到本地的 CPU 的指令集或 OS 的系统调用。Java语言是跨平台运行的，其实就是不同的操作系统，使用不同的JVM映射规则，让其与操作系统无关，完成了跨平台性。JVM 对上层的 Java 源文件是不关心的，它关注的只是由源文件生成的类文件（ class file）。类文件的组成包括 JVM 指令集，符号表以及一些补助信息。</code></pre><h4 id="JDK-JRE-JVM三者间的关系"><a href="#JDK-JRE-JVM三者间的关系" class="headerlink" title="JDK,JRE,JVM三者间的关系"></a>JDK,JRE,JVM三者间的关系</h4><pre><code>    其实在JDK的安装目录下有一个名为jre的目录，里面有两个文件夹bin和lib，在这里可以认为bin里的就是jvm，lib中则是jvm工作所需要的类库。</code></pre><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/04/02/xiang-jie-jdk-jre-jvm/003.png" alt="003"></p><pre><code>本文部分转载头条@波波说运维</code></pre><pre><code>有兴趣的小伙伴可以关注我的博客，只要有时间每天更新！ </code></pre><p><a href="http://www.zongmansheng.club" target="_blank" rel="noopener">www.zongmansheng.club</a></p><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/04/02/xiang-jie-jdk-jre-jvm/004.gif" alt="004"></p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> JDK </tag>
            
            <tag> JRK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web.xml组件加载顺序</title>
      <link href="/2019/04/02/web-xml-zu-jian-jia-zai-shun-xu/"/>
      <url>/2019/04/02/web-xml-zu-jian-jia-zai-shun-xu/</url>
      
        <content type="html"><![CDATA[<h1 id="Java的web-xml组件加载顺序"><a href="#Java的web-xml组件加载顺序" class="headerlink" title="Java的web.xml组件加载顺序"></a>Java的web.xml组件加载顺序</h1><pre><code>在我们日常开发中，配置项目组件可以说是家常便饭，了解Tomcat加载组件顺序很有必要。例如：    Quartz的集群功能需要数据库的支持，数据库的加载肯定要在框架组件加载之前。</code></pre><pre><code>web.xm组件加载顺序为：context-param -&gt; listener -&gt; filter -&gt; servlet(同类则按编写顺序执行)。</code></pre><p><strong>web.xml常用组件解析：</strong> </p><pre><code>&lt;web-app&gt;&lt;display-name&gt;&lt;/display-name&gt;WEB应用的名字&lt;description&gt;&lt;/description&gt; WEB应用的描述&lt;context-param&gt;&lt;/context-param&gt; context-param元素声明应用范围内的初始化参数&lt;!– 指定spring配置文件位置 –&gt;&lt;context-param&gt;&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;&lt;param-value&gt;&lt;!–加载多个spring配置文件 –&gt;/WEB-INF/applicationContext.xml, /WEB-INF/action-servlet.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;filter&gt;&lt;/filter&gt; 过滤器将一个名字与一个实现javax.servlet.Filter接口的类相关联&lt;filter-mapping&gt;&lt;/filter-mapping&gt; 一旦命名了一个过滤器，就要利用filter-mapping元素把它与一个或多个servlet或JSP页面相关联&lt;listener&gt;&lt;/listener&gt; 事件监听程序在建立、修改和删除会话或servlet环境时得到通知。Listener元素指出事件监听程序类。如Log4j这个广泛使用的监听和&lt;!– 定义SPRING监听器，加载spring –&gt;&lt;listener&gt;&lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;servlet&gt;&lt;/servlet&gt; 在向servlet或JSP页面制定初始化参数或定制URL时，必须首先命名servlet或JSP页面。Servlet元素就是用来完成此项任务的。&lt;servlet-mapping&gt;&lt;/servlet-mapping&gt; 服务器一般为servlet提供一个缺省的URL：http://host/webAppPrefix/servlet/ServletName。但是，常常会更改这个URL，以便servlet可以访问初始化参数或更容易地处理相对URL。在更改缺省URL时，使用servlet-mapping元素&lt;session-config&gt;&lt;/session-config&gt; 如果某个会话在一定时间内未被访问，服务器可以抛弃它以节省内存。 可通过使用HttpSession的setMaxInactiveInterval方法明确设置单个会话对象的超时值，或者可利用session-config元素制定缺省超时值&lt;mime-mapping&gt;&lt;/mime-mapping&gt;如果Web应用具有想到特殊的文件，希望能保证给他们分配特定的MIME类型，则mime-mapping元素提供这种保证&lt;welcome-file-list&gt;&lt;/welcome-file-list&gt; 指示服务器在收到引用一个目录名而不是文件名的URL时，使用哪个文件(其实就是欢迎界面或者说入口界面一般为index.*)&lt;error-page&gt;&lt;/error-page&gt; 在返回特定HTTP状态代码时，或者特定类型的异常被抛出时，能够制定将要显示的页面。&lt;taglib&gt;&lt;/taglib&gt; 对标记库描述符文件（Tag Libraryu Descriptor file）指定别名。此功能使你能够更改TLD文件的位置， 而不用编辑使用这些文件的JSP页面。&lt;resource-env-ref&gt;&lt;/resource-env-ref&gt;声明与资源相关的一个管理对象。&lt;resource-ref&gt;&lt;/resource-ref&gt; 声明一个资源工厂使用的外部资源。&lt;security-constraint&gt;&lt;/security-constraint&gt; 制定应该保护的URL。它与login-config元素联合使用&lt;login-config&gt;&lt;/login-config&gt; 指定服务器应该怎样给试图访问受保护页面的用户授权。它与sercurity-constraint元素联合使用。&lt;security-role&gt;&lt;/security-role&gt;给出安全角色的一个列表，这些角色将出现在servlet元素内的security-role-ref元素的role-name子元素中。分别地声明角色可使高级IDE处理安全信息更为容易&lt;env-entry&gt;&lt;/env-entry&gt;声明Web应用的环境项&lt;/web-app&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> web基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xml </tag>
            
            <tag> 配置文件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库索引</title>
      <link href="/2019/04/01/shu-ju-ku-suo-yin/"/>
      <url>/2019/04/01/shu-ju-ku-suo-yin/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h1><p>[TOC]</p><h4 id="一、索引"><a href="#一、索引" class="headerlink" title="一、索引"></a>一、索引</h4><pre><code>    索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。如果想按特定职员的姓来查找他或她，则与在表中搜索所有的行相比，索引有助于更快地获取信息。    索引的一个主要目的就是加快检索表中数据，亦即能协助信息搜索者尽快的找到符合限制条件的记录ID的辅助数据结构。</code></pre><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><pre><code>搜索码。它表示的是记录各种字符段的一个集合，它可以是一个或者是多个字符段的任意序列组合，并不是惟一的一个标识记录。数据目录项。即为索引的相关元素，在建立索引的过程中，数据目录项一般具有各种不同的选择方式。记录ID。每一个/段索引在存储内容中惟一的一个标识符。</code></pre><h5 id="主要种类"><a href="#主要种类" class="headerlink" title="主要种类"></a>主要种类</h5><pre><code>数据库索引好比是一本书前面的目录，能加快数据库的查询速度。索引分为聚簇索引和非聚簇索引两种，聚簇索引 是按照数据存放的物理位置为顺序的，而非聚簇索引就不一样了；聚簇索引能提高多行检索的速度，而非聚簇索引对于单行的检索很快。根据数据库的功能，可以在数据库设计器中创建三种索引：唯一索引、主键索引和聚集索引。有关数据库所支持的索引功能的详细信息，请参见数据库文档。提示：尽管唯一索引有助于定位信息，但为获得最佳性能结果，建议改用主键或唯一约束。</code></pre><h5 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h5><pre><code>    唯一索引是不允许其中任何两行具有相同索引值的索引。当现有数据中存在重复的键值时，大多数数据库不允许将新创建的唯一索引与表一起保存。数据库还可能防止添加将在表中创建重复键值的新数据。例如，如果在employee表中职员的姓(lname)上创建了唯一索引，则任何两个员工都不能同姓。</code></pre><h5 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h5><pre><code>    数据库表经常有一列或多列组合，其值唯一标识表中的每一行。该列称为表的主键。在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。</code></pre><h5 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h5><pre><code>    在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。聚集索引和非聚集索引的区别，如字典默认按字母顺序排序，读者如知道某个字的读音可根据字母顺序快速定位。因此聚集索引和表的内容是在一起的。如读者需查询某个生僻字，则需按字典前面的索引，举例按偏旁进行定位，找到该字对应的页数，再打开对应页数找到该字。这种通过两个地方而查询到某个字的方式就如非聚集索引。</code></pre><h5 id="索引列"><a href="#索引列" class="headerlink" title="索引列"></a>索引列</h5><pre><code>    可以基于数据库表中的单列或多列创建索引。多列索引可以区分其中一列可能有相同值的行。如果经常同时搜索两列或多列或按两列或多列排序时，索引也很有帮助。例如，如果经常在同一查询中为姓和名两列设置判据，那么在这两列上创建多列索引将很有意义。    检查查询的WHERE和JOIN子句。在任一子句中包括的每一列都是索引可以选择的对象。对新索引进行试验以检查它对运行查询性能的影响。考虑已在表上创建的索引数量。最好避免在单个表上有很多索引。检查已在表上创建的索引的定义。最好避免包含共享列的重叠索引。    检查某列中唯一数据值的数量，并将该数量与表中的行数进行比较。比较的结果就是该列的可选择性，这有助于确定该列是否适合建立索引，如果适合，确定索引的类型。</code></pre><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><pre><code>通过建立索引可以极大地提高在数据库中获取所需信息的速度，同时还能提高服务器处理相关搜索请求的效率，从这个方面来看它具有以下优点 [1]  ：    在设计数据库时，通过创建一个惟一的索引，能够在索引和信息之间形成一对一的映射式的对应关系，增加数据的惟一性特点。    能提高数据的搜索及检索速度，符合数据库建立的初衷。    能够加快表与表之间的连接速度，这对于提高数据的参考完整性方面具有重要作用。    在信息检索过程中，若使用分组及排序子句进行时，通过建立索引能有效的减少检索过程中所需的分组及排序时间，提高检索效率。建立索引之后，在信息查询过程中可以使用优化隐藏器，这对于提高整个信息检索系统的性能具有重要意义。</code></pre><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点:"></a>缺点:</h5><pre><code>虽然索引的建立在提高检索效率方面具有诸多积极的作用，但还是存在下列缺点 [1]  ：在数据库建立过程中，需花费较多的时间去建立并维护索引，特别是随着数据总量的增加，所花费的时间将不断递增。在数据库中创建的索引需要占用一定的物理存储空间，这其中就包括数据表所占的数据空间以及所创建的每一个索引所占用的物理空间，如果有必要建立起聚簇索引，所占用的空间还将进一步的增加在对表中的数据进行修改时，例如对其进行增加、删除或者是修改操作时，索引还需要进行动态的维护，这给数据库的维护速度带来了一定的麻烦。</code></pre><h5 id="数据库索引的数据结构基础-B-tree"><a href="#数据库索引的数据结构基础-B-tree" class="headerlink" title="数据库索引的数据结构基础 B+tree"></a>数据库索引的数据结构基础 B+tree</h5><pre><code>B＋tree 是一个n叉树，每个节点有多个叶子节点，一颗B+树包含根节点，内部节点，叶子节点。根节点可能是一个叶子节点，也可能是一个包含两个或两个以上叶子节点的节点。</code></pre><pre><code>B＋tree的性质：1.n棵子tree的节点包含n个关键字，不用来保存数据而是保存数据的索引。2.所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。3.所有的非终端结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。B＋tree结构原型图大概如下（引用）：</code></pre><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/04/01/shu-ju-ku-suo-yin/001.png" alt="001"></p><pre><code>    由于B+tree的性质， 它通常被用于数据库和操作系统的文件系统中。NTFS, ReiserFS, NSS, XFS, JFS, ReFS 和BFS等文件系统都在使用B+树作为元数据索引，因为B+ 树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度（B+ 树元素自底向上插入）。</code></pre><p>（二）数据库索引</p><pre><code>数据库索引是用于提高数据库表的数据访问速度的。数据库索引的特点：a）避免进行数据库全表的扫描，大多数情况，只需要扫描较少的索引页和数据页，而不是查询所有数据页。而且对于非聚集索引，有时不需要访问数据页即可得到数据。b）聚集索引可以避免数据插入操作，集中于表的最后一个数据页面。c）在某些情况下，索引可以避免排序操作。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql，索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM虚拟机</title>
      <link href="/2019/03/31/jvm-xu-ni-ji/"/>
      <url>/2019/03/31/jvm-xu-ni-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM虚拟机"><a href="#JVM虚拟机" class="headerlink" title="JVM虚拟机"></a>JVM虚拟机</h1><h4 id="一、运行时数据区域"><a href="#一、运行时数据区域" class="headerlink" title="一、运行时数据区域"></a>一、运行时数据区域</h4><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/03/31/jvm-xu-ni-ji/001.png" alt="001"></p><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/03/31/jvm-xu-ni-ji/002.png" alt="002"></p><h5 id="1-1-程序计数器"><a href="#1-1-程序计数器" class="headerlink" title="1.1 程序计数器"></a>1.1 程序计数器</h5><pre><code>记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）。</code></pre><h5 id="1-2-java虚拟机栈"><a href="#1-2-java虚拟机栈" class="headerlink" title="1.2 java虚拟机栈"></a>1.2 java虚拟机栈</h5><pre><code>    每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</code></pre><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/03/31/jvm-xu-ni-ji/003.png" alt="003"></p><pre><code>可以通过 -Xss 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小：    java -Xss512M HackTheJava</code></pre><p>该区域可能抛出以下异常：</p><pre><code>◾当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；◾栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。</code></pre><h5 id="1-3-本地方法栈"><a href="#1-3-本地方法栈" class="headerlink" title="1.3 本地方法栈"></a>1.3 本地方法栈</h5><pre><code>    本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。    本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。</code></pre><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/03/31/jvm-xu-ni-ji/004.png" alt="004"></p><h5 id="1-4-堆"><a href="#1-4-堆" class="headerlink" title="1.4 堆"></a>1.4 堆</h5><pre><code>    所有对象都在这里分配内存，是垃圾收集的主要区域（&quot;GC 堆&quot;）。    现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。可以将堆分成两块：</code></pre><pre><code>◾新生代（Young Generation）◾老年代（Old Generation）</code></pre><pre><code>堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。可以通过 -Xms 和 -Xmx 这两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。</code></pre><pre><code>java -Xms1M -Xmx2M HackTheJava</code></pre><h5 id="1-5-方法区"><a href="#1-5-方法区" class="headerlink" title="1.5 方法区"></a>1.5 方法区</h5><pre><code>用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。HotSpot 虚拟机把它当成永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。</code></pre><h5 id="1-6-运行时常量池"><a href="#1-6-运行时常量池" class="headerlink" title="1.6 运行时常量池"></a>1.6 运行时常量池</h5><pre><code>运行时常量池是方法区的一部分。Class 文件中的常量池（编译器生成的字面量和符号引用）会在类加载后被放入这个区域。除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。</code></pre><h5 id="1-7-直接内存"><a href="#1-7-直接内存" class="headerlink" title="1.7 直接内存"></a>1.7 直接内存</h5><pre><code>    在 JDK 1.4 中新引入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在堆内存和堆外内存来回拷贝数据。</code></pre><h4 id="二、垃圾收集"><a href="#二、垃圾收集" class="headerlink" title="二、垃圾收集"></a>二、垃圾收集</h4><pre><code>    垃圾收集主要是针对堆和方法区进行。程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收。</code></pre><h5 id="判断一个对象是否可被回收"><a href="#判断一个对象是否可被回收" class="headerlink" title="判断一个对象是否可被回收"></a><strong>判断一个对象是否可被回收</strong></h5><h6 id="2-1-引用计数算法"><a href="#2-1-引用计数算法" class="headerlink" title="2.1 引用计数算法"></a>2.1 引用计数算法</h6><pre><code>    为对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。    在两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。正是因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。</code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019/3/31 0031 * @Time: 21:38 * @Vsersion: 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestJvm</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> Object instance <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        TestJvm xxx <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TestJvm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        TestJvm yyy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TestJvm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        xxx<span class="token punctuation">.</span>instance <span class="token operator">=</span> yyy<span class="token punctuation">;</span>        yyy<span class="token punctuation">.</span>instance <span class="token operator">=</span> xxx<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h6 id="2-2-可达性分析算法"><a href="#2-2-可达性分析算法" class="headerlink" title="2.2  可达性分析算法"></a>2.2  可达性分析算法</h6><pre><code>以 GC Roots 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。Java 虚拟机使用该算法来判断对象是否可被回收，GC Roots 一般包含以下内容：</code></pre><pre><code>◾虚拟机栈中局部变量表中引用的对象◾本地方法栈中 JNI 中引用的对象◾方法区中类静态属性引用的对象◾方法区中的常量引用的对象</code></pre><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/03/31/jvm-xu-ni-ji/005.png" alt="005"></p><h6 id="2-3-方法区的回收"><a href="#2-3-方法区的回收" class="headerlink" title="2.3 方法区的回收"></a>2.3 方法区的回收</h6><pre><code>因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。主要是对常量池的回收和对类的卸载。为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能。类的卸载条件很多，需要满足以下三个条件，并且满足了条件也不一定会被卸载：</code></pre><pre><code>◾该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。◾加载该类的 ClassLoader 已经被回收。◾该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。</code></pre><h6 id="2-4-finalize"><a href="#2-4-finalize" class="headerlink" title="2.4 finalize()"></a>2.4 finalize()</h6><pre><code>类似 C++ 的析构函数，用于关闭外部资源。但是 try-finally 等方式可以做得更好，并且该方法运行代价很高，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会再调用该方法。</code></pre><p><strong>引用类型</strong></p><pre><code>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。Java 提供了四种强度不同的引用类型。</code></pre><ol><li><p>强引用</p><pre><code>被强引用关联的对象不会被回收。使用 new 一个新对象的方式来创建强引用。</code></pre><pre class=" language-java"><code class="language-java">Object obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>软引用</p><pre><code>被软引用关联的对象只有在内存不够的情况下才会被回收。使用 SoftReference 类来创建软引用。</code></pre><pre class=" language-java"><code class="language-java">Object obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>SoftReference<span class="token operator">&lt;</span>Object<span class="token operator">></span> softReference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//使对象只被软引用关联</span>obj <span class="token operator">=</span> null<span class="token punctuation">;</span></code></pre></li><li><p>弱引用</p><pre><code>被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。使用 WeakReference 类来创建弱引用。</code></pre><pre class=" language-java"><code class="language-java">Object obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>WeakReference<span class="token operator">&lt;</span>Object<span class="token operator">></span> weakReference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakReference</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>obj <span class="token operator">=</span> null<span class="token punctuation">;</span></code></pre></li><li><p>虚引用</p></li></ol><pre><code>又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。使用 PhantomReference 来创建虚引用。</code></pre><pre class=" language-java"><code class="language-java">Object obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>PhantomReference<span class="token operator">&lt;</span>Object<span class="token operator">></span> phantomReference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PhantomReference</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>obj <span class="token operator">=</span> null<span class="token punctuation">;</span></code></pre><h5 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h5><h6 id="1-标记-清除"><a href="#1-标记-清除" class="headerlink" title="1. 标记 - 清除"></a>1. 标记 - 清除</h6><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/03/31/jvm-xu-ni-ji/006.png" alt="006"></p><pre><code>标记要回收的对象，然后清除。不足：◾标记和清除过程效率都不高；◾会产生大量不连续的内存碎片，导致无法给大对象分配内存。</code></pre><h6 id="2-标记-整理"><a href="#2-标记-整理" class="headerlink" title="2. 标记 - 整理"></a>2. 标记 - 整理</h6><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/03/31/jvm-xu-ni-ji/007.png" alt="007"></p><pre><code>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</code></pre><h6 id="3-复制"><a href="#3-复制" class="headerlink" title="3. 复制"></a>3. 复制</h6><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/03/31/jvm-xu-ni-ji/008.png" alt="008"></p><pre><code>将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。主要不足是只使用了内存的一半。现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 就不够用了，此时需要依赖于老年代进行空间分配担保，也就是借用老年代的空间存储放不下的对象。</code></pre><h6 id="4-分代收集"><a href="#4-分代收集" class="headerlink" title="4. 分代收集"></a>4. 分代收集</h6><pre><code>现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。一般将堆分为新生代和老年代。◾新生代使用：复制算法老年代使用：标记 - 清除 或者 标记 - 整理 算法</code></pre><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/03/31/jvm-xu-ni-ji/009.png" alt="009"></p><pre><code>◾单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程；◾串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。</code></pre><h5 id="1-Serial-收集器"><a href="#1-Serial-收集器" class="headerlink" title="1. Serial 收集器"></a>1. Serial 收集器</h5><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/03/31/jvm-xu-ni-ji/010.png" alt="010"></p><pre><code>Serial 翻译为串行，也就是说它以串行的方式执行。它是单线程的收集器，只会使用一个线程进行垃圾收集工作。它的优点是简单高效，在单个 CPU 环境下，由于没有线程交互的开销，因此拥有最高的单线程收集效率。它是 Client 场景下的默认新生代收集器，因为在该场景下内存一般来说不会很大。它收集一两百兆垃圾的停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿时间是可以接受的。</code></pre><h5 id="2-ParNew-收集器"><a href="#2-ParNew-收集器" class="headerlink" title="2. ParNew 收集器"></a>2. ParNew 收集器</h5><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/03/31/jvm-xu-ni-ji/011.png" alt="011"></p><pre><code>它是 Serial 收集器的多线程版本。它是 Server 场景下默认的新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合使用。</code></pre><h5 id="3-Parallel-Scavenge-收集器"><a href="#3-Parallel-Scavenge-收集器" class="headerlink" title="3. Parallel Scavenge 收集器"></a>3. Parallel Scavenge 收集器</h5><pre><code>与 ParNew 一样是多线程收集器。其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，因此它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户程序的时间占总时间的比值。停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。可以通过一个开关参数打开 GC 自适应的调节策略（GC Ergonomics），就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例、晋升老年代对象年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。</code></pre><h5 id="4-Serial-Old-收集器"><a href="#4-Serial-Old-收集器" class="headerlink" title="4. Serial Old 收集器"></a>4. Serial Old 收集器</h5><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/03/31/jvm-xu-ni-ji/012.png" alt="012"></p><pre><code>是 Serial 收集器的老年代版本，也是给 Client 场景下的虚拟机使用。如果用在 Server 场景下，它有两大用途：◾在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。◾作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。</code></pre><h5 id="5-Parallel-Old-收集器"><a href="#5-Parallel-Old-收集器" class="headerlink" title="5. Parallel Old 收集器"></a>5. Parallel Old 收集器</h5><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/03/31/jvm-xu-ni-ji/013.png" alt="013"></p><pre><code>是 Parallel Scavenge 收集器的老年代版本。在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。</code></pre><h5 id="6-CMS-收集器"><a href="#6-CMS-收集器" class="headerlink" title="6. CMS 收集器"></a>6. CMS 收集器</h5><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/03/31/jvm-xu-ni-ji/014.png" alt="014"></p><pre><code>CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法。分为以下四个流程：◾初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。◾并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。◾重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。◾并发清除：不需要停顿。在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。具有以下缺点：◾吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。◾无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。◾标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。</code></pre><h5 id="7-G1-收集器"><a href="#7-G1-收集器" class="headerlink" title="7. G1 收集器"></a>7. G1 收集器</h5><pre><code>G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。</code></pre><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/03/31/jvm-xu-ni-ji/015.png" alt="015"></p><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/03/31/jvm-xu-ni-ji/016.png" alt="016"></p><pre><code>通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。</code></pre><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/03/31/jvm-xu-ni-ji/017.png" alt="017"></p><pre><code>如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：◾初始标记◾并发标记◾最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。◾筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。具备如下特点：◾空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。◾可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。</code></pre><h4 id="三、内存分配与回收策略"><a href="#三、内存分配与回收策略" class="headerlink" title="三、内存分配与回收策略"></a>三、内存分配与回收策略</h4><h5 id="Minor-GC-和-Full-GC"><a href="#Minor-GC-和-Full-GC" class="headerlink" title="Minor GC 和 Full GC"></a>Minor GC 和 Full GC</h5><pre><code>◾Minor GC：回收新生代上，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会  比较快。◾Full GC：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。</code></pre><h5 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h5><pre><code>1. 对象优先在 Eden 分配大多数情况下，对象在新生代 Eden 区分配，当 Eden 区空间不够时，发起 Minor GC。2. 大对象直接进入老年代大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 区和 Survivor 区之间的大量内存复制。3. 长期存活的对象进入老年代为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。-XX:MaxTenuringThreshold 用来定义年龄的阈值。4. 动态对象年龄判定虚拟机并不是永远地要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。5. 空间分配担保在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。如果不成立的话虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 设置不允许冒险，那么就要进行一次 Full GC。</code></pre><h5 id="Full-GC-的触发条件"><a href="#Full-GC-的触发条件" class="headerlink" title="Full GC 的触发条件"></a>Full GC 的触发条件</h5><pre><code>对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件：1. 调用 System.gc()只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。2. 老年代空间不足老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。3. 空间分配担保失败使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。具体内容请参考上面的第五小节。4. JDK 1.7 及以前的永久代空间不足在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。5. Concurrent Mode Failure执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。</code></pre><h4 id="四、类加载机制"><a href="#四、类加载机制" class="headerlink" title="四、类加载机制"></a>四、类加载机制</h4><pre><code>类是在运行期间第一次使用时动态加载的，而不是一次性加载。因为如果一次性加载，那么会占用很多的内存。</code></pre><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/03/31/jvm-xu-ni-ji/018.png" alt="018"></p><pre><code>包括以下 7 个阶段：◾加载（Loading）◾验证（Verification）◾准备（Preparation）◾解析（Resolution）◾初始化（Initialization）◾使用（Using）◾卸载（Unloading）类加载过程包含了加载、验证、准备、解析和初始化这 5 个阶段。</code></pre><h5 id="1-加载"><a href="#1-加载" class="headerlink" title="1. 加载"></a>1. 加载</h5><pre><code>加载是类加载的一个阶段，注意不要混淆。加载过程完成以下三件事：◾通过类的完全限定名称获取定义该类的二进制字节流。◾将该字节流表示的静态存储结构转换为方法区的运行时存储结构。◾在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口。其中二进制字节流可以从以下方式中获取：◾从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础。◾从网络中获取，最典型的应用是 Applet。◾运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。◾由其他文件生成，例如由 JSP 文件生成对应的 Class 类。</code></pre><h5 id="2-验证"><a href="#2-验证" class="headerlink" title="2. 验证"></a>2. 验证</h5><pre><code>确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</code></pre><h5 id="3-准备"><a href="#3-准备" class="headerlink" title="3. 准备"></a>3. 准备</h5><pre><code>类变量是被 static 修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存。实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中。应该注意到，实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123。</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span></code></pre><pre><code>如果类变量是常量，那么它将初始化为表达式所定义的值而不是 0。例如下面的常量 value 被初始化为 123 而不是 0。</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span></code></pre><h5 id="4-解析"><a href="#4-解析" class="headerlink" title="4. 解析"></a>4. 解析</h5><pre><code>将常量池的符号引用替换为直接引用的过程。其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。</code></pre><h5 id="5-初始化"><a href="#5-初始化" class="headerlink" title="5. 初始化"></a>5. 初始化</h5><pre><code>初始化阶段才真正开始执行类中定义的 Java 程序代码。初始化阶段是虚拟机执行类构造器 &lt;clinit&gt;() 方法的过程。在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。在准备阶段，已经为类变量分配了系统所需的初始值，并且在初始化阶段，根据程序员通过程序进行的主观计划来初始化类变量和其他资源。&lt;clinit&gt;() 是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。例如以下代码：</code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019/3/31 0031 * @Time: 22:22 * @Vsersion: 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestJvm</span> <span class="token punctuation">{</span> <span class="token keyword">static</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">//给变量赋值可以正常编译通过</span>     i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//编译器会提示“非法向前指引”</span>     System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">static</span> <span class="token keyword">int</span> i <span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre><code>由于父类的 &lt;clinit&gt;() 方法先执行，也就意味着父类中定义的静态语句块的执行要优先于子类。例如以下代码：</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Parent</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> A <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        A <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Sub</span> <span class="token keyword">extends</span> <span class="token class-name">Parent</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> B <span class="token operator">=</span> A<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Sub<span class="token punctuation">.</span>B<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//2</span><span class="token punctuation">}</span></code></pre><pre><code>接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 &lt;clinit&gt;() 方法。但接口与类不同的是，执行接口的 &lt;clinit&gt;() 方法不需要先执行父接口的 &lt;clinit&gt;() 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 &lt;clinit&gt;() 方法。虚拟机会保证一个类的 &lt;clinit&gt;() 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 &lt;clinit&gt;() 方法，其它线程都会阻塞等待，直到活动线程执行 &lt;clinit&gt;() 方法完毕。如果在一个类的 &lt;clinit&gt;() 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽。</code></pre><h4 id="类初始化时机"><a href="#类初始化时机" class="headerlink" title="类初始化时机"></a><strong>类初始化时机</strong></h4><h5 id="1-主动引用"><a href="#1-主动引用" class="headerlink" title="1. 主动引用"></a><strong>1. 主动引用</strong></h5><pre><code>虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了有且只有下列五种情况必须对类进行初始化（加载、验证、准备都会随之发生）：◾◾遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这 4 条指令的场景是：使用 new 关键字实例化对象的时候；读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候；以及调用一个类的静态方法的时候。◾使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。◾当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。◾当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类；◾当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REFgetStatic, REFputStatic, REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化；</code></pre><h5 id="2-被动引用"><a href="#2-被动引用" class="headerlink" title="2. 被动引用"></a><strong>2. 被动引用</strong></h5><pre><code>以上 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用的常见例子包括：◾通过子类引用父类的静态字段，不会导致子类初始化。</code></pre><pre class=" language-java"><code class="language-java">System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>SubClass<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre><code>◾通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。</code></pre><pre class=" language-java"><code class="language-java">SuperClass<span class="token punctuation">[</span><span class="token punctuation">]</span> sca <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SuperClass</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><pre><code>◾常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</code></pre><pre><code>System.out.println(ConstClass.HELLOWORLD);</code></pre><h4 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a><strong>类与类加载器</strong></h4><pre><code>两个类相等，需要类本身相等，并且使用同一个类加载器进行加载。这是因为每一个类加载器都拥有一个独立的类名称空间。这里的相等，包括类的 Class 对象的 equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果为 true，也包括使用 instanceof 关键字做对象所属关系判定结果为 true。类加载器分类从 Java 虚拟机的角度来讲，只存在以下两种不同的类加载器：◾◾启动类加载器（Bootstrap ClassLoader），使用 C++ 实现，是虚拟机自身的一部分；◾所有其它类的加载器，使用 Java 实现，独立于虚拟机，继承自抽象类 java.lang.ClassLoader。从 Java 开发人员的角度看，类加载器可以划分得更细致一些：◾◾启动类加载器（Bootstrap ClassLoader）此类加载器负责将存放在 &lt;JRE_HOME&gt;lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可。◾扩展类加载器（Extension ClassLoader）这个类加载器是由 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将 &lt;JAVA_HOME&gt;/lib/ext 或者被 java.ext.dir 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。◾应用程序类加载器（Application ClassLoader）这个类加载器是由 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此一般称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</code></pre><p><strong>双亲委派模型</strong></p><pre><code>应用程序是由三种类加载器互相配合从而实现类加载，除此之外还可以加入自己定义的类加载器。下图展示了类加载器之间的层次关系，称为双亲委派模型（Parents Delegation Model）。该模型要求除了顶层的启动类加载器外，其它的类加载器都要有自己的父类加载器。类加载器之间的父子关系一般通过组合关系（Composition）来实现，而不是继承关系（Inheritance）。</code></pre><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/03/31/jvm-xu-ni-ji/019.png" alt="019"></p><p><strong>1. 工作过程</strong></p><pre><code>一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载。</code></pre><p><strong>2. 好处</strong></p><pre><code>使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。例如 java.lang.Object 存放在 rt.jar 中，如果编写另外一个 java.lang.Object 并放到 ClassPath 中，程序可以编译通过。由于双亲委派模型的存在，所以在 rt.jar 中的 Object 比在 ClassPath 中的 Object 优先级更高，这是因为 rt.jar 中的 Object 使用的是启动类加载器，而 ClassPath 中的 Object 使用的是应用程序类加载器。rt.jar 中的 Object 优先级更高，那么程序中所有的 Object 都是这个 Object。</code></pre><p><strong>3. 实现</strong></p><pre><code>以下是抽象类 java.lang.ClassLoader 的代码片段，其中的 loadClass() 方法运行过程如下：先检查类是否已经加载过，如果没有则让父类加载器去加载。当父类加载器加载失败时抛出 ClassNotFoundException，此时尝试自己去加载。</code></pre><p>自定义类加载器实现</p><pre><code>FileSystemClassLoader 是自定义类加载器，继承自 java.lang.ClassLoader，用于加载文件系统上的类。它首先根据类的全名在文件系统上查找类的字节代码文件（.class 文件），然后读取该文件内容，最后通过 defineClass() 方法来把这些字节代码转换成 java.lang.Class 类的实例。java.lang.ClassLoader 的 loadClass() 实现了双亲委派模型的逻辑，自定义类加载器一般不去重写它，但是需要重写 findClass() 方法。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java8新特性</title>
      <link href="/2019/03/30/java8-xin-te-xing/"/>
      <url>/2019/03/30/java8-xin-te-xing/</url>
      
        <content type="html"><![CDATA[<h1 id="java-8-新特性"><a href="#java-8-新特性" class="headerlink" title="java 8-新特性"></a>java 8-新特性</h1><h4 id="一、Java-8-Lambda-表达式"><a href="#一、Java-8-Lambda-表达式" class="headerlink" title="一、Java 8 Lambda 表达式"></a>一、Java 8 Lambda 表达式</h4><pre><code>Lambda 表达式，也可称为闭包，它是推动 Java 8 发布的最重要新特性。Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。使用Lambda 表达式可以使代码变的更加简洁紧凑。</code></pre><h5 id="1-1-语法"><a href="#1-1-语法" class="headerlink" title="1.1 语法"></a>1.1 语法</h5><pre><code>lambda 表达式的语法格式如下：(parameters) -&gt; expression或(parameters) -&gt;{statements; }</code></pre><pre><code>lambda表达式的重要特征:可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。可选的大括号：如果主体包含了一个语句，就不需要使用大括号。可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。</code></pre><h5 id="1-2-Lambda-表达式实例"><a href="#1-2-Lambda-表达式实例" class="headerlink" title="1.2  Lambda 表达式实例"></a>1.2  Lambda 表达式实例</h5><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> java8<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019/3/30 0030 * @Time: 19:16 * @Vsersion: 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test1</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Test1 test <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 类型声明</span>        MathOperation addition <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 不用类型声明</span>        MathOperation subtraction <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> a <span class="token operator">-</span> b<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 大括号中的返回语句</span>        MathOperation multiplication <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> a <span class="token operator">*</span> b<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 没有大括号及返回语句</span>        MathOperation division <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> a <span class="token operator">/</span> b<span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"10 + 5 = "</span> <span class="token operator">+</span> test<span class="token punctuation">.</span><span class="token function">operate</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> addition<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"10 - 5 = "</span> <span class="token operator">+</span> test<span class="token punctuation">.</span><span class="token function">operate</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> subtraction<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"10 x 5 = "</span> <span class="token operator">+</span> test<span class="token punctuation">.</span><span class="token function">operate</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> multiplication<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"10 / 5 = "</span> <span class="token operator">+</span> test<span class="token punctuation">.</span><span class="token function">operate</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> division<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 不用括号</span>        GreetingService greetService1 <span class="token operator">=</span> message <span class="token operator">-</span><span class="token operator">></span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ZongMan say: "</span> <span class="token operator">+</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 用括号</span>        GreetingService greetService2 <span class="token operator">=</span> <span class="token punctuation">(</span>message<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ZongMan say: "</span> <span class="token operator">+</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>        greetService1<span class="token punctuation">.</span><span class="token function">sayMessage</span><span class="token punctuation">(</span><span class="token string">"说什么王权富贵！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        greetService2<span class="token punctuation">.</span><span class="token function">sayMessage</span><span class="token punctuation">(</span><span class="token string">"怕什么戒律清规！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">interface</span> <span class="token class-name">MathOperation</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> <span class="token function">operation</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">interface</span> <span class="token class-name">GreetingService</span> <span class="token punctuation">{</span>        <span class="token keyword">void</span> <span class="token function">sayMessage</span><span class="token punctuation">(</span>String message<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">operate</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> MathOperation mathOperation<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> mathOperation<span class="token punctuation">.</span><span class="token function">operation</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>运行结果：</p><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/03/30/java8-xin-te-xing/test1.png" alt="test1"></p><h5 id="1-3-注意事项"><a href="#1-3-注意事项" class="headerlink" title="1.3 注意事项"></a>1.3 注意事项</h5><pre><code>      Lambda 表达式主要用来定义行内执行的方法类型接口，例如，一个简单方法接口。在上面例子中，我们使用各种类型的Lambda表达式来定义MathOperation接口的方法。然后我们定义了sayMessage的执行。Lambda 表达式免去了使用匿名方法的麻烦，并且给予Java简单但是强大的函数化的编程能力。</code></pre><h4 id="二、Java-8-方法引用"><a href="#二、Java-8-方法引用" class="headerlink" title="二、Java 8 方法引用"></a>二、Java 8 方法引用</h4><pre><code>方法引用通过方法的名字来指向一个方法。方法引用可以使语言的构造更紧凑简洁，减少冗余代码。方法引用使用一对冒号 :: </code></pre><h5 id="2-1方法引用"><a href="#2-1方法引用" class="headerlink" title="2.1方法引用"></a>2.1方法引用</h5><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> java8<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>List<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019/3/30 0030 * @Time: 19:30 * @Vsersion: 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test2</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Car</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@FunctionalInterface</span>        <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Supplier</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>            T <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//Supplier是jdk1.8的接口，这里和lamda一起使用了</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> Car <span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">final</span> Supplier<span class="token operator">&lt;</span>Car<span class="token operator">></span> supplier<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> supplier<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">collide</span><span class="token punctuation">(</span><span class="token keyword">final</span> Car car<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Collided "</span> <span class="token operator">+</span> car<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">follow</span><span class="token punctuation">(</span><span class="token keyword">final</span> Car another<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Following the "</span> <span class="token operator">+</span> another<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">repair</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Repaired "</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//构造器引用：它的语法是Class::new，或者更一般的Class&lt; T >::new实例如下：</span>            Car car  <span class="token operator">=</span> Car<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>Car<span class="token operator">:</span><span class="token operator">:</span><span class="token keyword">new</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Car car1 <span class="token operator">=</span> Car<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>Car<span class="token operator">:</span><span class="token operator">:</span><span class="token keyword">new</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Car car2 <span class="token operator">=</span> Car<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>Car<span class="token operator">:</span><span class="token operator">:</span><span class="token keyword">new</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Car car3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Car</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            List<span class="token operator">&lt;</span>Car<span class="token operator">></span> cars <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>car<span class="token punctuation">,</span>car1<span class="token punctuation">,</span>car2<span class="token punctuation">,</span>car3<span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"&lt;===================构造器引用========================>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//静态方法引用：它的语法是Class::static_method，实例如下：</span>            cars<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>Car<span class="token operator">:</span><span class="token operator">:</span>collide<span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"&lt;===================静态方法引用========================>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//特定类的任意对象的方法引用：它的语法是Class::method实例如下：</span>            cars<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>Car<span class="token operator">:</span><span class="token operator">:</span>repair<span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"&lt;==============特定类的任意对象的方法引用================>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//特定对象的方法引用：它的语法是instance::method实例如下：</span>            <span class="token keyword">final</span> Car police <span class="token operator">=</span> Car<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>Car<span class="token operator">:</span><span class="token operator">:</span><span class="token keyword">new</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            cars<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>police<span class="token operator">:</span><span class="token operator">:</span>follow<span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"&lt;===================特定对象的方法引===================>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="三、Java-8-函数式接口"><a href="#三、Java-8-函数式接口" class="headerlink" title="三、Java 8 函数式接口"></a>三、Java 8 函数式接口</h4><pre><code>函数式接口(FunctionalInterface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。函数式接口可以被隐式转换为lambda表达式。函数式接口可以现有的函数友好地支持 lambda。JDK 1.8之前已有的函数式接口:    java.lang.Runnable    java.util.concurrent.Callable    java.security.PrivilegedAction    java.util.Comparator    java.io.FileFilter    java.nio.file.PathMatcher    java.lang.reflect.InvocationHandler    java.beans.PropertyChangeListener    java.awt.event.ActionListener    javax.swing.event.ChangeListenerJDK 1.8 新增加的函数接口：    java.util.function    java.util.function 它包含了很多类，用来支持 Java的函数式编程，该包中的函数式接口有：</code></pre><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/03/30/java8-xin-te-xing/test3-1.png" alt="test3-1"></p><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/03/30/java8-xin-te-xing/test3-2.png" alt="test3-2"></p><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/03/30/java8-xin-te-xing/test3-3.png" alt="test3-3"></p><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/03/30/java8-xin-te-xing/test3-4.png" alt="test3-4"></p><h5 id="3-1-函数式接口实例"><a href="#3-1-函数式接口实例" class="headerlink" title="3.1 函数式接口实例"></a>3.1 函数式接口实例</h5><pre><code>Predicate &lt;T&gt; 接口是一个函数式接口，它接受一个输入参数 T，返回一个布尔值结果。该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）。该接口用于测试对象是 true 或 false。</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> java8<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>List<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>function<span class="token punctuation">.</span>Predicate<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019/3/30 0030 * @Time: 19:42 * @Vsersion: 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test4</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Predicate&lt;Integer> predicate = n -> true</span>        <span class="token comment" spellcheck="true">// n 是一个参数传递到 Predicate 接口的 test 方法</span>        <span class="token comment" spellcheck="true">// n 如果存在则 test 方法返回 true</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"输出所有数据:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 传递参数 n</span>        <span class="token function">eval</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> n<span class="token operator">-</span><span class="token operator">></span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Predicate&lt;Integer> predicate1 = n -> n%2 == 0</span>        <span class="token comment" spellcheck="true">// n 是一个参数传递到 Predicate 接口的 test 方法</span>        <span class="token comment" spellcheck="true">// 如果 n%2 为 0 test 方法返回 true</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"输出所有偶数:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">eval</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> n<span class="token operator">-</span><span class="token operator">></span> n<span class="token operator">%</span><span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Predicate&lt;Integer> predicate2 = n -> n > 3</span>        <span class="token comment" spellcheck="true">// n 是一个参数传递到 Predicate 接口的 test 方法</span>        <span class="token comment" spellcheck="true">// 如果 n 大于 3 test 方法返回 true</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"输出大于 3 的所有数字:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">eval</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> n<span class="token operator">-</span><span class="token operator">></span> n <span class="token operator">></span> <span class="token number">3</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">eval</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list<span class="token punctuation">,</span> Predicate<span class="token operator">&lt;</span>Integer<span class="token operator">></span> predicate<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>Integer n<span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>predicate<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>结果：</p><pre class=" language-txt"><code class="language-txt">输出所有数据:1 2 3 4 5 6 7 8 9 输出所有偶数:2 4 6 8 输出大于 3 的所有数字:4 5 6 7 8 9 Process finished with exit code 0</code></pre><h4 id="四、Java-8-默认方法"><a href="#四、Java-8-默认方法" class="headerlink" title="四、Java 8 默认方法"></a>四、Java 8 默认方法</h4><pre><code>Java 8 新增了接口的默认方法。简单说，默认方法就是接口可以有实现方法，而且不需要实现类去实现其方法。我们只需在方法名前面加个default关键字即可实现默认方法。为什么要有这个特性？首先，之前的接口是个双刃剑，好处是面向抽象而不是面向具体编程，缺陷是，当需要修改接口时候，需要修改全部实现该接口的类，目前的java 8之前的集合框架没有foreach方法，通常能想到的解决办法是在JDK里给相关的接口添加新的方法及实现。然而，对于已经发布的版本，是没法在给接口添加新方法的同时不影响已有的实现。所以引进的默认方法。他们的目的是为了解决接口的修改与现有的实现不兼容的问题。</code></pre><h5 id="4-1语法"><a href="#4-1语法" class="headerlink" title="4.1语法"></a>4.1语法</h5><p>默认方法语法格式如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">vehicle</span> <span class="token punctuation">{</span>    <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Java是世界上最好的编程语言!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="4-2多个默认方法"><a href="#4-2多个默认方法" class="headerlink" title="4.2多个默认方法"></a>4.2多个默认方法</h5><pre><code>一个接口有默认方法，考虑这样的情况，一个类实现了多个接口，且这些接口有相同的默认方法，以下实例说明了这种情况的解决方法：</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">vehicle</span> <span class="token punctuation">{</span>    <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">fourWheeler</span> <span class="token punctuation">{</span>    <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>第一个解决方案是创建自己的默认方法，来覆盖重写接口的默认方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Car</span> <span class="token keyword">implements</span> <span class="token class-name">vehicle</span><span class="token punctuation">,</span> fourWheeler <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="五、Java-8-Optional-类"><a href="#五、Java-8-Optional-类" class="headerlink" title="五、Java 8 Optional 类"></a>五、Java 8 Optional 类</h4><pre><code>Optional 类是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。Optional 是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。Optional 类的引入很好的解决空指针异常。</code></pre><h5 id="5-1-类声明"><a href="#5-1-类声明" class="headerlink" title="5.1 类声明"></a>5.1 类声明</h5><pre><code>以下是一个 java.util.Optional&lt;T&gt; 类的声明：publicfinalclassOptional&lt;T&gt; extendsObject</code></pre><h5 id="5-2-类方法"><a href="#5-2-类方法" class="headerlink" title="5.2 类方法"></a>5.2 类方法</h5><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/03/30/java8-xin-te-xing/5-1.png" alt="5-1"></p><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/03/30/java8-xin-te-xing/5-2.png" alt="5-2"></p><pre><code>注意： 这些方法是从 java.lang.Object 类继承来的。</code></pre><h5 id="5-3-Optional-实例"><a href="#5-3-Optional-实例" class="headerlink" title="5.3 Optional 实例"></a>5.3 Optional 实例</h5><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> java8<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Optional<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019/3/30 0030 * @Time: 20:09 * @Vsersion: 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test5</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Test5 test <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test5</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Integer value1 <span class="token operator">=</span> null<span class="token punctuation">;</span>        Integer value2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Optional.ofNullable - 允许传递为 null 参数</span>        Optional<span class="token operator">&lt;</span>Integer<span class="token operator">></span> a <span class="token operator">=</span> Optional<span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span>value1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Optional.of - 如果传递的参数是 null，抛出异常 NullPointerException</span>        Optional<span class="token operator">&lt;</span>Integer<span class="token operator">></span> b <span class="token operator">=</span> Optional<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>value2<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>test<span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> Integer <span class="token function">sum</span><span class="token punctuation">(</span>Optional<span class="token operator">&lt;</span>Integer<span class="token operator">></span> a<span class="token punctuation">,</span> Optional<span class="token operator">&lt;</span>Integer<span class="token operator">></span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Optional.isPresent - 判断值是否存在</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"第一个参数值存在: "</span> <span class="token operator">+</span> a<span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"第二个参数值存在: "</span> <span class="token operator">+</span> b<span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Optional.orElse - 如果值存在，返回它，否则返回默认值</span>        Integer value1 <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//Optional.get - 获取值，值需要存在</span>        Integer value2 <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> value1 <span class="token operator">+</span> value2<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="六、Java-8-Stream"><a href="#六、Java-8-Stream" class="headerlink" title="六、Java 8 Stream"></a>六、Java 8 Stream</h4><pre><code>Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。Stream使用一种类似用SQL语句从数据库查询数据的直观方式来提供一种对Java集合运算和表达的高阶抽象。Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。这种风格将要处理的元素集合看作一种流，流在管道中传输，并且可以在管道的节点上进行处理，比如筛选，排序，聚合等。元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作(terminal operation)得到前面处理的结果。</code></pre><h5 id="6-1-什么是-Stream？"><a href="#6-1-什么是-Stream？" class="headerlink" title="6.1 什么是 Stream？"></a>6.1 什么是 Stream？</h5><pre><code>Stream（流）是一个来自数据源的元素队列并支持聚合操作元素：是特定类型的对象，形成一个队列。Java中的Stream并不会存储元素，而是按需计算。数据源 ：流的来源。可以是集合，数组，I/O channel，产生器generator等。聚合操作： 类似SQL语句一样的操作，比如filter, map, reduce, find,match, sorted等。和以前的Collection操作不同，Stream操作还有两个基础的特征：Pipelining:：中间操作都会返回流对象本身。这样多个操作可以串联成一个管道，如同流式风格（fluent style）。这样做可以对操作进行优化，比如延迟执行(laziness)和短路( short-circuiting)。内部迭代：以前对集合遍历都是通过Iterator或者For-Each的方式,显式的在集合外部进行迭代，这叫做外部迭代。Stream提供了内部迭代的方式，通过访问者模式(Visitor)实现。</code></pre><h5 id="6-2-生成流"><a href="#6-2-生成流" class="headerlink" title="6.2 生成流"></a>6.2 生成流</h5><pre><code>在Java 8中,集合接口有两个方法来生成流：stream() −为集合创建串行流。parallelStream() − 为集合创建并行流。</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>String<span class="token operator">></span> strings <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"bc"</span><span class="token punctuation">,</span> <span class="token string">"efg"</span><span class="token punctuation">,</span> <span class="token string">"abcd"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"jkl"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>String<span class="token operator">></span> filtered <span class="token operator">=</span> strings<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>string <span class="token operator">-</span><span class="token operator">></span> <span class="token operator">!</span>string<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h5 id="6-3-forEach"><a href="#6-3-forEach" class="headerlink" title="6.3  forEach"></a>6.3  forEach</h5><pre><code>Stream 提供了新的方法 &#39;forEach&#39; 来迭代流中的每个数据。以下代码片段使用forEach 输出了10个随机数：</code></pre><pre class=" language-java"><code class="language-java">Random random <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>random<span class="token punctuation">.</span><span class="token function">ints</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="6-4-map"><a href="#6-4-map" class="headerlink" title="6.4  map"></a>6.4  map</h5><pre><code>map 方法用于映射每个元素到对应的结果，以下代码片段使用 map 输出了元素对应的平方数：</code></pre><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> numbers <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 获取对应的平方数</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> squaresList <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>i <span class="token operator">-</span><span class="token operator">></span> i <span class="token operator">*</span> i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">distinct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="6-5-filter"><a href="#6-5-filter" class="headerlink" title="6.5  filter"></a>6.5  filter</h5><pre><code>filter 方法用于通过设置条件过滤出元素。以下代码片段使用filter 方法过滤出空字符串：</code></pre><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>String<span class="token operator">></span>strings <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"bc"</span><span class="token punctuation">,</span> <span class="token string">"efg"</span><span class="token punctuation">,</span> <span class="token string">"abcd"</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"jkl"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 获取空字符串的数量</span><span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> strings<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>string <span class="token operator">-</span><span class="token operator">></span> string<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="6-6-limit"><a href="#6-6-limit" class="headerlink" title="6.6  limit"></a>6.6  limit</h5><pre><code>limit 方法用于获取指定数量的流。以下代码片段使用 limit 方法打印出 10 条数据：</code></pre><pre class=" language-java"><code class="language-java">Random random <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>random<span class="token punctuation">.</span><span class="token function">ints</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="6-7-sorted"><a href="#6-7-sorted" class="headerlink" title="6.7  sorted"></a>6.7  sorted</h5><pre><code>sorted 方法用于对流进行排序。以下代码片段使用 sorted 方法对输出的 10 个随机数进行排序：</code></pre><h5 id="6-8-并行（parallel）程序"><a href="#6-8-并行（parallel）程序" class="headerlink" title="6.8  并行（parallel）程序"></a>6.8  并行（parallel）程序</h5><pre><code>parallelStream 是流并行处理程序的代替方法。以下实例我们使用parallelStream 来输出空字符串的数量：</code></pre><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>String<span class="token operator">></span> strings <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"bc"</span><span class="token punctuation">,</span> <span class="token string">"efg"</span><span class="token punctuation">,</span> <span class="token string">"abcd"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"jkl"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 获取空字符串的数量</span><span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> strings<span class="token punctuation">.</span><span class="token function">parallelStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>string <span class="token operator">-</span><span class="token operator">></span> string<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="6-9-Collectors"><a href="#6-9-Collectors" class="headerlink" title="6.9  Collectors"></a>6.9  Collectors</h5><pre><code>Collectors 类实现了很多归约操作，例如将流转换成集合和聚合元素。Collectors可用于返回列表或字符串：</code></pre><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>String<span class="token operator">></span> strings <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"bc"</span><span class="token punctuation">,</span> <span class="token string">"efg"</span><span class="token punctuation">,</span> <span class="token string">"abcd"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"jkl"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>List<span class="token operator">&lt;</span>String<span class="token operator">></span> filtered <span class="token operator">=</span> strings<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>string <span class="token operator">-</span><span class="token operator">></span> <span class="token operator">!</span>string<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"筛选列表: "</span> <span class="token operator">+</span> filtered<span class="token punctuation">)</span><span class="token punctuation">;</span>String mergedString <span class="token operator">=</span> strings<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>string <span class="token operator">-</span><span class="token operator">></span> <span class="token operator">!</span>string<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">joining</span><span class="token punctuation">(</span><span class="token string">", "</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"合并字符串: "</span> <span class="token operator">+</span> mergedString<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="6-10-统计"><a href="#6-10-统计" class="headerlink" title="6.10  统计"></a>6.10  统计</h5><pre><code>    另外，一些产生统计结果的收集器也非常有用。它们主要用于int、double、long等基本类型上，它们可以用来产生类似如下的统计结果。</code></pre><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> numbers <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>IntSummaryStatistics stats <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">mapToInt</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> x<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">summaryStatistics</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"列表中最大的数 : "</span> <span class="token operator">+</span> stats<span class="token punctuation">.</span><span class="token function">getMax</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"列表中最小的数 : "</span> <span class="token operator">+</span> stats<span class="token punctuation">.</span><span class="token function">getMin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"所有数之和 : "</span> <span class="token operator">+</span> stats<span class="token punctuation">.</span><span class="token function">getSum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"平均数 : "</span> <span class="token operator">+</span> stats<span class="token punctuation">.</span><span class="token function">getAverage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="6-11-Stream-完整实例"><a href="#6-11-Stream-完整实例" class="headerlink" title="6.11  Stream 完整实例"></a>6.11  Stream 完整实例</h5><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> java8<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>stream<span class="token punctuation">.</span>Collectors<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019/3/30 0030 * @Time: 20:27 * @Vsersion: 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test6</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"使用 Java 7: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 计算空字符串</span>        List<span class="token operator">&lt;</span>String<span class="token operator">></span> strings <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"bc"</span><span class="token punctuation">,</span> <span class="token string">"efg"</span><span class="token punctuation">,</span> <span class="token string">"abcd"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"jkl"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"列表: "</span> <span class="token operator">+</span> strings<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> count <span class="token operator">=</span> <span class="token function">getCountEmptyStringUsingJava7</span><span class="token punctuation">(</span>strings<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"空字符数量为: "</span> <span class="token operator">+</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>        count <span class="token operator">=</span> <span class="token function">getCountLength3UsingJava7</span><span class="token punctuation">(</span>strings<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"字符串长度为 3 的数量为: "</span> <span class="token operator">+</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 删除空字符串</span>        List<span class="token operator">&lt;</span>String<span class="token operator">></span> filtered <span class="token operator">=</span> <span class="token function">deleteEmptyStringsUsingJava7</span><span class="token punctuation">(</span>strings<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"筛选后的列表: "</span> <span class="token operator">+</span> filtered<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 删除空字符串，并使用逗号把它们合并起来</span>        String mergedString <span class="token operator">=</span> <span class="token function">getMergedStringUsingJava7</span><span class="token punctuation">(</span>strings<span class="token punctuation">,</span> <span class="token string">", "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"合并字符串: "</span> <span class="token operator">+</span> mergedString<span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> numbers <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 获取列表元素平方数</span>        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> squaresList <span class="token operator">=</span> <span class="token function">getSquares</span><span class="token punctuation">(</span>numbers<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"平方数列表: "</span> <span class="token operator">+</span> squaresList<span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> integers <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">17</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"列表: "</span> <span class="token operator">+</span> integers<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"列表中最大的数 : "</span> <span class="token operator">+</span> <span class="token function">getMax</span><span class="token punctuation">(</span>integers<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"列表中最小的数 : "</span> <span class="token operator">+</span> <span class="token function">getMin</span><span class="token punctuation">(</span>integers<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"所有数之和 : "</span> <span class="token operator">+</span> <span class="token function">getSum</span><span class="token punctuation">(</span>integers<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"平均数 : "</span> <span class="token operator">+</span> <span class="token function">getAverage</span><span class="token punctuation">(</span>integers<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"随机数: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 输出10个随机数</span>        Random random <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>random<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"使用 Java 8: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"列表: "</span> <span class="token operator">+</span> strings<span class="token punctuation">)</span><span class="token punctuation">;</span>        count <span class="token operator">=</span> strings<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>string <span class="token operator">-</span><span class="token operator">></span> string<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"空字符串数量为: "</span> <span class="token operator">+</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>        count <span class="token operator">=</span> strings<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>string <span class="token operator">-</span><span class="token operator">></span> string<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"字符串长度为 3 的数量为: "</span> <span class="token operator">+</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>        filtered <span class="token operator">=</span> strings<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>string <span class="token operator">-</span><span class="token operator">></span> <span class="token operator">!</span>string<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"筛选后的列表: "</span> <span class="token operator">+</span> filtered<span class="token punctuation">)</span><span class="token punctuation">;</span>        mergedString <span class="token operator">=</span> strings<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>string <span class="token operator">-</span><span class="token operator">></span> <span class="token operator">!</span>string<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">joining</span><span class="token punctuation">(</span><span class="token string">", "</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"合并字符串: "</span> <span class="token operator">+</span> mergedString<span class="token punctuation">)</span><span class="token punctuation">;</span>        squaresList <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>i <span class="token operator">-</span><span class="token operator">></span> i <span class="token operator">*</span> i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">distinct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Squares List: "</span> <span class="token operator">+</span> squaresList<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"列表: "</span> <span class="token operator">+</span> integers<span class="token punctuation">)</span><span class="token punctuation">;</span>        IntSummaryStatistics stats <span class="token operator">=</span> integers<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">mapToInt</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> x<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">summaryStatistics</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"列表中最大的数 : "</span> <span class="token operator">+</span> stats<span class="token punctuation">.</span><span class="token function">getMax</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"列表中最小的数 : "</span> <span class="token operator">+</span> stats<span class="token punctuation">.</span><span class="token function">getMin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"所有数之和 : "</span> <span class="token operator">+</span> stats<span class="token punctuation">.</span><span class="token function">getSum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"平均数 : "</span> <span class="token operator">+</span> stats<span class="token punctuation">.</span><span class="token function">getAverage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"随机数: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        random<span class="token punctuation">.</span><span class="token function">ints</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 并行处理</span>        count <span class="token operator">=</span> strings<span class="token punctuation">.</span><span class="token function">parallelStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>string <span class="token operator">-</span><span class="token operator">></span> string<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"空字符串的数量为: "</span> <span class="token operator">+</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getCountEmptyStringUsingJava7</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>String<span class="token operator">></span> strings<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>String string <span class="token operator">:</span> strings<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>string<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                count<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> count<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getCountLength3UsingJava7</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>String<span class="token operator">></span> strings<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>String string <span class="token operator">:</span> strings<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>string<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                count<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> count<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">deleteEmptyStringsUsingJava7</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>String<span class="token operator">></span> strings<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>String<span class="token operator">></span> filteredList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>String string <span class="token operator">:</span> strings<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>string<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                filteredList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> filteredList<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> String <span class="token function">getMergedStringUsingJava7</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>String<span class="token operator">></span> strings<span class="token punctuation">,</span> String separator<span class="token punctuation">)</span> <span class="token punctuation">{</span>        StringBuilder stringBuilder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>String string <span class="token operator">:</span> strings<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>string<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                stringBuilder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token punctuation">;</span>                stringBuilder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>separator<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        String mergedString <span class="token operator">=</span> stringBuilder<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> mergedString<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> mergedString<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">getSquares</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> numbers<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> squaresList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Integer number <span class="token operator">:</span> numbers<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Integer square <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>number<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> number<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>squaresList<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>square<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                squaresList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>square<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> squaresList<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getMax</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> numbers<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> max <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numbers<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Integer number <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>number<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> max<span class="token punctuation">)</span> <span class="token punctuation">{</span>                max <span class="token operator">=</span> number<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> max<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getMin</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> numbers<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> min <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numbers<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Integer number <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>number<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> min<span class="token punctuation">)</span> <span class="token punctuation">{</span>                min <span class="token operator">=</span> number<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> min<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getSum</span><span class="token punctuation">(</span>List numbers<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>numbers<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numbers<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            sum <span class="token operator">+=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> numbers<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getAverage</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> numbers<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">getSum</span><span class="token punctuation">(</span>numbers<span class="token punctuation">)</span> <span class="token operator">/</span> numbers<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="七、Java-8-Nashorn-JavaScript"><a href="#七、Java-8-Nashorn-JavaScript" class="headerlink" title="七、Java 8 Nashorn JavaScript"></a>七、Java 8 Nashorn JavaScript</h4><pre><code>Nashorn 一个 javascript 引擎。从JDK1.8开始，Nashorn取代Rhino(JDK 1.6, JDK1.7)成为Java的嵌入式JavaScript引擎。Nashorn完全支持ECMAScript 5.1规范以及一些扩展。它使用基于JSR292的新语言特性，其中包含在JDK 7中引入的 invokedynamic，将JavaScript编译成Java字节码。与先前的Rhino实现相比，这带来了2到10倍的性能提升。</code></pre><h5 id="7-1-jjs"><a href="#7-1-jjs" class="headerlink" title="7.1 jjs"></a>7.1 jjs</h5><pre><code>jjs是个基于Nashorn引擎的命令行工具。它接受一些JavaScript源代码为参数，并且执行这些源代码。</code></pre><h5 id="7-2-jjs-交互式编程"><a href="#7-2-jjs-交互式编程" class="headerlink" title="7.2  jjs 交互式编程"></a>7.2  jjs 交互式编程</h5><pre class=" language-java"><code class="language-java">$ jjsjjs<span class="token operator">></span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Hello, World!"</span><span class="token punctuation">)</span>Hello<span class="token punctuation">,</span>World<span class="token operator">!</span>jjs<span class="token operator">></span> <span class="token function">quit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>></span> </code></pre><h5 id="7-3-传递参数"><a href="#7-3-传递参数" class="headerlink" title="7.3 传递参数"></a>7.3 传递参数</h5><pre class=" language-java"><code class="language-java">$ jjs <span class="token operator">--</span> a b cjjs<span class="token operator">></span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">'字母: '</span><span class="token operator">+</span>arguments<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">", "</span><span class="token punctuation">)</span><span class="token punctuation">)</span>字母<span class="token operator">:</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> cjjs<span class="token operator">></span></code></pre><h5 id="7-4-Java-中调用-JavaScript"><a href="#7-4-Java-中调用-JavaScript" class="headerlink" title="7.4  Java 中调用 JavaScript"></a>7.4  Java 中调用 JavaScript</h5><pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        ScriptEngineManager scriptEngineManager <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ScriptEngineManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ScriptEngine nashorn <span class="token operator">=</span> scriptEngineManager<span class="token punctuation">.</span><span class="token function">getEngineByName</span><span class="token punctuation">(</span><span class="token string">"nashorn"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String name <span class="token operator">=</span> <span class="token string">"Runoob"</span><span class="token punctuation">;</span>        Integer result <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            nashorn<span class="token punctuation">.</span><span class="token function">eval</span><span class="token punctuation">(</span><span class="token string">"print('"</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">"')"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            result <span class="token operator">=</span> <span class="token punctuation">(</span>Integer<span class="token punctuation">)</span> nashorn<span class="token punctuation">.</span><span class="token function">eval</span><span class="token punctuation">(</span><span class="token string">"10 + 2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ScriptException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行脚本错误: "</span> <span class="token operator">+</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h4 id="八、Java-8-日期时间-API"><a href="#八、Java-8-日期时间-API" class="headerlink" title="八、Java 8 日期时间 API"></a>八、Java 8 日期时间 API</h4><pre><code>Java 8通过发布新的Date-Time API (JSR 310)来进一步加强对日期与时间的处理。在旧版的Java 中，日期时间API 存在诸多问题，其中有：非线程安全 − java.util.Date 是非线程安全的，所有的日期类都是可变的，这是Java日期类最大的问题之一    设计很差 − Java的日期/时间类的定义并不一致，在java.util和java.sql的包中都有日期类，此外用于格式化和解析的类在java.text包中定义。java.util.Date同时包含日期和时间，而java.sql.Date仅包含日期，将其纳入java.sql包并不合理。另外这两个类都有相同的名字，这本身就是一个非常糟糕的设计。    时区处理麻烦 − 日期类并不提供国际化，没有时区支持，因此Java引入了java.util.Calendar和java.util.TimeZone类，但他们同样存在上述所有的问题。Java 8 在 java.time 包下提供了很多新的 API。以下为两个比较重要的 API：    Local(本地) − 简化了日期时间的处理，没有时区的问题。    Zoned(时区) − 通过制定的时区处理日期时间。新的java.time包涵盖了所有处理日期，时间，日期/时间，时区，时刻（instants），过程（during）与时钟（clock）的操作。</code></pre><h5 id="8-1-本地化日期时间-API"><a href="#8-1-本地化日期时间-API" class="headerlink" title="8.1 本地化日期时间 API"></a>8.1 本地化日期时间 API</h5><pre class=" language-java"><code class="language-java">  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Java8Tester java8tester <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Java8Tester</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        java8tester<span class="token punctuation">.</span><span class="token function">testLocalDateTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testLocalDateTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 获取当前的日期时间</span>        LocalDateTime currentTime <span class="token operator">=</span> LocalDateTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"当前时间: "</span> <span class="token operator">+</span> currentTime<span class="token punctuation">)</span><span class="token punctuation">;</span>        LocalDate date1 <span class="token operator">=</span> currentTime<span class="token punctuation">.</span><span class="token function">toLocalDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"date1: "</span> <span class="token operator">+</span> date1<span class="token punctuation">)</span><span class="token punctuation">;</span>        Month month <span class="token operator">=</span> currentTime<span class="token punctuation">.</span><span class="token function">getMonth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> day <span class="token operator">=</span> currentTime<span class="token punctuation">.</span><span class="token function">getDayOfMonth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> seconds <span class="token operator">=</span> currentTime<span class="token punctuation">.</span><span class="token function">getSecond</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"月: "</span> <span class="token operator">+</span> month <span class="token operator">+</span> <span class="token string">", 日: "</span> <span class="token operator">+</span> day <span class="token operator">+</span> <span class="token string">", 秒: "</span> <span class="token operator">+</span> seconds<span class="token punctuation">)</span><span class="token punctuation">;</span>        LocalDateTime date2 <span class="token operator">=</span> currentTime<span class="token punctuation">.</span><span class="token function">withDayOfMonth</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">withYear</span><span class="token punctuation">(</span><span class="token number">2012</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"date2: "</span> <span class="token operator">+</span> date2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 12 december 2014</span>        LocalDate date3 <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2014</span><span class="token punctuation">,</span> Month<span class="token punctuation">.</span>DECEMBER<span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"date3: "</span> <span class="token operator">+</span> date3<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 22 小时 15 分钟</span>        LocalTime date4 <span class="token operator">=</span> LocalTime<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"date4: "</span> <span class="token operator">+</span> date4<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 解析字符串</span>        LocalTime date5 <span class="token operator">=</span> LocalTime<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token string">"20:15:30"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"date5: "</span> <span class="token operator">+</span> date5<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h5 id="8-2-使用时区的日期时间API"><a href="#8-2-使用时区的日期时间API" class="headerlink" title="8.2 使用时区的日期时间API"></a>8.2 使用时区的日期时间API</h5><pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Java8Tester java8tester <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Java8Tester</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        java8tester<span class="token punctuation">.</span><span class="token function">testZonedDateTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testZonedDateTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 获取当前时间日期</span>        ZonedDateTime date1 <span class="token operator">=</span> ZonedDateTime<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token string">"2015-12-03T10:15:30+05:30[Asia/Shanghai]"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"date1: "</span> <span class="token operator">+</span> date1<span class="token punctuation">)</span><span class="token punctuation">;</span>        ZoneId id <span class="token operator">=</span> ZoneId<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"Europe/Paris"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ZoneId: "</span> <span class="token operator">+</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>        ZoneId currentZone <span class="token operator">=</span> ZoneId<span class="token punctuation">.</span><span class="token function">systemDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"当期时区: "</span> <span class="token operator">+</span> currentZone<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h4 id="九、Java8-Base64"><a href="#九、Java8-Base64" class="headerlink" title="九、Java8 Base64"></a>九、Java8 Base64</h4><pre><code>在Java8中，Base64编码已经成为Java类库的标准。Java 8 内置了 Base64 编码的编码器和解码器。Base64工具类提供了一套静态方法获取下面三种BASE64编解码器：    基本：输出被映射到一组字符A-Za-z0-9+/，编码不添加任何行标，输出的解码仅支持A-Za-z0-9+/。    URL：输出映射到一组字符A-Za-z0-9+_，输出是URL和文件。    MIME：输出隐射到MIME友好格式。输出每行不超过76字符，并且使用&#39;\r&#39;并跟随&#39;\n&#39;作为分割。编码输出最后没有行分割。</code></pre><h5 id="9-1-内嵌类"><a href="#9-1-内嵌类" class="headerlink" title="9.1 内嵌类"></a>9.1 内嵌类</h5><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/03/30/java8-xin-te-xing/9-1.png" alt="9-1"></p><h5 id="9-2-方法"><a href="#9-2-方法" class="headerlink" title="9.2 方法"></a>9.2 方法</h5><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/03/30/java8-xin-te-xing/9-2.png" alt="9-2"></p><pre><code>注意：Base64 类的很多方法从 java.lang.Object 类继承。</code></pre><h5 id="9-3-Base64-实例"><a href="#9-3-Base64-实例" class="headerlink" title="9.3  Base64 实例"></a>9.3  Base64 实例</h5><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 使用基本编码</span>            String base64encodedString <span class="token operator">=</span> Base64<span class="token punctuation">.</span><span class="token function">getEncoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">encodeToString</span><span class="token punctuation">(</span><span class="token string">"runoob?java8"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Base64 编码字符串 (基本) :"</span> <span class="token operator">+</span> base64encodedString<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 解码</span>            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> base64decodedBytes <span class="token operator">=</span> Base64<span class="token punctuation">.</span><span class="token function">getDecoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span>base64encodedString<span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"原始字符串: "</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>base64decodedBytes<span class="token punctuation">,</span> <span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            base64encodedString <span class="token operator">=</span> Base64<span class="token punctuation">.</span><span class="token function">getUrlEncoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">encodeToString</span><span class="token punctuation">(</span><span class="token string">"TutorialsPoint?java8"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Base64 编码字符串 (URL) :"</span> <span class="token operator">+</span> base64encodedString<span class="token punctuation">)</span><span class="token punctuation">;</span>            StringBuilder stringBuilder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                stringBuilder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>UUID<span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> mimeBytes <span class="token operator">=</span> stringBuilder<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            String mimeEncodedString <span class="token operator">=</span> Base64<span class="token punctuation">.</span><span class="token function">getMimeEncoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">encodeToString</span><span class="token punctuation">(</span>mimeBytes<span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Base64 编码字符串 (MIME) :"</span> <span class="token operator">+</span> mimeEncodedString<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">UnsupportedEncodingException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Error :"</span> <span class="token operator">+</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 日常学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal</title>
      <link href="/2019/03/29/threadlocal/"/>
      <url>/2019/03/29/threadlocal/</url>
      
        <content type="html"><![CDATA[<h2 id="ThreadLocal的简单使用及实现的原理"><a href="#ThreadLocal的简单使用及实现的原理" class="headerlink" title="ThreadLocal的简单使用及实现的原理"></a>ThreadLocal的简单使用及实现的原理</h2><h4 id="一、ThreadLocal简介"><a href="#一、ThreadLocal简介" class="headerlink" title="一、ThreadLocal简介"></a>一、ThreadLocal简介</h4><pre><code>    ThreadLocal的实例代表了一个线程局部的变量，每条线程都只能看到自己的值，并不会意识到其它的线程中也存在该变量。    它采用采用空间来换取时间的方式，解决多线程中相同变量的访问冲突问题。</code></pre><h4 id="二、ThreadLocal的简单使用"><a href="#二、ThreadLocal的简单使用" class="headerlink" title="二、ThreadLocal的简单使用"></a>二、ThreadLocal的简单使用</h4><pre><code>    下面的例子中，创建了两个线程，然后线程对各自的局部变量进行递增的操作。每个线程中的局部变量的初始值都是100。</code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @author ZongMan * @version 1.0 * @date 2019/3/22 0022 8:04 */</span><span class="token keyword">class</span> <span class="token class-name">ThreadLocalDemo</span> <span class="token punctuation">{</span>    ThreadLocal<span class="token operator">&lt;</span>Integer<span class="token operator">></span> threadLocal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">protected</span> Integer <span class="token function">initialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">100</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> threadLocal<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        threadLocal<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>threadLocal<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>定义对ThreadLocal的操作，也就是在原来的基础上进行加10的操作，然后打印出结果。</code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @author ZongMan * @version 1.0 * @date 2019/3/22 0022 8:08 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalDemo2</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>    ThreadLocalDemo localDemo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocalDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ThreadLocalDemo2</span><span class="token punctuation">(</span>ThreadLocalDemo localDemo<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>localDemo <span class="token operator">=</span> localDemo<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            localDemo<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//输出不同线程的ThreadLocal的值</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"=====>"</span> <span class="token operator">+</span> localDemo<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>    创建两个线程并启动，主线程等待这两个线程执行完成。最值得注意的就是主线程中输出的threadLocalDemo.get(),输出的初始值100</code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @author ZongMan * @version 1.0 * @date 2019/3/22 0022 8:14 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        ThreadLocalDemo threadLocalDemo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocalDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//多个线程操作同一个变量 但是不同线程的结果是互不影响的</span>        ThreadLocalDemo2 localDemo2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocalDemo2</span><span class="token punctuation">(</span>threadLocalDemo<span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>localDemo2<span class="token punctuation">)</span><span class="token punctuation">;</span>        t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>localDemo2<span class="token punctuation">)</span><span class="token punctuation">;</span>        t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//这个是main()线程中的变量，输出的是ThreadLocalDemo中的初始值 也是就100</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>threadLocalDemo<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="三、ThreadLocal的实现原理"><a href="#三、ThreadLocal的实现原理" class="headerlink" title="三、ThreadLocal的实现原理"></a>三、ThreadLocal的实现原理</h4><pre><code>    每个Thread的对象都有一个ThreadLocalMap，当创建一个ThreadLocal的时候，就会将该ThreadLocal对象添加到该Map中，其中键就是ThreadLocal，值可以是任意类型。    在该类中，我觉得最重要的方法就是两个：set()和get()方法。当调用ThreadLocal的get()方法的时候，会先找到当前线程的ThreadLocalMap，然后再找到对应的值。set()方法也是一样。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 日常学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
            <tag> ThreadLocal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试之集合</title>
      <link href="/2019/03/28/mian-shi-zhi-ji-he/"/>
      <url>/2019/03/28/mian-shi-zhi-ji-he/</url>
      
        <content type="html"><![CDATA[<h3 id="ArrayList简介"><a href="#ArrayList简介" class="headerlink" title="ArrayList简介"></a>ArrayList简介</h3><blockquote><p>ArrayList 的底层是数组队列，相当于动态数组。与 Java 中的数组相比，它的容量能动态增长。在添加大量元素前，应用程序可以使用ensureCapacity操作来增加 ArrayList 实例的容量。这可以减少递增式再分配的数量。</p><p>  它继承于 AbstractList，实现了 List, RandomAccess, Cloneable, java.io.Serializable 这些接口。</p><p>  在我们学数据结构的时候就知道了线性表的顺序存储，插入删除元素的时间复杂度为O（n）,求表长以及增加元素，取第 i   元素的时间复杂度为O（1）</p><p>　  ArrayList 继承了AbstractList，实现了List。它是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。</p><p>　　ArrayList 实现了RandomAccess 接口，即提供了随机访问功能。RandomAccess 是 Java 中用来被 List 实现，为 List 提供快速访问功能的。在 ArrayList 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。</p><p>　　ArrayList 实现了Cloneable 接口，即覆盖了函数 clone()，能被克隆。</p><p>　　ArrayList 实现java.io.Serializable 接口，这意味着ArrayList支持序列化，能通过序列化去传输。</p><p>　　和 Vector 不同，ArrayList 中的操作不是线程安全的！所以，建议在单线程中才使用 ArrayList，而在多线程中可以选择 Vector 或者  CopyOnWriteArrayList。</p></blockquote><h3 id="ArrayList核心源码"><a href="#ArrayList核心源码" class="headerlink" title="ArrayList核心源码"></a>ArrayList核心源码</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> java<span class="token punctuation">.</span>util<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>function<span class="token punctuation">.</span>Consumer<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>function<span class="token punctuation">.</span>Predicate<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>function<span class="token punctuation">.</span>UnaryOperator<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractList</span><span class="token operator">&lt;</span>E<span class="token operator">></span>        <span class="token keyword">implements</span> <span class="token class-name">List</span><span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">,</span> RandomAccess<span class="token punctuation">,</span> Cloneable<span class="token punctuation">,</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable<span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 8683452581122892189L<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 默认初始容量大小     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_CAPACITY <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 空数组（用于空实例）。     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> EMPTY_ELEMENTDATA <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//用于默认大小空实例的共享空数组实例。</span>      <span class="token comment" spellcheck="true">//我们把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少。</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 保存ArrayList数据的数组     */</span>    <span class="token keyword">transient</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> elementData<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// non-private to simplify nested class access</span>    <span class="token comment" spellcheck="true">/**     * ArrayList 所包含的元素个数     */</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 带初始容量参数的构造函数。（用户自己指定容量）     */</span>    <span class="token keyword">public</span> <span class="token function">ArrayList</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//创建initialCapacity大小的数组</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>initialCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//创建空数组</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> EMPTY_ELEMENTDATA<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal Capacity: "</span><span class="token operator">+</span>                                               initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     *默认构造函数，DEFAULTCAPACITY_EMPTY_ELEMENTDATA 为0.初始化为10，也就是说初始其实是空数组 当添加第一个元素的时候数组容量才变成10     */</span>    <span class="token keyword">public</span> <span class="token function">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。     */</span>    <span class="token keyword">public</span> <span class="token function">ArrayList</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//</span>        elementData <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//如果指定集合元素个数不为0</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// c.toArray 可能返回的不是Object类型的数组所以加上下面的语句用于判断，</span>            <span class="token comment" spellcheck="true">//这里用到了反射里面的getClass()方法</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>                elementData <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> size<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 用空数组代替</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> EMPTY_ELEMENTDATA<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 修改这个ArrayList实例的容量是列表的当前大小。 应用程序可以使用此操作来最小化ArrayList实例的存储。      */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">trimToSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&lt;</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>            elementData <span class="token operator">=</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>              <span class="token operator">?</span> EMPTY_ELEMENTDATA              <span class="token operator">:</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//下面是ArrayList的扩容机制</span><span class="token comment" spellcheck="true">//ArrayList的扩容机制提高了性能，如果每次只扩充一个，</span><span class="token comment" spellcheck="true">//那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。</span>    <span class="token comment" spellcheck="true">/**     * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量     * @param   minCapacity   所需的最小容量     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">ensureCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> minExpand <span class="token operator">=</span> <span class="token punctuation">(</span>elementData <span class="token operator">!=</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// any size if not default element table</span>            <span class="token operator">?</span> <span class="token number">0</span>            <span class="token comment" spellcheck="true">// larger than default for default empty table. It's already</span>            <span class="token comment" spellcheck="true">// supposed to be at default size.</span>            <span class="token operator">:</span> DEFAULT_CAPACITY<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">></span> minExpand<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">//得到最小扩容量</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData <span class="token operator">==</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">// 获取默认的容量和传入参数的较大值</span>            minCapacity <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>DEFAULT_CAPACITY<span class="token punctuation">,</span> minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//判断是否需要扩容</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// overflow-conscious code</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">-</span> elementData<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span>            <span class="token function">grow</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 要分配的最大数组大小     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAX_ARRAY_SIZE <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE <span class="token operator">-</span> <span class="token number">8</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * ArrayList扩容的核心方法。     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">grow</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// oldCapacity为旧容量，newCapacity为新容量</span>        <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span>        <span class="token comment" spellcheck="true">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span>        <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> oldCapacity <span class="token operator">+</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            newCapacity <span class="token operator">=</span> minCapacity<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//再检查新容量是否超出了ArrayList所定义的最大容量，</span>        <span class="token comment" spellcheck="true">//若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，</span>        <span class="token comment" spellcheck="true">//如果minCapacity大于最大容量，则新容量则为ArrayList定义的最大容量，否则，新容量大小则为 minCapacity。 </span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> MAX_ARRAY_SIZE <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>            newCapacity <span class="token operator">=</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// minCapacity is usually close to size, so this is a win:</span>        elementData <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//比较minCapacity和 MAX_ARRAY_SIZE</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// overflow</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">OutOfMemoryError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">></span> MAX_ARRAY_SIZE<span class="token punctuation">)</span> <span class="token operator">?</span>            Integer<span class="token punctuation">.</span>MAX_VALUE <span class="token operator">:</span>            MAX_ARRAY_SIZE<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     *返回此列表中的元素数。      */</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> size<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 如果此列表不包含元素，则返回 true 。     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//注意=和==的区别</span>        <span class="token keyword">return</span> size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 如果此列表包含指定的元素，则返回true 。     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">contains</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//indexOf()方法：返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1 </span>        <span class="token keyword">return</span> <span class="token function">indexOf</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     *返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1      */</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">indexOf</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>null<span class="token punctuation">)</span>                    <span class="token keyword">return</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">//equals()方法比较</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。.     */</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">lastIndexOf</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> size<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>null<span class="token punctuation">)</span>                    <span class="token keyword">return</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> size<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 返回此ArrayList实例的浅拷贝。 （元素本身不被复制。）      */</span>    <span class="token keyword">public</span> Object <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            ArrayList<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> v <span class="token operator">=</span> <span class="token punctuation">(</span>ArrayList<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//Arrays.copyOf功能是实现数组的复制，返回复制后的数组。参数是被复制的数组和复制的长度</span>            v<span class="token punctuation">.</span>elementData <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>            v<span class="token punctuation">.</span>modCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> v<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">CloneNotSupportedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 这不应该发生，因为我们是可以克隆的</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InternalError</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     *以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。      *返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。     *因此，调用者可以自由地修改返回的数组。 此方法充当基于阵列和基于集合的API之间的桥梁。     */</span>    <span class="token keyword">public</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）;      *返回的数组的运行时类型是指定数组的运行时类型。 如果列表适合指定的数组，则返回其中。      *否则，将为指定数组的运行时类型和此列表的大小分配一个新数组。      *如果列表适用于指定的数组，其余空间（即数组的列表数量多于此元素），则紧跟在集合结束后的数组中的元素设置为null 。     *（这仅在调用者知道列表不包含任何空元素的情况下才能确定列表的长度。）      */</span>    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> T<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">toArray</span><span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> size<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// 新建一个运行时类型的数组，但是ArrayList数组的内容</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> size<span class="token punctuation">,</span> a<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//调用System提供的arraycopy()方法实现数组之间的复制</span>        System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span>length <span class="token operator">></span> size<span class="token punctuation">)</span>            a<span class="token punctuation">[</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">return</span> a<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// Positional Access Operations</span>    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>    E <span class="token function">elementData</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>E<span class="token punctuation">)</span> elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 返回此列表中指定位置的元素。     */</span>    <span class="token keyword">public</span> E <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">rangeCheck</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">elementData</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 用指定的元素替换此列表中指定位置的元素。      */</span>    <span class="token keyword">public</span> E <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> E element<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//对index进行界限检查</span>        <span class="token function">rangeCheck</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        E oldValue <span class="token operator">=</span> <span class="token function">elementData</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> element<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//返回原来在这个位置的元素</span>        <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 将指定的元素追加到此列表的末尾。      */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Increments modCount!!</span>        <span class="token comment" spellcheck="true">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span>        elementData<span class="token punctuation">[</span>size<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 在此列表中的指定位置插入指定的元素。      *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；     *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> E element<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">rangeCheckForAdd</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Increments modCount!!</span>        <span class="token comment" spellcheck="true">//arraycopy()这个实现数组之间复制的方法一定要看一下，下面就用到了arraycopy()方法实现数组自己复制自己</span>        System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>                         size <span class="token operator">-</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>        elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> element<span class="token punctuation">;</span>        size<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 删除该列表中指定位置的元素。 将任何后续元素移动到左侧（从其索引中减去一个元素）。      */</span>    <span class="token keyword">public</span> E <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">rangeCheck</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>        E oldValue <span class="token operator">=</span> <span class="token function">elementData</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> numMoved <span class="token operator">=</span> size <span class="token operator">-</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>numMoved <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>            System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span>                             numMoved<span class="token punctuation">)</span><span class="token punctuation">;</span>        elementData<span class="token punctuation">[</span><span class="token operator">--</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// clear to let GC do its work</span>      <span class="token comment" spellcheck="true">//从列表中删除的元素 </span>        <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 从列表中删除指定元素的第一个出现（如果存在）。 如果列表不包含该元素，则它不会更改。     *返回true，如果此列表包含指定的元素     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">fastRemove</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">fastRemove</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*     * Private remove method that skips bounds checking and does not     * return the value removed.     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">fastRemove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> numMoved <span class="token operator">=</span> size <span class="token operator">-</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>numMoved <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>            System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span>                             numMoved<span class="token punctuation">)</span><span class="token punctuation">;</span>        elementData<span class="token punctuation">[</span><span class="token operator">--</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// clear to let GC do its work</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 从列表中删除所有元素。      */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 把数组中所有的元素的值设为null</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            elementData<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>        size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾。     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">addAll</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Object<span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> numNew <span class="token operator">=</span> a<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> numNew<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Increments modCount</span>        System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> size<span class="token punctuation">,</span> numNew<span class="token punctuation">)</span><span class="token punctuation">;</span>        size <span class="token operator">+=</span> numNew<span class="token punctuation">;</span>        <span class="token keyword">return</span> numNew <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 将指定集合中的所有元素插入到此列表中，从指定的位置开始。     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">addAll</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">rangeCheckForAdd</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        Object<span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> numNew <span class="token operator">=</span> a<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> numNew<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Increments modCount</span>        <span class="token keyword">int</span> numMoved <span class="token operator">=</span> size <span class="token operator">-</span> index<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>numMoved <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>            System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index <span class="token operator">+</span> numNew<span class="token punctuation">,</span>                             numMoved<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span> numNew<span class="token punctuation">)</span><span class="token punctuation">;</span>        size <span class="token operator">+=</span> numNew<span class="token punctuation">;</span>        <span class="token keyword">return</span> numNew <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 从此列表中删除所有索引为fromIndex （含）和toIndex之间的元素。     *将任何后续元素移动到左侧（减少其索引）。     */</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">removeRange</span><span class="token punctuation">(</span><span class="token keyword">int</span> fromIndex<span class="token punctuation">,</span> <span class="token keyword">int</span> toIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> numMoved <span class="token operator">=</span> size <span class="token operator">-</span> toIndex<span class="token punctuation">;</span>        System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> toIndex<span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> fromIndex<span class="token punctuation">,</span>                         numMoved<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// clear to let GC do its work</span>        <span class="token keyword">int</span> newSize <span class="token operator">=</span> size <span class="token operator">-</span> <span class="token punctuation">(</span>toIndex<span class="token operator">-</span>fromIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> newSize<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            elementData<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        size <span class="token operator">=</span> newSize<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 检查给定的索引是否在范围内。     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">rangeCheck</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">>=</span> size<span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IndexOutOfBoundsException</span><span class="token punctuation">(</span><span class="token function">outOfBoundsMsg</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * add和addAll使用的rangeCheck的一个版本     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">rangeCheckForAdd</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">></span> size <span class="token operator">||</span> index <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IndexOutOfBoundsException</span><span class="token punctuation">(</span><span class="token function">outOfBoundsMsg</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 返回IndexOutOfBoundsException细节信息     */</span>    <span class="token keyword">private</span> String <span class="token function">outOfBoundsMsg</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"Index: "</span><span class="token operator">+</span>index<span class="token operator">+</span><span class="token string">", Size: "</span><span class="token operator">+</span>size<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 从此列表中删除指定集合中包含的所有元素。      */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">removeAll</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Objects<span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//如果此列表被修改则返回true</span>        <span class="token keyword">return</span> <span class="token function">batchRemove</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 仅保留此列表中包含在指定集合中的元素。     *换句话说，从此列表中删除其中不包含在指定集合中的所有元素。      */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">retainAll</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Objects<span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">batchRemove</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 从列表中的指定位置开始，返回列表中的元素（按正确顺序）的列表迭代器。     *指定的索引表示初始调用将返回的第一个元素为next 。 初始调用previous将返回指定索引减1的元素。      *返回的列表迭代器是fail-fast 。      */</span>    <span class="token keyword">public</span> ListIterator<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">listIterator</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> index <span class="token operator">></span> size<span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IndexOutOfBoundsException</span><span class="token punctuation">(</span><span class="token string">"Index: "</span><span class="token operator">+</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ListItr</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     *返回列表中的列表迭代器（按适当的顺序）。      *返回的列表迭代器是fail-fast 。     */</span>    <span class="token keyword">public</span> ListIterator<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">listIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ListItr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     *以正确的顺序返回该列表中的元素的迭代器。      *返回的迭代器是fail-fast 。      */</span>    <span class="token keyword">public</span> Iterator<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Itr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="ArrayList源码分析"><a href="#ArrayList源码分析" class="headerlink" title="ArrayList源码分析"></a>ArrayList源码分析</h3><h4 id="System-arraycopy-和Arrays-copyOf-方法"><a href="#System-arraycopy-和Arrays-copyOf-方法" class="headerlink" title="System.arraycopy()和Arrays.copyOf()方法"></a>System.arraycopy()和Arrays.copyOf()方法</h4><blockquote><p>​        通过上面源码我们发现这两个实现数组复制的方法被广泛使用而且很多地方都特别巧妙。比如下面<font color="red">add(int index, E element)</font>方法就很巧妙的用到了<font color="red">arraycopy()方法</font>让数组自己复制自己实现让index开始之后的所有成员后移一个位置:</p></blockquote><pre class=" language-java"><code class="language-java"> <span class="token comment" spellcheck="true">/**     * 在此列表中的指定位置插入指定的元素。      *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；     *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> E element<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">rangeCheckForAdd</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Increments modCount!!</span>        <span class="token comment" spellcheck="true">//arraycopy()方法实现数组自己复制自己</span>        <span class="token comment" spellcheck="true">//elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量；</span>        System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> size <span class="token operator">-</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>        elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> element<span class="token punctuation">;</span>        size<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><blockquote><p>又如toArray()方法中用到了copyOf()方法</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**     *以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。      *返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。     *因此，调用者可以自由地修改返回的数组。 此方法充当基于阵列和基于集合的API之间的桥梁。     */</span>    <span class="token keyword">public</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//elementData：要复制的数组；size：要复制的长度</span>        <span class="token keyword">return</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><blockquote><h5 id="两者联系与区别"><a href="#两者联系与区别" class="headerlink" title="两者联系与区别"></a>两者联系与区别</h5><p><strong>联系：</strong><br>看两者源代码可以发现<code>copyOf()</code>内部调用了<code>System.arraycopy()</code>方法<br><strong>区别：</strong></p><ol><li>arraycopy()需要目标数组，将原数组拷贝到你自己定义的数组里，而且可以选择拷贝的起点和长度以及放入新数组中的位置</li><li>copyOf()是系统自动在内部新建一个数组，并返回该数组。</li></ol></blockquote><h3 id="ArrayList-核心扩容技术"><a href="#ArrayList-核心扩容技术" class="headerlink" title="ArrayList 核心扩容技术"></a>ArrayList 核心扩容技术</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//下面是ArrayList的扩容机制</span><span class="token comment" spellcheck="true">//ArrayList的扩容机制提高了性能，如果每次只扩充一个，</span><span class="token comment" spellcheck="true">//那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。</span>    <span class="token comment" spellcheck="true">/**     * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量     * @param   minCapacity   所需的最小容量     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">ensureCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> minExpand <span class="token operator">=</span> <span class="token punctuation">(</span>elementData <span class="token operator">!=</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// any size if not default element table</span>            <span class="token operator">?</span> <span class="token number">0</span>            <span class="token comment" spellcheck="true">// larger than default for default empty table. It's already</span>            <span class="token comment" spellcheck="true">// supposed to be at default size.</span>            <span class="token operator">:</span> DEFAULT_CAPACITY<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">></span> minExpand<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">//得到最小扩容量</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData <span class="token operator">==</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">// 获取默认的容量和传入参数的较大值</span>            minCapacity <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>DEFAULT_CAPACITY<span class="token punctuation">,</span> minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//判断是否需要扩容,上面两个方法都要调用</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果说minCapacity也就是所需的最小容量大于保存ArrayList数据的数组的长度的话，就需要调用grow(minCapacity)方法扩容。</span>        <span class="token comment" spellcheck="true">//这个minCapacity到底为多少呢？举个例子在添加元素(add)方法中这个minCapacity的大小就为现在数组的长度加1</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">-</span> elementData<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span>            <span class="token function">grow</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"> <span class="token comment" spellcheck="true">/**     * ArrayList扩容的核心方法。     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">grow</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">//elementData为保存ArrayList数据的数组</span>       <span class="token comment" spellcheck="true">///elementData.length求数组长度elementData.size是求数组中的元素个数</span>        <span class="token comment" spellcheck="true">// oldCapacity为旧容量，newCapacity为新容量</span>        <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span>        <span class="token comment" spellcheck="true">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span>        <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> oldCapacity <span class="token operator">+</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            newCapacity <span class="token operator">=</span> minCapacity<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//再检查新容量是否超出了ArrayList所定义的最大容量，</span>        <span class="token comment" spellcheck="true">//若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，</span>        <span class="token comment" spellcheck="true">//如果minCapacity大于最大容量，则新容量则为ArrayList定义的最大容量，否则，新容量大小则为 minCapacity。 </span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> MAX_ARRAY_SIZE <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>            newCapacity <span class="token operator">=</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// minCapacity is usually close to size, so this is a win:</span>        elementData <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><blockquote><p>扩容机制代码已经做了详细的解释。另外值得注意的是大家很容易忽略的一个运算符：<strong>移位运算符</strong><br>　　<strong>简介</strong>：移位运算符就是在二进制的基础上对数字进行平移。按照平移的方向和填充数字的规则分为三种:<font color="red">&lt;&lt;(左移)</font>、<font color="red">&gt;&gt;(带符号右移)</font>和<font color="red">&gt;&gt;&gt;(无符号右移)</font>。<br>　　<strong>作用</strong>：<strong>对于大数据的2进制运算,位移运算符比那些普通运算符的运算要快很多,因为程序仅仅移动一下而已,不去计算,这样提高了效率,节省了资源</strong><br>　　比如这里：int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);<br>右移一位相当于除2，右移n位相当于除以 2 的 n 次方。这里 oldCapacity 明显右移了1位所以相当于oldCapacity /2。</p><p><strong>另外需要注意的是：</strong></p><ol><li>java 中的<strong>length 属性</strong>是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.</li><li>java 中的<strong>length()方法</strong>是针对字  符串String说的,如果想看这个字符串的长度则用到 length()这个方法.</li><li>.java 中的<strong>size()方法</strong>是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!</li></ol></blockquote><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><pre class=" language-java"><code class="language-java">         <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">Itr</span> <span class="token keyword">implements</span> <span class="token class-name">Iterator</span><span class="token operator">&lt;</span>E<span class="token operator">></span>      <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">ListItr</span> <span class="token keyword">extends</span> <span class="token class-name">Itr</span> <span class="token keyword">implements</span> <span class="token class-name">ListIterator</span><span class="token operator">&lt;</span>E<span class="token operator">></span>      <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">SubList</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractList</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">RandomAccess</span>      <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">ArrayListSpliterator</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Spliterator</span><span class="token operator">&lt;</span>E<span class="token operator">></span>  </code></pre><blockquote><p>ArrayList有四个内部类，其中的<strong>Itr是实现了Iterator接口</strong>，同时重写了里面的<strong>hasNext()</strong>，<strong>next()</strong>，<strong>remove()</strong>等方法；其中的<strong>ListItr</strong>继承<strong>Itr</strong>，实现了<strong>ListIterator接口</strong>，同时重写了<strong>hasPrevious()</strong>，<strong>nextIndex()</strong>，<strong>previousIndex()</strong>，<strong>previous()</strong>，<strong>set(E e)</strong>，<strong>add(E e)</strong>等方法，所以这也可以看出了<strong>Iterator和ListIterator的区别:</strong>ListIterator在Iterator的基础上增加了添加对象，修改对象，逆向遍历等方法，这些是Iterator不能实现的。</p></blockquote><h3 id="ArrayList经典Demo"><a href="#ArrayList经典Demo" class="headerlink" title="ArrayList经典Demo"></a>ArrayList经典Demo</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> list<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ArrayList<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Iterator<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArrayListDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> srgs<span class="token punctuation">)</span><span class="token punctuation">{</span>         ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> arrayList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Before add:arrayList.size() = %d\n"</span><span class="token punctuation">,</span>arrayList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         arrayList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         arrayList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         arrayList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         arrayList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         arrayList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"After add:arrayList.size() = %d\n"</span><span class="token punctuation">,</span>arrayList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Printing elements of arrayList"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 三种遍历方式打印元素</span>         <span class="token comment" spellcheck="true">// 第一种：通过迭代器遍历</span>         System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"通过迭代器遍历:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         Iterator<span class="token operator">&lt;</span>Integer<span class="token operator">></span> it <span class="token operator">=</span> arrayList<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">while</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>             System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>         System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 第二种：通过索引值遍历</span>         System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"通过索引值遍历:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arrayList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>             System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>arrayList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>         System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 第三种：for循环遍历</span>         System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"for循环遍历:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">for</span><span class="token punctuation">(</span>Integer number <span class="token operator">:</span> arrayList<span class="token punctuation">)</span><span class="token punctuation">{</span>             System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>number <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>         <span class="token comment" spellcheck="true">// toArray用法</span>         <span class="token comment" spellcheck="true">// 第一种方式(最常用)</span>         Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> integer <span class="token operator">=</span> arrayList<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 第二种方式(容易理解)</span>         Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> integer1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span>arrayList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>         arrayList<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span>integer1<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 抛出异常，java不支持向下转型</span>         <span class="token comment" spellcheck="true">//Integer[] integer2 = new Integer[arrayList.size()];</span>         <span class="token comment" spellcheck="true">//integer2 = arrayList.toArray();</span>         System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 在指定位置添加元素</span>         arrayList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 删除指定位置上的元素</span>         arrayList<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// 删除指定元素</span>         arrayList<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Object<span class="token punctuation">)</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 判断arrayList是否包含5</span>         System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ArrayList contains 5 is: "</span> <span class="token operator">+</span> arrayList<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 清空ArrayList</span>         arrayList<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 判断ArrayList是否为空</span>         System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ArrayList is empty: "</span> <span class="token operator">+</span> arrayList<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> List，ArrayList，LinkedList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>乐观锁与悲观锁的区别</title>
      <link href="/2019/03/25/le-guan-suo-yu-bei-guan-suo-de-qu-bie/"/>
      <url>/2019/03/25/le-guan-suo-yu-bei-guan-suo-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<h1 id="悲观锁和乐观锁的区别"><a href="#悲观锁和乐观锁的区别" class="headerlink" title="悲观锁和乐观锁的区别"></a>悲观锁和乐观锁的区别</h1><p>[TOC]</p><h4 id="一、悲观锁-Pessimistic-Lock"><a href="#一、悲观锁-Pessimistic-Lock" class="headerlink" title="一、悲观锁(Pessimistic Lock)"></a>一、悲观锁(Pessimistic Lock)</h4><blockquote><p>​        总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。<br>​        它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。</p></blockquote><h4 id="二、乐观锁-Optimistic-Lock"><a href="#二、乐观锁-Optimistic-Lock" class="headerlink" title="二、乐观锁(Optimistic Lock)"></a>二、乐观锁(Optimistic Lock)</h4><blockquote><p>​        总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。</p></blockquote><h4 id="三、乐观锁常见的两种实现方式"><a href="#三、乐观锁常见的两种实现方式" class="headerlink" title="三、乐观锁常见的两种实现方式"></a>三、乐观锁常见的两种实现方式</h4><blockquote><p>乐观锁一般会使用版本号机制或CAS算法实现。</p></blockquote><h5 id="1-版本号机制"><a href="#1-版本号机制" class="headerlink" title="1.版本号机制"></a>1.版本号机制</h5><blockquote><p>​        一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。</p><p>举一个简单的例子：<br>       假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ balance ）为 $100 。</p><p>   操作员 A 此时将其读出（ version=1 ），并从其帐户余额中扣除 50（50（100-$50 ）。<br>​        在操作员 A 操作的过程中，操作员B 也读入此用户信息（ version=1 ），并从其帐户余额中扣除 20（20（100-$20 ）。<br>操作员 A 完成了修改工作，将数据版本号加 1（ version=2 ），连同帐户扣除后余额（ balance=$50 ），提交至数据库更新，此时由于提交数据版本大于数据库记录当前版本，数据被更新，数据库记录 version 更新为 2 。<br>​        操作员 B 完成了操作，也将版本号加一（ version=2 ）试图向数据库提交数据（ balance=$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 2 ，数据库记录当前版本也为 2 ，不满足 “ 提交版本必须大于记录当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。<br>这样，就避免了操作员 B 用基于 version=1 的旧数据修改的结果覆盖操作员A 的操作结果的可能。</p></blockquote><h5 id="2-CAS算法"><a href="#2-CAS算法" class="headerlink" title="2.CAS算法"></a>2.CAS算法</h5><blockquote><p>​        即compare and swap（比较与交换），是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。CAS算法涉及到三个操作数</p><p>   需要读写的内存值 V<br>   进行比较的值 A<br>   拟写入的新值 B<br>   当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。</p></blockquote><h4 id="四、乐观锁的缺点"><a href="#四、乐观锁的缺点" class="headerlink" title="四、乐观锁的缺点"></a>四、乐观锁的缺点</h4><blockquote><p>ABA 问题是乐观锁一个常见的问题</p></blockquote><h5 id="1-ABA-问题"><a href="#1-ABA-问题" class="headerlink" title="1 ABA 问题"></a>1 ABA 问题</h5><blockquote><p>​        如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 “ABA”问题。</p><p>   JDK 1.5 以后的 AtomicStampedReference 类就提供了此种能力，其中的 compareAndSet 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p></blockquote><h5 id="2-循环时间长开销大"><a href="#2-循环时间长开销大" class="headerlink" title="2 循环时间长开销大"></a>2 循环时间长开销大</h5><blockquote><p>​        自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。 如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。</p></blockquote><h5 id="3-只能保证一个共享变量的原子操作"><a href="#3-只能保证一个共享变量的原子操作" class="headerlink" title="3 只能保证一个共享变量的原子操作"></a>3 只能保证一个共享变量的原子操作</h5><blockquote><p>​        CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5开始，提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用AtomicReference类把多个共享变量合并成一个共享变量来操作。</p></blockquote><h4 id="五、CAS与synchronized的使用情景"><a href="#五、CAS与synchronized的使用情景" class="headerlink" title="五、CAS与synchronized的使用情景"></a>五、CAS与synchronized的使用情景</h4><blockquote><p>简单的来说CAS适用于写比较少的情况下（多读场景，冲突一般较少），synchronized适用于写比较多的情况下（多写场景，冲突一般较多）</p></blockquote><blockquote><p>对于资源竞争较少（线程冲突较轻）的情况，使用synchronized同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。<br>对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。</p></blockquote><blockquote><p>补充： Java并发编程这个领域中synchronized关键字一直都是元老级的角色，很久之前很多人都会称它为 “重量级锁” 。但是，在JavaSE 1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的 偏向锁 和 轻量级锁 以及其它各种优化之后变得在某些情况下并不是那么重了。synchronized的底层实现主要依靠 Lock-Free 的队列，基本思路是 自旋后阻塞，竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了高吞吐量。在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 日常学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库，乐观锁，悲观锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zookeeper的羊群效应</title>
      <link href="/2019/03/25/zookeeper-de-yang-qun-xiao-ying/"/>
      <url>/2019/03/25/zookeeper-de-yang-qun-xiao-ying/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis缓存介绍</title>
      <link href="/2019/03/24/mybatis-huan-cun-jie-shao/"/>
      <url>/2019/03/24/mybatis-huan-cun-jie-shao/</url>
      
        <content type="html"><![CDATA[<h1 id="Mybatis缓存的介绍"><a href="#Mybatis缓存的介绍" class="headerlink" title="Mybatis缓存的介绍"></a>Mybatis缓存的介绍</h1><pre><code>    缓存：合理使用缓存是优化中最常见的，将从数据库中查询出来的数据放入缓存中，下次使用时不必从数据库查询，而是直接从缓存中读取，避免频繁操作数据库，减轻数据库压力，同时提高系统性能。</code></pre><h4 id="一、一级缓存"><a href="#一、一级缓存" class="headerlink" title="一、一级缓存"></a>一、一级缓存</h4><pre><code>    一级缓存是SqlSession级别的缓存，在操作数据库的时候需要构造sqlsession对象，在对象中有一个数据结构用于存储缓存数据。不同的SqlSession之间的缓存数据区域是互相不影响的。也就是它只能作用在同一个sqlSession中，不同的SqlSession中的缓存是互相不能读取的</code></pre><h5 id="1、一级缓存的工作原理"><a href="#1、一级缓存的工作原理" class="headerlink" title="1、一级缓存的工作原理"></a>1、一级缓存的工作原理</h5><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/03/24/mybatis-huan-cun-jie-shao/Mybatis一级缓存原理.png" alt="Mybatis一级缓存原理"></p><pre><code>    用户发起查询请求，查找某条数据，sqlsession先去缓存中查找，是否有该数据，如果有，读取如果没有，从数据库查询，并将查询到的数据放入 一级缓存区域，供下次使用但sqlsession执行commit，即增删改操作时会清空缓存。目的是避免脏读如果commit不清空缓存，会有以下的场景：A查询了某个商品为10件，并将10件库存的数据存入缓存中，之后被客户买走了10件，数据被delete了，但是下次查询这件商品时，并不从数据库中查询，而是从缓存中查询，就会出现错误。二级缓存    二级缓存是mapper级别的缓存，多个SqlSession去操作同一个Mapper的sql语句，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的，二级缓存的作用范围更大。    实际开发中，Mybatis通常和Spring进行整合开发，Spring将事务放在Service中管理，对于每一个service中的sqlsession是不同的，这是通过mybatis-spring中的org.mybatis.spring.mapper.MapperScannerConfigurer创建sqlsession自动注入到service中的。 每次查询之后都要进行关闭sqlSession，关闭之后数据被清空。所以spring整合之后，如果没有事务，一级缓存是没有意义的。</code></pre><h5 id="2-二级缓存的工作原理"><a href="#2-二级缓存的工作原理" class="headerlink" title="2.二级缓存的工作原理"></a>2.二级缓存的工作原理</h5><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/03/24/mybatis-huan-cun-jie-shao/Mybatis二级缓存原理.png" alt="Mybatis二级缓存原理"></p><pre><code>    二级缓存是mapper级别的缓存，多个SqlSession去操作同一个Mapper的sql语句，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。    UserMapper有一个二级缓存区域（按namespace分），其它mapper也有自己的二级缓存区域（按namespace分）。每一个namespace的mapper都有一个二级缓存区域，两个mapper的namespace如果相同，这两个mapper执行sql查询到数据将存在相同的二级缓存区域中。</code></pre><h5 id="3-开启二级缓存"><a href="#3-开启二级缓存" class="headerlink" title="3.开启二级缓存"></a>3.开启二级缓存</h5><p>在MyBatis的配置文件中加入：</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">font-size</span><span class="token punctuation">:</span><span class="token number">18</span>px<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>settings</span><span class="token punctuation">></span></span>       <span class="token comment" spellcheck="true">&lt;!--开启二级缓存--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cacheEnabled<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>settings</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span></code></pre><p>在需要开启二级缓存的mapper.xml中加入caceh标签</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">font-size</span><span class="token punctuation">:</span><span class="token number">18</span>px<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cache</span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span></code></pre><h4 id="二、总结"><a href="#二、总结" class="headerlink" title="二、总结"></a>二、总结</h4><pre><code>    对于查询多commit少且用户对查询结果实时性要求不高，此时采用mybatis二级缓存技术降低数据库访问量，提高访问速度。</code></pre><pre><code>但不能滥用二级缓存，二级缓存也有很多弊端，从MyBatis默认二级缓存是关闭的就可以看出来。二级缓存是建立在同一个namespace下的，如果对表的操作查询可能有多个namespace，那么得到的数据就是错误的。举个简单的例子:   订单和订单详情，orderMapper、orderDetailMapper。在查询订单详情时我们需要把订单信息也查询出来，那么这个订单详情的信息被二级缓存在orderDetailMapper的namespace中，这个时候有人要修改订单的基本信息，那就是在orderMapper的namespace下修改，他是不会影响到orderDetailMapper的缓存的，那么你再次查找订单详情时，拿到的是缓存的数据，这个数据其实已经是过时的。</code></pre><pre><code>根据以上，想要使用二级缓存时需要想好两个问题：1）对该表的操作与查询都在同一个namespace下，其他的namespace如果有操作，就会发生数据的脏读。2）对关联表的查询，关联的所有表的操作都必须在同一个namespace。hexi</code></pre>]]></content>
      
      
      <categories>
          
          <category> 日常学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dubbo常见面试题总结</title>
      <link href="/2019/02/19/dubbo-chang-jian-mian-shi-ti-zong-jie/"/>
      <url>/2019/02/19/dubbo-chang-jian-mian-shi-ti-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="Dubbo面试题总结"><a href="#Dubbo面试题总结" class="headerlink" title="Dubbo面试题总结"></a>Dubbo面试题总结</h1><h4 id="一、Dubbo是什么？"><a href="#一、Dubbo是什么？" class="headerlink" title="一、Dubbo是什么？"></a>一、Dubbo是什么？</h4><pre><code>Dubbo是阿里巴巴开源的基于 Java 的高性能 RPC 分布式服务框架，现已成为 Apache 基金会孵化项目。</code></pre><h4 id="二、远程过程调用协议"><a href="#二、远程过程调用协议" class="headerlink" title="二、远程过程调用协议"></a>二、远程过程调用协议</h4><pre><code>RPC:(Remote Procedure Call)    它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。RPC采用客户机/服务器模式。请求程序就是一个客户机，而服务提供程序就是一个服务器。首先，客户机调用进程发送一个有进程参数的调用信息到服务进程，然后等待应答信息。在服务器端，进程保持睡眠状态直到调用信息到达为止。当一个调用信息到达，服务器获得进程参数，计算结果，发送答复信息，然后等待下一个调用信息，最后，客户端调用进程接收答复信息，获得进程结果，然后调用执行继续进行。有多种 RPC模式和执行。最初由 Sun 公司提出。IETF ONC 宪章重新修订了 Sun 版本，使得 ONC RPC 协议成为 IETF 标准协议。现在使用最普遍的模式和执行是开放式软件基础的分布式计算环境（DCE）。</code></pre><h4 id="三、为什么要用Dubbo"><a href="#三、为什么要用Dubbo" class="headerlink" title="三、为什么要用Dubbo?"></a>三、为什么要用Dubbo?</h4><pre><code>    因为是阿里开源项目，国内很多互联网公司都在用，已经经过很多线上考验。内部使用了 Netty、Zookeeper，保证了高性能高可用性。    使用 Dubbo 可以将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，可用于提高业务复用灵活扩展，使前端应用能更快速的响应多变的市场需求。下面这张图可以很清楚的诠释，最重要的一点是，分布式架构可以承受更大规模的并发流量。</code></pre><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/02/19/dubbo-chang-jian-mian-shi-ti-zong-jie/1550554002964.png" alt="1550554002964"></p><p>下面是 Dubbo 的服务治理图。</p><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/02/19/dubbo-chang-jian-mian-shi-ti-zong-jie/1550554034880.png" alt="1550554034880"></p><h4 id="四、Dubbo-和-Spring-Cloud-有什么区别？"><a href="#四、Dubbo-和-Spring-Cloud-有什么区别？" class="headerlink" title="四、Dubbo 和 Spring Cloud 有什么区别？"></a>四、Dubbo 和 Spring Cloud 有什么区别？</h4><pre><code>两个没关联，如果硬要说区别，有以下几点。1）通信方式不同Dubbo 使用的是 RPC 通信，而 Spring Cloud 使用的是 HTTP RESTFul 方式。2）组成部分不同</code></pre><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/02/19/dubbo-chang-jian-mian-shi-ti-zong-jie/1550554095559.png" alt="1550554095559"></p><h4 id="五、dubbo都支持什么协议，推荐用哪种？"><a href="#五、dubbo都支持什么协议，推荐用哪种？" class="headerlink" title="五、dubbo都支持什么协议，推荐用哪种？"></a>五、dubbo都支持什么协议，推荐用哪种？</h4><pre><code>dubbo://（推荐）rmi://hessian://http://webservice://thrift://memcached://redis://rest://</code></pre><h4 id="六、Dubbo需要-Web-容器吗？"><a href="#六、Dubbo需要-Web-容器吗？" class="headerlink" title="六、Dubbo需要 Web 容器吗？"></a>六、Dubbo需要 Web 容器吗？</h4><pre><code>不需要，如果硬要用 Web 容器，只会增加复杂性，也浪费资源。</code></pre><h4 id="七、Dubbo内置了哪几种服务容器？"><a href="#七、Dubbo内置了哪几种服务容器？" class="headerlink" title="七、Dubbo内置了哪几种服务容器？"></a>七、Dubbo内置了哪几种服务容器？</h4><pre><code>Spring ContainerJetty ContainerLog4j ContainerDubbo 的服务容器只是一个简单的 Main 方法，并加载一个简单的 Spring 容器，用于暴露服务。</code></pre><h4 id="八、Dubbo里面有哪几种节点角色？"><a href="#八、Dubbo里面有哪几种节点角色？" class="headerlink" title="八、Dubbo里面有哪几种节点角色？"></a>八、Dubbo里面有哪几种节点角色？</h4><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/02/19/dubbo-chang-jian-mian-shi-ti-zong-jie/1550554250039.png" alt="1550554250039"></p><h4 id="九、画一画服务注册与发现的流程图"><a href="#九、画一画服务注册与发现的流程图" class="headerlink" title="九、画一画服务注册与发现的流程图"></a>九、画一画服务注册与发现的流程图</h4><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/02/19/dubbo-chang-jian-mian-shi-ti-zong-jie/1550554288101.png" alt="1550554288101"></p><h4 id="十、Dubbo默认使用什么注册中心，还有别的选择吗？"><a href="#十、Dubbo默认使用什么注册中心，还有别的选择吗？" class="headerlink" title="十、Dubbo默认使用什么注册中心，还有别的选择吗？"></a>十、Dubbo默认使用什么注册中心，还有别的选择吗？</h4><pre><code>推荐使用 Zookeeper 作为注册中心，还有 Redis、Multicast、Simple 注册中心，但不推荐。</code></pre><h4 id="十一、Dubbo有哪几种配置方式？"><a href="#十一、Dubbo有哪几种配置方式？" class="headerlink" title="十一、Dubbo有哪几种配置方式？"></a>十一、Dubbo有哪几种配置方式？</h4><pre><code>1）Spring 配置方式2）Java API 配置方式</code></pre><h4 id="十二、Dubbo-核心的配置有哪些？"><a href="#十二、Dubbo-核心的配置有哪些？" class="headerlink" title="十二、Dubbo 核心的配置有哪些？"></a>十二、Dubbo 核心的配置有哪些？</h4><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/02/19/dubbo-chang-jian-mian-shi-ti-zong-jie/1550554406352.png" alt="1550554406352"></p><p>配置之间的关系见下图。</p><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/02/19/dubbo-chang-jian-mian-shi-ti-zong-jie/1550554429525.png" alt="1550554429525"></p><h4 id="十三、在-Provider-上可以配置的-Consumer-端的属性有哪些？"><a href="#十三、在-Provider-上可以配置的-Consumer-端的属性有哪些？" class="headerlink" title="十三、在 Provider 上可以配置的 Consumer 端的属性有哪些？"></a>十三、在 Provider 上可以配置的 Consumer 端的属性有哪些？</h4><pre><code>1）timeout：方法调用超时2）retries：失败重试次数，默认重试 2 次3）loadbalance：负载均衡算法，默认随机4）actives 消费者端，最大并发调用限制</code></pre><h4 id="十四、Dubbo启动时如果依赖的服务不可用会怎样？"><a href="#十四、Dubbo启动时如果依赖的服务不可用会怎样？" class="headerlink" title="十四、Dubbo启动时如果依赖的服务不可用会怎样？"></a>十四、Dubbo启动时如果依赖的服务不可用会怎样？</h4><pre><code>Dubbo 缺省会在启动时检查依赖的服务是否可用，不可用时会抛出异常，阻止 Spring 初始化完成，默认 check=&quot;true&quot;，可以通过 check=&quot;false&quot; 关闭检查。</code></pre><h4 id="十五、Dubbo默认使用的是什么通信框架，还有别的选择吗？"><a href="#十五、Dubbo默认使用的是什么通信框架，还有别的选择吗？" class="headerlink" title="十五、Dubbo默认使用的是什么通信框架，还有别的选择吗？"></a>十五、Dubbo默认使用的是什么通信框架，还有别的选择吗？</h4><pre><code>Dubbo 默认使用 Netty 框架，也是推荐的选择，另外内容还集成有Mina、Grizzly。</code></pre><h4 id="十六、Dubbo推荐使用什么序列化框架，你知道的还有哪些？"><a href="#十六、Dubbo推荐使用什么序列化框架，你知道的还有哪些？" class="headerlink" title="十六、Dubbo推荐使用什么序列化框架，你知道的还有哪些？"></a>十六、Dubbo推荐使用什么序列化框架，你知道的还有哪些？</h4><pre><code>推荐使用Hessian序列化，还有Duddo、FastJson、Java自带序列化。</code></pre><h4 id="十七、Dubbo有哪几种集群容错方案，默认是哪种？"><a href="#十七、Dubbo有哪几种集群容错方案，默认是哪种？" class="headerlink" title="十七、Dubbo有哪几种集群容错方案，默认是哪种？"></a>十七、Dubbo有哪几种集群容错方案，默认是哪种？</h4><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/02/19/dubbo-chang-jian-mian-shi-ti-zong-jie/1550554627446.png" alt="1550554627446"></p><h4 id="十八、Dubbo有哪几种负载均衡策略，默认是哪种？"><a href="#十八、Dubbo有哪几种负载均衡策略，默认是哪种？" class="headerlink" title="十八、Dubbo有哪几种负载均衡策略，默认是哪种？"></a>十八、Dubbo有哪几种负载均衡策略，默认是哪种？</h4><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/02/19/dubbo-chang-jian-mian-shi-ti-zong-jie/1550554672227.png" alt="1550554672227"></p><h4 id="十九、注册了多个同一样的服务，如果测试指定的某一个服务呢？"><a href="#十九、注册了多个同一样的服务，如果测试指定的某一个服务呢？" class="headerlink" title="十九、注册了多个同一样的服务，如果测试指定的某一个服务呢？"></a>十九、注册了多个同一样的服务，如果测试指定的某一个服务呢？</h4><pre><code>可以配置环境点对点直连，绕过注册中心，将以服务接口为单位，忽略注册中心的提供者列表。</code></pre><h4 id="二十、Dubbo支持服务多协议吗？"><a href="#二十、Dubbo支持服务多协议吗？" class="headerlink" title="二十、Dubbo支持服务多协议吗？"></a>二十、Dubbo支持服务多协议吗？</h4><pre><code>Dubbo 允许配置多协议，在不同服务上支持不同协议或者同一服务上同时支持多种协议。</code></pre><h4 id="二十一、当一个服务接口有多种实现时怎么做？"><a href="#二十一、当一个服务接口有多种实现时怎么做？" class="headerlink" title="二十一、当一个服务接口有多种实现时怎么做？"></a>二十一、当一个服务接口有多种实现时怎么做？</h4><pre><code>当一个接口有多种实现时，可以用 group 属性来分组，服务提供方和消费方都指定同一个 group 即可。</code></pre><h4 id="二十二、服务上线怎么兼容旧版本？"><a href="#二十二、服务上线怎么兼容旧版本？" class="headerlink" title="二十二、服务上线怎么兼容旧版本？"></a>二十二、服务上线怎么兼容旧版本？</h4><pre><code>可以用版本号（version）过渡，多个不同版本的服务注册到注册中心，版本号不同的服务相互间不引用。这个和服务分组的概念有一点类似。</code></pre><h4 id="二十三、Dubbo可以对结果进行缓存吗？"><a href="#二十三、Dubbo可以对结果进行缓存吗？" class="headerlink" title="二十三、Dubbo可以对结果进行缓存吗？"></a>二十三、Dubbo可以对结果进行缓存吗？</h4><pre><code>可以，Dubbo 提供了声明式缓存，用于加速热门数据的访问速度，以减少用户加缓存的工作量。</code></pre><h4 id="二十四、Dubbo服务之间的调用是阻塞的吗？"><a href="#二十四、Dubbo服务之间的调用是阻塞的吗？" class="headerlink" title="二十四、Dubbo服务之间的调用是阻塞的吗？"></a>二十四、Dubbo服务之间的调用是阻塞的吗？</h4><pre><code>默认是同步等待结果阻塞的，支持异步调用。Dubbo 是基于 NIO 的非阻塞实现并行调用，客户端不需要启动多线程即可完成并行调用多个远程服务，相对多线程开销较小，异步调用会返回一个 Future 对象。</code></pre><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/02/19/dubbo-chang-jian-mian-shi-ti-zong-jie/1550554946569.png" alt="1550554946569"></p><h4 id="二十五、Dubbo支持分布式事务吗？"><a href="#二十五、Dubbo支持分布式事务吗？" class="headerlink" title="二十五、Dubbo支持分布式事务吗？"></a>二十五、Dubbo支持分布式事务吗？</h4><p>目前暂时不支持，后续可能采用基于 JTA/XA 规范实现，如以图所示。</p><p><img src="//github.com/zongmansheng/zongmansheng.github.io.git/2019/02/19/dubbo-chang-jian-mian-shi-ti-zong-jie/1550554990475.png" alt="1550554990475"></p><h4 id="二十六、Dubbo-telnet-命令能做什么？"><a href="#二十六、Dubbo-telnet-命令能做什么？" class="headerlink" title="二十六、Dubbo telnet 命令能做什么？"></a>二十六、Dubbo telnet 命令能做什么？</h4><pre><code>dubbo 通过 telnet 命令来进行服务治理，具体使用看这篇文章《dubbo服务调试管理实用命令》。telnet localhost 8090</code></pre><h4 id="二十七、Dubbo支持服务降级吗？"><a href="#二十七、Dubbo支持服务降级吗？" class="headerlink" title="二十七、Dubbo支持服务降级吗？"></a>二十七、Dubbo支持服务降级吗？</h4><pre><code>Dubbo 2.2.0 以上版本支持。</code></pre><h4 id="二十八、Dubbo如何优雅停机？"><a href="#二十八、Dubbo如何优雅停机？" class="headerlink" title="二十八、Dubbo如何优雅停机？"></a>二十八、Dubbo如何优雅停机？</h4><pre><code>Dubbo 是通过 JDK 的 ShutdownHook 来完成优雅停机的，所以如果使用 kill -9 PID 等强制关闭指令，是不会执行优雅停机的，只有通过 kill PID 时，才会执行。</code></pre><h4 id="二十九、服务提供者能实现失效踢出是什么原理？"><a href="#二十九、服务提供者能实现失效踢出是什么原理？" class="headerlink" title="二十九、服务提供者能实现失效踢出是什么原理？"></a>二十九、服务提供者能实现失效踢出是什么原理？</h4><pre><code>服务失效踢出基于 Zookeeper 的临时节点原理。</code></pre><h4 id="三十、如何解决服务调用链过长的问题？"><a href="#三十、如何解决服务调用链过长的问题？" class="headerlink" title="三十、如何解决服务调用链过长的问题？"></a>三十、如何解决服务调用链过长的问题？</h4><pre><code>Dubbo 可以使用 Pinpoint 和 Apache Skywalking(Incubator) 实现分布式服务追踪，当然还有其他很多方案。</code></pre><h4 id="三十一、服务读写推荐的容错策略是怎样的？"><a href="#三十一、服务读写推荐的容错策略是怎样的？" class="headerlink" title="三十一、服务读写推荐的容错策略是怎样的？"></a>三十一、服务读写推荐的容错策略是怎样的？</h4><pre><code>读操作建议使用 Failover 失败自动切换，默认重试两次其他服务器。写操作建议使用 Failfast 快速失败，发一次调用失败就立即报错。</code></pre><h4 id="三十二、Dubbo的管理控制台能做什么？"><a href="#三十二、Dubbo的管理控制台能做什么？" class="headerlink" title="三十二、Dubbo的管理控制台能做什么？"></a>三十二、Dubbo的管理控制台能做什么？</h4><pre><code>管理控制台主要包含：路由规则，动态配置，服务降级，访问控制，权重调整，负载均衡，等管理功能。</code></pre><h4 id="三十三、说说-Dubbo-服务暴露的过程。"><a href="#三十三、说说-Dubbo-服务暴露的过程。" class="headerlink" title="三十三、说说 Dubbo 服务暴露的过程。"></a>三十三、说说 Dubbo 服务暴露的过程。</h4><pre><code>Dubbo 会在 Spring 实例化完 bean 之后，在刷新容器最后一步发布 ContextRefreshEvent 事件的时候，通知实现了 ApplicationListener 的 ServiceBean 类进行回调 onApplicationEvent 事件方法，Dubbo 会在这个方法中调用 ServiceBean 父类 ServiceConfig 的 export 方法，而该方法真正实现了服务的（异步或者非异步）发布。    </code></pre><h4 id="三十四、Dubbo-停止维护了吗？"><a href="#三十四、Dubbo-停止维护了吗？" class="headerlink" title="三十四、Dubbo 停止维护了吗？"></a>三十四、Dubbo 停止维护了吗？</h4><pre><code>2014 年开始停止维护过几年，17 年开始重新维护，并进入了 Apache 项目。</code></pre><h4 id="三十五、Dubbo-和-Dubbox-有什么区别？"><a href="#三十五、Dubbo-和-Dubbox-有什么区别？" class="headerlink" title="三十五、Dubbo 和 Dubbox 有什么区别？"></a>三十五、Dubbo 和 Dubbox 有什么区别？</h4><pre><code>Dubbox 是继 Dubbo 停止维护后，当当网基于 Dubbo 做的一个扩展项目，如加了服务可 Restful 调用，更新了开源组件等。</code></pre><h4 id="三十六、你还了解别的分布式框架吗？"><a href="#三十六、你还了解别的分布式框架吗？" class="headerlink" title="三十六、你还了解别的分布式框架吗？"></a>三十六、你还了解别的分布式框架吗？</h4><pre><code>别的还有 Spring cloud、Facebook 的 Thrift、Twitter 的 Finagle 等。</code></pre><h4 id="三十七、Dubbo-能集成-Spring-Boot-吗？"><a href="#三十七、Dubbo-能集成-Spring-Boot-吗？" class="headerlink" title="三十七、Dubbo 能集成 Spring Boot 吗？"></a>三十七、Dubbo 能集成 Spring Boot 吗？</h4><pre><code>https://github.com/apache/incubator-dubbo-spring-boot-project</code></pre>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dubbo </tag>
            
            <tag> Zookeeper </tag>
            
            <tag> RPC </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
