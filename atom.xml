<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>晓笙的BLOG</title>
  
  <subtitle>一个来自IT界的菜鸟007</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zongmansheng.club/"/>
  <updated>2019-04-26T13:16:33.055Z</updated>
  <id>http://zongmansheng.club/</id>
  
  <author>
    <name>ZongMan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://zongmansheng.club/2019/04/26/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/"/>
    <id>http://zongmansheng.club/2019/04/26/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/</id>
    <published>2019-04-26T12:37:03.649Z</published>
    <updated>2019-04-26T13:16:33.055Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL事务及ACID特性的实现原理"><a href="#MySQL事务及ACID特性的实现原理" class="headerlink" title="MySQL事务及ACID特性的实现原理"></a>MySQL事务及ACID特性的实现原理</h1><h4 id="一、MySQL-事务基础概念"><a href="#一、MySQL-事务基础概念" class="headerlink" title="一、MySQL 事务基础概念"></a>一、MySQL 事务基础概念</h4><blockquote><p>​    事务(Transaction)是访问和更新数据库的程序执行单元;事务中可能包含一个或多个 sql 语句，这些语句要么都执行，要么都不执行。</p></blockquote><blockquote><p>​    作为一个关系型数据库，MySQL 支持事务，本文介绍基于 MySQL 5.6。首先回顾一下 MySQL 事务的基础知识。</p></blockquote><h4 id="二、逻辑架构和存储引擎"><a href="#二、逻辑架构和存储引擎" class="headerlink" title="二、逻辑架构和存储引擎"></a>二、逻辑架构和存储引擎</h4><p><img src="//zongmansheng.club/2019/04/26/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/001.jpg" alt="001"></p><blockquote><p>如上图所示，MySQL 服务器逻辑架构从上往下可以分为三层：</p></blockquote><p>++++</p><ul><li>第一层：处理客户端连接、授权认证等。</li><li>第二层：服务器层，负责查询语句的解析、优化、缓存以及内置函数的实现、存储过程等。</li><li>第三层：存储引擎，负责 MySQL 中数据的存储和提取。MySQL 中服务器层不管理事务，事务是由存储引擎实现的。</li></ul><blockquote><p>MySQL 支持事务的存储引擎有 InnoDB、NDB Cluster 等，其中 InnoDB 的使用最为广泛;其他存储引擎不支持事务，如 MyIsam、Memory 等。</p></blockquote><blockquote><p>如无特殊说明，后文中描述的内容都是基于 InnoDB。</p></blockquote><h4 id="三、提交和回滚"><a href="#三、提交和回滚" class="headerlink" title="三、提交和回滚"></a>三、提交和回滚</h4><blockquote><p>典型的 MySQL 事务是如下操作的：</p></blockquote><pre class=" language-java"><code class="language-java">start transaction<span class="token punctuation">;</span> …… #一条或多条sql语句 commit<span class="token punctuation">;</span> </code></pre><blockquote><p>其中 start transaction 标识事务开始，commit 提交事务，将执行结果写入到数据库。</p></blockquote><blockquote><p>如果 sql 语句执行出现问题，会调用 rollback，回滚所有已经执行成功的 sql 语句。当然，也可以在事务中直接使用 rollback 语句进行回滚。</p></blockquote><h4 id="四、自动提交"><a href="#四、自动提交" class="headerlink" title="四、自动提交"></a>四、自动提交</h4><blockquote><p>MySQL 中默认采用的是自动提交(autocommit)模式，如下所示：</p></blockquote><p><img src="//zongmansheng.club/2019/04/26/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/002.jpg" alt="002"></p><blockquote><p>在自动提交模式下，如果没有 start transaction 显式地开始一个事务，那么每个 sql 语句都会被当做一个事务执行提交操作。</p></blockquote><blockquote><p>通过如下方式，可以关闭 autocommit;需要注意的是，autocommit 参数是针对连接的，在一个连接中修改了参数，不会对其他连接产生影响。</p></blockquote><blockquote><p><img src="//zongmansheng.club/2019/04/26/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/003.jpg" alt="003"></p></blockquote><blockquote><p>如果关闭了 autocommit，则所有的 sql 语句都在一个事务中，直到执行了 commit 或 rollback，该事务结束，同时开始了另外一个事务。</p></blockquote><h4 id="五、特殊操作"><a href="#五、特殊操作" class="headerlink" title="五、特殊操作"></a>五、特殊操作</h4><blockquote><p>在 MySQL 中，存在一些特殊的命令，如果在事务中执行了这些命令，会马上强制执行 commit 提交事务;如 DDL 语句(create table/drop table/alter/table)、lock tables 语句等等。</p></blockquote><blockquote><p>不过，常用的 select、insert、update 和 delete 命令，都不会强制提交事务。</p></blockquote><h4 id="六、ACID-特性"><a href="#六、ACID-特性" class="headerlink" title="六、ACID 特性"></a>六、ACID 特性</h4><blockquote><p>ACID 是衡量事务的四个特性：</p></blockquote><ul><li><strong>原子性(Atomicity，或称不可分割性)</strong></li><li><strong>一致性(Consistency)</strong></li><li><strong>隔离性(Isolation)</strong></li><li><strong>持久性(Durability)</strong></li></ul><blockquote><p>按照严格的标准，只有同时满足 ACID 特性才是事务;但是在各大数据库厂商的实现中，真正满足 ACID 的事务少之又少。</p></blockquote><blockquote><p>例如 MySQL 的 NDB Cluster 事务不满足持久性和隔离性;InnoDB 默认事务隔离级别是可重复读，不满足隔离性;Oracle 默认的事务隔离级别为 READ COMMITTED，不满足隔离性……</p></blockquote><blockquote><p>因此与其说 ACID 是事务必须满足的条件，不如说它们是衡量事务的四个维度。</p></blockquote><blockquote><p>下面将详细介绍 ACID 特性及其实现原理，为了便于理解，介绍的顺序不是严格按照 A-C-I-D。</p></blockquote><h4 id="七、ACID-特性及其实现原理"><a href="#七、ACID-特性及其实现原理" class="headerlink" title="七、ACID 特性及其实现原理"></a>七、ACID 特性及其实现原理</h4><h5 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a><strong>原子性</strong></h5><p><strong>定义</strong></p><blockquote><p>原子性是指一个事务是一个不可分割的工作单位，其中的操作要么都做，要么都不做。</p></blockquote><blockquote><p>如果事务中一个 sql 语句执行失败，则已执行的语句也必须回滚，数据库退回到事务前的状态。</p></blockquote><p><strong>实现原理：undo log</strong></p><blockquote><p>在说明原子性原理之前，首先介绍一下 MySQL 的事务日志。MySQL 的日志有很多种，如二进制日志、错误日志、查询日志、慢查询日志等。</p></blockquote><blockquote><p>此外 InnoDB 存储引擎还提供了两种事务日志：</p></blockquote><ul><li><strong>redo log(重做日志)</strong></li><li><strong>undo log(回滚日志)</strong></li></ul><blockquote><p>其中 redo log 用于保证事务持久性;undo log 则是事务原子性和隔离性实现的基础。</p></blockquote><blockquote><p>下面说回 undo log。实现原子性的关键，是当事务回滚时能够撤销所有已经成功执行的 sql 语句。</p></blockquote><blockquote><p>InnoDB 实现回滚，靠的是 undo log：</p></blockquote><ul><li>当事务对数据库进行修改时，InnoDB 会生成对应的 undo log。</li><li>如果事务执行失败或调用了 rollback，导致事务需要回滚，便可以利用 undo log 中的信息将数据回滚到修改之前的样子。</li></ul><blockquote><p>undo log 属于逻辑日志，它记录的是 sql 执行相关的信息。当发生回滚时，InnoDB 会根据 undo log 的内容做与之前相反的工作：</p></blockquote><ul><li>对于每个 insert，回滚时会执行 delete。</li><li>对于每个 delete，回滚时会执行 insert。</li><li>对于每个 update，回滚时会执行一个相反的 update，把数据改回去。</li></ul><blockquote><p>以 update 操作为例：当事务执行 update 时，其生成的 undo log 中会包含被修改行的主键(以便知道修改了哪些行)、修改了哪些列、这些列在修改前后的值等信息，回滚时便可以使用这些信息将数据还原到 update 之前的状态。</p></blockquote><h5 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a><strong>持久性</strong></h5><p><strong>定义</strong></p><blockquote><p>持久性是指事务一旦提交，它对数据库的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。</p></blockquote><p><strong>实现原理：redo log</strong></p><blockquote><p>redo log 和 undo log 都属于 InnoDB 的事务日志。下面先聊一下 redo log 存在的背景。</p></blockquote><blockquote><p>InnoDB 作为 MySQL 的存储引擎，数据是存放在磁盘中的，但如果每次读写数据都需要磁盘 IO，效率会很低。</p></blockquote><blockquote><p>为此，InnoDB 提供了缓存(Buffer Pool)，Buffer Pool 中包含了磁盘中部分数据页的映射，作为访问数据库的缓冲：</p></blockquote><ul><li>当从数据库读取数据时，会首先从 Buffer Pool 中读取，如果 Buffer Pool 中没有，则从磁盘读取后放入 Buffer Pool。</li><li>当向数据库写入数据时，会首先写入 Buffer Pool，Buffer Pool 中修改的数据会定期刷新到磁盘中(这一过程称为刷脏)。</li></ul><blockquote><p>Buffer Pool 的使用大大提高了读写数据的效率，但是也带来了新的问题：如果 MySQL 宕机，而此时 Buffer Pool 中修改的数据还没有刷新到磁盘，就会导致数据的丢失，事务的持久性无法保证。</p></blockquote><blockquote><p>于是，redo log 被引入来解决这个问题：当数据修改时，除了修改 Buffer Pool 中的数据，还会在 redo log 记录这次操作;当事务提交时，会调用 fsync 接口对 redo log 进行刷盘。</p></blockquote><blockquote><p>如果 MySQL 宕机，重启时可以读取 redo log 中的数据，对数据库进行恢复。</p></blockquote><blockquote><p>redo log 采用的是 WAL(Write-ahead logging，预写式日志)，所有修改先写入日志，再更新到 Buffer Pool，保证了数据不会因 MySQL 宕机而丢失，从而满足了持久性要求。</p></blockquote><blockquote><p>既然 redo log 也需要在事务提交时将日志写入磁盘，为什么它比直接将 Buffer Pool 中修改的数据写入磁盘(即刷脏)要快呢?</p></blockquote><blockquote><p>主要有以下两方面的原因：</p></blockquote><ul><li>刷脏是随机 IO，因为每次修改的数据位置随机，但写 redo log 是追加操作，属于顺序 IO。</li><li>刷脏是以数据页(Page)为单位的，MySQL 默认页大小是 16KB，一个 Page 上一个小修改都要整页写入;而 redo log 中只包含真正需要写入的部分，无效 IO 大大减少。</li></ul><p><strong>redo log 与 binlog</strong></p><blockquote><p>我们知道，在 MySQL 中还存在 binlog(二进制日志)也可以记录写操作并用于数据的恢复，但二者是有着根本的不同的。</p></blockquote><blockquote><p>作用不同：</p></blockquote><ul><li>redo log 是用于 crash recovery 的，保证 MySQL 宕机也不会影响持久性;</li><li>binlog 是用于 point-in-time recovery 的，保证服务器可以基于时间点恢复数据，此外 binlog 还用于主从复制。</li></ul><blockquote><p>层次不同：</p></blockquote><ul><li>redo log 是 InnoDB 存储引擎实现的，</li><li>而 binlog 是 MySQL 的服务器层(可以参考文章前面对 MySQL 逻辑架构的介绍)实现的，同时支持 InnoDB 和其他存储引擎。</li></ul><blockquote><p>内容不同：</p></blockquote><ul><li>redo log 是物理日志，内容基于磁盘的 Page。</li><li>binlog 是逻辑日志，内容是一条条 sql。</li></ul><blockquote><p>写入时机不同：</p></blockquote><ul><li>redo log 的写入时机相对多元。前面曾提到，当事务提交时会调用 fsync 对 redo log 进行刷盘;这是默认情况下的策略，修改 innodb_flush_log_at_trx_commit 参数可以改变该策略，但事务的持久性将无法保证。</li></ul><blockquote><p>除了事务提交时，还有其他刷盘时机：如 master thread 每秒刷盘一次 redo log 等，这样的好处是不一定要等到 commit 时刷盘，commit 速度大大加快。</p></blockquote><ul><li>binlog 在事务提交时写入。</li></ul><h5 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a><strong>隔离性</strong></h5><p><strong>定义</strong></p><blockquote><p>与原子性、持久性侧重于研究事务本身不同，隔离性研究的是不同事务之间的相互影响。</p></blockquote><blockquote><p>隔离性是指事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p></blockquote><blockquote><p>严格的隔离性，对应了事务隔离级别中的 Serializable(可串行化)，但实际应用中出于性能方面的考虑很少会使用可串行化。</p></blockquote><blockquote><p>隔离性追求的是并发情形下事务之间互不干扰。简单起见，我们仅考虑最简单的读操作和写操作(暂时不考虑带锁读等特殊操作)。</p></blockquote><blockquote><p>那么隔离性的探讨，主要可以分为两个方面：</p></blockquote><ul><li>(一个事务)写操作对(另一个事务)写操作的影响：锁机制保证隔离性。</li><li>(一个事务)写操作对(另一个事务)读操作的影响：MVCC 保证隔离性。</li></ul><h5 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a><strong>锁机制</strong></h5><blockquote><p>首先来看两个事务的写操作之间的相互影响。隔离性要求同一时刻只能有一个事务对数据进行写操作，InnoDB 通过锁机制来保证这一点。</p></blockquote><blockquote><p>锁机制的基本原理可以概括为：</p></blockquote><ul><li>事务在修改数据之前，需要先获得相应的锁。</li><li>获得锁之后，事务便可以修改数据。</li><li>该事务操作期间，这部分数据是锁定的，其他事务如果需要修改数据，需要等待当前事务提交或回滚后释放锁。</li></ul><blockquote><p>行锁与表锁：按照粒度，锁可以分为表锁、行锁以及其他位于二者之间的锁。</p></blockquote><blockquote><p>表锁在操作数据时会锁定整张表，并发性能较差;行锁则只锁定需要操作的数据，并发性能好。</p></blockquote><blockquote><p>但是由于加锁本身需要消耗资源(获得锁、检查锁、释放锁等都需要消耗资源)，因此在锁定数据较多情况下使用表锁可以节省大量资源。</p></blockquote><blockquote><p>MySQL 中不同的存储引擎支持的锁是不一样的，例如 MyIsam 只支持表锁，而 InnoDB 同时支持表锁和行锁，且出于性能考虑，绝大多数情况下使用的都是行锁。</p></blockquote><blockquote><p>如何查看锁信息?有多种方法可以查看 InnoDB 中锁的情况，例如：</p></blockquote><pre class=" language-mysql"><code class="language-mysql">select * from information_schema.innodb_locks; #锁的概况 show engine innodb status; #InnoDB整体状态，其中包括锁的情况 </code></pre><p>下面来看一个例子：</p><pre class=" language-mysql"><code class="language-mysql">#在事务A中执行： start transaction; update account SET balance = 1000 where id = 1; 在事务B中执行： start transaction; update account SET balance = 2000 where id = 1; </code></pre><p>此时查看锁的情况：</p><p><img src="//zongmansheng.club/2019/04/26/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/004.jpg" alt="004"></p><p>show engine innodb status 查看锁相关的部分：</p><p><img src="//zongmansheng.club/2019/04/26/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/005.jpg" alt="005"></p><blockquote><p>通过上述命令可以查看事务 24052 和 24053 占用锁的情况;其中 lock_type 为 RECORD，代表锁为行锁(记录锁);lock_mode 为 X，代表排它锁(写锁)。</p></blockquote><blockquote><p>除了排它锁(写锁)之外，MySQL 中还有共享锁(读锁)的概念。由于本文重点是 MySQL 事务的实现原理，因此对锁的介绍到此为止。</p></blockquote><blockquote><p>介绍完写操作之间的相互影响，下面讨论写操作对读操作的影响。</p></blockquote><h5 id="脏读、不可重复读和幻读"><a href="#脏读、不可重复读和幻读" class="headerlink" title="脏读、不可重复读和幻读"></a><strong>脏读、不可重复读和幻读</strong></h5><blockquote><p>首先来看并发情况下，读操作可能存在的三类问题。</p></blockquote><blockquote><p>①脏读：当前事务(A)中可以读到其他事务(B)未提交的数据(脏数据)，这种现象是脏读。</p></blockquote><p>举例如下(以账户余额表为例)：</p><p><img src="//zongmansheng.club/2019/04/26/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/006.jpg" alt="006"></p><blockquote><p>②不可重复读：在事务 A 中先后两次读取同一个数据，两次读取的结果不一样，这种现象称为不可重复读。</p></blockquote><blockquote><p>脏读与不可重复读的区别在于：前者读到的是其他事务未提交的数据，后者读到的是其他事务已提交的数据。</p></blockquote><p>举例如下：</p><p><img src="//zongmansheng.club/2019/04/26/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/007.jpg" alt="007"></p><blockquote><p>③幻读：在事务 A 中按照某个条件先后两次查询数据库，两次查询结果的条数不同，这种现象称为幻读。</p></blockquote><blockquote><p>不可重复读与幻读的区别可以通俗的理解为：前者是数据变了，后者是数据的行数变了。</p></blockquote><p>举例如下：</p><p><img src="//zongmansheng.club/2019/04/26/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/008.jpg" alt="008"></p><h5 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a><strong>事务隔离级别</strong></h5><blockquote><p>sql 标准中定义了四种隔离级别，并规定了每种隔离级别下上述几个问题是否存在。</p></blockquote><blockquote><p>一般来说，隔离级别越低，系统开销越低，可支持的并发越高，但隔离性也越差。</p></blockquote><blockquote><p>隔离级别与读问题的关系如下：</p></blockquote><p><img src="//zongmansheng.club/2019/04/26/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/009.jpg" alt="009"></p><blockquote><p>在实际应用中，读未提交在并发时会导致很多问题，而性能相对于其他隔离级别提高却很有限，因此使用较少。</p></blockquote><blockquote><p>可串行化强制事务串行，并发效率很低，只有当对数据一致性要求极高且可以接受没有并发时使用，因此使用也较少。</p></blockquote><blockquote><p>因此在大多数数据库系统中，默认的隔离级别是读已提交(如 Oracle)或可重复读(后文简称 RR)。</p></blockquote><blockquote><p>可以通过如下两个命令分别查看全局隔离级别和本次会话的隔离级别：</p></blockquote><p><img src="//zongmansheng.club/2019/04/26/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/010.jpg" alt="010"></p><h4 id="八、MVCC"><a href="#八、MVCC" class="headerlink" title="八、MVCC"></a>八、MVCC</h4><blockquote><p>RR 解决脏读、不可重复读、幻读等问题，使用的是 MVCC：MVCC 全称 Multi-Version Concurrency Control，即多版本的并发控制协议。</p></blockquote><blockquote><p>下面的例子很好的体现了 MVCC 的特点：在同一时刻，不同的事务读取到的数据可能是不同的(即多版本)——在 T5 时刻，事务 A 和事务 C 可以读取到不同版本的数据。</p></blockquote><p><img src="//zongmansheng.club/2019/04/26/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/011.jpg" alt="011"></p><blockquote><p>MVCC 最大的优点是读不加锁，因此读写不冲突，并发性能好。InnoDB 实现 MVCC，多个版本的数据可以共存，主要是依靠数据的隐藏列(也可以称之为标记位)和 undo log。</p></blockquote><blockquote><p>其中数据的隐藏列包括了该行数据的版本号、删除时间、指向 undo log 的指针等等。</p></blockquote><blockquote><p>当读取数据时，MySQL 可以通过隐藏列判断是否需要回滚并找到回滚需要的 undo log，从而实现 MVCC;隐藏列的详细格式不再展开。</p></blockquote><blockquote><p>下面结合前文提到的几个问题分别说明。</p></blockquote><h5 id="①脏读"><a href="#①脏读" class="headerlink" title="①脏读"></a><strong>①脏读</strong></h5><p><img src="//zongmansheng.club/2019/04/26/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/012.jpg" alt="012"></p><blockquote><p>当事务 A 在 T3 时间节点读取 zhangsan 的余额时，会发现数据已被其他事务修改，且状态为未提交。</p></blockquote><blockquote><p>此时事务 A 读取最新数据后，根据数据的 undo log 执行回滚操作，得到事务 B 修改前的数据，从而避免了脏读。</p></blockquote><h5 id="②不可重复读"><a href="#②不可重复读" class="headerlink" title="②不可重复读"></a>②不可重复读</h5><p><img src="//zongmansheng.club/2019/04/26/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/013.jpg" alt="013"></p><blockquote><p>当事务 A 在 T2 节点第一次读取数据时，会记录该数据的版本号(数据的版本号是以 row 为单位记录的)，假设版本号为 1;当事务 B 提交时，该行记录的版本号增加，假设版本号为 2。</p></blockquote><blockquote><p>当事务 A 在 T5 再一次读取数据时，发现数据的版本号(2)大于第一次读取时记录的版本号(1)，因此会根据 undo log 执行回滚操作，得到版本号为 1 时的数据，从而实现了可重复读。</p></blockquote><h5 id="③幻读"><a href="#③幻读" class="headerlink" title="③幻读"></a>③幻读</h5><blockquote><p>InnoDB 实现的 RR 通过 next-keylock 机制避免了幻读现象。</p></blockquote><blockquote><p>next-keylock 是行锁的一种，实现相当于 record lock(记录锁) + gap lock(间隙锁);其特点是不仅会锁住记录本身(record lock 的功能)，还会锁定一个范围(gap lock 的功能)。</p></blockquote><blockquote><p>当然，这里我们讨论的是不加锁读：此时的 next-key lock 并不是真的加锁，只是为读取的数据增加了标记(标记内容包括数据的版本号等);准确起见姑且称之为类 next-key lock 机制。</p></blockquote><blockquote><p>还是以前面的例子来说明：</p></blockquote><p><img src="//zongmansheng.club/2019/04/26/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/014.jpg" alt="014"></p><blockquote><p>当事务 A 在 T2 节点第一次读取 0</p></blockquote><blockquote><p>这样当 T5 时刻再次读取 0</p></blockquote><blockquote><p>小结：概括来说，InnoDB 实现的 RR，通过锁机制、数据的隐藏列、undo log 和类 next-key lock，实现了一定程度的隔离性，可以满足大多数场景的需要。</p></blockquote><blockquote><p>不过需要说明的是，RR 虽然避免了幻读问题，但是毕竟不是 Serializable，不能保证完全的隔离。</p></blockquote><blockquote><p>下面是一个例子，大家可以自己验证一下：</p></blockquote><p><img src="//zongmansheng.club/2019/04/26/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/015.jpg" alt="015"></p><p><strong>一致性</strong></p><p><strong>基本概念</strong></p><p>一致性是指事务执行结束后，数据库的完整性约束没有被破坏，事务执行的前后都是合法的数据状态。</p><p>数据库的完整性约束包括但不限于：</p><ul><li>实体完整性(如行的主键存在且唯一)</li><li>列完整性(如字段的类型、大小、长度要符合要求)</li><li>外键约束</li><li>用户自定义完整性(如转账前后，两个账户余额的和应该不变)</li></ul><p><strong>实现</strong></p><p>可以说，一致性是事务追求的最终目标：前面提到的原子性、持久性和隔离性，都是为了保证数据库状态的一致性。此外，除了数据库层面的保障，一致性的实现也需要应用层面进行保障。</p><p>实现一致性的措施包括：</p><ul><li>保证原子性、持久性和隔离性，如果这些特性无法保证，事务的一致性也无法保证。</li><li>数据库本身提供保障，例如不允许向整形列插入字符串值、字符串长度不能超过列的限制等。</li><li>应用层面进行保障，例如如果转账操作只扣除转账者的余额，而没有增加接收者的余额，无论数据库实现的多么完美，也无法保证状态的一致。</li></ul><p><strong>总结</strong></p><p>下面总结一下 ACID 特性及其实现原理：</p><ul><li>原子性：语句要么全执行，要么全不执行，是事务最核心的特性。事务本身就是以原子性来定义的;实现主要基于 undo log。</li><li>持久性：保证事务提交后不会因为宕机等原因导致数据丢失;实现主要基于 redo log。</li><li>隔离性：保证事务执行尽可能不受其他事务影响;InnoDB 默认的隔离级别是 RR，RR 的实现主要基于锁机制、数据的隐藏列、undo log 和类 next-key lock 机制。</li><li>一致性：事务追求的最终目标，一致性的实现既需要数据库层面的保障，也需要应用层面的保障。</li></ul><h4 id="九、参考文献："><a href="#九、参考文献：" class="headerlink" title="九、参考文献："></a>九、参考文献：</h4><ul><li>《MySQL 技术内幕：InnoDB 存储引擎》</li><li>《高性能 MySQL》</li><li>《MySQL 运维内参》</li><li><a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_acid" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_acid</a></li><li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-next-key-locking.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.6/en/innodb-next-key-locking.html</a></li><li><a href="http://blog.sina.com.cn/s/blog_499740cb0100ugs7.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_499740cb0100ugs7.html</a></li><li><a href="https://mp.weixin.qq.com/s/2dwGBTmu_da2x-HiHlN0vw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/2dwGBTmu_da2x-HiHlN0vw</a></li><li><a href="http://www.cnblogs.com/chenpingzhao/p/5065316.html" target="_blank" rel="noopener">http://www.cnblogs.com/chenpingzhao/p/5065316.html</a></li><li><a href="https://juejin.im/entry/5ba0a254e51d450e735e4a1f" target="_blank" rel="noopener">https://juejin.im/entry/5ba0a254e51d450e735e4a1f</a></li><li><a href="http://hedengcheng.com/?p=771" target="_blank" rel="noopener">http://hedengcheng.com/?p=771</a></li></ul><p>转发自：<a href="https://www.toutiao.com/i6651767011648995843/" target="_blank" rel="noopener">https://www.toutiao.com/i6651767011648995843/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL事务及ACID特性的实现原理&quot;&gt;&lt;a href=&quot;#MySQL事务及ACID特性的实现原理&quot; class=&quot;headerlink&quot; title=&quot;MySQL事务及ACID特性的实现原理&quot;&gt;&lt;/a&gt;MySQL事务及ACID特性的实现原理&lt;/h1&gt;&lt;h4 i
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SQL注入XSS和CSRF</title>
    <link href="http://zongmansheng.club/2019/04/26/sql-zhu-ru-xss-he-csrf/"/>
    <id>http://zongmansheng.club/2019/04/26/sql-zhu-ru-xss-he-csrf/</id>
    <published>2019-04-26T00:31:32.000Z</published>
    <updated>2019-04-26T12:30:58.142Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SQL注入、XSS和CSRF"><a href="#SQL注入、XSS和CSRF" class="headerlink" title="SQL注入、XSS和CSRF"></a>SQL注入、XSS和CSRF</h1><h4 id="一、SQL注入"><a href="#一、SQL注入" class="headerlink" title="一、SQL注入"></a>一、SQL注入</h4><pre><code>SQL注入是属于注入式攻击，这种攻击是因为在项目中没有将代码与数据（比如用户敏感数据）隔离，在读取数据的时候，错误的将数据作为代码的一部分执行而导致的。典型的例子就是当对SQL语句进行字符串拼接的时候，直接使用未转义的用户输入内容作为变量。这时，只要在sql语句的中间做修改，比如加上drop、delete等关键字，执行之后后果不堪设想。说到这里，那么该怎么处理这种情况呢？三个方面：1、过滤用户输入参数中的特殊字符，降低风险。2、禁止通过字符串拼接sql语句，要严格使用参数绑定来传入参数。3、合理使用数据库框架提供的机制。就比如Mybatis提供的传入参数的方式 #{}，禁止使用${}，后者相当于是字符串拼接sql，要使用参数化的语句。总结下，就是要正确使用参数化绑定sql变量。</code></pre><h4 id="二、XSS"><a href="#二、XSS" class="headerlink" title="二、XSS"></a>二、XSS</h4><p>​    </p><blockquote><p>​       XSS：跨站脚本攻击，Cross-Site Scripting，为了和前端的css避免重名，简称为XSS，是指通过技术手段，向正常用户请求的HTML页面中插入恶意脚本，执行。</p></blockquote><blockquote><p>​    这种攻击主要是用于信息窃取和破坏等目的。比如2011年的微博XSS攻击事件，攻击者利用了微博发布功能中未对action-data漏洞做有效的过滤，在发布微博信息的时候带上了包含攻击脚本的URL，用户访问就会加载恶意脚本，导致大量用户被攻击。</p></blockquote><blockquote><p>​    关于防范XSS上，主要就是通过对用户输入的数据做过滤或者是转义，可以使用框架提供的工具类HtmlUtil。另外前端在浏览器展示数据的时候，要使用安全的API展示数据。比如使用innerText而不是innerHTML。</p></blockquote><h4 id="三、CSRF"><a href="#三、CSRF" class="headerlink" title="三、CSRF"></a>三、CSRF</h4><blockquote><p>​    跨站请求伪造，在用户并不知情的情况下，冒充用户发送请求，在当前已经登录的web网站上执行恶意操作，比如恶意发帖，修改密码等。</p></blockquote><blockquote><p>​    大致来看，与XSS有重合的地方，前者是黑客盗用用户浏览器中的登录信息，冒充用户去执行操作。后者是在正常用户请求的HTML中放入恶意代码，</p></blockquote><blockquote><p>​    XSS问题出在用户数据没有转义，过滤；CSRF问题出现在HTTP接口没有防范不守信用的调用。</p></blockquote><blockquote><p>防范CSRF的漏洞方式：</p></blockquote><blockquote><p>​    1、CSRF Token验证，利用浏览器的同源限制，在HTTP接口执行前验证Cookie中的Token，验证通过才会继续执行请求。</p></blockquote><blockquote><p>​    2、人机交互，例如短信验证码、界面的滑块。</p></blockquote><blockquote><p>之前在会议上也有一个思考，在人机验证这块，如果不用验证码的方式，用界面上的滑块这种方式，而且滑块还是第三方的。在APP的注册、登录使用这种人机验证的方式的话，如果第三方出现了问题，那么自己的APP就完全崩掉了，发版之后的APP什么也改不了。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SQL注入、XSS和CSRF&quot;&gt;&lt;a href=&quot;#SQL注入、XSS和CSRF&quot; class=&quot;headerlink&quot; title=&quot;SQL注入、XSS和CSRF&quot;&gt;&lt;/a&gt;SQL注入、XSS和CSRF&lt;/h1&gt;&lt;h4 id=&quot;一、SQL注入&quot;&gt;&lt;a href=
      
    
    </summary>
    
      <category term="日常学习" scheme="http://zongmansheng.club/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="SQL" scheme="http://zongmansheng.club/tags/SQL/"/>
    
      <category term="XSS" scheme="http://zongmansheng.club/tags/XSS/"/>
    
      <category term="CSRF" scheme="http://zongmansheng.club/tags/CSRF/"/>
    
  </entry>
  
  <entry>
    <title>一致性Hash</title>
    <link href="http://zongmansheng.club/2019/04/24/yi-zhi-xing-hash/"/>
    <id>http://zongmansheng.club/2019/04/24/yi-zhi-xing-hash/</id>
    <published>2019-04-24T13:17:59.000Z</published>
    <updated>2019-04-26T13:31:08.144Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一致性Hash"><a href="#一致性Hash" class="headerlink" title="一致性Hash"></a>一致性Hash</h1><blockquote><p>一致性Hash是分布式架构最重要最基础的东西，作为一个后端必须要了解，这里以分布式图片缓存服务器为例进行讲述。</p></blockquote><p><strong>原始问题：假设我们需要对一堆图片做缓存，缓存的图片放在了2台服务器上，当到来一个请求，应该如何知道请求的图片在哪台上面呢？</strong></p><blockquote><p>暴力遍历就不要去想了，否则缓存就没有意义了。一个自然的想法就是根据图片的名字做一个映射（Hash），将图片名字映射到0，1两个数字上面，例如有这样的映射函数：</p></blockquote><blockquote><p>f(图片名称) = md5(图片名称) % 2</p></blockquote><blockquote><p>md5是一个典型的哈希函数，会产生128bit的值，模2后只可能是0或1，那么我们就根据这个值把图片存入0、1两台服务器，当请求过来，根据图片名称计算出值，就可以知道图片缓存放在第几号服务器了：</p></blockquote><p><img src="/一致性Hash\001.jpg" alt="001"></p><blockquote><p>但假设现在我们图片太多了，需要再增加一台服务器分担压力，哈希函数必须更改成0、1、2映射，我们改为：</p></blockquote><blockquote><p>f(图片名称) = md5(图片名称) % 3</p></blockquote><blockquote><p>理论上讲，会有(N-1)/N的缓存会失效，其中N是服务器的数量，例如上述图片缓存，除了0图片、1图片，其余图片的存放位置都变了，失效的缓存有 2/3 * 6 = 4张图片：</p></blockquote><p><img src="/一致性Hash\002.jpg" alt="002"></p><p>减少图片服务器数量造成的后果亦是如此——在同一个时刻将会有大量缓存同时失效，称为“缓存雪崩”。失效了就会直接去后端服务器取，大量的请求直接透过缓存打到后端服务器，后端服务器极有可能承受不住压力而接连崩溃，最终造成整个系统瘫痪。</p><p><strong>所以出现进阶问题：当缓存服务器数量发生变化时，如何尽可能避免大量缓存同时失效？</strong></p><p>答案就是一致性Hash。</p><h4 id="一、一致性Hash原理"><a href="#一、一致性Hash原理" class="headerlink" title="一、一致性Hash原理"></a>一、一致性Hash原理</h4><h5 id="1、放置服务器"><a href="#1、放置服务器" class="headerlink" title="1、放置服务器"></a><strong>1、放置服务器</strong></h5><blockquote><p>我们将服务器像图片一样也进行哈希，服务器的“图片名称”一般就使用固定IP地址，Hash取模也不再是服务器数量，而是2^32，Hash的方法也不局限于md5，用一个抽象的函数表示：</p></blockquote><blockquote><p>f(服务器IP地址) = Hash(服务器IP地址) % 2^32</p></blockquote><blockquote><p>于是服务器被放置到了0~2^32-1某个数字对应的位置上去：</p></blockquote><p><img src="/一致性Hash\003.jpg" alt="003"></p><blockquote><p>为什么是2^32-1呢？因为第一次提出一致性Hash的论文是1997年发表的，那时候32位机器还是主流，2^32-1是最大的Integer。而现在64位早就普及了，完全可以将这个值扩大到2^64-1。</p></blockquote><h5 id="2、放置数据"><a href="#2、放置数据" class="headerlink" title="2、放置数据"></a><strong>2、放置数据</strong></h5><blockquote><p>我们将数据也按照相同的方式放到0~2^32-1的某个数字上去：</p></blockquote><blockquote><p>f(图片名称) = Hash(图片名称) % 2^32</p></blockquote><p><img src="//zongmansheng.club/2019/04/24/yi-zhi-xing-hash/004.jpg" alt="004"></p><h5 id="3、把数据放到服务器上"><a href="#3、把数据放到服务器上" class="headerlink" title="3、把数据放到服务器上"></a><strong>3、把数据放到服务器上</strong></h5><blockquote><p>对于每个数据，从映射的位置开始，顺时针行走，放置到碰到的第一个服务器上。例如3、230将会放到0号图片服务器，232将会放到1号图片服务器，4175556547将会放到2号图片服务器：</p></blockquote><p><img src="//zongmansheng.club/2019/04/24/yi-zhi-xing-hash/005.jpg" alt="005"></p><blockquote><p>这样一致性Hash就完成了。查找数据也是先映射、再顺时针行走找到第一台服务器。</p></blockquote><h4 id="二、一致性Hash如何缓解数据失效问题"><a href="#二、一致性Hash如何缓解数据失效问题" class="headerlink" title="二、一致性Hash如何缓解数据失效问题"></a>二、一致性Hash如何缓解数据失效问题</h4><blockquote><p>假设现在1号服务器崩溃，图片232找不到1号服务器，顺时针行走的第一台服务器是2号服务器，于是232的缓存位置发生了改变，变为了2号：</p></blockquote><p><img src="//zongmansheng.club/2019/04/24/yi-zhi-xing-hash/006.jpg" alt="006"></p><blockquote><p>而对于其他图片来说，缓存位置并没有发生变化，影响的数据量从（N-1）/ N 降为了 M，其中M是0号图片服务器到1号图片服务器之间的图片数量。需要重新获取的缓存数据量降低了，雪崩问题自然也就能够得到缓解。</p></blockquote><h4 id="三、Hash环偏斜和虚拟节点"><a href="#三、Hash环偏斜和虚拟节点" class="headerlink" title="三、Hash环偏斜和虚拟节点"></a>三、Hash环偏斜和虚拟节点</h4><blockquote><p>前面讨论得太理想了，实际的服务器分布和数据分布很可能是这样的：</p></blockquote><p><img src="//zongmansheng.club/2019/04/24/yi-zhi-xing-hash/007.jpg" alt="007"></p><blockquote><p>0、1、2三台服务器并没有均匀分布在环上，大量的图片数据都被放到了0号服务器上，而很少数据放到1、2号等其他图片服务器上，这种情况称之为Hash环偏斜。如果存放的是缓存则0号服务器崩溃就会引起缓存雪崩，如果存放的是数据则0号服务器就可能单点故障。</p></blockquote><blockquote><p>很自然可以想到，增加多台服务器就好了嘛。我们在Hash环上生成0、1、2三台服务器的虚拟节点：</p></blockquote><p><img src="//zongmansheng.club/2019/04/24/yi-zhi-xing-hash/008.jpg" alt="008"></p><blockquote><p>具体的做法是，在服务器IP后面增加编号，每一台服务器产生多个Hash值，就能放置在0~2^32-1的多个位置上了。这样一来，顺时针行走能找到不同的服务器概率将会大大提高，避免了偏斜问题。虚拟的服务器节点数越多，偏斜出现的概率就越低。通常都需要设置32或以上的虚拟节点数目，我见过甚至有设置500的。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一致性Hash&quot;&gt;&lt;a href=&quot;#一致性Hash&quot; class=&quot;headerlink&quot; title=&quot;一致性Hash&quot;&gt;&lt;/a&gt;一致性Hash&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;一致性Hash是分布式架构最重要最基础的东西，作为一个后端必须要了解，这里
      
    
    </summary>
    
      <category term="后端" scheme="http://zongmansheng.club/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="算法" scheme="http://zongmansheng.club/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Hash" scheme="http://zongmansheng.club/tags/Hash/"/>
    
  </entry>
  
  <entry>
    <title>三次握手和四次挥手</title>
    <link href="http://zongmansheng.club/2019/04/20/san-ci-wo-shou-he-si-ci-hui-shou/"/>
    <id>http://zongmansheng.club/2019/04/20/san-ci-wo-shou-he-si-ci-hui-shou/</id>
    <published>2019-04-20T12:31:54.000Z</published>
    <updated>2019-04-20T13:04:25.221Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三次握手和四次挥手"><a href="#三次握手和四次挥手" class="headerlink" title="三次握手和四次挥手"></a>三次握手和四次挥手</h1><h4 id="常用的熟知端口号"><a href="#常用的熟知端口号" class="headerlink" title="常用的熟知端口号"></a>常用的熟知端口号</h4><p><img src="//zongmansheng.club/2019/04/20/san-ci-wo-shou-he-si-ci-hui-shou/004.jpg" alt="004"></p><h4 id="TCP的概述"><a href="#TCP的概述" class="headerlink" title="TCP的概述"></a>TCP的概述</h4><pre><code>TCP把连接作为最基本的对象，每一条TCP连接都有两个端点，这种断点我们叫作套接字（socket），它的定义为端口号拼接到IP地址即构成了套接字，例如，若IP地址为192.3.4.16 而端口号为80，那么得到的套接字为192.3.4.16:80。</code></pre><h4 id="TCP报文首部"><a href="#TCP报文首部" class="headerlink" title="TCP报文首部"></a>TCP报文首部</h4><pre><code>1、源端口和目的端口，各占2个字节，分别写入源端口和目的端口；2、序号，占4个字节，TCP连接中传送的字节流中的每个字节都按顺序编号。例如，一段报文的序号字段值是 301 ，而携带的数据共有100字段，显然下一个报文段（如果还有的话）的数据序号应该从401开始；3、确认号，占4个字节，是期望收到对方下一个报文的第一个数据字节的序号。例如，B收到了A发送过来的报文，其序列号字段是501，而数据长度是200字节，这表明B正确的收到了A发送的到序号700为止的数据。因此，B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701；4、数据偏移，占4位，它指出TCP报文的数据距离TCP报文段的起始处有多远；5、保留，占6位，保留今后使用，但目前应都位0；6、紧急URG，当URG=1，表明紧急指针字段有效。告诉系统此报文段中有紧急数据；7、确认ACK，仅当ACK=1时，确认号字段才有效。TCP规定，在连接建立后所有报文的传输都必须把ACK置1；8、推送PSH，当两个应用进程进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应，这时候就将PSH=1；9、复位RST，当RST=1，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立连接；10、同步SYN，在连接建立时用来同步序号。当SYN=1，ACK=0，表明是连接请求报文，若同意连接，则响应报文中应该使SYN=1，ACK=1；11、终止FIN，用来释放连接。当FIN=1，表明此报文的发送方的数据已经发送完毕，并且要求释放；12、窗口，占2字节，指的是通知接收方，发送本报文你需要有多大的空间来接受；13、检验和，占2字节，校验首部和数据这两部分；14、紧急指针，占2字节，指出本报文段中的紧急数据的字节数；15、选项，长度可变，定义一些其他的可选的参数。</code></pre><pre><code>为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。漫画图解：图片来源：《图解HTTP》</code></pre><p><img src="//zongmansheng.club/2019/04/20/san-ci-wo-shou-he-si-ci-hui-shou/001.jpg" alt="001"></p><p>简单示意图：</p><p><img src="//zongmansheng.club/2019/04/20/san-ci-wo-shou-he-si-ci-hui-shou/002.jpg" alt="002"></p><p>动图：</p><p><img src="//zongmansheng.club/2019/04/20/san-ci-wo-shou-he-si-ci-hui-shou/005.gif" alt="005"></p><pre><code>- 客户端–发送带有 SYN 标志的数据包–一次握手–服务端- 服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端- 客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端</code></pre><pre><code>最开始的时候客户端和服务器都是处于CLOSED状态。主动打开连接的为客户端，被动打开连接的是服务器</code></pre><pre><code>1、TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态；2、TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。3、TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。4、TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。5、当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。</code></pre><p><img src="//zongmansheng.club/2019/04/20/san-ci-wo-shou-he-si-ci-hui-shou/006.png" alt="006"></p><h4 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h4><pre><code>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。第一次握手：Client 什么都不能确认；Server 确认了对方发送正常第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己接收正常，对方发送正常第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送接收正常所以三次握手就能确认双发收发功能都正常，缺一不可。</code></pre><h4 id="为什么要传回-SYN"><a href="#为什么要传回-SYN" class="headerlink" title="为什么要传回 SYN"></a>为什么要传回 SYN</h4><pre><code>接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。SYN 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement[汉译：确认字符 ,在数据通信传输中，接收站发给发送站的一种传输控制字符。它表示确认发来的数据已经接受无误。 ]）消息响应。这样在客户机和服务器之间才能建立起可靠的TCP连接，数据才可以在客户机和服务器之间传递。</code></pre><h4 id="传了-SYN-为啥还要传-ACK"><a href="#传了-SYN-为啥还要传-ACK" class="headerlink" title="传了 SYN,为啥还要传 ACK"></a>传了 SYN,为啥还要传 ACK</h4><pre><code>双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证。</code></pre><p><img src="//zongmansheng.club/2019/04/20/san-ci-wo-shou-he-si-ci-hui-shou/003.jpg" alt="003"></p><pre><code>断开一个 TCP 连接则需要“四次挥手”：- 客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送- 服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号- 服务器-关闭与客户端的连接，发送一个FIN给客户端- 客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1</code></pre><h4 id="TCP连接的释放（四次挥手）"><a href="#TCP连接的释放（四次挥手）" class="headerlink" title="TCP连接的释放（四次挥手）"></a>TCP连接的释放（四次挥手）</h4><p><img src="//zongmansheng.club/2019/04/20/san-ci-wo-shou-he-si-ci-hui-shou/007.gif" alt="007"></p><pre><code>数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于ESTABLISHED状态，然后客户端主动关闭，服务器被动关闭。</code></pre><pre><code>1、客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。2、服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。3、客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。4、服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。5、客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗ *∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。6、服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</code></pre><p><img src="//zongmansheng.club/2019/04/20/san-ci-wo-shou-he-si-ci-hui-shou/008.png" alt="008"></p><h4 id="为什么客户端最后还要等待2MSL？"><a href="#为什么客户端最后还要等待2MSL？" class="headerlink" title="为什么客户端最后还要等待2MSL？"></a>为什么客户端最后还要等待2MSL？</h4><pre><code>MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</code></pre><h4 id="为什么建立连接是三次握手，关闭连接确是四次挥手呢？"><a href="#为什么建立连接是三次握手，关闭连接确是四次挥手呢？" class="headerlink" title="为什么建立连接是三次握手，关闭连接确是四次挥手呢？"></a>为什么建立连接是三次握手，关闭连接确是四次挥手呢？</h4><pre><code>建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。</code></pre><h4 id="为什么要四次挥手"><a href="#为什么要四次挥手" class="headerlink" title="为什么要四次挥手"></a>为什么要四次挥手</h4><pre><code>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。</code></pre><h4 id="如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办？</h4><pre><code>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;三次握手和四次挥手&quot;&gt;&lt;a href=&quot;#三次握手和四次挥手&quot; class=&quot;headerlink&quot; title=&quot;三次握手和四次挥手&quot;&gt;&lt;/a&gt;三次握手和四次挥手&lt;/h1&gt;&lt;h4 id=&quot;常用的熟知端口号&quot;&gt;&lt;a href=&quot;#常用的熟知端口号&quot; class=&quot;
      
    
    </summary>
    
      <category term="计算机网络" scheme="http://zongmansheng.club/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="TCP" scheme="http://zongmansheng.club/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>原型模式</title>
    <link href="http://zongmansheng.club/2019/04/19/yuan-xing-mo-shi/"/>
    <id>http://zongmansheng.club/2019/04/19/yuan-xing-mo-shi/</id>
    <published>2019-04-19T14:07:51.000Z</published>
    <updated>2019-04-20T13:56:23.260Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><h4 id="一-原型模式介绍"><a href="#一-原型模式介绍" class="headerlink" title="一 原型模式介绍"></a>一 原型模式介绍</h4><pre><code>在面向对象系统中，使用原型模式来复制一个对象自身，从而克隆出多个与原型对象一模一样的对象。另外在软件系统中，有些对象的创建过程较为复杂，而且有时候需要频繁创建，原型模式通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的办法创建出更多同类型的对象，这就是原型模式的意图所在。</code></pre><p><img src="//zongmansheng.club/2019/04/19/yuan-xing-mo-shi/001.jpg" alt="001"></p><h5 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h5><p>GOF给出的原型模式定义如下：</p><pre class=" language-java"><code class="language-java">Specify the kind of objects to create using a prototypical instance<span class="token punctuation">,</span> and create <span class="token keyword">new</span> <span class="token class-name">objects</span> by copying <span class="token keyword">this</span> prototype<span class="token punctuation">.</span> （使用原型实例指定将要创建的对象类型，通过复制这个实例创建新的对象。）</code></pre><h5 id="1-2-原型模式适用场景"><a href="#1-2-原型模式适用场景" class="headerlink" title="1.2 原型模式适用场景"></a>1.2 原型模式适用场景</h5><pre><code>我们现在一般会使用new关键字指定类名生成类的实例（PS：我们以前使用java.lang.Cloneable的一个很大原因是使用new创建对象的速度相对来说会慢一些，随着JVM性能的提升，new的速度和Object的clone（）方法的速度差不多了。）。使用new关键字创建类的时候必须指定类名，但是在开发过程中也会有“在不指定类名的前提下生成实例”的需求。例如，在下面这些情况下，就需要根据现有的实例来生成新的实例。1) 对象种类繁多，无法将他们整合到一个类的时候；2) 难以根据类生成实例时；3) 想解耦框架与生成的实例时。如果想要让生成实例的框架不再依赖于具体的类，这时，不能指定类名来生成实例，而要事先“注册”一个“原型”实例，然后通过复制该实例来生成新的实例。</code></pre><h5 id="1-3-模式分析"><a href="#1-3-模式分析" class="headerlink" title="1.3 模式分析"></a>1.3 模式分析</h5><pre><code>在原型模式结构中定义了一个抽象原型类，所有的Java类都继承自java.lang.Object，而Object类提供一个clone()方法，可以将一个Java对象复制一份。因此在Java中可以直接使用Object提供的clone()方法来实现对象的克隆，Java语言中的原型模式实现很简单。能够实现克隆的Java类必须实现一个标识接口Cloneable，表示这个Java类支持复制。如果一个类没有实现这个接口但是调用了clone()方法，Java编译器将抛出一个CloneNotSupportedException异常。注意： `java.lang.Cloneable 只是起到告诉程序可以调用clone方法的作用，它本身并没有定义任何方法。在使用原型模式克隆对象时，根据其成员对象是否也克隆，原型模式可以分为两种形式：深克隆 和 浅克隆 。</code></pre><h5 id="1-4-模式优缺点分析"><a href="#1-4-模式优缺点分析" class="headerlink" title="1.4 模式优缺点分析"></a>1.4 模式优缺点分析</h5><p>原型模式的优点：</p><pre><code>1、当创建新的对象实例较为复杂时，使用原型模式可以简化对象的创建过程，通过一个已有实例可以提高新实例的创建效率。2、可以动态增加或减少产品类。3、原型模式提供了简化的创建结构。4、可以使用深克隆的方式保存对象的状态。</code></pre><p>原型模式的缺点：</p><pre><code>1、需要为每一个类配备一个克隆方法，而且这个克隆方法需要对类的功能进行通盘考虑，这对全新的类来说不是很难，但对已有的类进行改造时，不一定是件容易的事，必须修改其源代码，违背了“开闭原则”。2、在实现深克隆时需要编写较为复杂的代码。</code></pre><h4 id="二-示例程序"><a href="#二-示例程序" class="headerlink" title="二 示例程序"></a>二 示例程序</h4><p>下面示例程序的作用是将字符串放入方框中显示出来或者是加了下划线显示出来。</p><p>类和接口一览表：</p><p><img src="//zongmansheng.club/2019/04/19/yuan-xing-mo-shi/002.jpg" alt="002"></p><p>示例程序类图：</p><p><img src="//zongmansheng.club/2019/04/19/yuan-xing-mo-shi/003.jpg" alt="003"></p><h5 id="2-1-Product接口-（Prototype）"><a href="#2-1-Product接口-（Prototype）" class="headerlink" title="2.1 Product接口 （Prototype）"></a>2.1 Product接口 （Prototype）</h5><pre><code>    Product接口是复制功能接口，该接口继承了java.lang.Cloneable(只有实现了该接口的类的实例才可以调用clone()方法复制实例,否则会抛出异常).     另外需要注意：`java.lang.Cloneable 只是起到告诉程序可以调用clone方法的作用，它本身并没有定义任何方法。</code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @author ZongMan */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Product</span> <span class="token keyword">extends</span> <span class="token class-name">Cloneable</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//use方法是用于“使用”的方法，具体怎么“使用”，则被交给子类去实现</span>    <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">use</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//creatClone方法是用于复制实例的方法</span>    <span class="token keyword">abstract</span> Product <span class="token function">creatClone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h5 id="2-2-Manager类（Client）"><a href="#2-2-Manager类（Client）" class="headerlink" title="2.2 Manager类（Client）"></a>2.2 Manager类（Client）</h5><pre><code>Manager类使用Product接口来复制实例。Product接口以及Manager类的代码完全没有出现在MessageBox类和UnderlinePen类的名字，因此这意味着我们可以独立地修改Product接口以及Manager类，不受MessageBox类和UnderlinePen类的影响。这是非常重要的，因为 一旦在类中使用到了别的类名，就意味着该类与其他类紧密的地耦合在了一起 。在Manager类中，并没有写明具体的类名， 仅仅使用了Product这个接口名。也就是说，Product接口成为了连接Manager类与其他具体类之间的桥梁。</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>HashMap<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author ZongMan */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Manager</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//保存实例的“名字”和“实例”之间的对应关系</span>    <span class="token keyword">private</span> HashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Product<span class="token operator">></span> showcase <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*    register方法将接收到的一组“名字”和“Product接口”注册到showcase中。    这里Product是实现Product接口的实例，具体还未确定     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">register</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> Product product<span class="token punctuation">)</span> <span class="token punctuation">{</span>        showcase<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> product<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> Product <span class="token function">create</span><span class="token punctuation">(</span>String productname<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Product p <span class="token operator">=</span> showcase<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>productname<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> p<span class="token punctuation">.</span><span class="token function">creatClone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="2-3-MessageBox类（ConcreteProtorype）"><a href="#2-3-MessageBox类（ConcreteProtorype）" class="headerlink" title="2.3 MessageBox类（ConcreteProtorype）"></a>2.3 MessageBox类（ConcreteProtorype）</h5><p>装饰方框样式的具体原型，实现了Product接口，实现复制现有实例并生成新实例的方法。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @author ZongMan */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MessageBox</span> <span class="token keyword">implements</span> <span class="token class-name">Product</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//保存的是装饰方框使用的字符样式</span>    <span class="token keyword">private</span> <span class="token keyword">char</span> decochar<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">MessageBox</span><span class="token punctuation">(</span><span class="token keyword">char</span> decochar<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>decochar <span class="token operator">=</span> decochar<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">use</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> length <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"--------->"</span> <span class="token operator">+</span> decochar<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>decochar <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> str <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> decochar<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>decochar<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 该方法用于复制自己     * @return     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Product <span class="token function">creatClone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Product p <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            p <span class="token operator">=</span> <span class="token punctuation">(</span>Product<span class="token punctuation">)</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">CloneNotSupportedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> p<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>只有类自己（或是它的子类）能够调用Java语言中定义的clone方法。当其他类要求复制实例时，必须先调用createClone这样的方法，然后在该方法内部在调用clone方法。</code></pre><h5 id="2-4-UnderlinePen类（ConcreteProtorype）"><a href="#2-4-UnderlinePen类（ConcreteProtorype）" class="headerlink" title="2.4 UnderlinePen类（ConcreteProtorype）"></a>2.4 UnderlinePen类（ConcreteProtorype）</h5><pre><code>    下划线样式的具体原型，实现了Product接口，用于实现复制现有实例并生成新实例的方法。UnderlinePen类的实现几乎和MessageBox类一样，不同的可能只是use方法的实现。</code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @author ZongMan */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UnderlinePen</span> <span class="token keyword">implements</span> <span class="token class-name">Product</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">char</span> ulchar<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">UnderlinePen</span><span class="token punctuation">(</span><span class="token keyword">char</span> ulchar<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>ulchar <span class="token operator">=</span> ulchar<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">use</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> length <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"\""</span> <span class="token operator">+</span> str <span class="token operator">+</span> <span class="token string">"\""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>ulchar<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Product <span class="token function">creatClone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Product p <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            p <span class="token operator">=</span> <span class="token punctuation">(</span>Product<span class="token punctuation">)</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">CloneNotSupportedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> p<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span></code></pre><h5 id="2-5-Main类"><a href="#2-5-Main类" class="headerlink" title="2.5 Main类"></a>2.5 Main类</h5><pre><code>Main类首先生成Manager实例。接着，在Manager实例中通过`register方法注册了UnderlinePen类的实例（带名字）和MessageBox类的实例（带名字）。</code></pre><pre><code>package clone;/** * @author ZongMan */public class Main {    public static void main(String[] args) {        Manager manager = new Manager();        UnderlinePen underlinePen=new UnderlinePen(&#39;~&#39;);        MessageBox mbox=new MessageBox(&#39;*&#39;);        MessageBox sbox=new MessageBox(&#39;#&#39;);        manager.register(&quot;Strong message&quot;, underlinePen);        manager.register(&quot;Waring Box&quot;, mbox);        manager.register(&quot;Slash Box&quot;, sbox);        Product p1=manager.create(&quot;Strong message&quot;);        p1.use(&quot;hello world&quot;);        Product p2=manager.create(&quot;Waring Box&quot;);        p2.use(&quot;hello world&quot;);        Product p3=manager.create(&quot;Slash Box&quot;);        p3.use(&quot;hello world&quot;);    }}</code></pre><p>运行结果：</p><p><img src="//zongmansheng.club/2019/04/19/yuan-xing-mo-shi/004.jpg" alt="004"></p><h4 id="三-原型模式的角色分析"><a href="#三-原型模式的角色分析" class="headerlink" title="三 原型模式的角色分析"></a>三 原型模式的角色分析</h4><h5 id="3-1-Prototype（抽象原型类）"><a href="#3-1-Prototype（抽象原型类）" class="headerlink" title="3.1 Prototype（抽象原型类）"></a>3.1 Prototype（抽象原型类）</h5><pre><code>Product角色负责定义用于复制现有实例来生成新实例的方法。在示例程序中的Product接口就是该角色。</code></pre><h5 id="3-2-ConcretePrototype（具体原型类）"><a href="#3-2-ConcretePrototype（具体原型类）" class="headerlink" title="3.2 ConcretePrototype（具体原型类）"></a>3.2 ConcretePrototype（具体原型类）</h5><pre><code>ConcretePrototype角色负责实现复制现有实例并生成新实例的方法。在示例程序中，MessageBox和UnderlinePen都是该角色。</code></pre><h5 id="3-3-Client（客户类-使用者）"><a href="#3-3-Client（客户类-使用者）" class="headerlink" title="3.3 Client（客户类/使用者）"></a>3.3 Client（客户类/使用者）</h5><pre><code>Client角色负责使用复制实例的方法生成新的实例。在示例程序中，Manager类扮演的就是该角色。</code></pre><p>Prototype模式的类图：</p><p><img src="//zongmansheng.club/2019/04/19/yuan-xing-mo-shi/005.jpg" alt="005"></p><h4 id="四-原型模式的实际应用案例"><a href="#四-原型模式的实际应用案例" class="headerlink" title="四 原型模式的实际应用案例"></a>四 原型模式的实际应用案例</h4><pre><code>(1) 原型模式应用于很多软件中，如果每次创建一个对象要花大量时间，原型模式是最好的解决方案。很多软件提供的复制(Ctrl + C)和粘贴(Ctrl + V)操作就是原型模式的应用，复制得到的对象与原型对象是两个类型相同但内存地址不同的对象，通过原型模式可以大大提高对象的创建效率。(2) 在Struts2中为了保证线程的安全性，Action对象的创建使用了原型模式，访问一个已经存在的`Action对象时将通过克隆的方式创建出一个新的对象，从而保证其中定义的变量无须进行加锁实现同步，每一个Action中都有自己的成员变量，避免Struts1因使用单例模式而导致的并发和同步问题。(3) 在Spring中，用户也可以采用原型模式来创建新的bean实例，从而实现每次获取的是通过克隆生成的新实例，对其进行修改时对原有实例对象不造成任何影响。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原型模式&quot;&gt;&lt;a href=&quot;#原型模式&quot; class=&quot;headerlink&quot; title=&quot;原型模式&quot;&gt;&lt;/a&gt;原型模式&lt;/h1&gt;&lt;h4 id=&quot;一-原型模式介绍&quot;&gt;&lt;a href=&quot;#一-原型模式介绍&quot; class=&quot;headerlink&quot; title=&quot;一
      
    
    </summary>
    
      <category term="设计模式" scheme="http://zongmansheng.club/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="原型，复制" scheme="http://zongmansheng.club/tags/%E5%8E%9F%E5%9E%8B%EF%BC%8C%E5%A4%8D%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode</title>
    <link href="http://zongmansheng.club/2019/04/18/leetcode/"/>
    <id>http://zongmansheng.club/2019/04/18/leetcode/</id>
    <published>2019-04-18T14:10:48.000Z</published>
    <updated>2019-04-18T14:16:54.904Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode上的算法题"><a href="#LeetCode上的算法题" class="headerlink" title="LeetCode上的算法题"></a>LeetCode上的算法题</h1><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><pre><code>/** * @author ZongMan * @version 1.0 * @date 2019/4/18 0018 8:31 * 在给定的整数数组中，总有一个最大的元素。查找数组中的最大元素是否至少是数组中每个其他数字的两倍。 * 如果是，则返回最大元素的索引，否则返回-1。例如： * 输入：nums = [3,6,1,0] * 输出：1 * 说明：6是最大的整数，对于数组x中的每个其他数字，6是x的两倍多。 值6的索引是1，所以我们返回1。 * 输入：nums = [1,2,3,4] * 输出：-1 * 说明：4至少不是3的值的两倍，所以我们返回-1。 */</code></pre><h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo01</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">dominantIndex</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"----------------------------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">dominantIndex2</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 题目的要求是返回最大数的索引，所以需要先将最大数找出来，并记录下其索引。     * 然后在次遍历数组中的元素，将最大数之外的其他数都乘以2和最大数比较(在此处我是使用位移处理)，     * 如果大于就返回-1，如果其他元素都满足条件，就返回之前记录的最大数的索引。     *     * @param nums 数组     * @return 相对应的结果     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">dominantIndex</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> max<span class="token punctuation">)</span> <span class="token punctuation">{</span>                max <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                index <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> max <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span> <span class="token operator">></span> max<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> index<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 我们还可以只使用一次循环来解决。并非需要使用每一个元素乘以2后再去和最大元素比较，     * 只需要用第二大的数去比较就行，如果第二大的数不能满足条件，就可以直接做判断了。     * 比如[2,3,4]，3乘以2等于6大于4，不符合题目要求，就不需要比较2了。     * @param nums 数组     * @return 对应结果     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">dominantIndex2</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> second <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> max<span class="token punctuation">)</span> <span class="token punctuation">{</span>                second <span class="token operator">=</span> max<span class="token punctuation">;</span>                max <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                index <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> second<span class="token punctuation">)</span> <span class="token punctuation">{</span>                second <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> second <span class="token operator">&lt;&lt;</span> <span class="token number">1</span> <span class="token operator">&lt;=</span> max <span class="token operator">?</span> index <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;LeetCode上的算法题&quot;&gt;&lt;a href=&quot;#LeetCode上的算法题&quot; class=&quot;headerlink&quot; title=&quot;LeetCode上的算法题&quot;&gt;&lt;/a&gt;LeetCode上的算法题&lt;/h1&gt;&lt;h4 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述
      
    
    </summary>
    
      <category term="每日算法" scheme="http://zongmansheng.club/categories/%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="http://zongmansheng.club/tags/LeetCode/"/>
    
      <category term="算法" scheme="http://zongmansheng.club/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>DNS劫持投毒解析</title>
    <link href="http://zongmansheng.club/2019/04/17/dns-jie-chi-tou-du-jie-xi/"/>
    <id>http://zongmansheng.club/2019/04/17/dns-jie-chi-tou-du-jie-xi/</id>
    <published>2019-04-17T05:08:59.000Z</published>
    <updated>2019-04-17T14:01:39.802Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DNS劫持投毒解析"><a href="#DNS劫持投毒解析" class="headerlink" title="DNS劫持投毒解析"></a>DNS劫持投毒解析</h1><p>本文以第一人称来讲述：</p><h4 id="一、什么是URL和IP"><a href="#一、什么是URL和IP" class="headerlink" title="一、什么是URL和IP"></a>一、什么是URL和IP</h4><pre><code>    我的冒险，要从一张“羊皮卷”说起。那天，浏览器大叔神秘兮兮招呼我过去，告诉我CPU下达了一个命令：派遣使者访问外邦。而我是大叔最得力的门生，也是这类任务最合适的人选。大叔为我准备了一张羊皮卷，上面记录了我这次冒险需要用到的必要信息。当仁不让地，我接过了它，即刻启程。我缓缓展开羊皮卷，第一行赫然写着：URL: https://mail.google.com    什么是“URL”？我在脑中快速回忆着，对了！URL即 Uniform Resource Locator的缩写，翻译成中文便是“统一资源定位符”。因为互联网世界存在着不计其数的资源，每一处资源都需要有一个标记来定位它，正如人类城市中的门牌号。    有人可能会认为，既然有了门牌号，找到指定地点不是轻而易举吗？朋友们，我也希望如此，但现实往往没有这么简单。    即使有了URL，恕我愚笨，我还是无法直接理解它所指向的目的地。因为这是人类的语言，我无法翻译解读。（其实是人类太笨了，记不住IP地址，需要用方便记忆的域名来代替）    对我来说，IP地址才是唯一的坐标。什么是IP？IP即Internet Protocol的缩写，中文译为“互联网协议”，一个如雷贯耳的名字，互联网的基石之一，一切依赖互联网通信的软件都得遵循这个协议。那么，如何才能将域名转换为IP地址呢？    浏览器大叔在平日工作之余，十分细心，他将用户访问过的站点整理了一份“域名-IP对应清单”。假如是一个已被记录的IP地址，那么他会直接告诉我，我可以立即向着目标IP地址出发，这就是浏览器缓存的作用。    假如用户输入的URL不在浏览器的记录范围之内，那么操作系统会查找一个名为“hosts”的文件。它是一份文本，记录了域名和IP地址的映射。如果“hosts”能够告诉我目标IP地址，那也能节省我不少工夫。这就是系统缓存。此外，还有路由器缓存，相信不用我多介绍了，即保存在路由器中的域名-IP映射。    这些缓存都能有效帮助我以最快的速度找到相应的IP地址。但是，互联网世界日新月异，各种资源层出不穷。在很多情况下，用户会想要访问一个全新的、任何缓存都没有记录过的域名。    为此，人类专门设计了DNS。在这次任务中，我的第一站，就是赶往DNS。为了更短的响应时间与更好的用户体验，我快马加鞭。</code></pre><h4 id="二、关于DNS劫持的记忆"><a href="#二、关于DNS劫持的记忆" class="headerlink" title="二、关于DNS劫持的记忆"></a>二、关于DNS劫持的记忆</h4><h5 id="DNS是什么？"><a href="#DNS是什么？" class="headerlink" title="DNS是什么？"></a>DNS是什么？</h5><pre><code>全称Domain Name System，是一个将域名和IP相互映射的分布式数据库。    全球有很多家DNS服务中心，假如你关心过你的计算机，你会发现，在你的网卡上，有着一项“DNS服务器”的配置项，它设定了我将要抵达的目的地。</code></pre><p><img src="//zongmansheng.club/2019/04/17/dns-jie-chi-tou-du-jie-xi/001.png" alt="001"></p><pre><code>一转眼的工夫，我来到了114.114.114.114DNS中心。    这个地方我来过很多次，表面上风平浪静，实则暗流涌动。我小心翼翼地来到办事大厅，不禁想起了我第一次被DNS劫持的经历。那天，我来到办事窗口，柜员热情地接待了我。    “先生，请问你想要查询哪个地址？”当时我还是一位新晋的网络请求，涉世尚浅，不知晓一些不可说的条例，于是毫不避讳地回答：“你好，我要去大名鼎鼎的mail.google.com！”    柜员的表情一下子凝固了，他上下打量了我一番，然后硬挤出一丝微笑，“好的先生，请稍等。”说完，他便向旁边的同事使了个眼色。我正纳闷呢，突然两边窜出身材魁梧的警卫，架着我强行往一处拖拽。我这才意识到大事不妙，“这是怎么回事？！你们凭什么劫持我？”我发疯了一般嘶吼着。    “你好，根据本ISP（电信运营商）颁布的条例，世界上不存在你所说的站点，现怀疑你是一个不合规的网络请求，将把你转发至baidu.com的IP地址。你有权保持沉默！”警卫冷漠地望着我。我知道，现在无论如何解释、挣扎都没有用了，只怪自己太年轻。无奈，我只好乖乖就范。</code></pre><p><img src="//zongmansheng.club/2019/04/17/dns-jie-chi-tou-du-jie-xi/002.png" alt="002"></p><pre><code>    还好当时正在使用计算机的用户有一些网络知识，当他发现自己输入的是google，返回的是baidu的页面时，并没有怪罪于我，大概是他心中已经猜到了原因。于是他将网卡的DNS配置为：8.8.8.8，这是一个国际上“不存在”的公司提供的DNS服务中心。仅仅这样就能畅通无阻地访问互联网了吗？经历了被DNS劫持，我依然不敢放松。</code></pre><h4 id="三、我遇到过DNS投毒"><a href="#三、我遇到过DNS投毒" class="headerlink" title="三、我遇到过DNS投毒"></a>三、我遇到过DNS投毒</h4><pre><code>还未休息片刻，浏览器大叔再一次地给我分配了任务：继续尝试请求mail.google.com的资源。    人类出国要坐飞机，要办护照。我们网络请求也是这样，全国只有在几个主要城市才会部署国际出口，所有访问境外资源的网络请求，都得经过这儿接受检查。与上次不同，因为这次我要访问的DNS服务器位于海外，所以我首先来到了大中华局域网的上海国际出口。我一路奔波到上海真的是又累又乏，正当我火急火燎地准备过安检，通道附近有一位穿着制服的小伙迎了上来。    还没等我开口，他热情地迎了上来：“远道而来的朋友，一定是十分疲惫了吧？天气这么热，先喝杯水吧！”我悄悄地打量着他，看他的打扮应该是一位服务人员。    “国际出口就是不一样啊，服务真到位！”由于确实是太渴了，我放松了警惕。“啊，真清凉，谢……”我一边感叹着，一边接过了小伙递给我的水。可当我第二个“谢”字还没说出口，立即感到一阵头晕目眩。    “不好！遇上了黑客，这是DNS投毒！”我的视线渐渐模糊，小伙的微笑也渐渐似乎变成了狞笑。我尽力搜索着脑海中和这一切有关的知识，想要知道寻求的办法。</code></pre><p><img src="//zongmansheng.club/2019/04/17/dns-jie-chi-tou-du-jie-xi/003.png" alt="003"></p><pre><code> DNS投毒，英文叫DNS cache poisoning，也叫做DNS污染。从客户端向DNS服务器发出查询IP的请求，到响应返回到客户端的这段时间里，如果有黑客或者其他一些不可说的设施伪造返回了一个错误的DNS应答，那么用户将不能访问到真正的资源。想到这里，我已经明显感觉难以控制自己的身体了，眼前一黑，就什么都不知道了。</code></pre><h4 id="四、DNS正常解析"><a href="#四、DNS正常解析" class="headerlink" title="四、DNS正常解析"></a>四、DNS正常解析</h4><pre><code>以前发生过的险情历历在目，如今想起来，我依旧心有余悸。这次，为了确保万无一失，我打起了十二分精神。这次，我已经顺利来到8.8.8.8 DNS服务中心。“你好亲，有什么可以帮到您的嘛”办事窗口内传来了软妹子的声音。“我想查询域名mail.google.com的IP地址。”我试探性地问，依然不敢松懈。“好的呢亲，这边通过树状检索，在顶级域名com下，查询到google目录，在google目录下查询到mail,IP地址是xx.xxx.xx.xx呢。”</code></pre><p><img src="//zongmansheng.club/2019/04/17/dns-jie-chi-tou-du-jie-xi/004.png" alt="004"></p><pre><code>    我松了口气，谢天谢地，终于拿到了结果。可我知道作为一次完整的网络请求，这刚刚开始，这才是万里长征第一步，我得赶紧将这个解析结果带回去，等会还得马不停蹄往返三次建立连接。</code></pre><p><img src="//zongmansheng.club/2019/04/17/dns-jie-chi-tou-du-jie-xi/005.png" alt="005"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DNS劫持投毒解析&quot;&gt;&lt;a href=&quot;#DNS劫持投毒解析&quot; class=&quot;headerlink&quot; title=&quot;DNS劫持投毒解析&quot;&gt;&lt;/a&gt;DNS劫持投毒解析&lt;/h1&gt;&lt;p&gt;本文以第一人称来讲述：&lt;/p&gt;
&lt;h4 id=&quot;一、什么是URL和IP&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="进阶" scheme="http://zongmansheng.club/categories/%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="DNS，劫持，投毒，解析" scheme="http://zongmansheng.club/tags/DNS%EF%BC%8C%E5%8A%AB%E6%8C%81%EF%BC%8C%E6%8A%95%E6%AF%92%EF%BC%8C%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap</title>
    <link href="http://zongmansheng.club/2019/04/16/concurrenthashmap/"/>
    <id>http://zongmansheng.club/2019/04/16/concurrenthashmap/</id>
    <published>2019-04-16T00:42:45.000Z</published>
    <updated>2019-04-17T14:12:53.084Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><pre><code>JDK8 对ConcurrentHashMap 进行了脱胎换骨式的改造，使用了大量的lock-free 技术来减轻因锁的竞争而对性能造成的影响。ConcurrentHashMap 被Segment 分成了很多小区，Segment 就相当于小区保安，HashEntry 列表相当于小区业主，小区保安通过加锁的方式，保证每个Segment 内都不发生冲突。</code></pre><p><img src="//zongmansheng.club/2019/04/16/concurrenthashmap/001.png" alt="001"></p><pre><code>通过分析Hashtable就知道，synchronized是针对整张Hash表的，即每次锁住整张表让线程独占，ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术。它使用了多个锁来控制对hash表的不同部分进行的修改。ConcurrentHashMap内部使用段(Segment)来表示这些不同的部分，每个段其实就是一个小的hash table，它们有自己的锁。只要多个修改操作发生在不同的段上，它们就可以并发进行。有些方法需要跨段，比如size()和containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁。这里“按顺序”是很重要的，否则极有可能出现死锁，在ConcurrentHashMap内部，段数组是final的，并且其成员变量实际上也是final的，但是，仅仅是将数组声明为final的并不保证数组成员也是final的，这需要实现上的保证。这可以确保不会出现死锁，因为获得锁的顺序是固定的。</code></pre><pre><code>数据存储结构分为2种：            链表            红黑树</code></pre><pre><code>当某个槽内的元素个数增加到超过8个，且table的容量大于或者等于64时，由链表转为红黑树；当某个槽内的元素个数减少到6个时，由红黑树重新转回链表。</code></pre><pre><code>table 扩容：当table需要进行扩容时，依次遍历当前table 中的每一个槽位，如果不为null，则需要把其中所有的元素根据 hash 值放入扩容后的 nextTable 中，而元table的槽内会放置一个 ForwardingNode 节点。此节点会把 find() 请求转发到扩容后的 nextTable 上。而执行 put() 方法的线程，如果碰到此节点，也会协助进行迁移。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ConcurrentHashMap&quot;&gt;&lt;a href=&quot;#ConcurrentHashMap&quot; class=&quot;headerlink&quot; title=&quot;ConcurrentHashMap&quot;&gt;&lt;/a&gt;ConcurrentHashMap&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;JD
      
    
    </summary>
    
      <category term="基础底层" scheme="http://zongmansheng.club/categories/%E5%9F%BA%E7%A1%80%E5%BA%95%E5%B1%82/"/>
    
    
      <category term="ConcurrentHashMap" scheme="http://zongmansheng.club/tags/ConcurrentHashMap/"/>
    
      <category term="HashMap" scheme="http://zongmansheng.club/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>sort排序原理</title>
    <link href="http://zongmansheng.club/2019/04/15/sort-pai-xu-yuan-li/"/>
    <id>http://zongmansheng.club/2019/04/15/sort-pai-xu-yuan-li/</id>
    <published>2019-04-15T05:17:48.000Z</published>
    <updated>2019-04-15T05:22:13.168Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java-sort排序原理"><a href="#java-sort排序原理" class="headerlink" title="java sort排序原理"></a>java sort排序原理</h1><pre><code>    事实上Collections.sort方法底层就是调用的Arrays.sort方法，而Arrays.sort使用了两种排序方法，快速排序和优化的归并排序。快速排序主要是对那些基本类型数据（int,short,long等）排序， 而归并排序用于对Object类型进行排序。    使用不同类型的排序算法主要是由于快速排序是不稳定的，而归并排序是稳定的。这里的稳定是指比较相等的数据在排序之后仍然按照排序之前的前后顺序排列。对于基本数据类型，稳定性没有意义，而对于Object类型，稳定性是比较重要的，因为对象相等的判断可能只是判断关键属性，最好保持相等对象的非关键属性的顺序与排序前一致；另外一个原因是由于归并排序相对而言比较次数比快速排序少，移动（对象引用的移动）次数比快速排序多，而对于对象来说，比较一般比移动耗时。    此外，对大数组排序。快速排序的sort()采用递归实现，数组规模太大时会发生堆栈溢出，而归并排序sort()采用非递归实现，不存在此问题。</code></pre><pre><code>总结：首先先判断需要排序的数据量是否大于60。小于60：使用插入排序，插入排序是稳定的大于60的数据量会根据数据类型选择排序方式：基本类型：使用快速排序。因为基本类型。1、2都是指向同一个常量池不需要考虑稳定性。Object类型：使用归并排序。因为归并排序具有稳定性。注意：不管是快速排序还是归并排序。在二分的时候小于60的数据量依旧会使用插入排序</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java-sort排序原理&quot;&gt;&lt;a href=&quot;#java-sort排序原理&quot; class=&quot;headerlink&quot; title=&quot;java sort排序原理&quot;&gt;&lt;/a&gt;java sort排序原理&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;    事实上Collections
      
    
    </summary>
    
      <category term="java基础" scheme="http://zongmansheng.club/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="sort" scheme="http://zongmansheng.club/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>Spring中AOP的两种代理</title>
    <link href="http://zongmansheng.club/2019/04/14/spring-zhong-aop-de-liang-chong-dai-li/"/>
    <id>http://zongmansheng.club/2019/04/14/spring-zhong-aop-de-liang-chong-dai-li/</id>
    <published>2019-04-14T13:23:15.000Z</published>
    <updated>2019-04-14T14:28:33.664Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring中AOP的两种代理"><a href="#Spring中AOP的两种代理" class="headerlink" title="Spring中AOP的两种代理"></a>Spring中AOP的两种代理</h1><h2 id="方式动态代理和CGLIB详解"><a href="#方式动态代理和CGLIB详解" class="headerlink" title="方式动态代理和CGLIB详解"></a>方式动态代理和CGLIB详解</h2><h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><h5 id="1、什么是代理"><a href="#1、什么是代理" class="headerlink" title="1、什么是代理"></a>1、什么是代理</h5><pre><code>    代理的概念容易理解，比如：微商，简单来说微商就是替厂家卖商品。当我们从微商(代理)那里买东西时通常不知道背后的商家究竟是谁，也就是说，委托者对我们来说是不可见的。作为微商，有其自己的目标客户，这也相当于为厂家做了一次过滤。把微商和厂家进一步抽象，微商可以抽象为代理类，厂家可抽象为委托类(被代理类)。通过微商和厂家特点可知，通过使用代理，通常有两个优点：其一:可以隐藏委托类的实现;其二:可以实现客户与委托类间的解耦，在不修改委托类代码的情况下能够做一些额外的处理。</code></pre><h5 id="2、静态代理"><a href="#2、静态代理" class="headerlink" title="2、静态代理"></a>2、静态代理</h5><pre><code>若代理类在程序运行前就已经存在，那么这种代理方式被成为静态代理。这种情况下的代理类通常都是我们在Java代码中定义的。 通常情况下，静态代理中的代理类和委托类会实现同一接口或是派生自相同的父类。 下面我们用Vendor类代表生产厂家，BusinessAgent类代表微商代理，来介绍下静态代理的简单实现。委托类和代理类都实现了Sell接口，Sell接口的定义如下：</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> test<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author ZongMan * @version 1.0 * @date 2019/4/14 0014 21:29 */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Sell</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">sell</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>Vendor类的定义如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> test<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author ZongMan * @version 1.0 * @date 2019/4/14 0014 22:06 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Vendor</span> <span class="token keyword">implements</span> <span class="token class-name">Sell</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sell</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"sell method"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"add method"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>BusinessAgent类的定义如下:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> test<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author ZongMan * @version 1.0 * @date 2019/4/14 0014 22:07 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BusinessAgent</span> <span class="token keyword">implements</span> <span class="token class-name">Sell</span> <span class="token punctuation">{</span>    Vendor vendor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vendor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sell</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isCollegeStudent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            vendor<span class="token punctuation">.</span><span class="token function">sell</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isCollegeStudent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>    从BusinessAgent类的定义我们可以了解到，静态代理可以通过聚合来实现，让代理类持有一个委托类的引用即可。    如果需要增加一个需求：给Vendor类增加一个过滤功能，不可以卖给学生。通过静态代理，我们无需修改Vendor类的代码就可以实现，只需在BusinessAgent类中的sell方法中添加一个判断即可。如上图可以。    这对应着我们上面提到的使用代理的第二个优点：可以实现客户与委托类间的解耦，在不修改委托类代码的情况下能够做一些额外的处理。静态代理的局限在于运行前必须编写好代理类，下面我们重点来介绍下运行时生成代理类的动态代理方式，即动态代理机制。</code></pre><h4 id="二、动态代理"><a href="#二、动态代理" class="headerlink" title="二、动态代理"></a>二、动态代理</h4><pre><code>    代理类在程序运行时创建的代理方式被成为 动态代理。 也就是说，这种情况下，代理类并不是在Java代码中定义的，而是在运行时根据我们在Java代码中的“指示”动态生成的。相比于静态代理， 动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类的函数。 这么说比较抽象，下面我们结合一个实例来介绍一下动态代理的这个优势是怎么体现的。    现在，假设我们要实现这样一个需求：在执行委托类中的方法之前输出“before”，在执行完毕后输出“after”。我们还是以上面例子中的Vendor类作为委托类，BusinessAgent类作为代理类来进行介绍。首先我们来使用静态代理来实现这一需求，相关代码如下：</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> test<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author ZongMan * @version 1.0 * @date 2019/4/14 0014 22:07 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BusinessAgent</span> <span class="token keyword">implements</span> <span class="token class-name">Sell</span> <span class="token punctuation">{</span>    Vendor vendor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vendor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sell</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"before"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isCollegeStudent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            vendor<span class="token punctuation">.</span><span class="token function">sell</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isCollegeStudent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"before"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vendor<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>    从以上代码中我们可以了解到，通过静态代理实现我们的需求需要我们在每个方法中都添加相应的逻辑，这里只存在两个方法所以工作量还不算大，假如Sell接口中包含上百个方法呢?这时候使用静态代理就会编写许多冗余代码。通过使用动态代理，我们可以做一个“统一指示”，从而对所有代理类的方法进行统一处理，而不用逐一修改每个方法。下面我们来具体介绍下如何使用动态代理方式实现我们的需求。</code></pre><h5 id="使用动态代理"><a href="#使用动态代理" class="headerlink" title="使用动态代理"></a>使用动态代理</h5><pre><code>(1)InvocationHandler接口在使用动态代理时，我们需要定义一个位于代理类与委托类之间的中介类，这个中介类被要求实现InvocationHandler接口，这个接口的定义如下：</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> test<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Method<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author ZongMan * @version 1.0 * @date 2019/4/14 0014 22:13 */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">InvocationHandler</span> <span class="token punctuation">{</span>    Object <span class="token function">invoke</span><span class="token punctuation">(</span>Object proxy<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span>Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre><code>从InvocationHandler这个名称我们就可以知道，实现了这个接口的中介类用做“调用处理器”。当我们调用代理类对象的方法时，这个“调用”会转送到invoke方法中，代理类对象作为proxy参数传入，参数method标识了我们具体调用的是代理类的哪个方法，args为这个方法的参数。这样一来，我们对代理类中的所有方法的调用都会变为对invoke的调用，这样我们可以在invoke方法中添加统一的处理逻辑(也可以根据method参数对不同的代理类方法做不同的处理)。因此我们只需在中介类的invoke方法实现中输出“before”，然后调用委托类的invoke方法，再输出“after”。下面我们来一步一步具体实现它。(2)委托类的定义动态代理方式下，要求委托类必须实现某个接口，这里我们实现的是Sell接口。委托类Vendor类的定义如下：</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> test<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author ZongMan * @version 1.0 * @date 2019/4/14 0014 22:06 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Vendor</span> <span class="token keyword">implements</span> <span class="token class-name">Sell</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sell</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"sell method"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"add method"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>(3)中介类上面我们提到过，中介类必须实现InvocationHandler接口，作为调用处理器”拦截“对代理类方法的调用。中介类的定义如下：</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> test<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Method<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author ZongMan * @version 1.0 * @date 2019/4/14 0014 22:17 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DynamicProxy</span> <span class="token keyword">implements</span> <span class="token class-name">InvocationHandler</span><span class="token punctuation">,</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>InvocationHandler <span class="token punctuation">{</span>    <span class="token keyword">private</span> Object object<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">DynamicProxy</span><span class="token punctuation">(</span>Object object<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>object <span class="token operator">=</span> object<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Object <span class="token function">invoke</span><span class="token punctuation">(</span>Object proxy<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"before"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Object result <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>object<span class="token punctuation">,</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>从以上代码中我们可以看到，中介类持有一个委托类对象引用，在invoke方法中调用了委托类对象的相应方法，通过聚合方式持有委托类对象引用，把外部对invoke的调用最终都转为对委托类对象的调用。下面我们来介绍一下如何”指示“以动态生成代理类。(4)动态生成代理类动态生成代理类的相关代码如下：</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> test<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Proxy<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author ZongMan * @version 1.0 * @date 2019/4/14 0014 22:20 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//创建中介类实例</span>        DynamicProxy inter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DynamicProxy</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Vendor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//获取代理类实例sell</span>        Sell sell <span class="token operator">=</span> <span class="token punctuation">(</span>Sell<span class="token punctuation">)</span> Proxy<span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span>Sell<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>Sell<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">,</span>inter<span class="token punctuation">)</span><span class="token punctuation">;</span>        sell<span class="token punctuation">.</span><span class="token function">sell</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sell<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>在以上代码中，我们调用Proxy类的newProxyInstance方法来获取一个代理类实例。这个代理类实现了我们指定的接口并且会把方法调用分发到指定的调用处理器。这个方法的声明如下：</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> Object <span class="token function">newProxyInstance</span><span class="token punctuation">(</span>ClassLoader loader<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> interfaces<span class="token punctuation">,</span> InvocationHandler h<span class="token punctuation">)</span> <span class="token keyword">throws</span> IllegalArgumentException</code></pre><pre><code>方法的三个参数含义分别如下：loader：定义了代理类的ClassLoder;interfaces：代理类实现的接口列表h：调用处理器，也就是我们上面定义的实现了InvocationHandler接口的类实例这里再简单的总结下：首先通过newProxyInstance方法获取代理类实例，而后我们便可以通过这个代理类实例调用代理类的方法，对代理类的方法的调用实际上都会调用中介类(调用处理器)的invoke方法，在invoke方法中我们调用委托类的相应方法，并且可以添加自己的处理逻辑。如上将上面代理、静态代理，动态代理都理解，下面讲解Spring中AOP的两种代理方式（Java动态代理和CGLIB代理）</code></pre><h5 id="1、动态代理"><a href="#1、动态代理" class="headerlink" title="1、动态代理"></a>1、动态代理</h5><pre><code>相关概念及用法上面已经讲到，其具体有如下四步骤：1、通过实现 InvocationHandler 接口创建自己的调用处理器；2、通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来创建动态代理类；3、通过反射机制获得动态代理类的构造函数，其唯一参数类型是调用处理器接口类型；4、通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入。</code></pre><h5 id="2、GCLIB代理"><a href="#2、GCLIB代理" class="headerlink" title="2、GCLIB代理"></a>2、GCLIB代理</h5><pre><code>cglib（Code Generation Library）是一个强大的,高性能,高质量的Code生成类库。它可以在运行期扩展Java类与实现Java接口。cglib封装了asm，可以在运行期动态生成新的class。cglib用于AOP，jdk中的proxy必须基于接口，cglib却没有这个限制。</code></pre><h5 id="3、原理区别："><a href="#3、原理区别：" class="headerlink" title="3、原理区别："></a>3、原理区别：</h5><pre><code>java动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。而cglib动态代理是利用asm开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。1、如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP 2、如果目标对象实现了接口，可以强制使用CGLIB实现AOP 3、如果目标对象没有实现了接口，必须采用CGLIB库，spring会自动在JDK动态代理和CGLIB之间转换Spring自己的CGLIB的实现方式,他是生成了一个被代理类的子类,你也可以在子类中增加父类没有的功能.如何强制使用CGLIB实现AOP？ * 添加CGLIB库，SPRING_HOME/cglib/*.jar * 在spring配置文件中加入&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt;4、JDK动态代理和CGLIB字节码生成的区别？ * JDK动态代理只能对实现了接口的类生成代理，而不能针对类 * CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法 因为是继承，所以该类或方法最好不要声明成final。*要将CGLIB的二进制发行包放在classpath下。5、Spring AOP里面的代理实现方式spring用代理类包裹切面，把他们织入到Spring管理的bean中。也就是说代理类伪装成目标类，它会截取对目标类中方法的调用，让调用者对目标类的调用都先变成调用伪装类，伪装类中就先执行了切面，再把调用转发给真正的目标bean。现在可以自己想一想，怎么搞出来这个伪装类，才不会被调用者发现（过JVM的检查，JAVA是强类型检查，哪里都要检查类型）。1.实现和目标类相同的接口，我也实现和你一样的接口，反正上层都是接口级别的调用，这样我就伪装成了和目标类一样的类（实现了同一接口，咱是兄弟了），也就逃过了类型检查，到java运行期的时候，利用多态的后期绑定（所以spring采用运行时），伪装类（代理类）就变成了接口的真正实现，而他里面包裹了真实的那个目标类，最后实现具体功能的还是目标类，只不过伪装类在之前干了点事情（写日志，安全检查，事物等）。2.生成子类调用，这次用子类来做为伪装类，当然这样也能逃过JVM的强类型检查，我继承的吗，当然查不出来了，子类重写了目标类的所有方法，当然在这些重写的方法中，不仅实现了目标类的功能，还在这些功能之前，实现了一些其他的（写日志，安全检查，事物等）。前一种兄弟模式，spring会使用JDK的java.lang.reflect.Proxy类，它允许Spring动态生成一个新类来实现必要的接口，织入通知，并且把对这些接口的任何调用都转发到目标类。后一种父子模式，spring使用CGLIB库生成目标类的一个子类，在创建这个子类的时候，spring织入通知，并且把对这个子类的调用委托到目标类。相比之下，还是兄弟模式好些，他能更好的实现松耦合，尤其在今天都高喊着面向接口编程的情况下，父子模式只是在没有实现接口的时候，也能织入通知，应当做一种例外。</code></pre><h4 id="三、spring-aop的使用方式："><a href="#三、spring-aop的使用方式：" class="headerlink" title="三、spring aop的使用方式："></a>三、spring aop的使用方式：</h4><h5 id="使用aop的目的："><a href="#使用aop的目的：" class="headerlink" title="使用aop的目的："></a>使用aop的目的：</h5><pre><code>1就是为了方便，看一个国外很有名的大师说，编程的人都是“懒人”，因为他把自己做的事情都让程序做了。用了aop能让你少写很多代码，这点就够充分了吧2就是为了更清晰的逻辑，可以让你的业务逻辑去关注自己本身的业务，而不去想一些其他的事情，这些其他的事情包括：安全，事物，日志等。</code></pre><h5 id="第一种实现方式：使用AspectJ提供的注解package-test-mine-spring-bean"><a href="#第一种实现方式：使用AspectJ提供的注解package-test-mine-spring-bean" class="headerlink" title="第一种实现方式：使用AspectJ提供的注解package test.mine.spring.bean;"></a>第一种实现方式：使用AspectJ提供的注解package test.mine.spring.bean;</h5><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> org<span class="token punctuation">.</span>aspectj<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>AfterReturning<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>aspectj<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Aspect<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>aspectj<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Before<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>aspectj<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Pointcut<span class="token punctuation">;</span><span class="token annotation punctuation">@Aspect</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SleepHelper</span> <span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token function">SleepHelper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Pointcut</span><span class="token punctuation">(</span><span class="token string">"execution(* *.sleep())"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sleeppoint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Before</span><span class="token punctuation">(</span><span class="token string">"sleeppoint()"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">beforeSleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"睡觉前要脱衣服!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@AfterReturning</span><span class="token punctuation">(</span><span class="token string">"sleeppoint()"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterSleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"睡醒了要穿衣服！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>用@Aspect的注解来标识切面,注意不要把它漏了，否则Spring创建代理的时候会找不到它,@Pointcut注解指定了切点，@Before和@AfterReturning指定了运行时的通知，注意的是要在注解中传入切点的名称。然后我们在Spring配置文件上下点功夫,首先是增加AOP的XML命名空间和声明相关schema命名空间:xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;schema声明:http://www.springframework.org/schema/aophttp://www.springframework.org/schema/aop/spring-aop-2.0.xsd然后加上这个标签:&lt;aop:aspectj-autoproxy/&gt; 有了这个Spring就能够自动扫描被@Aspect标注的切面了最后是运行，很简单方便了：</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>ApplicationContext appCtx <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">"applicationContext.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Sleepable human <span class="token operator">=</span> <span class="token punctuation">(</span>Sleepable<span class="token punctuation">)</span>appCtx<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"human"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>human<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="第二种使用方式："><a href="#第二种使用方式：" class="headerlink" title="第二种使用方式："></a>第二种使用方式：</h5><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sleepHelper<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>test.spring.aop.bean.SleepHelper<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">aop:</span>config</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">aop:</span>aspect</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sleepHelper<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">aop:</span>before</span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>beforeSleep<span class="token punctuation">"</span></span> <span class="token attr-name">pointcut</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>execution(* *.sleep(..))<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">aop:</span>after</span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>afterSleep<span class="token punctuation">"</span></span> <span class="token attr-name">pointcut</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>execution(* *.sleep(..))<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">aop:</span>aspect</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">aop:</span>config</span><span class="token punctuation">></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring中AOP的两种代理&quot;&gt;&lt;a href=&quot;#Spring中AOP的两种代理&quot; class=&quot;headerlink&quot; title=&quot;Spring中AOP的两种代理&quot;&gt;&lt;/a&gt;Spring中AOP的两种代理&lt;/h1&gt;&lt;h2 id=&quot;方式动态代理和CGLIB详
      
    
    </summary>
    
      <category term="Spring" scheme="http://zongmansheng.club/categories/Spring/"/>
    
    
      <category term="框架" scheme="http://zongmansheng.club/tags/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="AOP" scheme="http://zongmansheng.club/tags/AOP/"/>
    
      <category term="Spring" scheme="http://zongmansheng.club/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>30道java面试题</title>
    <link href="http://zongmansheng.club/2019/04/13/30-dao-java-mian-shi-ti/"/>
    <id>http://zongmansheng.club/2019/04/13/30-dao-java-mian-shi-ti/</id>
    <published>2019-04-13T14:22:35.000Z</published>
    <updated>2019-04-13T14:34:03.398Z</updated>
    
    <content type="html"><![CDATA[<h1 id="30道java面试题"><a href="#30道java面试题" class="headerlink" title="30道java面试题"></a>30道java面试题</h1><h4 id="1、Spring-DAO-中最常用的类是（）"><a href="#1、Spring-DAO-中最常用的类是（）" class="headerlink" title="1、Spring DAO 中最常用的类是（）"></a>1、Spring DAO 中最常用的类是（）</h4><pre><code>A，JdbcTemplate ，SimpleJdbcTemplateB，SimpleJdbcInsert，SimpleJdbcProcedureC，SimpleJdbcInsert ，SimpleJdbcStoredProcD，SimpleJdbcQuery ，SimpleJdbcExec正确答案：A</code></pre><h4 id="2、Spring-AOP-中，-织入（Weaving）-可以在下面什么时间完成（）"><a href="#2、Spring-AOP-中，-织入（Weaving）-可以在下面什么时间完成（）" class="headerlink" title="2、Spring AOP 中， 织入（Weaving） 可以在下面什么时间完成（）"></a>2、Spring AOP 中， 织入（Weaving） 可以在下面什么时间完成（）</h4><pre><code>A，全部选项B，Run timeC，Load timeD，Compile time正确答案：A</code></pre><h4 id="3、下面关于Spring-MVC-描述正确的是（）"><a href="#3、下面关于Spring-MVC-描述正确的是（）" class="headerlink" title="3、下面关于Spring MVC 描述正确的是（）"></a>3、下面关于Spring MVC 描述正确的是（）</h4><pre><code>A，DispatcherServlet在 Spring MVC 中是核心servlet , 它负责接收请求并将请求分发给适合的控制器B，在Spring MVC 中,可以配置多个DispatcherServletC，全部选项D，要使Spring MVC可用，DispatcherServlet需要在web.xml中配置正确答案：C</code></pre><h4 id="4、下面哪项是Spring自动装载模式（）"><a href="#4、下面哪项是Spring自动装载模式（）" class="headerlink" title="4、下面哪项是Spring自动装载模式（）"></a>4、下面哪项是Spring自动装载模式（）</h4><pre><code>A，autodetectB，全部选项C，constructorD，byname, byType正确答案：B</code></pre><h4 id="5、Spring-中，下面哪一项不是使用事务的方法（）"><a href="#5、Spring-中，下面哪一项不是使用事务的方法（）" class="headerlink" title="5、Spring 中，下面哪一项不是使用事务的方法（）"></a>5、Spring 中，下面哪一项不是使用事务的方法（）</h4><pre><code>A，proxiesB，declarativelyC，programmaticly正确答案：A</code></pre><h4 id="6、Spring提供了JMS层的抽象，正确吗（）"><a href="#6、Spring提供了JMS层的抽象，正确吗（）" class="headerlink" title="6、Spring提供了JMS层的抽象，正确吗（）"></a>6、Spring提供了JMS层的抽象，正确吗（）</h4><pre><code>A，正确B，错误正确答案：A</code></pre><h4 id="7、关于”-Order”注解，最正确的描述是（）"><a href="#7、关于”-Order”注解，最正确的描述是（）" class="headerlink" title="7、关于”@Order”注解，最正确的描述是（）"></a>7、关于”@Order”注解，最正确的描述是（）</h4><pre><code>A，实现org.springframework.core.Ordered接口B，指定一个bean的范围C，通常用于注入域对象的属性D，全不正确正确答案：A</code></pre><h4 id="8、如何在Spring应用中使用SLF4J（）"><a href="#8、如何在Spring应用中使用SLF4J（）" class="headerlink" title="8、如何在Spring应用中使用SLF4J（）"></a>8、如何在Spring应用中使用SLF4J（）</h4><pre><code>A，作为日志框架B，全不正确C，作为一个beanD，作为JDBC框架正确答案：A</code></pre><h4 id="9、Spring-bean-的默认作用范围是（）"><a href="#9、Spring-bean-的默认作用范围是（）" class="headerlink" title="9、Spring bean 的默认作用范围是（）"></a>9、Spring bean 的默认作用范围是（）</h4><pre><code>A，全不正确B，SingletonC，PrototypeD，SessionE， Abstract正确答案：B</code></pre><h4 id="10、Spring中，单例意味着每-只有一个实例（）"><a href="#10、Spring中，单例意味着每-只有一个实例（）" class="headerlink" title="10、Spring中，单例意味着每_只有一个实例（）"></a>10、Spring中，单例意味着每<strong>_</strong>只有一个实例（）</h4><pre><code>A，ContextB， JVMC，Thread正确答案：A</code></pre><h4 id="11、使用Spring-MVC-处理普通页面请求，-下面哪个排序是正确的（）"><a href="#11、使用Spring-MVC-处理普通页面请求，-下面哪个排序是正确的（）" class="headerlink" title="11、使用Spring MVC 处理普通页面请求， 下面哪个排序是正确的（）"></a>11、使用Spring MVC 处理普通页面请求， 下面哪个排序是正确的（）</h4><pre><code>1.请求：请求提交给服务器2.分发：分发器通过web 应用配置信息 ， 将请求分发至适当的控制器3.服务调用：控制器与业务层交互4.响应：控制器更新模型，将执行结果返回给客户端展现A，1-2-3-4B，1-4-3-2C，1-4-2-3D，1-3-2-4正确答案：A</code></pre><h4 id="12、以下哪个不是-Spring-AOP-的注解（）"><a href="#12、以下哪个不是-Spring-AOP-的注解（）" class="headerlink" title="12、以下哪个不是 Spring AOP 的注解（）"></a>12、以下哪个不是 Spring AOP 的注解（）</h4><pre><code>A，@BeforeB，@AroundC，@BeforeReturningD，@AfterThrowing正确答案：C</code></pre><h4 id="13、”-RequestMapping是Spring中的哪一部分（）"><a href="#13、”-RequestMapping是Spring中的哪一部分（）" class="headerlink" title="13、”@RequestMapping是Spring中的哪一部分（）"></a>13、”@RequestMapping是Spring中的哪一部分（）</h4><pre><code>A，DAOB，SecurityC，Web MVCD，Web正确答案：C</code></pre><h4 id="14、下面关于spring和struts2的描述，错误的是（）"><a href="#14、下面关于spring和struts2的描述，错误的是（）" class="headerlink" title="14、下面关于spring和struts2的描述，错误的是（）"></a>14、下面关于spring和struts2的描述，错误的是（）</h4><pre><code>A，spring mvc的入口是filter，而struts2是servletB，spring mvc是基于方法的设计，而struts2是基于类的设计C，struts2有以自己的interceptor机制，spring mvc用的是独立的AOP方式D， spring mvc的方法之间基本上独立的，独享request response数据，struts2所有Action变量是共享的正确答案：A</code></pre><h4 id="15、Spring中，下面哪个选项支持ORM（）"><a href="#15、Spring中，下面哪个选项支持ORM（）" class="headerlink" title="15、Spring中，下面哪个选项支持ORM（）"></a>15、Spring中，下面哪个选项支持ORM（）</h4><pre><code>A，OJBB，TopLinkC，全部选项D，Java Data Objects(JDO)E，iBatis正确答案：C</code></pre><h4 id="16、Spring和Hibernate的集成中，下面哪项是SessionFactory-正确的实现（）"><a href="#16、Spring和Hibernate的集成中，下面哪项是SessionFactory-正确的实现（）" class="headerlink" title="16、Spring和Hibernate的集成中，下面哪项是SessionFactory 正确的实现（）"></a>16、Spring和Hibernate的集成中，下面哪项是SessionFactory 正确的实现（）</h4><pre><code>A，LocalSessionFactoryBeanB，LocalFactoryBeanC，SessionFactoryD，SessionFactoryBean正确答案：A</code></pre><h4 id="17、下面哪个是Spring最核心的servlet（）"><a href="#17、下面哪个是Spring最核心的servlet（）" class="headerlink" title="17、下面哪个是Spring最核心的servlet（）"></a>17、下面哪个是Spring最核心的servlet（）</h4><pre><code>A，WebServletB，SpringServletC，DispatcherServletD，IoCServlet正确答案：C</code></pre><h4 id="18、Spring-test-用什么约定在测试中使用HTTP会话和HTTP-请求对象（）"><a href="#18、Spring-test-用什么约定在测试中使用HTTP会话和HTTP-请求对象（）" class="headerlink" title="18、Spring-test 用什么约定在测试中使用HTTP会话和HTTP 请求对象（）"></a>18、Spring-test 用什么约定在测试中使用HTTP会话和HTTP 请求对象（）</h4><pre><code>A，MVCB，Open-closed principleC，DAOsD，Mock objects正确答案：D</code></pre><h4 id="19、Spring-中，”-Cacheable”的key生成方式，以下哪个是正确的（）"><a href="#19、Spring-中，”-Cacheable”的key生成方式，以下哪个是正确的（）" class="headerlink" title="19、Spring 中，”@Cacheable”的key生成方式，以下哪个是正确的（）"></a>19、Spring 中，”@Cacheable”的key生成方式，以下哪个是正确的（）</h4><pre><code>A，可以是方法参数及其成员变量的任意表达式B，只能使用所有方法参数，但可以调整次序C，只能使用所有方法参数，且不能调整次序D，只能指定方法参数是否参与key的生成，不能控制参数的成员变量正确答案：A</code></pre><h4 id="20、使用-Required但不关联bean-来注解setter方法，将会发生（）"><a href="#20、使用-Required但不关联bean-来注解setter方法，将会发生（）" class="headerlink" title="20、使用@Required但不关联bean 来注解setter方法，将会发生（）"></a>20、使用@Required但不关联bean 来注解setter方法，将会发生（）</h4><pre><code>A，bean被设置为nullB，启动异常C，Spring 将创建beanD，什么也不发生正确答案：B</code></pre><h4 id="21，有关线程的哪些叙述是对的（-）"><a href="#21，有关线程的哪些叙述是对的（-）" class="headerlink" title="21，有关线程的哪些叙述是对的（ ）"></a>21，有关线程的哪些叙述是对的（ ）</h4><pre><code>A，一旦一个线程被创建，它就立即开始运行。B，使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。C，当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。D，一个线程可能因为不同的原因停止并进入就绪状态。答案：BCD在抢占式线程模型中，操作系统可以在任何时候打断线程。通常会在它运行了一段时间（就是所谓的一个时间片）后才打断它。这样的结果自然是没有线程能够不公平地长时间霸占处理器。</code></pre><hr><h4 id="22，哪个关键字可以对对象加互斥锁-（）"><a href="#22，哪个关键字可以对对象加互斥锁-（）" class="headerlink" title="22，哪个关键字可以对对象加互斥锁 （）"></a>22，哪个关键字可以对对象加互斥锁 （）</h4><pre><code>A，serializeB，synchronizedC，transientD，static答案：BA是对象串行化、C是关键字transient修饰的属性将不被串行化、D是静态的</code></pre><h4 id="23，下列关于线程优先级的说法中，正确的是（）"><a href="#23，下列关于线程优先级的说法中，正确的是（）" class="headerlink" title="23，下列关于线程优先级的说法中，正确的是（）"></a>23，下列关于线程优先级的说法中，正确的是（）</h4><pre><code>A、线程的优先级是不能改变的B、线程的优先级是在创建线程时设置的C、在创建线程后的任何时候都可以设置D、B和C答案：C    Java语言中线程的优先级是用一个介于MIN_PRIORITY和MAX_PRIORITY之间的整数来表示的。可以在创建线程后的任何时候修改线程的优先级。</code></pre><h4 id="24，为了使模块尽可能独立，要求"><a href="#24，为了使模块尽可能独立，要求" class="headerlink" title="24，为了使模块尽可能独立，要求( )"></a>24，为了使模块尽可能独立，要求( )</h4><pre><code>A．模块的内聚程度要尽量高，且耦合程度要尽量强B．模块的内聚程度要尽量高，且耦合程度要尽量弱C．模块的内聚程度要尽量低，且耦合程度要尽量弱D．模块的内聚程度要尽量低，且耦合程度要尽量强答案：B    系统设计的质量主要反映在模块的独立性上。评价模块独立性的主要标准有两个：一是模块之间的耦合，它表明两个模块之间互相独立的程度；二是模块内部之间的关系是否紧密，称为内聚。一般来说，要求模块之间的耦合尽可能地弱，即模块尽可能独立，而要求模块的内聚程度尽量高。</code></pre><h4 id="25，下列对于线性链表的描述中正确的是（）"><a href="#25，下列对于线性链表的描述中正确的是（）" class="headerlink" title="25，下列对于线性链表的描述中正确的是（）"></a>25，下列对于线性链表的描述中正确的是（）</h4><pre><code>A．存储空间不一定是连续，且各元素的存储顺序是任意的B．存储空间不一定是连续，且前件元素一定存储在后件元素的前面C．存储空间必须连续，且前件元素一定存储在后件元素的前面D．存储空间必须连续，且各元素的存储顺序是任意的答案：A在链式存储结构中，存储数据结构的存储空间可以不连续，各数据结点的存储顺序与数据元素之间 的逻辑关系可以不一致，而数据元素之间的逻辑关系是由指针域来确定的。</code></pre><h4 id="26，下列叙述中错误的是"><a href="#26，下列叙述中错误的是" class="headerlink" title="26，下列叙述中错误的是( )"></a>26，下列叙述中错误的是( )</h4><pre><code>A.线性表是由n个元素组成的一个有限序列B.线性表是一种线性结构C.线性表的所有结点有且仅有一个前件和后件D.线性表可以是空表答案：C线性表是一种线性结构，由n(n≥0)个元素组成，所以线性表可以是空表。但是在线性表中，第一个结点没有前驱，最后一个结点没有后继，其他结点有且只有一个前驱和后继，所以选项C是错误的。</code></pre><h4 id="27，已知一棵二叉树前序遍历和中序遍历分别为ABDEGCFH和DBGEACHF，则该二叉树的后序遍历为"><a href="#27，已知一棵二叉树前序遍历和中序遍历分别为ABDEGCFH和DBGEACHF，则该二叉树的后序遍历为" class="headerlink" title="27，已知一棵二叉树前序遍历和中序遍历分别为ABDEGCFH和DBGEACHF，则该二叉树的后序遍历为( )"></a>27，已知一棵二叉树前序遍历和中序遍历分别为ABDEGCFH和DBGEACHF，则该二叉树的后序遍历为( )</h4><pre><code>A.GEDHFBCAB.DGEBHFCAC.ABCDEFGHD.ACBFEDHG答案：B二叉树的遍历有3种：前序、中序和后序。先序：先访问根结点、左结点、右结点中序：先访问左结点、根结点、右结点后序：先访问左结点、右结点、根结点本题根据前序遍历和中序遍历的结果可以得出二叉树的结构，然后再对其进行后序遍历。</code></pre><h4 id="28，面向对象方法中，继承是指"><a href="#28，面向对象方法中，继承是指" class="headerlink" title="28，面向对象方法中，继承是指( )"></a>28，面向对象方法中，继承是指( )</h4><pre><code>A.一组对象所具有的相似性质B.一个对象具有另一个对象的性质C.各对象之间的共同性质D.类之间共享属性和操作的机制答案：D继承：在程序设计中，继承是指子类自动享用父类的属性和方法，并可以增加新的属性和方法的一种机制。它是实现代码共享的重要手段，可以使软件更具有开放性、可扩充性，这是信息组织与分类的行之有效的方法，也是面向对象的主要优点之一。继承又分为单重继承和多重继承，单重继承是指子类只能继承一个父类的属性和操作；而多重继承是指子类可以继承了多个父类的属性和操作。扩展：Java是一种单重继承语言，而C++是一种多重继承语言。</code></pre><h4 id="29，栈和队列的共同点是"><a href="#29，栈和队列的共同点是" class="headerlink" title="29，栈和队列的共同点是( )"></a>29，栈和队列的共同点是( )</h4><pre><code>A.都是先进先出B.都是先进后出C.只允许在端点处插入和删除元素D.没有共同特点答案：C栈是只允许在表的一端进行插入和删除的操作，队列是允许在表的一端进行插入，另一端进行删除的操作。</code></pre><h4 id="30，下列关于修饰符混用的说法，错误的是（）"><a href="#30，下列关于修饰符混用的说法，错误的是（）" class="headerlink" title="30，下列关于修饰符混用的说法，错误的是（）"></a>30，下列关于修饰符混用的说法，错误的是（）</h4><pre><code>A.abstract不能与final并列修饰同一个类B.abstract类中不可以有private的成员C.abstract方法必须在abstract类中D.static方法中能处理非static的数据答案：D静态方法是属于类的，而普通方法是属于对象的。属于类的静态方法可以在对象不存在的时候就能访问到，而普通方法必须先new一个对象才能用这个对象访问。当我们访问调用静态方法的时候（使用类名.静态方法名）这个时候就没有对象创建，所以普通方法是访问不到的。为了避免这种错误，所以java就不允许在静态方法中访问非静态方法。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;30道java面试题&quot;&gt;&lt;a href=&quot;#30道java面试题&quot; class=&quot;headerlink&quot; title=&quot;30道java面试题&quot;&gt;&lt;/a&gt;30道java面试题&lt;/h1&gt;&lt;h4 id=&quot;1、Spring-DAO-中最常用的类是（）&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="面试题" scheme="http://zongmansheng.club/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="java" scheme="http://zongmansheng.club/tags/java/"/>
    
      <category term="面试题" scheme="http://zongmansheng.club/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>MySql中锁的理解</title>
    <link href="http://zongmansheng.club/2019/04/12/mysql-zhong-suo-de-li-jie/"/>
    <id>http://zongmansheng.club/2019/04/12/mysql-zhong-suo-de-li-jie/</id>
    <published>2019-04-12T04:34:39.000Z</published>
    <updated>2019-04-13T13:51:53.225Z</updated>
    
    <content type="html"><![CDATA[<p><img src="//zongmansheng.club/2019/04/12/mysql-zhong-suo-de-li-jie/001.png" alt="001"></p><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><pre><code>注：MySQL是一个支持插件式存储引擎的数据库系统。本文下面的所有介绍，都是基于InnoDB存储引擎，其他引擎的表现，会有较大的区别。</code></pre><h4 id="存储引擎查看"><a href="#存储引擎查看" class="headerlink" title="存储引擎查看"></a>存储引擎查看</h4><pre><code>MySQL给开发者提供了查询存储引擎的功能，我这里使用的是MySQL5.6.4，可以使用：SHOW ENGINES</code></pre><p><img src="//zongmansheng.club/2019/04/12/mysql-zhong-suo-de-li-jie/002.png" alt="002"></p><p><img src="//zongmansheng.club/2019/04/12/mysql-zhong-suo-de-li-jie/003.png" alt="003"></p><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><pre><code>    用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加1。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。</code></pre><h5 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h5><h6 id="1、数据库表设计"><a href="#1、数据库表设计" class="headerlink" title="1、数据库表设计"></a>1、数据库表设计</h6><pre><code>三个字段，分别是id,value、version</code></pre><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> id<span class="token punctuation">,</span><span class="token keyword">value</span><span class="token punctuation">,</span>version <span class="token keyword">from</span> <span class="token keyword">TABLE</span> <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token comment" spellcheck="true">#{id}</span></code></pre><h6 id="2、每次更新表中的value字段时，为了防止发生冲突，需要这样操作"><a href="#2、每次更新表中的value字段时，为了防止发生冲突，需要这样操作" class="headerlink" title="2、每次更新表中的value字段时，为了防止发生冲突，需要这样操作"></a>2、每次更新表中的value字段时，为了防止发生冲突，需要这样操作</h6><pre class=" language-sql"><code class="language-sql"><span class="token keyword">update</span> <span class="token keyword">TABLE</span> <span class="token keyword">set</span> <span class="token keyword">value</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span>version<span class="token operator">=</span>version<span class="token operator">+</span><span class="token number">1</span> <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token comment" spellcheck="true">#{id} and version=#{version};</span></code></pre><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><pre><code>    与乐观锁相对应的就是悲观锁了。悲观锁就是在操作数据时，认为此操作会出现数据冲突，所以在进行每次操作时都要通过获取锁才能进行对相同数据的操作，这点跟java中的synchronized很相似，所以悲观锁需要耗费较多的时间。另外与乐观锁相对应的，悲观锁是由数据库自己实现了的，要用的时候，我们直接调用数据库的相关语句就可以了。    说到这里，由悲观锁涉及到的另外两个锁概念就出来了，它们就是共享锁与排它锁。共享锁和排它锁是悲观锁的不同的实现，它俩都属于悲观锁的范畴。使用，排它锁 举例    要使用悲观锁，我们必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。我们可以使用命令设置MySQL为非autocommit模式：</code></pre><pre class=" language-sql"><code class="language-sql"><span class="token keyword">set</span> autocommit<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"># 设置完autocommit后，我们就可以执行我们的正常业务了。具体如下：</span><span class="token comment" spellcheck="true"># 1. 开始事务</span><span class="token keyword">begin</span><span class="token punctuation">;</span><span class="token operator">/</span><span class="token keyword">begin</span> <span class="token keyword">work</span><span class="token punctuation">;</span><span class="token operator">/</span><span class="token keyword">start</span> <span class="token keyword">transaction</span><span class="token punctuation">;</span> <span class="token punctuation">(</span>三者选一就可以<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 2. 查询表信息</span><span class="token keyword">select</span> <span class="token keyword">status</span> <span class="token keyword">from</span> <span class="token keyword">TABLE</span> <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token number">1</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"># 3. 插入一条数据</span><span class="token keyword">insert</span> <span class="token keyword">into</span> <span class="token keyword">TABLE</span> <span class="token punctuation">(</span>id<span class="token punctuation">,</span><span class="token keyword">value</span><span class="token punctuation">)</span> <span class="token keyword">values</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"># 4. 修改数据为</span><span class="token keyword">update</span> <span class="token keyword">TABLE</span> <span class="token keyword">set</span> <span class="token keyword">value</span><span class="token operator">=</span><span class="token number">2</span> <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"># 5. 提交事务</span><span class="token keyword">commit</span><span class="token punctuation">;</span><span class="token operator">/</span><span class="token keyword">commit</span> <span class="token keyword">work</span><span class="token punctuation">;</span></code></pre><h4 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h4><pre><code>共享锁又称读锁 read lock，是读取操作创建的锁。其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排他锁。获得共享锁的事务只能读数据，不能修改数据打开第一个查询窗口</code></pre><pre class=" language-sql"><code class="language-sql"><span class="token keyword">begin</span><span class="token punctuation">;</span><span class="token operator">/</span><span class="token keyword">begin</span> <span class="token keyword">work</span><span class="token punctuation">;</span><span class="token operator">/</span><span class="token keyword">start</span> <span class="token keyword">transaction</span><span class="token punctuation">;</span> <span class="token punctuation">(</span>三者选一就可以<span class="token punctuation">)</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">TABLE</span> <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span> <span class="token keyword">lock</span> <span class="token operator">in</span> <span class="token keyword">share mode</span><span class="token punctuation">;</span></code></pre><p>然后在另一个查询窗口中，对id为1的数据进行更新</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">update</span> <span class="token keyword">TABLE</span> <span class="token keyword">set</span> name<span class="token operator">=</span><span class="token string">"www.souyunku.com"</span> <span class="token keyword">where</span> id <span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span></code></pre><pre><code>此时，操作界面进入了卡顿状态，过了超时间，提示错误信息如果在超时前，执行 commit，此更新语句就会成功。</code></pre><pre class=" language-sql"><code class="language-sql"><span class="token punctuation">[</span>SQL<span class="token punctuation">]</span><span class="token keyword">update</span> test_one <span class="token keyword">set</span> name<span class="token operator">=</span><span class="token string">"www.souyunku.com"</span> <span class="token keyword">where</span> id <span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">[</span>Err<span class="token punctuation">]</span> <span class="token number">1205</span> <span class="token operator">-</span> <span class="token keyword">Lock</span> wait timeout exceeded<span class="token punctuation">;</span> try restarting <span class="token keyword">transaction</span></code></pre><p>加上共享锁后，也提示错误信息</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">update</span> test_one <span class="token keyword">set</span> name<span class="token operator">=</span><span class="token string">"www.souyunku.com"</span> <span class="token keyword">where</span> id <span class="token operator">=</span><span class="token number">1</span> <span class="token keyword">lock</span> <span class="token operator">in</span> <span class="token keyword">share mode</span><span class="token punctuation">;</span><span class="token punctuation">[</span>SQL<span class="token punctuation">]</span><span class="token keyword">update</span> test_one <span class="token keyword">set</span> name<span class="token operator">=</span><span class="token string">"www.souyunku.com"</span> <span class="token keyword">where</span> id <span class="token operator">=</span><span class="token number">1</span> <span class="token keyword">lock</span> <span class="token operator">in</span> <span class="token keyword">share mode</span><span class="token punctuation">;</span><span class="token punctuation">[</span>Err<span class="token punctuation">]</span> <span class="token number">1064</span> <span class="token operator">-</span> You have an error <span class="token operator">in</span> your SQL syntax<span class="token punctuation">;</span> <span class="token keyword">check</span> the manual that corresponds <span class="token keyword">to</span> your MySQL server version <span class="token keyword">for</span> the <span class="token keyword">right</span> syntax <span class="token keyword">to</span> <span class="token keyword">use</span> near <span class="token string">'lock in share mode'</span> at line <span class="token number">1</span></code></pre><pre><code>    在查询语句后面增加 LOCK IN SHARE MODE，Mysql会对查询结果中的每行都加共享锁，当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请共享锁，否则会被阻塞。其他线程也可以读取使用了共享锁的表，而且这些线程读取的是同一个版本的数据。加上共享锁后，对于update,insert,delete语句会自动加排它锁。</code></pre><h4 id="排它锁"><a href="#排它锁" class="headerlink" title="排它锁"></a>排它锁</h4><pre><code>排他锁 exclusive lock（也叫writer lock）又称写锁。排它锁是悲观锁的一种实现，在上面悲观锁也介绍过。若事务 1 对数据对象A加上X锁，事务 1 可以读A也可以修改A，其他事务不能再对A加任何锁，直到事物 1 释放A上的锁。这保证了其他事务在事物 1 释放A上的锁之前不能再读取和修改A。排它锁会阻塞所有的排它锁和共享锁读取为什么要加读锁呢：防止数据在被读取的时候被别的线程加上写锁，使用方式：在需要执行的语句后面加上for update就可以了</code></pre><h4 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h4><pre><code>行锁又分共享锁和排他锁,由字面意思理解，就是给某一行加上锁，也就是一条记录加上锁。注意：行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁。共享锁：名词解释：共享锁又叫做读锁，所有的事务只能对其进行读操作不能写操作，加上共享锁后在事务结束之前其他事务只能再加共享锁，除此之外其他任何类型的锁都不能再加了。</code></pre><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">TABLE</span> <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token string">"1"</span> <span class="token keyword">lock</span> <span class="token operator">in</span> <span class="token keyword">share mode</span><span class="token punctuation">;</span> 结果集的数据都会加共享锁</code></pre><h4 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h4><pre><code>如何加表锁innodb 的行锁是在有索引的情况下,没有索引的表是锁定全表的.</code></pre><h4 id="Innodb中的行锁与表锁"><a href="#Innodb中的行锁与表锁" class="headerlink" title="Innodb中的行锁与表锁"></a>Innodb中的行锁与表锁</h4><pre><code>前面提到过，在Innodb引擎中既支持行锁也支持表锁，那么什么时候会锁住整张表，什么时候或只锁住一行呢？只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！在实际应用中，要特别注意InnoDB行锁的这一特性，不然的话，可能导致大量的锁冲突，从而影响并发性能。行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁。行级锁的缺点是：由于需要请求大量的锁资源，所以速度慢，内存消耗大。</code></pre><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><pre><code>死锁（Deadlock） 所谓死锁：是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。由于资源占用是互斥的，当某个进程提出申请资源后，使得有关进程在无外力协助下，永远分配不到必需的资源而无法继续运行，这就产生了一种特殊现象死锁。解除正在死锁的状态有两种方法：</code></pre><p><strong>第一种</strong>：</p><p>1.查询是否锁表</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">show</span> <span class="token keyword">OPEN</span> <span class="token keyword">TABLES</span> <span class="token keyword">where</span> In_use <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span></code></pre><p>2.查询进程（如果您有SUPER权限，您可以看到所有线程。否则，您只能看到您自己的线程）</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">show</span> processlist</code></pre><p><img src="//zongmansheng.club/2019/04/12/mysql-zhong-suo-de-li-jie/004.png" alt="004"></p><p>3.杀死进程id（就是上面命令的id列）</p><pre><code>kill id</code></pre><p><strong>第二种</strong>：</p><p>1：查看当前的事务</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> INFORMATION_SCHEMA<span class="token punctuation">.</span>INNODB_TRX<span class="token punctuation">;</span></code></pre><p>2：查看当前锁定的事务</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> INFORMATION_SCHEMA<span class="token punctuation">.</span>INNODB_LOCKS<span class="token punctuation">;</span></code></pre><p>3：查看当前等锁的事务</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> INFORMATION_SCHEMA<span class="token punctuation">.</span>INNODB_LOCK_WAITS<span class="token punctuation">;</span></code></pre><p>杀死进程</p><pre><code>kill 进程ID</code></pre><pre><code>如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。其次，进程运行推进顺序与速度不同，也可能产生死锁。产生死锁的四个必要条件：（1） 互斥条件：一个资源每次只能被一个进程使用。（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。（3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。虽然不能完全避免死锁，但可以使死锁的数量减至最少。将死锁减至最少可以增加事务的吞吐量并减少系统开销，因为只有很少的事务回滚，而回滚会取消事务执行的所有工作。由于死锁时回滚而由应用程序重新提交。下列方法有助于最大限度地降低死锁：（1）按同一顺序访问对象。（2）避免事务中的用户交互。（3）保持事务简短并在一个批处理中。（4）使用低隔离级别。（5）使用绑定连接。</code></pre><p>原文：<a href="https://segmentfault.com/a/1190000015815061" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015815061</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;//zongmansheng.club/2019/04/12/mysql-zhong-suo-de-li-jie/001.png&quot; alt=&quot;001&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;锁&quot;&gt;&lt;a href=&quot;#锁&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
      <category term="数据库" scheme="http://zongmansheng.club/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="乐观锁，悲观锁，共享锁，排它锁，行锁，表锁" scheme="http://zongmansheng.club/tags/%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%8C%E6%82%B2%E8%A7%82%E9%94%81%EF%BC%8C%E5%85%B1%E4%BA%AB%E9%94%81%EF%BC%8C%E6%8E%92%E5%AE%83%E9%94%81%EF%BC%8C%E8%A1%8C%E9%94%81%EF%BC%8C%E8%A1%A8%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>Swagger使用指南</title>
    <link href="http://zongmansheng.club/2019/04/11/swagger-shi-yong-zhi-nan/"/>
    <id>http://zongmansheng.club/2019/04/11/swagger-shi-yong-zhi-nan/</id>
    <published>2019-04-11T00:29:09.000Z</published>
    <updated>2019-04-13T13:29:38.979Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Swagger"><a href="#Swagger" class="headerlink" title="Swagger"></a>Swagger</h1><h4 id="1：认识Swagger"><a href="#1：认识Swagger" class="headerlink" title="1：认识Swagger"></a>1：认识Swagger</h4><pre><code>    Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。总体目标是使客户端和文件系统作为服务器以同样的速度来更新。文件的方法，参数和模型紧密集成到服务器端的代码，允许API来始终保持同步。</code></pre><h4 id="2：Maven依赖"><a href="#2：Maven依赖" class="headerlink" title="2：Maven依赖"></a>2：Maven依赖</h4><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>io.springfox<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>springfox-swagger2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.7.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>io.springfox<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>springfox-swagger-ui<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.7.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><h4 id="3：创建Swagger2配置类（springboot搭建）"><a href="#3：创建Swagger2配置类（springboot搭建）" class="headerlink" title="3：创建Swagger2配置类（springboot搭建）"></a>3：创建Swagger2配置类（springboot搭建）</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>zms<span class="token punctuation">.</span>cmsdemo<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>SpringApplication<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>SpringBootApplication<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Bean<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>EnableMBeanExport<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>jmx<span class="token punctuation">.</span>support<span class="token punctuation">.</span>RegistrationPolicy<span class="token punctuation">;</span><span class="token keyword">import</span> springfox<span class="token punctuation">.</span>documentation<span class="token punctuation">.</span>builders<span class="token punctuation">.</span>ApiInfoBuilder<span class="token punctuation">;</span><span class="token keyword">import</span> springfox<span class="token punctuation">.</span>documentation<span class="token punctuation">.</span>builders<span class="token punctuation">.</span>PathSelectors<span class="token punctuation">;</span><span class="token keyword">import</span> springfox<span class="token punctuation">.</span>documentation<span class="token punctuation">.</span>builders<span class="token punctuation">.</span>RequestHandlerSelectors<span class="token punctuation">;</span><span class="token keyword">import</span> springfox<span class="token punctuation">.</span>documentation<span class="token punctuation">.</span>service<span class="token punctuation">.</span>ApiInfo<span class="token punctuation">;</span><span class="token keyword">import</span> springfox<span class="token punctuation">.</span>documentation<span class="token punctuation">.</span>spi<span class="token punctuation">.</span>DocumentationType<span class="token punctuation">;</span><span class="token keyword">import</span> springfox<span class="token punctuation">.</span>documentation<span class="token punctuation">.</span>spring<span class="token punctuation">.</span>web<span class="token punctuation">.</span>plugins<span class="token punctuation">.</span>Docket<span class="token punctuation">;</span><span class="token keyword">import</span> springfox<span class="token punctuation">.</span>documentation<span class="token punctuation">.</span>swagger2<span class="token punctuation">.</span>annotations<span class="token punctuation">.</span>EnableSwagger2<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author ZongMan */</span><span class="token annotation punctuation">@EnableSwagger2</span><span class="token annotation punctuation">@SpringBootApplication</span><span class="token annotation punctuation">@EnableMBeanExport</span><span class="token punctuation">(</span>registration <span class="token operator">=</span> RegistrationPolicy<span class="token punctuation">.</span>IGNORE_EXISTING<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CmsDemoApplication</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>CmsDemoApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> Docket <span class="token function">cmsApi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Docket</span><span class="token punctuation">(</span>DocumentationType<span class="token punctuation">.</span>SWAGGER_2<span class="token punctuation">)</span>               <span class="token punctuation">.</span><span class="token function">apiInfo</span><span class="token punctuation">(</span><span class="token function">testApiInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>               <span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span>               <span class="token punctuation">.</span><span class="token function">apis</span><span class="token punctuation">(</span>RequestHandlerSelectors<span class="token punctuation">.</span><span class="token function">basePackage</span><span class="token punctuation">(</span><span class="token string">"com.zms.cmsdemo.controller"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>               <span class="token punctuation">.</span><span class="token function">paths</span><span class="token punctuation">(</span>PathSelectors<span class="token punctuation">.</span><span class="token function">any</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>               <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> ApiInfo <span class="token function">testApiInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ApiInfoBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">title</span><span class="token punctuation">(</span><span class="token string">"咨询信息模块"</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">description</span><span class="token punctuation">(</span><span class="token string">"公共平台接口，主要用于测试."</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">termsOfServiceUrl</span><span class="token punctuation">(</span><span class="token string">"http:127.0.0.1:8080/cms"</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">version</span><span class="token punctuation">(</span><span class="token string">"1.0"</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="4：添加文档内容"><a href="#4：添加文档内容" class="headerlink" title="4：添加文档内容"></a>4：添加文档内容</h4><pre><code>Swagger使用的注解及其说明：@Api：用在类上，说明该类的作用。@ApiOperation：注解来给API增加方法说明。@ApiImplicitParams : 用在方法上包含一组参数说明。@ApiImplicitParam：用来注解来给方法入参增加说明。@ApiResponses：用于表示一组响应@ApiResponse：用在@ApiResponses中，一般用于表达一个错误的响应信息   code：数字，例如400   message：信息，例如&quot;请求参数没填好&quot;   response：抛出异常的类   @ApiModel：描述一个Model的信息（一般用在请求参数无法使用@ApiImplicitParam注解进行描述的时候）   @ApiModelProperty：描述一个model的属性</code></pre><p>注意：@ApiImplicitParam的参数说明：</p><p><img src="//zongmansheng.club/2019/04/11/swagger-shi-yong-zhi-nan/001.png" alt="001"></p><h5 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h5><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>zms<span class="token punctuation">.</span>cmsdemo<span class="token punctuation">.</span>controller<span class="token punctuation">;</span><span class="token keyword">import</span> io<span class="token punctuation">.</span>swagger<span class="token punctuation">.</span>annotations<span class="token punctuation">.</span>Api<span class="token punctuation">;</span><span class="token keyword">import</span> io<span class="token punctuation">.</span>swagger<span class="token punctuation">.</span>annotations<span class="token punctuation">.</span>ApiImplicitParam<span class="token punctuation">;</span><span class="token keyword">import</span> io<span class="token punctuation">.</span>swagger<span class="token punctuation">.</span>annotations<span class="token punctuation">.</span>ApiOperation<span class="token punctuation">;</span><span class="token keyword">import</span> io<span class="token punctuation">.</span>swagger<span class="token punctuation">.</span>annotations<span class="token punctuation">.</span>ApiResponse<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span>Logger<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span>LoggerFactory<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span>Controller<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>PathVariable<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>RequestMapping<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>RequestMethod<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>ResponseBody<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author ZongMan * @version 1.0 * @date 2019/4/12 0012 11:30 */</span><span class="token annotation punctuation">@Api</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/750p"</span><span class="token punctuation">,</span>description <span class="token operator">=</span> <span class="token string">"咨询信息的Controller"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Controller</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"750/p"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CmsController</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Logger LOGGER <span class="token operator">=</span> LoggerFactory<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span>CmsController<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 添加咨询信息     * @return     */</span>    <span class="token annotation punctuation">@ApiOperation</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"添加咨询信息"</span><span class="token punctuation">,</span>notes <span class="token operator">=</span> <span class="token string">"添加咨询信息"</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@ApiImplicitParam</span><span class="token punctuation">(</span>paramType<span class="token operator">=</span><span class="token string">"xxx"</span><span class="token punctuation">,</span>name <span class="token operator">=</span> <span class="token string">"咨询信息实体"</span><span class="token punctuation">,</span>value <span class="token operator">=</span> <span class="token string">"咨询信息实体"</span><span class="token punctuation">,</span>required <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">,</span>dataType <span class="token operator">=</span> <span class="token string">"实体类型"</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@ApiResponse</span><span class="token punctuation">(</span>code <span class="token operator">=</span> <span class="token number">001</span><span class="token operator">-</span><span class="token number">000</span><span class="token operator">-</span><span class="token number">001</span><span class="token punctuation">,</span>message <span class="token operator">=</span> <span class="token string">"添加咨询信息失败"</span><span class="token punctuation">,</span>response <span class="token operator">=</span> CmsController<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"addConOne"</span><span class="token punctuation">,</span>method <span class="token operator">=</span> RequestMethod<span class="token punctuation">.</span>POST<span class="token punctuation">)</span>    <span class="token annotation punctuation">@ResponseBody</span>    <span class="token keyword">public</span> String <span class="token function">addConOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"添加成功"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"deleteConOne/{id}"</span><span class="token punctuation">,</span>method <span class="token operator">=</span> RequestMethod<span class="token punctuation">.</span>DELETE<span class="token punctuation">)</span>    <span class="token annotation punctuation">@ResponseBody</span>    <span class="token keyword">public</span> String <span class="token function">deleteConOne</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span> String id<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token string">"删除成功"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>启动Spring Boot程序，访问：<a href="http://localhost:8080/swagger-ui.html" target="_blank" rel="noopener">http://localhost:8080/swagger-ui.html</a></p><p><img src="//zongmansheng.club/2019/04/11/swagger-shi-yong-zhi-nan/002.png" alt="002"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Swagger&quot;&gt;&lt;a href=&quot;#Swagger&quot; class=&quot;headerlink&quot; title=&quot;Swagger&quot;&gt;&lt;/a&gt;Swagger&lt;/h1&gt;&lt;h4 id=&quot;1：认识Swagger&quot;&gt;&lt;a href=&quot;#1：认识Swagger&quot; class=&quot;he
      
    
    </summary>
    
      <category term="日常学习" scheme="http://zongmansheng.club/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Swagger" scheme="http://zongmansheng.club/tags/Swagger/"/>
    
      <category term="在线文档" scheme="http://zongmansheng.club/tags/%E5%9C%A8%E7%BA%BF%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title>装饰者设计模式</title>
    <link href="http://zongmansheng.club/2019/04/10/zhuang-shi-zhe-she-ji-mo-shi/"/>
    <id>http://zongmansheng.club/2019/04/10/zhuang-shi-zhe-she-ji-mo-shi/</id>
    <published>2019-04-10T09:35:12.000Z</published>
    <updated>2019-04-13T14:19:08.466Z</updated>
    
    <content type="html"><![CDATA[<h1 id="装饰者设计模式"><a href="#装饰者设计模式" class="headerlink" title="装饰者设计模式"></a>装饰者设计模式</h1><h4 id="一、装饰者模式的概念"><a href="#一、装饰者模式的概念" class="headerlink" title="一、装饰者模式的概念"></a>一、装饰者模式的概念</h4><p>​    装饰者模式又名包装(Wrapper)模式。装饰者模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案。</p><h4 id="二、装饰者模式的结构"><a href="#二、装饰者模式的结构" class="headerlink" title="二、装饰者模式的结构"></a>二、装饰者模式的结构</h4><p>​    装饰者模式以对客户透明的方式动态地给一个对象附加上更多的责任。换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。装饰者模式可以在不使用创造更多子类的情况下，将对象的功能加以扩展。<img src="//zongmansheng.club/2019/04/10/zhuang-shi-zhe-she-ji-mo-shi/个人学习文档\装饰者设计模式\Snipaste_2019-01-14_22-44-24.png" alt="Snipaste_2019-01-14_22-44-24"></p><p>在装饰模式中的角色有：</p><p>●　　抽象构件(Component)角色：给出一个抽象接口，以规范准备接收附加责任的对象。</p><p>●　　具体构件(ConcreteComponent)角色：定义一个将要接收附加责任的类。</p><p>●　　装饰(Decorator)角色：持有一个构件(Component)对象的实例，并定义一个与抽象构件接口一致的接口。</p><p>●　　具体装饰(ConcreteDecorator)角色：负责给构件对象“贴上”附加的责任。</p><h4 id="三、装饰者模式实例演示"><a href="#三、装饰者模式实例演示" class="headerlink" title="三、装饰者模式实例演示"></a>三、装饰者模式实例演示</h4><h5 id="齐天大圣的例子"><a href="#齐天大圣的例子" class="headerlink" title="齐天大圣的例子"></a>齐天大圣的例子</h5><p>​    孙悟空有七十二般变化，他的每一种变化都给他带来一种附加的本领。他变成鱼儿时，就可以到水里游泳；他变成鸟儿时，就可以在天上飞行。</p><p>​    本例中，Component的角色便由鼎鼎大名的齐天大圣扮演；ConcreteComponent的角色属于大圣的本尊，就是猢狲本人；Decorator的角色由大圣的七十二变扮演。而ConcreteDecorator的角色便是鱼儿、鸟儿等七十二般变化</p><p><img src="//zongmansheng.club/2019/04/10/zhuang-shi-zhe-she-ji-mo-shi/Snipaste_2019-01-14_22-47-58.png" alt="Snipaste_2019-01-14_22-47-58"></p><h4 id="四、装饰者模式的优缺点"><a href="#四、装饰者模式的优缺点" class="headerlink" title="四、装饰者模式的优缺点"></a>四、装饰者模式的优缺点</h4><h5 id="装饰模式的优点"><a href="#装饰模式的优点" class="headerlink" title="装饰模式的优点"></a>装饰模式的优点</h5><p>（1）装饰模式与继承关系的目的都是要扩展对象的功能，但是装饰模式可以提供比继承更多的灵活性。装    饰模式允许系统动态决定“贴上”一个需要的“装饰”，或者除掉一个不需要的“装饰”。继承关系则不同，继承关系是静态的，它在系统运行前就决定了。</p><p>（2）通过使用不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的组合。</p><h5 id="装饰模式的缺点"><a href="#装饰模式的缺点" class="headerlink" title="装饰模式的缺点"></a>装饰模式的缺点</h5><p>由于使用装饰模式，可以比使用继承关系需要较少数目的类。使用较少的类，当然使设计比较易于进行。但是，在另一方面，使用装饰模式会产生比使用继承关系更多的对象。更多的对象会使得查错变得困难，特别是这些对象看上去都很相像。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;装饰者设计模式&quot;&gt;&lt;a href=&quot;#装饰者设计模式&quot; class=&quot;headerlink&quot; title=&quot;装饰者设计模式&quot;&gt;&lt;/a&gt;装饰者设计模式&lt;/h1&gt;&lt;h4 id=&quot;一、装饰者模式的概念&quot;&gt;&lt;a href=&quot;#一、装饰者模式的概念&quot; class=&quot;head
      
    
    </summary>
    
      <category term="设计模式" scheme="http://zongmansheng.club/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Wrapper，装饰者" scheme="http://zongmansheng.club/tags/Wrapper%EF%BC%8C%E8%A3%85%E9%A5%B0%E8%80%85/"/>
    
  </entry>
  
  <entry>
    <title>单例设计模式</title>
    <link href="http://zongmansheng.club/2019/04/09/dan-li-she-ji-mo-shi/"/>
    <id>http://zongmansheng.club/2019/04/09/dan-li-she-ji-mo-shi/</id>
    <published>2019-04-09T12:04:33.000Z</published>
    <updated>2019-04-13T14:08:01.054Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单例的几种写法"><a href="#单例的几种写法" class="headerlink" title="单例的几种写法"></a>单例的几种写法</h1><h4 id="第一种写法（饿汉式-可用）"><a href="#第一种写法（饿汉式-可用）" class="headerlink" title="第一种写法（饿汉式 可用）"></a>第一种写法（饿汉式 可用）</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019/1/23 0023 * @Time: 8:42 * @Vsersion: 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingletonDemo01</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 单例模式第一种写法：     * 饿汉式（静态常量）     */</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> SingletonDemo01 INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingletonDemo01</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">SingletonDemo01</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> SingletonDemo01 <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> INSTANCE<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>优点：写法比较简单，在类装载的时候就进行实例化，避免了线程同步的问题缺点：在类装载的时候就完成实例化，没有达到Lazy Loading的效果，如果从始至终都没有使用这个实例，就会造成内存的浪费。</code></pre><h4 id="第二种写法（饿汉式-可用）"><a href="#第二种写法（饿汉式-可用）" class="headerlink" title="第二种写法（饿汉式 可用）"></a>第二种写法（饿汉式 可用）</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019/1/23 0023 * @Time: 8:52 * @Vsersion: 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingletonDemo02</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 单例模式第二种写法：     * 静态代码块     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> SingletonDemo02 instance<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingletonDemo02</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">SingletonDemo02</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> SingletonDemo02 <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>优缺点同上</code></pre><h4 id="第三种写法（懒汉式-线程不安全、不可用）"><a href="#第三种写法（懒汉式-线程不安全、不可用）" class="headerlink" title="第三种写法（懒汉式 线程不安全、不可用）"></a>第三种写法（懒汉式 线程不安全、不可用）</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019/1/23 0023 * @Time: 8:56 * @Vsersion: 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingletonDemo03</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 单例模式的第三种写法     * 懒汉式（线程不安全）     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> SingletonDemo03 singleton<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">SingletonDemo03</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> SingletonDemo03 <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>            singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingletonDemo03</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>这种写法起到了Lazy Loading的效果，但是只能在单线程下使用。如果在多线程下，一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式。</code></pre><h4 id="第四种写法（懒汉式-线程安全、同步方法）"><a href="#第四种写法（懒汉式-线程安全、同步方法）" class="headerlink" title="第四种写法（懒汉式 线程安全、同步方法）"></a>第四种写法（懒汉式 线程安全、同步方法）</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019/1/23 0023 * @Time: 9:01 * @Vsersion: 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingletonDemo04</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 单例的第四种写法     * 线程安全 同步方法     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> SingletonDemo04 singleton<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">SingletonDemo04</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> SingletonDemo04 <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingletonDemo04</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>    解决上面第三种实现方式的线程不安全问题，做个线程同步就可以了，于是就对getInstance()方法进行了线程同步。缺点：效率太低了，每个线程在想获得类的实例时候，执行getInstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接return就行了。方法进行同步效率太低要改进。</code></pre><h4 id="第五种写法（懒汉式-线程安全、同步代码块）"><a href="#第五种写法（懒汉式-线程安全、同步代码块）" class="headerlink" title="第五种写法（懒汉式 线程安全、同步代码块）"></a>第五种写法（懒汉式 线程安全、同步代码块）</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019/1/23 0023 * @Time: 9:04 * @Vsersion: 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingletonDemo05</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 第五种：懒汉式     * 线程安全 同步代码块 不可用     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> SingletonDemo05 singleton<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">SingletonDemo05</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> SingletonDemo05 <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>SingletonDemo05<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingletonDemo05</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>    由于第四种实现方式同步效率太低，所以摒弃同步方法，改为同步产生实例化的的代码块。但是这种同步并不能起到线程同步的作用。跟第3种实现方式遇到的情形一致，假如一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。</code></pre><h4 id="第六种写法（双重检查-推荐使用）"><a href="#第六种写法（双重检查-推荐使用）" class="headerlink" title="第六种写法（双重检查  推荐使用）"></a>第六种写法（双重检查  推荐使用）</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019/1/23 0023 * @Time: 9:08 * @Vsersion: 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingletonDemo06</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 第六种：双重检查     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> SingletonDemo06 singleton<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">SingletonDemo06</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> SingletonDemo06 <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>SingletonDemo06<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingletonDemo06</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>    Double-Check概念对于多线程开发者来说不会陌生，如代码中所示，我们进行了两次if (singleton == null)检查，这样就可以保证线程安全了。这样，实例化代码只用执行一次，后面再次访问时，判断if (singleton == null)，直接return实例化对象。优点：线程安全；延迟加载；效率较高。</code></pre><h4 id="第七种写法（静态内部类-推荐使用）"><a href="#第七种写法（静态内部类-推荐使用）" class="headerlink" title="第七种写法（静态内部类    推荐使用）"></a>第七种写法（静态内部类    推荐使用）</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019/1/23 0023 * @Time: 9:11 * @Vsersion: 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingletonDemo07</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 静态内部类     */</span>    <span class="token keyword">private</span> <span class="token function">SingletonDemo07</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SingletonInstance</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> SingletonDemo07 INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingletonDemo07</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> SingletonDemo07 <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> SingletonInstance<span class="token punctuation">.</span>INSTANCE<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>    这种方式跟饿汉式方式采用的机制类似，但又有不同。两者都是采用了类装载的机制来保证初始化实例时只有一个线程。不同的地方在饿汉式方式是只要Singleton类被装载就会实例化，没有Lazy-Loading的作用，而静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化时，调用getInstance方法，才会装载SingletonInstance类，从而完成Singleton的实例化。    类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。优点：避免了线程不安全，延迟加载，效率高。</code></pre><h4 id="第八种写法（枚举-推荐用）"><a href="#第八种写法（枚举-推荐用）" class="headerlink" title="第八种写法（枚举 推荐用）"></a>第八种写法（枚举 推荐用）</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019/1/23 0023 * @Time: 9:14 * @Vsersion: 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingletonDemo08</span> <span class="token punctuation">{</span>    INSTANCE<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">whateverMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。可能是因为枚举在JDK1.5中才添加，所以在实际项目开发中，很少见人这么写过。优点系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能。缺点当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用new，可能会给其他开发人员造成困扰，特别是看不到源码的时候。适用场合需要频繁的进行创建和销毁的对象；创建对象时耗时过多或耗费资源过多，但又经常用到的对象；工具类对象；频繁访问数据库或文件的对象。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;单例的几种写法&quot;&gt;&lt;a href=&quot;#单例的几种写法&quot; class=&quot;headerlink&quot; title=&quot;单例的几种写法&quot;&gt;&lt;/a&gt;单例的几种写法&lt;/h1&gt;&lt;h4 id=&quot;第一种写法（饿汉式-可用）&quot;&gt;&lt;a href=&quot;#第一种写法（饿汉式-可用）&quot; class
      
    
    </summary>
    
      <category term="设计模式" scheme="http://zongmansheng.club/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式，singleton" scheme="http://zongmansheng.club/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8Csingleton/"/>
    
  </entry>
  
  <entry>
    <title>http的各种状态</title>
    <link href="http://zongmansheng.club/2019/04/08/http-de-ge-chong-zhuang-tai/"/>
    <id>http://zongmansheng.club/2019/04/08/http-de-ge-chong-zhuang-tai/</id>
    <published>2019-04-08T14:08:20.000Z</published>
    <updated>2019-04-13T14:13:55.523Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h1><pre><code>HTTP状态码（HTTP Status Code）是用以表示网页服务器HTTP响应状态的3位数字代码。我们可以通过查看HTTP状态码来判断服务器状态，常见的有404 、502等；但是其他不是很常见的状态码都代表什么状态呢？下面有两张有趣的图片，让你瞬间都能理解了。</code></pre><p><img src="http的各种状态\Snipaste_2019-01-18_08-34-19.png" alt="Snipaste_2019-01-18_08-34-19"></p><pre><code>301—永久移动。被请求的资源已被永久移动位置；302—请求的资源现在临时从不同的 URI 响应请求；305—使用代理。被请求的资源必须通过指定的代理才能被访问；307—临时跳转。被请求的资源在临时从不同的URL响应请求；400—错误请求；402—需要付款。该状态码是为了将来可能的需求而预留的，用于一些数字货币或者是微支付；403—禁止访问。服务器已经理解请求，但是拒绝执行它；404—找不到对象。请求失败，资源不存在；406—不可接受的。请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体；</code></pre><p><img src="http的各种状态\Snipaste_2019-01-18_08-36-12.png" alt="Snipaste_2019-01-18_08-36-12"></p><pre><code>408—请求超时；409—冲突。由于和被请求的资源的当前状态之间存在冲突，请求无法完成；410—遗失的。被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址；413—响应实体太大。服务器拒绝处理当前请求，请求超过服务器所能处理和允许的最大值。417—期望失败。在请求头 Expect 中指定的预期内容无法被服务器满足；418—我是一个茶壶。超文本咖啡罐控制协议，但是并没有被实际的HTTP服务器实现；420—方法失效。422—不可处理的实体。请求格式正确，但是由于含有语义错误，无法响应；500—服务器内部错误。服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理；</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HTTP状态码&quot;&gt;&lt;a href=&quot;#HTTP状态码&quot; class=&quot;headerlink&quot; title=&quot;HTTP状态码&quot;&gt;&lt;/a&gt;HTTP状态码&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;HTTP状态码（HTTP Status Code）是用以表示网页服务器HTTP响应状
      
    
    </summary>
    
      <category term="计算机网络" scheme="http://zongmansheng.club/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="http" scheme="http://zongmansheng.club/tags/http/"/>
    
      <category term="状态码" scheme="http://zongmansheng.club/tags/%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Netty相关知识</title>
    <link href="http://zongmansheng.club/2019/04/08/netty-xiang-guan-zhi-shi/"/>
    <id>http://zongmansheng.club/2019/04/08/netty-xiang-guan-zhi-shi/</id>
    <published>2019-04-08T12:42:53.000Z</published>
    <updated>2019-04-08T14:31:01.730Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Netty相关知识"><a href="#Netty相关知识" class="headerlink" title="Netty相关知识"></a>Netty相关知识</h1><h4 id="1-Netty简介"><a href="#1-Netty简介" class="headerlink" title="1.Netty简介"></a>1.Netty简介</h4><pre><code>Netty是由JBOSS提供的一个java开源框架。    Netty是一个高性能、异步事件驱动的NIO框架，它提供了对TCP、UDP和文件传输的支持。作为当前最流行的NIO框架，Netty在互联网领域、大数据分布式计算领域、游戏行业、通信行业等获得了广泛的应用，一些业界著名的开源组件也基于Netty的NIO框架构建</code></pre><h4 id="2-Netty的特点"><a href="#2-Netty的特点" class="headerlink" title="2.Netty的特点"></a>2.Netty的特点</h4><h5 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h5><pre><code>Netty是一款基于NIO（Nonblocking I/O，非阻塞IO）开发的网络通信框架，对比于BIO（Blocking I/O，阻塞IO），他的并发性能得到了很大提高 。</code></pre><h5 id="传输快"><a href="#传输快" class="headerlink" title="传输快"></a>传输快</h5><pre><code>Netty的传输快其实也是依赖了NIO的一个特性——零拷贝。</code></pre><h5 id="封装好"><a href="#封装好" class="headerlink" title="封装好"></a>封装好</h5><pre><code>Netty封装了NIO操作的很多细节，提供易于使用的API。</code></pre><h4 id="3-为什么选择Netty"><a href="#3-为什么选择Netty" class="headerlink" title="3.为什么选择Netty"></a>3.为什么选择Netty</h4><pre><code>JDK 原生也有一套网络应用程序 API，但是存在一系列问题，主要如下：1）NIO 的类库和 API 繁杂，使用麻烦：你需要熟练掌握 Selector、ServerSocketChannel、SocketChannel、ByteBuffer 等。2）需要具备其他的额外技能做铺垫：例如熟悉 Java 多线程编程，因为 NIO 编程涉及到 Reactor 模式，你必须对多线程和网路编程非常熟悉，才能编写出高质量的 NIO 程序。3）可靠性能力补齐，开发工作量和难度都非常大：例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常码流的处理等等。NIO 编程的特点是功能开发相对容易，但是可靠性能力补齐工作量和难度都非常大。4）JDK NIO 的 Bug：例如臭名昭著的 Epoll Bug，它会导致 Selector 空轮询，最终导致 CPU 100%。官方声称在 JDK 1.6 版本的 update 18 修复了该问题，但是直到 JDK 1.7 版本该问题仍旧存在，只不过该 Bug 发生概率降低了一些而已，它并没有被根本解决。</code></pre><h4 id="4-Netty框架的优势"><a href="#4-Netty框架的优势" class="headerlink" title="4.Netty框架的优势"></a>4.Netty框架的优势</h4><pre><code>API使用简单，开发门槛低；功能强大，预置了多种编解码功能，支持多种主流协议；定制能力强，可以通过ChannelHandler对通信框架进行灵活地扩展；性能高，通过与其他业界主流的NIO框架对比，Netty的综合性能最优；成熟、稳定，Netty修复了已经发现的所有JDK NIO BUG，业务开发人员不需要再为NIO的BUG而烦恼；社区活跃，版本迭代周期短，发现的BUG可以被及时修复，同时，更多的新功能会加入；经历了大规模的商业应用考验，质量得到验证。在互联网、大数据、网络游戏、企业应用、电信软件等众多行业得到成功商用，证明了它已经完全能够满足不同行业的商业应用了。</code></pre><h4 id="5-Netty的架构设计"><a href="#5-Netty的架构设计" class="headerlink" title="5.Netty的架构设计"></a>5.Netty的架构设计</h4><h5 id="总体结构"><a href="#总体结构" class="headerlink" title="总体结构"></a>总体结构</h5><p>Netty 采用了比较典型的三层网络架构进行设计，逻辑架构图如下所示：</p><p><img src="//zongmansheng.club/2019/04/08/netty-xiang-guan-zhi-shi/002.png" alt="002"></p><pre><code>1）传输服务：支持 BIO 和 NIO；2）容器集成：支持 OSGI、JBossMC、Spring、Guice 容器；3）协议支持：HTTP、Protobuf、二进制、文本、WebSocket 等一系列常见协议都支持。还支持通过实行编码解码逻辑来实现自定义协议；4）Core 核心：可扩展事件模型、通用通信 API、支持零拷贝的 ByteBuf 缓冲对象。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Netty相关知识&quot;&gt;&lt;a href=&quot;#Netty相关知识&quot; class=&quot;headerlink&quot; title=&quot;Netty相关知识&quot;&gt;&lt;/a&gt;Netty相关知识&lt;/h1&gt;&lt;h4 id=&quot;1-Netty简介&quot;&gt;&lt;a href=&quot;#1-Netty简介&quot; class
      
    
    </summary>
    
      <category term="日常学习" scheme="http://zongmansheng.club/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Netty" scheme="http://zongmansheng.club/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>HashMap</title>
    <link href="http://zongmansheng.club/2019/04/07/hashmap/"/>
    <id>http://zongmansheng.club/2019/04/07/hashmap/</id>
    <published>2019-04-07T13:10:38.000Z</published>
    <updated>2019-04-17T14:42:09.969Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HashMap简介"><a href="#HashMap简介" class="headerlink" title="HashMap简介"></a>HashMap简介</h1><pre><code>HashMap 主要用来存放键值对，它基于哈希表的Map接口实现&lt;/font&gt;，是常用的Java集合之一。 JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树，以减少搜索时间。</code></pre><h2 id="底层数据结构分析"><a href="#底层数据结构分析" class="headerlink" title="底层数据结构分析"></a>底层数据结构分析</h2><h4 id="JDK1-8之前"><a href="#JDK1-8之前" class="headerlink" title="JDK1.8之前"></a>JDK1.8之前</h4><pre><code>JDK1.8 之前 HashMap 底层是 数组和链表 结合在一起使用也就是 链表散列。HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash  值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。JDK 1.8 HashMap 的 hash 方法源码:JDK 1.8 的 hash方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。</code></pre><pre class=" language-java"><code class="language-java">  <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> h<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// key.hashCode()：返回散列值也就是hashcode</span>        <span class="token comment" spellcheck="true">// ^ ：按位异或</span>        <span class="token comment" spellcheck="true">// >>>:无符号右移，忽略符号位，空位都以0补齐</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>对比一下 JDK1.7的 HashMap 的 hash 方法源码.</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// This function ensures that hashCodes that differ only by</span>    <span class="token comment" spellcheck="true">// constant multiples at each bit position have a bounded</span>    <span class="token comment" spellcheck="true">// number of collisions (approximately 8 at default load factor).</span>    h <span class="token operator">^=</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> h <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre><code>相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。所谓 “拉链法” 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</code></pre><p><img src="//zongmansheng.club/2019/04/07/hashmap/001.png" alt="001"></p><h4 id="JDK1-8之后"><a href="#JDK1-8之后" class="headerlink" title="JDK1.8之后"></a>JDK1.8之后</h4><pre><code>    相比于之前的版本，jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</code></pre><p><img src="//zongmansheng.club/2019/04/07/hashmap/002.png" alt="002"></p><p>类的属性：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractMap</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Map</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">,</span> Cloneable<span class="token punctuation">,</span> Serializable <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 序列号</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 362498820763181265L<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 默认的初始容量是16</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_INITIAL_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 最大容量</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAXIMUM_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 默认的填充因子</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">float</span> DEFAULT_LOAD_FACTOR <span class="token operator">=</span> <span class="token number">0.75f</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 当桶(bucket)上的结点数大于这个值时会转成红黑树</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 当桶(bucket)上的结点数小于这个值时树转链表</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> UNTREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 桶中结构转化为红黑树对应的table的最小大小</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MIN_TREEIFY_CAPACITY <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 存储元素的数组，总是2的幂次倍</span>    <span class="token keyword">transient</span> Node<span class="token operator">&lt;</span>k<span class="token punctuation">,</span>v<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 存放具体元素的集</span>    <span class="token keyword">transient</span> Set<span class="token operator">&lt;</span>map<span class="token punctuation">.</span>entry<span class="token operator">&lt;</span>k<span class="token punctuation">,</span>v<span class="token operator">>></span> entrySet<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 存放元素的个数，注意这个不等于数组的长度。</span>    <span class="token keyword">transient</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 每次扩容和更改map结构的计数器</span>    <span class="token keyword">transient</span> <span class="token keyword">int</span> modCount<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容</span>    <span class="token keyword">int</span> threshold<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 填充因子</span>    <span class="token keyword">final</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre><code>- loadFactor加载因子  loadFactor加载因子是控制数组存放数据的疏密程度，loadFactor越趋近于1，那么   数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，load   Factor越小，也就是趋近于0，  loadFactor太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor的默认值为0.75f是官方给出的一个比较好的临界值。   给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 = 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。- threshold  threshold = capacity * loadFactor，当Size&gt;=threshold的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是 衡量数组是否需要扩增的一个标准。</code></pre><p>Node节点类源码:</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 继承自 Map.Entry&lt;K,V></span><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token punctuation">{</span>       <span class="token keyword">final</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 哈希值，存放元素到hashmap中时用来与其他元素hash值比较</span>       <span class="token keyword">final</span> K key<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//键</span>       V value<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//值</span>       <span class="token comment" spellcheck="true">// 指向下一个节点</span>       Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">;</span>       <span class="token function">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>hash <span class="token operator">=</span> hash<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> K <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span> <span class="token keyword">return</span> key<span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> V <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span> <span class="token keyword">return</span> value<span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> key <span class="token operator">+</span> <span class="token string">"="</span> <span class="token operator">+</span> value<span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 重写hashCode()方法</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> Objects<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">^</span> Objects<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> V <span class="token function">setValue</span><span class="token punctuation">(</span>V newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>            V oldValue <span class="token operator">=</span> value<span class="token punctuation">;</span>            value <span class="token operator">=</span> newValue<span class="token punctuation">;</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 重写 equals() 方法</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token keyword">this</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token keyword">instanceof</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token operator">></span> e <span class="token operator">=</span> <span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">)</span>o<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>Objects<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                    Objects<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>树节点类源码:</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">TreeNode</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token punctuation">{</span>        TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> parent<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 父</span>        TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> left<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 左</span>        TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> right<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 右</span>        TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> prev<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// needed to unlink next upon deletion</span>        <span class="token keyword">boolean</span> red<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 判断颜色</span>        <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V val<span class="token punctuation">,</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">super</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 返回根节点</span>        <span class="token keyword">final</span> TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">root</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> r <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">,</span> p<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> r<span class="token punctuation">.</span>parent<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>                    <span class="token keyword">return</span> r<span class="token punctuation">;</span>                r <span class="token operator">=</span> p<span class="token punctuation">;</span>       <span class="token punctuation">}</span></code></pre><h2 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="HashMap源码分析"></a>HashMap源码分析</h2><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p><img src="//zongmansheng.club/2019/04/07/hashmap/003.png" alt="003"></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 默认构造函数。</span>    <span class="token keyword">public</span> More <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> DEFAULT_LOAD_FACTOR<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// all   other fields defaulted</span>     <span class="token punctuation">}</span>     <span class="token comment" spellcheck="true">// 包含另一个“Map”的构造函数</span>     <span class="token keyword">public</span> More <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">HashMap</span><span class="token punctuation">(</span>Map<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token operator">></span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> DEFAULT_LOAD_FACTOR<span class="token punctuation">;</span>         <span class="token function">putMapEntries</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//下面会分析到这个方法</span>     <span class="token punctuation">}</span>     <span class="token comment" spellcheck="true">// 指定“容量大小”的构造函数</span>     <span class="token keyword">public</span> More <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">this</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">,</span> DEFAULT_LOAD_FACTOR<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token comment" spellcheck="true">// 指定“容量大小”和“加载因子”的构造函数</span>     <span class="token keyword">public</span> More <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>             <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal initial capacity: "</span> <span class="token operator">+</span> initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">></span> MAXIMUM_CAPACITY<span class="token punctuation">)</span>             initialCapacity <span class="token operator">=</span> MAXIMUM_CAPACITY<span class="token punctuation">;</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>loadFactor <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> Float<span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span>loadFactor<span class="token punctuation">)</span><span class="token punctuation">)</span>             <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal load factor: "</span> <span class="token operator">+</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> loadFactor<span class="token punctuation">;</span>         <span class="token keyword">this</span><span class="token punctuation">.</span>threshold <span class="token operator">=</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span></code></pre><p>putMapEntries方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">putMapEntries</span><span class="token punctuation">(</span>Map<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token operator">></span> m<span class="token punctuation">,</span> <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> s <span class="token operator">=</span> m<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 判断table是否已经初始化</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>table <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// pre-size</span>            <span class="token comment" spellcheck="true">// 未初始化，s为m的实际元素个数</span>            <span class="token keyword">float</span> ft <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>s <span class="token operator">/</span> loadFactor<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1.0F</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ft <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token operator">?</span>                    <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>ft <span class="token operator">:</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 计算得到的t大于阈值，则初始化阈值</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">></span> threshold<span class="token punctuation">)</span>                threshold <span class="token operator">=</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 已初始化，并且m元素个数大于阈值，进行扩容处理</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">></span> threshold<span class="token punctuation">)</span>            <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 将m中的所有元素添加至HashMap中</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token operator">></span> e <span class="token operator">:</span> m<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            K key <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            V value <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> evict<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h4><pre><code>HashMap只提供了put用于添加元素，putVal方法只是给put方法调用的一个方法，并没有提供给用户使用。对putVal方法添加元素的分析如下：    - ①如果定位到的数组位置没有元素 就直接插入。    - ②如果定位到的数组位置有元素就和要插入的key比较，如果key相同就直接覆盖，如果key不相同，就判断p是否是一个树节点，如果是就调用e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)将元素添加进入。如果不是就遍历链表插入。</code></pre><p><img src="//zongmansheng.club/2019/04/07/hashmap/004.png" alt="004"></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">final</span> V <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span>                   <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// table未初始化或者长度为0，进行扩容</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>        tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 桶中已经存在元素</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span> K k<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">// 将第一个元素赋值给e，用e来记录</span>                e <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// hash值不相等，即key不相等；为红黑树结点</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// 放入树中</span>            e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 为链表结点</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 在链表最末插入结点</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 到达链表的尾部</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 在尾部插入新结点</span>                    p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 结点数量达到阈值，转化为红黑树</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">>=</span> TREEIFY_THRESHOLD <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// -1 for 1st</span>                        <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 跳出循环</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// 判断链表中结点的key值与插入的元素的key值是否相等</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token comment" spellcheck="true">// 相等，跳出循环</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span>                p <span class="token operator">=</span> e<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 表示在桶中找到key值、hash值与插入元素相等的结点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token comment" spellcheck="true">// 记录e的value</span>            V oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// onlyIfAbsent为false或者旧值为null</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> null<span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">//用新值替换旧值</span>                e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 访问后回调</span>            <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 返回旧值</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 结构性修改</span>    <span class="token operator">++</span>modCount<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 实际大小大于阈值则扩容</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">></span> threshold<span class="token punctuation">)</span>        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 插入后回调</span>    <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span> </code></pre><p><strong>我们再来对比一下 JDK1.7 put方法的代码</strong></p><p><strong>对于put方法的分析如下：</strong></p><ul><li>①如果定位到的数组位置没有元素 就直接插入。</li><li>②如果定位到的数组位置有元素，遍历以这个元素为头结点的链表，依次和插入的key比较，如果key相同就直接覆盖，不同就采用头插法插入元素。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>table <span class="token operator">==</span> EMPTY_TABLE<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token function">inflateTable</span><span class="token punctuation">(</span>threshold<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token function">putForNullKey</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> null<span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 先遍历</span>        Object k<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            V oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">recordAccess</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>         <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token function">addEntry</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 再插入</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">get</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">?</span> null <span class="token operator">:</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">final</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> first<span class="token punctuation">,</span> e<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span> K k<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>        <span class="token punctuation">(</span>first <span class="token operator">=</span> tab<span class="token punctuation">[</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 数组元素相等</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>first<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token comment" spellcheck="true">// always check first node</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> first<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> first<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 桶中不止一个节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> first<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 在树中get</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>first<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTreeNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 在链表中get</span>            <span class="token keyword">do</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> e<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="resize方法"><a href="#resize方法" class="headerlink" title="resize方法"></a>resize方法</h4><pre><code>    进行扩容，会伴随着一次重新hash分配，并且会遍历hash表中所有的元素，是非常耗时的。在编写程序中，要尽量避免resize。</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> oldTab <span class="token operator">=</span> table<span class="token punctuation">;</span>    <span class="token keyword">int</span> oldCap <span class="token operator">=</span> <span class="token punctuation">(</span>oldTab <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> oldTab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> oldThr <span class="token operator">=</span> threshold<span class="token punctuation">;</span>    <span class="token keyword">int</span> newCap<span class="token punctuation">,</span> newThr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">>=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token punctuation">{</span>            threshold <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>            <span class="token keyword">return</span> oldTab<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 没超过最大值，就扩充为原来的2倍</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newCap <span class="token operator">=</span> oldCap <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span> oldCap <span class="token operator">>=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span>            newThr <span class="token operator">=</span> oldThr <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// double threshold</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldThr <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// initial capacity was placed in threshold</span>        newCap <span class="token operator">=</span> oldThr<span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>         signifies using defaults        newCap <span class="token operator">=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">;</span>        newThr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>DEFAULT_LOAD_FACTOR <span class="token operator">*</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 计算新的resize上限</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newThr <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">float</span> ft <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>newCap <span class="token operator">*</span> loadFactor<span class="token punctuation">;</span>        newThr <span class="token operator">=</span> <span class="token punctuation">(</span>newCap <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span> ft <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>MAXIMUM_CAPACITY <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>ft <span class="token operator">:</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    threshold <span class="token operator">=</span> newThr<span class="token punctuation">;</span>    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"rawtypes"</span><span class="token punctuation">,</span><span class="token string">"unchecked"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTab <span class="token operator">=</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span>newCap<span class="token punctuation">]</span><span class="token punctuation">;</span>    table <span class="token operator">=</span> newTab<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldTab <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 把每个bucket都移动到新的buckets中</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> oldCap<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span>                    newTab<span class="token punctuation">[</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> <span class="token punctuation">(</span>newCap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>e<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> newTab<span class="token punctuation">,</span> j<span class="token punctuation">,</span> oldCap<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token punctuation">{</span>                     Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> loHead <span class="token operator">=</span> null<span class="token punctuation">,</span> loTail <span class="token operator">=</span> null<span class="token punctuation">;</span>                    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> hiHead <span class="token operator">=</span> null<span class="token punctuation">,</span> hiTail <span class="token operator">=</span> null<span class="token punctuation">;</span>                    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">;</span>                    <span class="token keyword">do</span> <span class="token punctuation">{</span>                        next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 原索引</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> oldCap<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">==</span> null<span class="token punctuation">)</span>                                loHead <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token keyword">else</span>                                loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>                            loTail <span class="token operator">=</span> e<span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        <span class="token comment" spellcheck="true">// 原索引+oldCap</span>                        <span class="token keyword">else</span> <span class="token punctuation">{</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">==</span> null<span class="token punctuation">)</span>                                hiHead <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token keyword">else</span>                                hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>                            hiTail <span class="token operator">=</span> e<span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 原索引放到bucket里</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>                        newTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> loHead<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token comment" spellcheck="true">// 原索引+oldCap放到bucket里</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>                        newTab<span class="token punctuation">[</span>j <span class="token operator">+</span> oldCap<span class="token punctuation">]</span> <span class="token operator">=</span> hiHead<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> newTab<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="HashMap常用方法测试"><a href="#HashMap常用方法测试" class="headerlink" title="HashMap常用方法测试"></a>HashMap常用方法测试</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> map<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Collection<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>HashMap<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Set<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashMapDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        HashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 键不能重复，值可以重复</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"san"</span><span class="token punctuation">,</span> <span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"si"</span><span class="token punctuation">,</span> <span class="token string">"李四"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"wu"</span><span class="token punctuation">,</span> <span class="token string">"王五"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"wang"</span><span class="token punctuation">,</span> <span class="token string">"老王"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"wang"</span><span class="token punctuation">,</span> <span class="token string">"老王2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 老王被覆盖</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"lao"</span><span class="token punctuation">,</span> <span class="token string">"老王"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"-------直接输出hashmap:-------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/**         * 遍历HashMap         */</span>        <span class="token comment" spellcheck="true">// 1.获取Map中的所有键</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"-------foreach获取Map中所有的键:------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Set<span class="token operator">&lt;</span>String<span class="token operator">></span> keys <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>String key <span class="token operator">:</span> keys<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>key<span class="token operator">+</span><span class="token string">"  "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//换行</span>        <span class="token comment" spellcheck="true">// 2.获取Map中所有值</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"-------foreach获取Map中所有的值:------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Collection<span class="token operator">&lt;</span>String<span class="token operator">></span> values <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>String value <span class="token operator">:</span> values<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>value<span class="token operator">+</span><span class="token string">"  "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//换行</span>        <span class="token comment" spellcheck="true">// 3.得到key的值的同时得到key所对应的值</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"-------得到key的值的同时得到key所对应的值:-------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Set<span class="token operator">&lt;</span>String<span class="token operator">></span> keys2 <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>String key <span class="token operator">:</span> keys2<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>key <span class="token operator">+</span> <span class="token string">"："</span> <span class="token operator">+</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"   "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">/**         * 另外一种不常用的遍历方式         */</span>        <span class="token comment" spellcheck="true">// 当我调用put(key,value)方法的时候，首先会把key和value封装到</span>        <span class="token comment" spellcheck="true">// Entry这个静态内部类对象中，把Entry对象再添加到数组中，所以我们想获取</span>        <span class="token comment" spellcheck="true">// map中的所有键值对，我们只要获取数组中的所有Entry对象，接下来</span>        <span class="token comment" spellcheck="true">// 调用Entry对象中的getKey()和getValue()方法就能获取键值对了</span>        Set<span class="token operator">&lt;</span>java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">>></span> entrys <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> entry <span class="token operator">:</span> entrys<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"--"</span> <span class="token operator">+</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">/**         * HashMap其他常用方法         */</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after map.size()："</span><span class="token operator">+</span>map<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after map.isEmpty()："</span><span class="token operator">+</span>map<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">"san"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after map.remove()："</span><span class="token operator">+</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after map.get(si)："</span><span class="token operator">+</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"si"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after map.containsKey(si)："</span><span class="token operator">+</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span><span class="token string">"si"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after containsValue(李四)："</span><span class="token operator">+</span>map<span class="token punctuation">.</span><span class="token function">containsValue</span><span class="token punctuation">(</span><span class="token string">"李四"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">"si"</span><span class="token punctuation">,</span> <span class="token string">"李四2"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after map.replace(si, 李四2):"</span><span class="token operator">+</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HashMap简介&quot;&gt;&lt;a href=&quot;#HashMap简介&quot; class=&quot;headerlink&quot; title=&quot;HashMap简介&quot;&gt;&lt;/a&gt;HashMap简介&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;HashMap 主要用来存放键值对，它基于哈希表的Map接口实现&amp;l
      
    
    </summary>
    
      <category term="日常学习" scheme="http://zongmansheng.club/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="HashMap" scheme="http://zongmansheng.club/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>逆向工程</title>
    <link href="http://zongmansheng.club/2019/04/06/ni-xiang-gong-cheng/"/>
    <id>http://zongmansheng.club/2019/04/06/ni-xiang-gong-cheng/</id>
    <published>2019-04-06T08:33:27.000Z</published>
    <updated>2019-04-06T14:07:34.602Z</updated>
    
    <content type="html"><![CDATA[<h1 id="逆向工程"><a href="#逆向工程" class="headerlink" title="逆向工程"></a>逆向工程</h1><pre><code>日常开发中，逆向工程在我们的工作中用的非常普遍</code></pre><h4 id="generatorConfig-xml"><a href="#generatorConfig-xml" class="headerlink" title="generatorConfig.xml"></a>generatorConfig.xml</h4><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token doctype">&lt;!DOCTYPE generatorConfiguration        PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"        "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>generatorConfiguration</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>context</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>testTables<span class="token punctuation">"</span></span> <span class="token attr-name">targetRuntime</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>MyBatis3<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.mybatis.generator.plugins.SerializablePlugin<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>commentGenerator</span><span class="token punctuation">></span></span>            <span class="token comment" spellcheck="true">&lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>suppressAllComments<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>commentGenerator</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>jdbcConnection</span> <span class="token attr-name">driverClass</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.mysql.jdbc.Driver<span class="token punctuation">"</span></span>                        <span class="token attr-name">connectionURL</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jdbc:mysql://localhost:3306/shucangdb<span class="token punctuation">"</span></span> <span class="token attr-name">userId</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span>                        <span class="token attr-name">password</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>jdbcConnection</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- &lt;jdbcConnection driverClass="oracle.jdbc.OracleDriver"            connectionURL="jdbc:oracle:thin:@127.0.0.1:1521:yycg"            userId="yycg"            password="yycg">        &lt;/jdbcConnection> --></span>        <span class="token comment" spellcheck="true">&lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和            NUMERIC 类型解析为java.math.BigDecimal --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>javaTypeResolver</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>forceBigDecimals<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>javaTypeResolver</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- targetProject:生成PO类的位置 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>javaModelGenerator</span> <span class="token attr-name">targetPackage</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.xxxxxxxx<span class="token punctuation">"</span></span>                            <span class="token attr-name">targetProject</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>generator/src/main/java<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token comment" spellcheck="true">&lt;!-- enableSubPackages:是否让schema作为包的后缀 --></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>enableSubPackages<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>            <span class="token comment" spellcheck="true">&lt;!-- 从数据库返回的值被清理前后的空格 --></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>trimStrings<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>javaModelGenerator</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- targetProject:mapper映射文件生成的位置 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>sqlMapGenerator</span> <span class="token attr-name">targetPackage</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.xxxxxxxxxx<span class="token punctuation">"</span></span>                         <span class="token attr-name">targetProject</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>generator/src/main/java<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token comment" spellcheck="true">&lt;!-- enableSubPackages:是否让schema作为包的后缀 --></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>enableSubPackages<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>sqlMapGenerator</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- targetPackage：mapper接口生成的位置 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>javaClientGenerator</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>XMLMAPPER<span class="token punctuation">"</span></span>                             <span class="token attr-name">targetPackage</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.xxxxxxxx<span class="token punctuation">"</span></span>                             <span class="token attr-name">targetProject</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>generator/src/main/java<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token comment" spellcheck="true">&lt;!-- enableSubPackages:是否让schema作为包的后缀 --></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>enableSubPackages<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>javaClientGenerator</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 指定数据库表 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">tableName</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>xxxx<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>table</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">tableName</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>xxxx<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>table</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 有些表的字段需要指定java类型         &lt;table schema="" tableName="">            &lt;columnOverride column="" javaType="" />        &lt;/table> --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>context</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>generatorConfiguration</span><span class="token punctuation">></span></span></code></pre><h4 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h4><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0         http://maven.apache.org/xsd/maven-4.0.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modelVersion</span><span class="token punctuation">></span></span>4.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modelVersion</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.zms<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>generator<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.0-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span>                <span class="token comment" spellcheck="true">&lt;!-- 逆向工程--></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.mybatis.generator<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mybatis-generator-maven-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.3.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>mysql<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mysql-connector-java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>5.1.45<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>runtime<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.mybatis.generator<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mybatis-generator-core<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.3.7<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>                        <span class="token comment" spellcheck="true">&lt;!--配置文件的路径--></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configurationFile</span><span class="token punctuation">></span></span>${basedir}/src/main/resources/generatorConfig.xml<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configurationFile</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>overwrite</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>overwrite</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>verbose</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>verbose</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resources</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resource</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>directory</span><span class="token punctuation">></span></span>src/main/java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>directory</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--mapper--></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>includes</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span><span class="token punctuation">></span></span>**/*.properties<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>include</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span><span class="token punctuation">></span></span>**/*.xml<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>include</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>includes</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filtering</span><span class="token punctuation">></span></span>false<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filtering</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resource</span><span class="token punctuation">></span></span>                <span class="token comment" spellcheck="true">&lt;!-- 上面的配置导致src/main/resources的所有文件都不能被扫描，因此还要配多一个 --></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resource</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>directory</span><span class="token punctuation">></span></span>src/main/resources<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>directory</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>includes</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span><span class="token punctuation">></span></span>**/*.properties<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>include</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span><span class="token punctuation">></span></span>**/*.xml<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>include</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span><span class="token punctuation">></span></span>**/static/**<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>include</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span><span class="token punctuation">></span></span>**/*.js<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>include</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span><span class="token punctuation">></span></span>**/*.css<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>include</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span><span class="token punctuation">></span></span>**/*.json<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>include</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>includes</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filtering</span><span class="token punctuation">></span></span>false<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filtering</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resource</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resources</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>mysql<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mysql-connector-java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>5.1.46<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.mybatis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mybatis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.4.4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;逆向工程&quot;&gt;&lt;a href=&quot;#逆向工程&quot; class=&quot;headerlink&quot; title=&quot;逆向工程&quot;&gt;&lt;/a&gt;逆向工程&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;日常开发中，逆向工程在我们的工作中用的非常普遍
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;generator
      
    
    </summary>
    
      <category term="日常学习" scheme="http://zongmansheng.club/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="mybatis，mysql，generator" scheme="http://zongmansheng.club/tags/mybatis%EF%BC%8Cmysql%EF%BC%8Cgenerator/"/>
    
  </entry>
  
  <entry>
    <title>jdbc和mybatis的区别</title>
    <link href="http://zongmansheng.club/2019/04/05/jdbc-he-mybatis-de-qu-bie/"/>
    <id>http://zongmansheng.club/2019/04/05/jdbc-he-mybatis-de-qu-bie/</id>
    <published>2019-04-05T11:26:14.000Z</published>
    <updated>2019-04-05T12:18:33.430Z</updated>
    
    <content type="html"><![CDATA[<h1 id="jdbc和mybatis的区别"><a href="#jdbc和mybatis的区别" class="headerlink" title="jdbc和mybatis的区别"></a>jdbc和mybatis的区别</h1><pre><code>mybatis也是基于JDBC的。Java与数据库操作仅能通过JDBC完成。 mybatis也要通过JDBC完成数据查询、更新这些动作。mybatis仅仅是在JDBC基础上做了，OO化、封装事务管理接口这些东西。</code></pre><p><img src="//zongmansheng.club/2019/04/05/jdbc-he-mybatis-de-qu-bie/001.png" alt="001"></p><pre><code>JDBC是地基,mybatis/Hibernate 是两栋外形各自有特点的楼房，楼房之间可以比较！地基就这一种。</code></pre><h4 id="传统JDBC操作数据"><a href="#传统JDBC操作数据" class="headerlink" title="传统JDBC操作数据"></a>传统JDBC操作数据</h4><pre><code>1.使用JDBC编程需要连接数据库，注册驱动和数据库信息2.操作Connection，打开 Statement 对象 。3.通过Statement执行SQL， 返回结果到ResultSet对象。4.使用ResultSet读取数据，然后通过代码转化为具体的POJO对象。5.关闭数据库的相关资源。</code></pre><h5 id="jdbc存在弊端："><a href="#jdbc存在弊端：" class="headerlink" title="jdbc存在弊端："></a>jdbc存在弊端：</h5><pre><code>1.工作量相对较大，每次都要去创建，关闭，获取2.JDBC编程可能产生的异常进行捕捉处理并正确关闭资源</code></pre><h4 id="对象关系映射（Object-Relational-Mapping）简称-ORM"><a href="#对象关系映射（Object-Relational-Mapping）简称-ORM" class="headerlink" title="对象关系映射（Object Relational Mapping）简称 ORM"></a>对象关系映射（Object Relational Mapping）简称 ORM</h4><pre><code>ORM模型就是数据库的表和简单Java对象（Plain Ordinary Java Object，简称POJO）的映射关系模型。</code></pre><pre><code>ORM模型提供了统一的规则使得数据库的数据通过配置便可轻易的映射到POJO上</code></pre><h4 id="常见的有两种"><a href="#常见的有两种" class="headerlink" title="常见的有两种"></a>常见的有两种</h4><h5 id="mybatis"><a href="#mybatis" class="headerlink" title="mybatis"></a>mybatis</h5><pre><code>1.易于上手和掌握。2.sql写在xml里，便于统一管理和优化。3.解除sql与程序代码的耦合。4.提供映射标签，支持对象与数据库的orm字段关系映射5.提供对象关系映射标签，支持对象关系组建维护6.提供xml标签，支持编写动态sql。</code></pre><h5 id="hibernate"><a href="#hibernate" class="headerlink" title="hibernate"></a>hibernate</h5><pre><code>1.消除了代码的映射规则，它全部被分离到XML或者注解里面去配置。2.无需再管理数据库连接，它也配置到XML里面。3.一个会话中，不要操作多个对象，只要操作Sesison即可。4.关闭资源只需要关闭一个Session即可。</code></pre><h4 id="Mybatis常见的面试题"><a href="#Mybatis常见的面试题" class="headerlink" title="Mybatis常见的面试题"></a>Mybatis常见的面试题</h4><h5 id="1-和-的区别是什么？"><a href="#1-和-的区别是什么？" class="headerlink" title="1. #{}和${}的区别是什么？"></a>1. #{}和${}的区别是什么？</h5><pre><code>#{}是预编译处理，${}是字符串替换。Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；Mybatis在处理${}时，就是把${}替换成变量的值。使用#{}可以有效的防止SQL注入，提高系统安全性。在我们日常开发中，能用#的地方都尽量用#。</code></pre><h5 id="2-通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？"><a href="#2-通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？" class="headerlink" title="2. 通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？"></a>2. 通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？</h5><p><img src="//zongmansheng.club/2019/04/05/jdbc-he-mybatis-de-qu-bie/002.png" alt="002"></p><p><img src="//zongmansheng.club/2019/04/05/jdbc-he-mybatis-de-qu-bie/003.png" alt="003"></p><pre><code>    Dao接口，就是人们常说的Mapper接口，接口的全限名，就是映射文件中的namespace的值，接口的方法名，就是映射文件中MappedStatement的id值，接口方法内的参数，就是传递给sql的参数。Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MappedStatement，举例：com.mybatis3.mappers.StudentDao.findStudentById，可以唯一找到namespace为com.mybatis3.mappers.StudentDao下面id = findStudentById的MappedStatement。在Mybatis中，每一个&lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;标签，都会被解析为一个MappedStatement对象。Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。    Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。</code></pre><h4 id="3-Mybatis是如何进行分页的？分页插件的原理是什么？"><a href="#3-Mybatis是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="3. Mybatis是如何进行分页的？分页插件的原理是什么？"></a>3. Mybatis是如何进行分页的？分页插件的原理是什么？</h4><pre><code>    Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页，可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。    分页插件(pagehelper)的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。</code></pre><h5 id="4-Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"><a href="#4-Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？" class="headerlink" title="4. Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"></a>4. Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？</h5><pre><code>    第一种是使用&lt;resultMap&gt;标签，逐一定义列名和对象属性名之间的映射关系。第二种是使用sql列的别名功能，将列别名书写为对象属性名，比如T_NAME AS NAME，对象属性名一般是name，小写，但是列名不区分大小写，Mybatis会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成T_NAME AS NaMe，Mybatis一样可以正常工作。    有了列名与属性名的映射关系后，Mybatis通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</code></pre><h5 id="5-Xml映射文件中，除了常见的select-insert-update-delete标签之外，还有哪些标签？"><a href="#5-Xml映射文件中，除了常见的select-insert-update-delete标签之外，还有哪些标签？" class="headerlink" title="5. Xml映射文件中，除了常见的select|insert|update|delete标签之外，还有哪些标签？"></a>5. Xml映射文件中，除了常见的select|insert|update|delete标签之外，还有哪些标签？</h5><pre><code>还有很多其他的标签，加上动态sql的9个标签，trim|where|set|foreach|if|choose|when|otherwise|bind等，其中为sql片段标签，通过标签引入sql片段，为不支持自增的主键生成策略标签。</code></pre><h5 id="6-简述Mybatis的插件运行原理，以及如何编写一个插件"><a href="#6-简述Mybatis的插件运行原理，以及如何编写一个插件" class="headerlink" title="6. 简述Mybatis的插件运行原理，以及如何编写一个插件"></a>6. 简述Mybatis的插件运行原理，以及如何编写一个插件</h5><pre><code>    Mybatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler、Executor这4种接口的插件，Mybatis使用JDK的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是InvocationHandler的invoke()方法，当然，只会拦截那些你指定需要拦截的方法。实现Mybatis的Interceptor接口并复写intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，还需要在配置文件中配置你编写的插件。</code></pre><h5 id="7-一级、二级缓存"><a href="#7-一级、二级缓存" class="headerlink" title="7. 一级、二级缓存"></a>7. 一级、二级缓存</h5><pre><code>1）一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空。2）二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。要开启二级缓存，你需要在你的 SQL 映射文件中添加一行：&lt;cache/&gt;3）对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</code></pre><h5 id="8-Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#8-Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="8. Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？"></a>8. Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？</h5><pre><code>    Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。    它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。</code></pre><h5 id="9-Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？"><a href="#9-Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？" class="headerlink" title="9. Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？"></a>9. Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？</h5><pre><code>    虽然Mybatis解析Xml映射文件是按照顺序解析的，但是，被引用的B标签依然可以定义在任何地方，Mybatis都可以正确识别。    原理是，Mybatis解析A标签，发现A标签引用了B标签，但是B标签尚未解析到，尚不存在，此时，Mybatis会将A标签标记为未解析状态，然后继续解析余下的标签，包含B标签，待所有标签解析完毕，Mybatis会重新解析那些被标记为未解析的标签，此时再解析A标签时，B标签已经存在，A标签也就可以正常解析完成了。</code></pre><h5 id="10-简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？"><a href="#10-简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？" class="headerlink" title="10. 简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？"></a>10. 简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？</h5><pre><code>    Mybatis将所有Xml配置信息都封装到All-In-One重量级对象Configuration内部。在Xml映射文件中，&lt;parameterMap&gt;标签会被解析为ParameterMap对象，其每个子元素会被解析为ParameterMapping对象。&lt;resultMap&gt;标签会被解析为ResultMap对象，其每个子元素会被解析为ResultMapping对象。每一个&lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;标签均会被解析为MappedStatement对象，标签内的sql会被解析为BoundSql对象。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;jdbc和mybatis的区别&quot;&gt;&lt;a href=&quot;#jdbc和mybatis的区别&quot; class=&quot;headerlink&quot; title=&quot;jdbc和mybatis的区别&quot;&gt;&lt;/a&gt;jdbc和mybatis的区别&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;mybatis也是基
      
    
    </summary>
    
      <category term="日常学习" scheme="http://zongmansheng.club/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="jdbc" scheme="http://zongmansheng.club/tags/jdbc/"/>
    
      <category term="mybatis" scheme="http://zongmansheng.club/tags/mybatis/"/>
    
  </entry>
  
</feed>
