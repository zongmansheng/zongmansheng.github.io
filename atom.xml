<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>晓笙的BLOG</title>
  
  <subtitle>一个来自IT界的菜鸟007</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zongmansheng.club/"/>
  <updated>2019-03-29T12:07:02.993Z</updated>
  <id>http://zongmansheng.club/</id>
  
  <author>
    <name>ZongMan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ThreadLocal</title>
    <link href="http://zongmansheng.club/2019/03/29/threadlocal/"/>
    <id>http://zongmansheng.club/2019/03/29/threadlocal/</id>
    <published>2019-03-29T11:54:15.000Z</published>
    <updated>2019-03-29T12:07:02.993Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ThreadLocal的简单使用及实现的原理"><a href="#ThreadLocal的简单使用及实现的原理" class="headerlink" title="ThreadLocal的简单使用及实现的原理"></a>ThreadLocal的简单使用及实现的原理</h2><h4 id="一、ThreadLocal简介"><a href="#一、ThreadLocal简介" class="headerlink" title="一、ThreadLocal简介"></a>一、ThreadLocal简介</h4><pre><code>    ThreadLocal的实例代表了一个线程局部的变量，每条线程都只能看到自己的值，并不会意识到其它的线程中也存在该变量。    它采用采用空间来换取时间的方式，解决多线程中相同变量的访问冲突问题。</code></pre><h4 id="二、ThreadLocal的简单使用"><a href="#二、ThreadLocal的简单使用" class="headerlink" title="二、ThreadLocal的简单使用"></a>二、ThreadLocal的简单使用</h4><pre><code>    下面的例子中，创建了两个线程，然后线程对各自的局部变量进行递增的操作。每个线程中的局部变量的初始值都是100。</code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @author ZongMan * @version 1.0 * @date 2019/3/22 0022 8:04 */</span><span class="token keyword">class</span> <span class="token class-name">ThreadLocalDemo</span> <span class="token punctuation">{</span>    ThreadLocal<span class="token operator">&lt;</span>Integer<span class="token operator">></span> threadLocal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">protected</span> Integer <span class="token function">initialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">100</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> threadLocal<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        threadLocal<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>threadLocal<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>定义对ThreadLocal的操作，也就是在原来的基础上进行加10的操作，然后打印出结果。</code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @author ZongMan * @version 1.0 * @date 2019/3/22 0022 8:08 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalDemo2</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>    ThreadLocalDemo localDemo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocalDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ThreadLocalDemo2</span><span class="token punctuation">(</span>ThreadLocalDemo localDemo<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>localDemo <span class="token operator">=</span> localDemo<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            localDemo<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//输出不同线程的ThreadLocal的值</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"=====>"</span> <span class="token operator">+</span> localDemo<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>    创建两个线程并启动，主线程等待这两个线程执行完成。最值得注意的就是主线程中输出的threadLocalDemo.get(),输出的初始值100</code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @author ZongMan * @version 1.0 * @date 2019/3/22 0022 8:14 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        ThreadLocalDemo threadLocalDemo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocalDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//多个线程操作同一个变量 但是不同线程的结果是互不影响的</span>        ThreadLocalDemo2 localDemo2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocalDemo2</span><span class="token punctuation">(</span>threadLocalDemo<span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>localDemo2<span class="token punctuation">)</span><span class="token punctuation">;</span>        t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>localDemo2<span class="token punctuation">)</span><span class="token punctuation">;</span>        t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//这个是main()线程中的变量，输出的是ThreadLocalDemo中的初始值 也是就100</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>threadLocalDemo<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="三、ThreadLocal的实现原理"><a href="#三、ThreadLocal的实现原理" class="headerlink" title="三、ThreadLocal的实现原理"></a>三、ThreadLocal的实现原理</h4><pre><code>    每个Thread的对象都有一个ThreadLocalMap，当创建一个ThreadLocal的时候，就会将该ThreadLocal对象添加到该Map中，其中键就是ThreadLocal，值可以是任意类型。    在该类中，我觉得最重要的方法就是两个：set()和get()方法。当调用ThreadLocal的get()方法的时候，会先找到当前线程的ThreadLocalMap，然后再找到对应的值。set()方法也是一样。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ThreadLocal的简单使用及实现的原理&quot;&gt;&lt;a href=&quot;#ThreadLocal的简单使用及实现的原理&quot; class=&quot;headerlink&quot; title=&quot;ThreadLocal的简单使用及实现的原理&quot;&gt;&lt;/a&gt;ThreadLocal的简单使用及实现的
      
    
    </summary>
    
      <category term="日常学习" scheme="http://zongmansheng.club/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="JUC" scheme="http://zongmansheng.club/tags/JUC/"/>
    
      <category term="ThreadLocal" scheme="http://zongmansheng.club/tags/ThreadLocal/"/>
    
  </entry>
  
  <entry>
    <title>面试之集合</title>
    <link href="http://zongmansheng.club/2019/03/28/mian-shi-zhi-ji-he/"/>
    <id>http://zongmansheng.club/2019/03/28/mian-shi-zhi-ji-he/</id>
    <published>2019-03-28T12:41:18.000Z</published>
    <updated>2019-03-28T13:20:59.667Z</updated>
    
    <content type="html"><![CDATA[<h4 id="ArrayList简介"><a href="#ArrayList简介" class="headerlink" title="ArrayList简介"></a>ArrayList简介</h4><pre><code>    ArrayList 的底层是数组队列，相当于动态数组。与 Java 中的数组相比，它的容量能动态增长。在添加大量元素前，应用程序可以使用ensureCapacity操作来增加 ArrayList 实例的容量。这可以减少递增式再分配的数量。   它继承于 AbstractList，实现了 List, RandomAccess, Cloneable, java.io.Serializable 这些接口。   在我们学数据结构的时候就知道了线性表的顺序存储，插入删除元素的时间复杂度为O（n）,求表长以及增加元素，取第 i   元素的时间复杂度为O（1）　  ArrayList 继承了AbstractList，实现了List。它是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。　　ArrayList 实现了RandomAccess 接口，即提供了随机访问功能。RandomAccess 是 Java 中用来被 List 实现，为 List 提供快速访问功能的。在 ArrayList 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。　　ArrayList 实现了Cloneable 接口，即覆盖了函数 clone()，能被克隆。　　ArrayList 实现java.io.Serializable 接口，这意味着ArrayList支持序列化，能通过序列化去传输。　　和 Vector 不同，ArrayList 中的操作不是线程安全的！所以，建议在单线程中才使用 ArrayList，而在多线程中可以选择 Vector 或者  CopyOnWriteArrayList。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;ArrayList简介&quot;&gt;&lt;a href=&quot;#ArrayList简介&quot; class=&quot;headerlink&quot; title=&quot;ArrayList简介&quot;&gt;&lt;/a&gt;ArrayList简介&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;    ArrayList 的底层是数组队列，相当于
      
    
    </summary>
    
      <category term="面试" scheme="http://zongmansheng.club/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="List，ArrayList，LinkedList" scheme="http://zongmansheng.club/tags/List%EF%BC%8CArrayList%EF%BC%8CLinkedList/"/>
    
  </entry>
  
  <entry>
    <title>乐观锁与悲观锁的区别</title>
    <link href="http://zongmansheng.club/2019/03/25/le-guan-suo-yu-bei-guan-suo-de-qu-bie/"/>
    <id>http://zongmansheng.club/2019/03/25/le-guan-suo-yu-bei-guan-suo-de-qu-bie/</id>
    <published>2019-03-25T11:06:51.000Z</published>
    <updated>2019-03-25T11:17:50.553Z</updated>
    
    <content type="html"><![CDATA[<h1 id="悲观锁和乐观锁的区别"><a href="#悲观锁和乐观锁的区别" class="headerlink" title="悲观锁和乐观锁的区别"></a>悲观锁和乐观锁的区别</h1><h4 id="一、悲观锁-Pessimistic-Lock"><a href="#一、悲观锁-Pessimistic-Lock" class="headerlink" title="一、悲观锁(Pessimistic Lock)"></a>一、悲观锁(Pessimistic Lock)</h4><pre><code>    总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。    它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。</code></pre><h4 id="二、乐观锁-Optimistic-Lock"><a href="#二、乐观锁-Optimistic-Lock" class="headerlink" title="二、乐观锁(Optimistic Lock)"></a>二、乐观锁(Optimistic Lock)</h4><pre><code>    总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。</code></pre><h4 id="三、乐观锁常见的两种实现方式"><a href="#三、乐观锁常见的两种实现方式" class="headerlink" title="三、乐观锁常见的两种实现方式"></a>三、乐观锁常见的两种实现方式</h4><pre><code>乐观锁一般会使用版本号机制或CAS算法实现。</code></pre><h5 id="1-版本号机制"><a href="#1-版本号机制" class="headerlink" title="1.版本号机制"></a>1.版本号机制</h5><pre><code>    一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。举一个简单的例子：     假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ balance ）为 $100 。    操作员 A 此时将其读出（ version=1 ），并从其帐户余额中扣除 50（50（100-$50 ）。在操作员 A 操作的过程中，操作员B 也读入此用户信息（ version=1 ），并从其帐户余额中扣除 20（20（100-$20 ）。操作员 A 完成了修改工作，将数据版本号加 1（ version=2 ），连同帐户扣除后余额（ balance=$50 ），提交至数据库更新，此时由于提交数据版本大于数据库记录当前版本，数据被更新，数据库记录 version 更新为 2 。    操作员 B 完成了操作，也将版本号加一（ version=2 ）试图向数据库提交数据（ balance=$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 2 ，数据库记录当前版本也为 2 ，不满足 “ 提交版本必须大于记录当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。这样，就避免了操作员 B 用基于 version=1 的旧数据修改的结果覆盖操作员A 的操作结果的可能。</code></pre><h5 id="2-CAS算法"><a href="#2-CAS算法" class="headerlink" title="2.CAS算法"></a>2.CAS算法</h5><pre><code>    即compare and swap（比较与交换），是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。CAS算法涉及到三个操作数    需要读写的内存值 V    进行比较的值 A    拟写入的新值 B    当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。</code></pre><h4 id="四、乐观锁的缺点"><a href="#四、乐观锁的缺点" class="headerlink" title="四、乐观锁的缺点"></a>四、乐观锁的缺点</h4><pre><code>ABA 问题是乐观锁一个常见的问题</code></pre><h5 id="1-ABA-问题"><a href="#1-ABA-问题" class="headerlink" title="1 ABA 问题"></a>1 ABA 问题</h5><pre><code>    如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 “ABA”问题。    JDK 1.5 以后的 AtomicStampedReference 类就提供了此种能力，其中的 compareAndSet 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</code></pre><h5 id="2-循环时间长开销大"><a href="#2-循环时间长开销大" class="headerlink" title="2 循环时间长开销大"></a>2 循环时间长开销大</h5><pre><code>    自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。 如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。</code></pre><h5 id="3-只能保证一个共享变量的原子操作"><a href="#3-只能保证一个共享变量的原子操作" class="headerlink" title="3 只能保证一个共享变量的原子操作"></a>3 只能保证一个共享变量的原子操作</h5><pre><code>    CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5开始，提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用AtomicReference类把多个共享变量合并成一个共享变量来操作。</code></pre><h4 id="五、CAS与synchronized的使用情景"><a href="#五、CAS与synchronized的使用情景" class="headerlink" title="五、CAS与synchronized的使用情景"></a>五、CAS与synchronized的使用情景</h4><pre><code>    简单的来说CAS适用于写比较少的情况下（多读场景，冲突一般较少），synchronized适用于写比较多的情况下（多写场景，冲突一般较多）</code></pre><pre><code>    对于资源竞争较少（线程冲突较轻）的情况，使用synchronized同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。</code></pre><pre><code>补充： Java并发编程这个领域中synchronized关键字一直都是元老级的角色，很久之前很多人都会称它为 “重量级锁” 。但是，在JavaSE 1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的 偏向锁 和 轻量级锁 以及其它各种优化之后变得在某些情况下并不是那么重了。synchronized的底层实现主要依靠 Lock-Free 的队列，基本思路是 自旋后阻塞，竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了高吞吐量。在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;悲观锁和乐观锁的区别&quot;&gt;&lt;a href=&quot;#悲观锁和乐观锁的区别&quot; class=&quot;headerlink&quot; title=&quot;悲观锁和乐观锁的区别&quot;&gt;&lt;/a&gt;悲观锁和乐观锁的区别&lt;/h1&gt;&lt;h4 id=&quot;一、悲观锁-Pessimistic-Lock&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="日常学习" scheme="http://zongmansheng.club/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="数据库，乐观锁，悲观锁" scheme="http://zongmansheng.club/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%8C%E6%82%B2%E8%A7%82%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper的羊群效应</title>
    <link href="http://zongmansheng.club/2019/03/25/zookeeper-de-yang-qun-xiao-ying/"/>
    <id>http://zongmansheng.club/2019/03/25/zookeeper-de-yang-qun-xiao-ying/</id>
    <published>2019-03-25T09:55:24.000Z</published>
    <updated>2019-03-25T09:55:24.953Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Mybatis缓存介绍</title>
    <link href="http://zongmansheng.club/2019/03/24/mybatis-huan-cun-jie-shao/"/>
    <id>http://zongmansheng.club/2019/03/24/mybatis-huan-cun-jie-shao/</id>
    <published>2019-03-24T14:35:38.000Z</published>
    <updated>2019-03-25T09:53:53.201Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mybatis缓存的介绍"><a href="#Mybatis缓存的介绍" class="headerlink" title="Mybatis缓存的介绍"></a>Mybatis缓存的介绍</h1><pre><code>    缓存：合理使用缓存是优化中最常见的，将从数据库中查询出来的数据放入缓存中，下次使用时不必从数据库查询，而是直接从缓存中读取，避免频繁操作数据库，减轻数据库压力，同时提高系统性能。</code></pre><h4 id="一、一级缓存"><a href="#一、一级缓存" class="headerlink" title="一、一级缓存"></a>一、一级缓存</h4><pre><code>    一级缓存是SqlSession级别的缓存，在操作数据库的时候需要构造sqlsession对象，在对象中有一个数据结构用于存储缓存数据。不同的SqlSession之间的缓存数据区域是互相不影响的。也就是它只能作用在同一个sqlSession中，不同的SqlSession中的缓存是互相不能读取的</code></pre><h5 id="1、一级缓存的工作原理"><a href="#1、一级缓存的工作原理" class="headerlink" title="1、一级缓存的工作原理"></a>1、一级缓存的工作原理</h5><p><img src="//zongmansheng.club/2019/03/24/mybatis-huan-cun-jie-shao/Mybatis一级缓存原理.png" alt="Mybatis一级缓存原理"></p><pre><code>    用户发起查询请求，查找某条数据，sqlsession先去缓存中查找，是否有该数据，如果有，读取如果没有，从数据库查询，并将查询到的数据放入 一级缓存区域，供下次使用但sqlsession执行commit，即增删改操作时会清空缓存。目的是避免脏读如果commit不清空缓存，会有以下的场景：A查询了某个商品为10件，并将10件库存的数据存入缓存中，之后被客户买走了10件，数据被delete了，但是下次查询这件商品时，并不从数据库中查询，而是从缓存中查询，就会出现错误。二级缓存    二级缓存是mapper级别的缓存，多个SqlSession去操作同一个Mapper的sql语句，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的，二级缓存的作用范围更大。    实际开发中，Mybatis通常和Spring进行整合开发，Spring将事务放在Service中管理，对于每一个service中的sqlsession是不同的，这是通过mybatis-spring中的org.mybatis.spring.mapper.MapperScannerConfigurer创建sqlsession自动注入到service中的。 每次查询之后都要进行关闭sqlSession，关闭之后数据被清空。所以spring整合之后，如果没有事务，一级缓存是没有意义的。</code></pre><h5 id="2-二级缓存的工作原理"><a href="#2-二级缓存的工作原理" class="headerlink" title="2.二级缓存的工作原理"></a>2.二级缓存的工作原理</h5><p><img src="//zongmansheng.club/2019/03/24/mybatis-huan-cun-jie-shao/Mybatis二级缓存原理.png" alt="Mybatis二级缓存原理"></p><pre><code>    二级缓存是mapper级别的缓存，多个SqlSession去操作同一个Mapper的sql语句，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。    UserMapper有一个二级缓存区域（按namespace分），其它mapper也有自己的二级缓存区域（按namespace分）。每一个namespace的mapper都有一个二级缓存区域，两个mapper的namespace如果相同，这两个mapper执行sql查询到数据将存在相同的二级缓存区域中。</code></pre><h5 id="3-开启二级缓存"><a href="#3-开启二级缓存" class="headerlink" title="3.开启二级缓存"></a>3.开启二级缓存</h5><p>在MyBatis的配置文件中加入：</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">font-size</span><span class="token punctuation">:</span><span class="token number">18</span>px<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>settings</span><span class="token punctuation">></span></span>       <span class="token comment" spellcheck="true">&lt;!--开启二级缓存--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cacheEnabled<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>settings</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span></code></pre><p>在需要开启二级缓存的mapper.xml中加入caceh标签</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">font-size</span><span class="token punctuation">:</span><span class="token number">18</span>px<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cache</span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span></code></pre><h4 id="二、总结"><a href="#二、总结" class="headerlink" title="二、总结"></a>二、总结</h4><pre><code>    对于查询多commit少且用户对查询结果实时性要求不高，此时采用mybatis二级缓存技术降低数据库访问量，提高访问速度。</code></pre><pre><code>但不能滥用二级缓存，二级缓存也有很多弊端，从MyBatis默认二级缓存是关闭的就可以看出来。二级缓存是建立在同一个namespace下的，如果对表的操作查询可能有多个namespace，那么得到的数据就是错误的。举个简单的例子:   订单和订单详情，orderMapper、orderDetailMapper。在查询订单详情时我们需要把订单信息也查询出来，那么这个订单详情的信息被二级缓存在orderDetailMapper的namespace中，这个时候有人要修改订单的基本信息，那就是在orderMapper的namespace下修改，他是不会影响到orderDetailMapper的缓存的，那么你再次查找订单详情时，拿到的是缓存的数据，这个数据其实已经是过时的。</code></pre><pre><code>根据以上，想要使用二级缓存时需要想好两个问题：1）对该表的操作与查询都在同一个namespace下，其他的namespace如果有操作，就会发生数据的脏读。2）对关联表的查询，关联的所有表的操作都必须在同一个namespace。hexi</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Mybatis缓存的介绍&quot;&gt;&lt;a href=&quot;#Mybatis缓存的介绍&quot; class=&quot;headerlink&quot; title=&quot;Mybatis缓存的介绍&quot;&gt;&lt;/a&gt;Mybatis缓存的介绍&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;    缓存：合理使用缓存是优化中最常见的，
      
    
    </summary>
    
      <category term="日常学习" scheme="http://zongmansheng.club/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Mybatis" scheme="http://zongmansheng.club/tags/Mybatis/"/>
    
      <category term="框架" scheme="http://zongmansheng.club/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo常见面试题总结</title>
    <link href="http://zongmansheng.club/2019/02/19/dubbo-chang-jian-mian-shi-ti-zong-jie/"/>
    <id>http://zongmansheng.club/2019/02/19/dubbo-chang-jian-mian-shi-ti-zong-jie/</id>
    <published>2019-02-19T13:16:01.000Z</published>
    <updated>2019-03-25T09:47:11.141Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Dubbo面试题总结"><a href="#Dubbo面试题总结" class="headerlink" title="Dubbo面试题总结"></a>Dubbo面试题总结</h1><h4 id="一、Dubbo是什么？"><a href="#一、Dubbo是什么？" class="headerlink" title="一、Dubbo是什么？"></a>一、Dubbo是什么？</h4><pre><code>Dubbo是阿里巴巴开源的基于 Java 的高性能 RPC 分布式服务框架，现已成为 Apache 基金会孵化项目。</code></pre><h4 id="二、远程过程调用协议"><a href="#二、远程过程调用协议" class="headerlink" title="二、远程过程调用协议"></a>二、远程过程调用协议</h4><pre><code>RPC:(Remote Procedure Call)    它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。RPC采用客户机/服务器模式。请求程序就是一个客户机，而服务提供程序就是一个服务器。首先，客户机调用进程发送一个有进程参数的调用信息到服务进程，然后等待应答信息。在服务器端，进程保持睡眠状态直到调用信息到达为止。当一个调用信息到达，服务器获得进程参数，计算结果，发送答复信息，然后等待下一个调用信息，最后，客户端调用进程接收答复信息，获得进程结果，然后调用执行继续进行。有多种 RPC模式和执行。最初由 Sun 公司提出。IETF ONC 宪章重新修订了 Sun 版本，使得 ONC RPC 协议成为 IETF 标准协议。现在使用最普遍的模式和执行是开放式软件基础的分布式计算环境（DCE）。</code></pre><h4 id="三、为什么要用Dubbo"><a href="#三、为什么要用Dubbo" class="headerlink" title="三、为什么要用Dubbo?"></a>三、为什么要用Dubbo?</h4><pre><code>    因为是阿里开源项目，国内很多互联网公司都在用，已经经过很多线上考验。内部使用了 Netty、Zookeeper，保证了高性能高可用性。    使用 Dubbo 可以将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，可用于提高业务复用灵活扩展，使前端应用能更快速的响应多变的市场需求。下面这张图可以很清楚的诠释，最重要的一点是，分布式架构可以承受更大规模的并发流量。</code></pre><p><img src="//zongmansheng.club/2019/02/19/dubbo-chang-jian-mian-shi-ti-zong-jie/1550554002964.png" alt="1550554002964"></p><p>下面是 Dubbo 的服务治理图。</p><p><img src="//zongmansheng.club/2019/02/19/dubbo-chang-jian-mian-shi-ti-zong-jie/1550554034880.png" alt="1550554034880"></p><h4 id="四、Dubbo-和-Spring-Cloud-有什么区别？"><a href="#四、Dubbo-和-Spring-Cloud-有什么区别？" class="headerlink" title="四、Dubbo 和 Spring Cloud 有什么区别？"></a>四、Dubbo 和 Spring Cloud 有什么区别？</h4><pre><code>两个没关联，如果硬要说区别，有以下几点。1）通信方式不同Dubbo 使用的是 RPC 通信，而 Spring Cloud 使用的是 HTTP RESTFul 方式。2）组成部分不同</code></pre><p><img src="//zongmansheng.club/2019/02/19/dubbo-chang-jian-mian-shi-ti-zong-jie/1550554095559.png" alt="1550554095559"></p><h4 id="五、dubbo都支持什么协议，推荐用哪种？"><a href="#五、dubbo都支持什么协议，推荐用哪种？" class="headerlink" title="五、dubbo都支持什么协议，推荐用哪种？"></a>五、dubbo都支持什么协议，推荐用哪种？</h4><pre><code>dubbo://（推荐）rmi://hessian://http://webservice://thrift://memcached://redis://rest://</code></pre><h4 id="六、Dubbo需要-Web-容器吗？"><a href="#六、Dubbo需要-Web-容器吗？" class="headerlink" title="六、Dubbo需要 Web 容器吗？"></a>六、Dubbo需要 Web 容器吗？</h4><pre><code>不需要，如果硬要用 Web 容器，只会增加复杂性，也浪费资源。</code></pre><h4 id="七、Dubbo内置了哪几种服务容器？"><a href="#七、Dubbo内置了哪几种服务容器？" class="headerlink" title="七、Dubbo内置了哪几种服务容器？"></a>七、Dubbo内置了哪几种服务容器？</h4><pre><code>Spring ContainerJetty ContainerLog4j ContainerDubbo 的服务容器只是一个简单的 Main 方法，并加载一个简单的 Spring 容器，用于暴露服务。</code></pre><h4 id="八、Dubbo里面有哪几种节点角色？"><a href="#八、Dubbo里面有哪几种节点角色？" class="headerlink" title="八、Dubbo里面有哪几种节点角色？"></a>八、Dubbo里面有哪几种节点角色？</h4><p><img src="//zongmansheng.club/2019/02/19/dubbo-chang-jian-mian-shi-ti-zong-jie/1550554250039.png" alt="1550554250039"></p><h4 id="九、画一画服务注册与发现的流程图"><a href="#九、画一画服务注册与发现的流程图" class="headerlink" title="九、画一画服务注册与发现的流程图"></a>九、画一画服务注册与发现的流程图</h4><p><img src="//zongmansheng.club/2019/02/19/dubbo-chang-jian-mian-shi-ti-zong-jie/1550554288101.png" alt="1550554288101"></p><h4 id="十、Dubbo默认使用什么注册中心，还有别的选择吗？"><a href="#十、Dubbo默认使用什么注册中心，还有别的选择吗？" class="headerlink" title="十、Dubbo默认使用什么注册中心，还有别的选择吗？"></a>十、Dubbo默认使用什么注册中心，还有别的选择吗？</h4><pre><code>推荐使用 Zookeeper 作为注册中心，还有 Redis、Multicast、Simple 注册中心，但不推荐。</code></pre><h4 id="十一、Dubbo有哪几种配置方式？"><a href="#十一、Dubbo有哪几种配置方式？" class="headerlink" title="十一、Dubbo有哪几种配置方式？"></a>十一、Dubbo有哪几种配置方式？</h4><pre><code>1）Spring 配置方式2）Java API 配置方式</code></pre><h4 id="十二、Dubbo-核心的配置有哪些？"><a href="#十二、Dubbo-核心的配置有哪些？" class="headerlink" title="十二、Dubbo 核心的配置有哪些？"></a>十二、Dubbo 核心的配置有哪些？</h4><p><img src="//zongmansheng.club/2019/02/19/dubbo-chang-jian-mian-shi-ti-zong-jie/1550554406352.png" alt="1550554406352"></p><p>配置之间的关系见下图。</p><p><img src="//zongmansheng.club/2019/02/19/dubbo-chang-jian-mian-shi-ti-zong-jie/1550554429525.png" alt="1550554429525"></p><h4 id="十三、在-Provider-上可以配置的-Consumer-端的属性有哪些？"><a href="#十三、在-Provider-上可以配置的-Consumer-端的属性有哪些？" class="headerlink" title="十三、在 Provider 上可以配置的 Consumer 端的属性有哪些？"></a>十三、在 Provider 上可以配置的 Consumer 端的属性有哪些？</h4><pre><code>1）timeout：方法调用超时2）retries：失败重试次数，默认重试 2 次3）loadbalance：负载均衡算法，默认随机4）actives 消费者端，最大并发调用限制</code></pre><h4 id="十四、Dubbo启动时如果依赖的服务不可用会怎样？"><a href="#十四、Dubbo启动时如果依赖的服务不可用会怎样？" class="headerlink" title="十四、Dubbo启动时如果依赖的服务不可用会怎样？"></a>十四、Dubbo启动时如果依赖的服务不可用会怎样？</h4><pre><code>Dubbo 缺省会在启动时检查依赖的服务是否可用，不可用时会抛出异常，阻止 Spring 初始化完成，默认 check=&quot;true&quot;，可以通过 check=&quot;false&quot; 关闭检查。</code></pre><h4 id="十五、Dubbo默认使用的是什么通信框架，还有别的选择吗？"><a href="#十五、Dubbo默认使用的是什么通信框架，还有别的选择吗？" class="headerlink" title="十五、Dubbo默认使用的是什么通信框架，还有别的选择吗？"></a>十五、Dubbo默认使用的是什么通信框架，还有别的选择吗？</h4><pre><code>Dubbo 默认使用 Netty 框架，也是推荐的选择，另外内容还集成有Mina、Grizzly。</code></pre><h4 id="十六、Dubbo推荐使用什么序列化框架，你知道的还有哪些？"><a href="#十六、Dubbo推荐使用什么序列化框架，你知道的还有哪些？" class="headerlink" title="十六、Dubbo推荐使用什么序列化框架，你知道的还有哪些？"></a>十六、Dubbo推荐使用什么序列化框架，你知道的还有哪些？</h4><pre><code>推荐使用Hessian序列化，还有Duddo、FastJson、Java自带序列化。</code></pre><h4 id="十七、Dubbo有哪几种集群容错方案，默认是哪种？"><a href="#十七、Dubbo有哪几种集群容错方案，默认是哪种？" class="headerlink" title="十七、Dubbo有哪几种集群容错方案，默认是哪种？"></a>十七、Dubbo有哪几种集群容错方案，默认是哪种？</h4><p><img src="//zongmansheng.club/2019/02/19/dubbo-chang-jian-mian-shi-ti-zong-jie/1550554627446.png" alt="1550554627446"></p><h4 id="十八、Dubbo有哪几种负载均衡策略，默认是哪种？"><a href="#十八、Dubbo有哪几种负载均衡策略，默认是哪种？" class="headerlink" title="十八、Dubbo有哪几种负载均衡策略，默认是哪种？"></a>十八、Dubbo有哪几种负载均衡策略，默认是哪种？</h4><p><img src="//zongmansheng.club/2019/02/19/dubbo-chang-jian-mian-shi-ti-zong-jie/1550554672227.png" alt="1550554672227"></p><h4 id="十九、注册了多个同一样的服务，如果测试指定的某一个服务呢？"><a href="#十九、注册了多个同一样的服务，如果测试指定的某一个服务呢？" class="headerlink" title="十九、注册了多个同一样的服务，如果测试指定的某一个服务呢？"></a>十九、注册了多个同一样的服务，如果测试指定的某一个服务呢？</h4><pre><code>可以配置环境点对点直连，绕过注册中心，将以服务接口为单位，忽略注册中心的提供者列表。</code></pre><h4 id="二十、Dubbo支持服务多协议吗？"><a href="#二十、Dubbo支持服务多协议吗？" class="headerlink" title="二十、Dubbo支持服务多协议吗？"></a>二十、Dubbo支持服务多协议吗？</h4><pre><code>Dubbo 允许配置多协议，在不同服务上支持不同协议或者同一服务上同时支持多种协议。</code></pre><h4 id="二十一、当一个服务接口有多种实现时怎么做？"><a href="#二十一、当一个服务接口有多种实现时怎么做？" class="headerlink" title="二十一、当一个服务接口有多种实现时怎么做？"></a>二十一、当一个服务接口有多种实现时怎么做？</h4><pre><code>当一个接口有多种实现时，可以用 group 属性来分组，服务提供方和消费方都指定同一个 group 即可。</code></pre><h4 id="二十二、服务上线怎么兼容旧版本？"><a href="#二十二、服务上线怎么兼容旧版本？" class="headerlink" title="二十二、服务上线怎么兼容旧版本？"></a>二十二、服务上线怎么兼容旧版本？</h4><pre><code>可以用版本号（version）过渡，多个不同版本的服务注册到注册中心，版本号不同的服务相互间不引用。这个和服务分组的概念有一点类似。</code></pre><h4 id="二十三、Dubbo可以对结果进行缓存吗？"><a href="#二十三、Dubbo可以对结果进行缓存吗？" class="headerlink" title="二十三、Dubbo可以对结果进行缓存吗？"></a>二十三、Dubbo可以对结果进行缓存吗？</h4><pre><code>可以，Dubbo 提供了声明式缓存，用于加速热门数据的访问速度，以减少用户加缓存的工作量。</code></pre><h4 id="二十四、Dubbo服务之间的调用是阻塞的吗？"><a href="#二十四、Dubbo服务之间的调用是阻塞的吗？" class="headerlink" title="二十四、Dubbo服务之间的调用是阻塞的吗？"></a>二十四、Dubbo服务之间的调用是阻塞的吗？</h4><pre><code>默认是同步等待结果阻塞的，支持异步调用。Dubbo 是基于 NIO 的非阻塞实现并行调用，客户端不需要启动多线程即可完成并行调用多个远程服务，相对多线程开销较小，异步调用会返回一个 Future 对象。</code></pre><p><img src="//zongmansheng.club/2019/02/19/dubbo-chang-jian-mian-shi-ti-zong-jie/1550554946569.png" alt="1550554946569"></p><h4 id="二十五、Dubbo支持分布式事务吗？"><a href="#二十五、Dubbo支持分布式事务吗？" class="headerlink" title="二十五、Dubbo支持分布式事务吗？"></a>二十五、Dubbo支持分布式事务吗？</h4><p>目前暂时不支持，后续可能采用基于 JTA/XA 规范实现，如以图所示。</p><p><img src="//zongmansheng.club/2019/02/19/dubbo-chang-jian-mian-shi-ti-zong-jie/1550554990475.png" alt="1550554990475"></p><h4 id="二十六、Dubbo-telnet-命令能做什么？"><a href="#二十六、Dubbo-telnet-命令能做什么？" class="headerlink" title="二十六、Dubbo telnet 命令能做什么？"></a>二十六、Dubbo telnet 命令能做什么？</h4><pre><code>dubbo 通过 telnet 命令来进行服务治理，具体使用看这篇文章《dubbo服务调试管理实用命令》。telnet localhost 8090</code></pre><h4 id="二十七、Dubbo支持服务降级吗？"><a href="#二十七、Dubbo支持服务降级吗？" class="headerlink" title="二十七、Dubbo支持服务降级吗？"></a>二十七、Dubbo支持服务降级吗？</h4><pre><code>Dubbo 2.2.0 以上版本支持。</code></pre><h4 id="二十八、Dubbo如何优雅停机？"><a href="#二十八、Dubbo如何优雅停机？" class="headerlink" title="二十八、Dubbo如何优雅停机？"></a>二十八、Dubbo如何优雅停机？</h4><pre><code>Dubbo 是通过 JDK 的 ShutdownHook 来完成优雅停机的，所以如果使用 kill -9 PID 等强制关闭指令，是不会执行优雅停机的，只有通过 kill PID 时，才会执行。</code></pre><h4 id="二十九、服务提供者能实现失效踢出是什么原理？"><a href="#二十九、服务提供者能实现失效踢出是什么原理？" class="headerlink" title="二十九、服务提供者能实现失效踢出是什么原理？"></a>二十九、服务提供者能实现失效踢出是什么原理？</h4><pre><code>服务失效踢出基于 Zookeeper 的临时节点原理。</code></pre><h4 id="三十、如何解决服务调用链过长的问题？"><a href="#三十、如何解决服务调用链过长的问题？" class="headerlink" title="三十、如何解决服务调用链过长的问题？"></a>三十、如何解决服务调用链过长的问题？</h4><pre><code>Dubbo 可以使用 Pinpoint 和 Apache Skywalking(Incubator) 实现分布式服务追踪，当然还有其他很多方案。</code></pre><h4 id="三十一、服务读写推荐的容错策略是怎样的？"><a href="#三十一、服务读写推荐的容错策略是怎样的？" class="headerlink" title="三十一、服务读写推荐的容错策略是怎样的？"></a>三十一、服务读写推荐的容错策略是怎样的？</h4><pre><code>读操作建议使用 Failover 失败自动切换，默认重试两次其他服务器。写操作建议使用 Failfast 快速失败，发一次调用失败就立即报错。</code></pre><h4 id="三十二、Dubbo的管理控制台能做什么？"><a href="#三十二、Dubbo的管理控制台能做什么？" class="headerlink" title="三十二、Dubbo的管理控制台能做什么？"></a>三十二、Dubbo的管理控制台能做什么？</h4><pre><code>管理控制台主要包含：路由规则，动态配置，服务降级，访问控制，权重调整，负载均衡，等管理功能。</code></pre><h4 id="三十三、说说-Dubbo-服务暴露的过程。"><a href="#三十三、说说-Dubbo-服务暴露的过程。" class="headerlink" title="三十三、说说 Dubbo 服务暴露的过程。"></a>三十三、说说 Dubbo 服务暴露的过程。</h4><pre><code>Dubbo 会在 Spring 实例化完 bean 之后，在刷新容器最后一步发布 ContextRefreshEvent 事件的时候，通知实现了 ApplicationListener 的 ServiceBean 类进行回调 onApplicationEvent 事件方法，Dubbo 会在这个方法中调用 ServiceBean 父类 ServiceConfig 的 export 方法，而该方法真正实现了服务的（异步或者非异步）发布。    </code></pre><h4 id="三十四、Dubbo-停止维护了吗？"><a href="#三十四、Dubbo-停止维护了吗？" class="headerlink" title="三十四、Dubbo 停止维护了吗？"></a>三十四、Dubbo 停止维护了吗？</h4><pre><code>2014 年开始停止维护过几年，17 年开始重新维护，并进入了 Apache 项目。</code></pre><h4 id="三十五、Dubbo-和-Dubbox-有什么区别？"><a href="#三十五、Dubbo-和-Dubbox-有什么区别？" class="headerlink" title="三十五、Dubbo 和 Dubbox 有什么区别？"></a>三十五、Dubbo 和 Dubbox 有什么区别？</h4><pre><code>Dubbox 是继 Dubbo 停止维护后，当当网基于 Dubbo 做的一个扩展项目，如加了服务可 Restful 调用，更新了开源组件等。</code></pre><h4 id="三十六、你还了解别的分布式框架吗？"><a href="#三十六、你还了解别的分布式框架吗？" class="headerlink" title="三十六、你还了解别的分布式框架吗？"></a>三十六、你还了解别的分布式框架吗？</h4><pre><code>别的还有 Spring cloud、Facebook 的 Thrift、Twitter 的 Finagle 等。</code></pre><h4 id="三十七、Dubbo-能集成-Spring-Boot-吗？"><a href="#三十七、Dubbo-能集成-Spring-Boot-吗？" class="headerlink" title="三十七、Dubbo 能集成 Spring Boot 吗？"></a>三十七、Dubbo 能集成 Spring Boot 吗？</h4><pre><code>https://github.com/apache/incubator-dubbo-spring-boot-project</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Dubbo面试题总结&quot;&gt;&lt;a href=&quot;#Dubbo面试题总结&quot; class=&quot;headerlink&quot; title=&quot;Dubbo面试题总结&quot;&gt;&lt;/a&gt;Dubbo面试题总结&lt;/h1&gt;&lt;h4 id=&quot;一、Dubbo是什么？&quot;&gt;&lt;a href=&quot;#一、Dubbo是什么
      
    
    </summary>
    
      <category term="面试题" scheme="http://zongmansheng.club/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="Dubbo" scheme="http://zongmansheng.club/tags/Dubbo/"/>
    
      <category term="Zookeeper" scheme="http://zongmansheng.club/tags/Zookeeper/"/>
    
      <category term="RPC" scheme="http://zongmansheng.club/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://zongmansheng.club/2019/02/17/hello-world/"/>
    <id>http://zongmansheng.club/2019/02/17/hello-world/</id>
    <published>2019-02-17T03:38:58.205Z</published>
    <updated>2019-02-17T03:38:58.205Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
