<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>晓笙的BLOG</title>
  
  <subtitle>一个来自暗夜里的影子</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zongmansheng.club/"/>
  <updated>2019-08-09T12:38:37.078Z</updated>
  <id>http://zongmansheng.club/</id>
  
  <author>
    <name>ZongMan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MYSQL数据库设计规范与原则</title>
    <link href="http://zongmansheng.club/2019/08/08/mysql-shu-ju-ku-she-ji-gui-fan-yu-yuan-ze/"/>
    <id>http://zongmansheng.club/2019/08/08/mysql-shu-ju-ku-she-ji-gui-fan-yu-yuan-ze/</id>
    <published>2019-08-08T01:07:49.000Z</published>
    <updated>2019-08-09T12:38:37.078Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MYSQL数据库设计规范与原则"><a href="#MYSQL数据库设计规范与原则" class="headerlink" title="MYSQL数据库设计规范与原则"></a>MYSQL数据库设计规范与原则</h1><p>MYSQL数据库设计规范</p><pre><code>1、数据库命名规范    采用26个英文字母(区分大小写)和0-9的自然数(经常不需要)加上下划线&#39;_&#39;组成;    命名简洁明确(长度不能超过30个字符);    例如：user, stat, log, 也可以wifi_user, wifi_stat, wifi_log给数据库加个前缀;    除非是备份数据库可以加0-9的自然数：user_db_20151210;2、数据库表名命名规范    采用26个英文字母(区分大小写)和0-9的自然数(经常不需要)加上下划线&#39;_&#39;组成;    命名简洁明确,多个单词用下划线&#39;_&#39;分隔;    例如：user_login, user_profile, user_detail, user_role, user_role_relation,        user_role_right, user_role_right_relation    表前缀&#39;user_&#39;可以有效的把相同关系的表显示在一起;3、数据库表字段名命名规范    采用26个英文字母(区分大小写)和0-9的自然数(经常不需要)加上下划线&#39;_&#39;组成;    命名简洁明确,多个单词用下划线&#39;_&#39;分隔;    例如：user_login表字段 user_id, user_name, pass_word, eamil, tickit, status, mobile, add_time;    每个表中必须有自增主键,add_time(默认系统时间)    表与表之间的相关联字段名称要求尽可能的相同;4、数据库表字段类型规范    用尽量少的存储空间来存数一个字段的数据;    例如：能使用int就不要使用varchar、char,能用varchar(16)就不要使用varchar(256);    IP地址最好使用int类型;    固定长度的类型最好使用char,例如：邮编;    能使用tinyint就不要使用smallint,int;    最好给每个字段一个默认值,最好不能为null;5、数据库表索引规范    命名简洁明确,例如：user_login表user_name字段的索引应为user_name_index唯一索引;    为每个表创建一个主键索引;    为每个表创建合理的索引;    建立复合索引请慎重;6、简单熟悉数据库范式    第一范式(1NF)：字段值具有原子性,不能再分(所有关系型数据库系统都满足第一范式);        例如：姓名字段,其中姓和名是一个整体,如果区分姓和名那么必须设立两个独立字段;    第二范式(2NF)：一个表必须有主键,即每行数据都能被唯一的区分;        备注：必须先满足第一范式;    第三范式(3NF)：一个表中不能包涵其他相关表中非关键字段的信息,即数据表不能有沉余字段;        备注：必须先满足第二范式;</code></pre><p>数据库的三范式：<br>①字段不可分。<br>②有主键，非主键字段依赖主键。<br>③非主键字段不能互相依赖。</p><pre><code>    备注：往往我们在设计表中不能遵守第三范式,因为合理的沉余字段将会给我们减少join的查询;          例如：相册表中会添加图片的点击数字段,在相册图片表中也会添加图片的点击数字段;</code></pre><p>MYSQL数据库设计原则</p><pre><code>1、核心原则    不在数据库做运算;    cpu计算务必移至业务层;    控制列数量(字段少而精,字段数建议在20以内);    平衡范式与冗余(效率优先；往往牺牲范式)    拒绝3B(拒绝大sql语句：big sql、拒绝大事物：big transaction、拒绝大批量：big batch);2、字段类原则    用好数值类型(用合适的字段类型节约空间);    字符转化为数字(能转化的最好转化,同样节约空间、提高查询性能);    避免使用NULL字段(NULL字段很难查询优化、NULL字段的索引需要额外空间、NULL字段的复合索引无效);    少用text类型(尽量使用varchar代替text字段);3、索引类原则    合理使用索引(改善查询,减慢更新,索引一定不是越多越好);    字符字段必须建前缀索引;    不在索引做列运算;    innodb主键推荐使用自增列(主键建立聚簇索引,主键不应该被修改,字符串不应该做主键)(理解Innodb的索引保存结构就知道了);    不用外键(由程序保证约束);4、sql类原则    sql语句尽可能简单(一条sql只能在一个cpu运算,大语句拆小语句,减少锁时间,一条大sql可以堵死整个库);    简单的事务;    避免使用trig/func(触发器、函数不用客户端程序取而代之);    不用select *(消耗cpu,io,内存,带宽,这种程序不具有扩展性);    OR改写为IN(or的效率是n级别);    OR改写为UNION(mysql的索引合并很弱智);        select id from t where phone = ’159′ or name = ‘john’;        =&gt;        select id from t where phone=’159′        union        select id from t where name=’jonh’    避免负向%;    慎用count(*);    limit高效分页(limit越大，效率越低);    使用union all替代union(union有去重开销);    少用连接join;    使用group by;    请使用同类型比较;    打散批量更新;5、性能分析工具    show profile;    mysqlsla;    mysqldumpslow;    explain;    show slow log;    show processlist;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MYSQL数据库设计规范与原则&quot;&gt;&lt;a href=&quot;#MYSQL数据库设计规范与原则&quot; class=&quot;headerlink&quot; title=&quot;MYSQL数据库设计规范与原则&quot;&gt;&lt;/a&gt;MYSQL数据库设计规范与原则&lt;/h1&gt;&lt;p&gt;MYSQL数据库设计规范&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="数据库" scheme="http://zongmansheng.club/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mysql" scheme="http://zongmansheng.club/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql-存储过程</title>
    <link href="http://zongmansheng.club/2019/07/31/mysql-cun-chu-guo-cheng/"/>
    <id>http://zongmansheng.club/2019/07/31/mysql-cun-chu-guo-cheng/</id>
    <published>2019-07-31T05:20:33.000Z</published>
    <updated>2019-07-31T05:25:12.288Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL-数据库之存储过程的创建和调用"><a href="#MySQL-数据库之存储过程的创建和调用" class="headerlink" title="MySQL 数据库之存储过程的创建和调用"></a>MySQL 数据库之存储过程的创建和调用</h1><h3 id="MySQL-5-0-版本开始支持存储过程。"><a href="#MySQL-5-0-版本开始支持存储过程。" class="headerlink" title="MySQL 5.0 版本开始支持存储过程。"></a>MySQL 5.0 版本开始支持存储过程。</h3><blockquote><p>存储过程（Stored Procedure）是一种在数据库中存储复杂程序，以便外部程序调用的一种数据库对象。</p><p>存储过程是为了完成特定功能的SQL语句集，经编译创建并保存在数据库中，用户可通过指定存储过程的名字并给定参数(需要时)来调用执行。</p><p>存储过程思想上很简单，就是数据库 SQL 语言层面的代码封装与重用。</p></blockquote><h4 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h4><blockquote><ul><li>存储过程可封装，并隐藏复杂的商业逻辑。</li><li>存储过程可以回传值，并可以接受参数。</li><li>存储过程无法使用 SELECT 指令来运行，因为它是子程序，与查看表，数据表或用户定义函数不同。</li><li>存储过程可以用在数据检验，强制实行商业逻辑等。</li></ul></blockquote><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点:"></a>缺点:</h4><blockquote><ul><li>存储过程，往往定制化于特定的数据库上，因为支持的编程语言不同。当切换到其他厂商的数据库系统时，需要重写原有的存储过程。</li><li>存储过程的性能调校与撰写，受限于各种数据库系统。</li></ul></blockquote><h3 id="存储过程的创建和调用"><a href="#存储过程的创建和调用" class="headerlink" title="存储过程的创建和调用"></a>存储过程的创建和调用</h3><h4 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL-数据库之存储过程的创建和调用&quot;&gt;&lt;a href=&quot;#MySQL-数据库之存储过程的创建和调用&quot; class=&quot;headerlink&quot; title=&quot;MySQL 数据库之存储过程的创建和调用&quot;&gt;&lt;/a&gt;MySQL 数据库之存储过程的创建和调用&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="数据库" scheme="http://zongmansheng.club/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mysql" scheme="http://zongmansheng.club/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>线程池</title>
    <link href="http://zongmansheng.club/2019/07/30/xian-cheng-chi/"/>
    <id>http://zongmansheng.club/2019/07/30/xian-cheng-chi/</id>
    <published>2019-07-30T05:42:30.000Z</published>
    <updated>2019-07-30T08:18:26.573Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h1><blockquote><p>​        我们有两种常见的创建线程的方法，一种是继承Thread类，一种是实现Runnable的接口，Thread类其实也是实现了Runnable接口。但是我们创建这两种线程在运行结束后都会被虚拟机销毁，如果线程数量多的话，频繁的创建和销毁线程会大大浪费时间和效率，更重要的是浪费内存，因为正常来说线程执行完毕后死亡，线程对象变成垃圾！那么有没有一种方法能让线程运行完后不立即销毁，而是让线程重复使用，继续执行其他的任务哪？我们使用线程池就能很好地解决这个问题。</p></blockquote><h3 id="一、Java中的ThreadPoolExecutor类"><a href="#一、Java中的ThreadPoolExecutor类" class="headerlink" title="一、Java中的ThreadPoolExecutor类"></a>一、Java中的ThreadPoolExecutor类</h3><blockquote><p>java.uitl.concurrent.ThreadPoolExecutor类是线程池中最核心的一个类，因此如果要透彻地了解Java中的线程池，必须先了解这个类。下面我们来看一下ThreadPoolExecutor类的具体实现源码。</p><p>在ThreadPoolExecutor类中提供了四个构造方法：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadPoolExecutor</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractExecutorService</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">public</span> <span class="token function">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span><span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span><span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>TimeUnit unit<span class="token punctuation">,</span>            BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span><span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span><span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>TimeUnit unit<span class="token punctuation">,</span>            BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue<span class="token punctuation">,</span>ThreadFactory threadFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span><span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span><span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>TimeUnit unit<span class="token punctuation">,</span>            BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue<span class="token punctuation">,</span>RejectedExecutionHandler handler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span><span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span><span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>TimeUnit unit<span class="token punctuation">,</span>        BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue<span class="token punctuation">,</span>ThreadFactory threadFactory<span class="token punctuation">,</span>RejectedExecutionHandler handler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><blockquote><p>从上面的代码可以得知，ThreadPoolExecutor继承了AbstractExecutorService类，并提供了四个构造器，事实上，通过观察每个构造器的源码具体实现，发现前面三个构造器都是调用的第四个构造器进行的初始化工作。</p><p>　　下面解释下一下构造器中各个参数的含义：</p><ul><li>corePoolSize：核心池的大小，这个参数跟后面讲述的线程池的实现原理有非常大的关系。在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了prestartAllCoreThreads()或者prestartCoreThread()方法，从这2个方法的名字就可以看出，是预创建线程的意思，即在没有任务到来之前就创建corePoolSize个线程或者一个线程。默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中；</li><li>maximumPoolSize：线程池最大线程数，这个参数也是一个非常重要的参数，它表示在线程池中最多能创建多少个线程；</li><li>keepAliveTime：表示线程没有任务执行时最多保持多久时间会终止。默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用，直到线程池中的线程数不大于corePoolSize，即当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize。但是如果调用了allowCoreThreadTimeOut(boolean)方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0；</li><li>unit：参数keepAliveTime的时间单位，有7种取值，在TimeUnit类中有7种静态属性：</li></ul></blockquote><pre class=" language-java"><code class="language-java">TimeUnit<span class="token punctuation">.</span>DAYS<span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">//天</span>TimeUnit<span class="token punctuation">.</span>HOURS<span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//小时</span>TimeUnit<span class="token punctuation">.</span>MINUTES<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//分钟</span>TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//秒</span>TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//毫秒</span>TimeUnit<span class="token punctuation">.</span>MICROSECONDS<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//微妙</span>TimeUnit<span class="token punctuation">.</span>NANOSECONDS<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//纳秒</span></code></pre><blockquote><p>workQueue：一个阻塞队列，用来存储等待执行的任务，这个参数的选择也很重要，会对线程池的运行过程产生重大影响，一般来说，这里的阻塞队列有以下几种选择：</p></blockquote><blockquote><pre class=" language-java"><code class="language-java">ArrayBlockingQueue<span class="token punctuation">;</span>LinkedBlockingQueue<span class="token punctuation">;</span>SynchronousQueue<span class="token punctuation">;</span></code></pre></blockquote><blockquote><p>ArrayBlockingQueue和PriorityBlockingQueue使用较少，一般使用LinkedBlockingQueue和Synchronous。线程池的排队策略与BlockingQueue有关。</p><ul><li>threadFactory：线程工厂，主要用来创建线程；</li><li>handler：表示当拒绝处理任务时的策略，有以下四种取值：</li></ul></blockquote><pre class=" language-java"><code class="language-java">ThreadPoolExecutor<span class="token punctuation">.</span>AbortPolicy<span class="token operator">:</span>丢弃任务并抛出RejectedExecutionException异常。 ThreadPoolExecutor<span class="token punctuation">.</span>DiscardPolicy：也是丢弃任务，但是不抛出异常。 ThreadPoolExecutor<span class="token punctuation">.</span>DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）ThreadPoolExecutor<span class="token punctuation">.</span>CallerRunsPolicy：由调用线程处理该任务 </code></pre><blockquote><p>从上面给出的ThreadPoolExecutor类的代码可以知道，ThreadPoolExecutor继承了AbstractExecutorService，我们来看一下AbstractExecutorService的实现：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @since 1.5 * @author Doug Lea */</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractExecutorService</span> <span class="token keyword">implements</span> <span class="token class-name">ExecutorService</span> <span class="token punctuation">{</span>    <span class="token keyword">protected</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> RunnableFuture<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">newTaskFor</span><span class="token punctuation">(</span>Runnable runnable<span class="token punctuation">,</span> T value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>runnable<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">protected</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> RunnableFuture<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">newTaskFor</span><span class="token punctuation">(</span>Callable<span class="token operator">&lt;</span>T<span class="token operator">></span> callable<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>callable<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * @throws RejectedExecutionException {@inheritDoc}     * @throws NullPointerException       {@inheritDoc}     */</span>    <span class="token keyword">public</span> Future<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">submit</span><span class="token punctuation">(</span>Runnable task<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>task <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        RunnableFuture<span class="token operator">&lt;</span>Void<span class="token operator">></span> ftask <span class="token operator">=</span> <span class="token function">newTaskFor</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">execute</span><span class="token punctuation">(</span>ftask<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ftask<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * @throws RejectedExecutionException {@inheritDoc}     * @throws NullPointerException       {@inheritDoc}     */</span>    <span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> Future<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">submit</span><span class="token punctuation">(</span>Runnable task<span class="token punctuation">,</span> T result<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>task <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        RunnableFuture<span class="token operator">&lt;</span>T<span class="token operator">></span> ftask <span class="token operator">=</span> <span class="token function">newTaskFor</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">execute</span><span class="token punctuation">(</span>ftask<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ftask<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * @throws RejectedExecutionException {@inheritDoc}     * @throws NullPointerException       {@inheritDoc}     */</span>    <span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> Future<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">submit</span><span class="token punctuation">(</span>Callable<span class="token operator">&lt;</span>T<span class="token operator">></span> task<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>task <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        RunnableFuture<span class="token operator">&lt;</span>T<span class="token operator">></span> ftask <span class="token operator">=</span> <span class="token function">newTaskFor</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">execute</span><span class="token punctuation">(</span>ftask<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ftask<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * the main mechanics of invokeAny.     */</span>    <span class="token keyword">private</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> T <span class="token function">doInvokeAny</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>T<span class="token operator">>></span> tasks<span class="token punctuation">,</span>                              <span class="token keyword">boolean</span> timed<span class="token punctuation">,</span> <span class="token keyword">long</span> nanos<span class="token punctuation">)</span>        <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">,</span> ExecutionException<span class="token punctuation">,</span> TimeoutException <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>tasks <span class="token operator">==</span> null<span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> ntasks <span class="token operator">=</span> tasks<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ntasks <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ArrayList<span class="token operator">&lt;</span>Future<span class="token operator">&lt;</span>T<span class="token operator">>></span> futures <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Future<span class="token operator">&lt;</span>T<span class="token operator">>></span><span class="token punctuation">(</span>ntasks<span class="token punctuation">)</span><span class="token punctuation">;</span>        ExecutorCompletionService<span class="token operator">&lt;</span>T<span class="token operator">></span> ecs <span class="token operator">=</span>            <span class="token keyword">new</span> <span class="token class-name">ExecutorCompletionService</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// For efficiency, especially in executors with limited</span>        <span class="token comment" spellcheck="true">// parallelism, check to see if previously submitted tasks are</span>        <span class="token comment" spellcheck="true">// done before submitting more of them. This interleaving</span>        <span class="token comment" spellcheck="true">// plus the exception mechanics account for messiness of main</span>        <span class="token comment" spellcheck="true">// loop.</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// Record exceptions so that if we fail to obtain any</span>            <span class="token comment" spellcheck="true">// result, we can throw the last exception we got.</span>            ExecutionException ee <span class="token operator">=</span> null<span class="token punctuation">;</span>            <span class="token keyword">final</span> <span class="token keyword">long</span> deadline <span class="token operator">=</span> timed <span class="token operator">?</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> nanos <span class="token operator">:</span> 0L<span class="token punctuation">;</span>            Iterator<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>T<span class="token operator">>></span> it <span class="token operator">=</span> tasks<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// Start one task for sure; the rest incrementally</span>            futures<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>ecs<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">--</span>ntasks<span class="token punctuation">;</span>            <span class="token keyword">int</span> active <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                Future<span class="token operator">&lt;</span>T<span class="token operator">></span> f <span class="token operator">=</span> ecs<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>ntasks <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token operator">--</span>ntasks<span class="token punctuation">;</span>                        futures<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>ecs<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token operator">++</span>active<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>active <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>timed<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        f <span class="token operator">=</span> ecs<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span>nanos<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>NANOSECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token operator">==</span> null<span class="token punctuation">)</span>                            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TimeoutException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        nanos <span class="token operator">=</span> deadline <span class="token operator">-</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">else</span>                        f <span class="token operator">=</span> ecs<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token operator">--</span>active<span class="token punctuation">;</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        <span class="token keyword">return</span> f<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ExecutionException</span> eex<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        ee <span class="token operator">=</span> eex<span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RuntimeException</span> rex<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        ee <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ExecutionException</span><span class="token punctuation">(</span>rex<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ee <span class="token operator">==</span> null<span class="token punctuation">)</span>                ee <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ExecutionException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">throw</span> ee<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> size <span class="token operator">=</span> futures<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>                futures<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> T <span class="token function">invokeAny</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>T<span class="token operator">>></span> tasks<span class="token punctuation">)</span>        <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">,</span> ExecutionException <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token function">doInvokeAny</span><span class="token punctuation">(</span>tasks<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">TimeoutException</span> cannotHappen<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">assert</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> T <span class="token function">invokeAny</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>T<span class="token operator">>></span> tasks<span class="token punctuation">,</span>                           <span class="token keyword">long</span> timeout<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">)</span>        <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">,</span> ExecutionException<span class="token punctuation">,</span> TimeoutException <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">doInvokeAny</span><span class="token punctuation">(</span>tasks<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> List<span class="token operator">&lt;</span>Future<span class="token operator">&lt;</span>T<span class="token operator">>></span> <span class="token function">invokeAll</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>T<span class="token operator">>></span> tasks<span class="token punctuation">)</span>        <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>tasks <span class="token operator">==</span> null<span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ArrayList<span class="token operator">&lt;</span>Future<span class="token operator">&lt;</span>T<span class="token operator">>></span> futures <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Future<span class="token operator">&lt;</span>T<span class="token operator">>></span><span class="token punctuation">(</span>tasks<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> done <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Callable<span class="token operator">&lt;</span>T<span class="token operator">></span> t <span class="token operator">:</span> tasks<span class="token punctuation">)</span> <span class="token punctuation">{</span>                RunnableFuture<span class="token operator">&lt;</span>T<span class="token operator">></span> f <span class="token operator">=</span> <span class="token function">newTaskFor</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>                futures<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">execute</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> size <span class="token operator">=</span> futures<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                Future<span class="token operator">&lt;</span>T<span class="token operator">></span> f <span class="token operator">=</span> futures<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>f<span class="token punctuation">.</span><span class="token function">isDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        f<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">CancellationException</span> ignore<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ExecutionException</span> ignore<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            done <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> futures<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>done<span class="token punctuation">)</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> size <span class="token operator">=</span> futures<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>                    futures<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> List<span class="token operator">&lt;</span>Future<span class="token operator">&lt;</span>T<span class="token operator">>></span> <span class="token function">invokeAll</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>T<span class="token operator">>></span> tasks<span class="token punctuation">,</span>                                         <span class="token keyword">long</span> timeout<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">)</span>        <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>tasks <span class="token operator">==</span> null<span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> nanos <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>        ArrayList<span class="token operator">&lt;</span>Future<span class="token operator">&lt;</span>T<span class="token operator">>></span> futures <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Future<span class="token operator">&lt;</span>T<span class="token operator">>></span><span class="token punctuation">(</span>tasks<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> done <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Callable<span class="token operator">&lt;</span>T<span class="token operator">></span> t <span class="token operator">:</span> tasks<span class="token punctuation">)</span>                futures<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token function">newTaskFor</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">final</span> <span class="token keyword">long</span> deadline <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> nanos<span class="token punctuation">;</span>            <span class="token keyword">final</span> <span class="token keyword">int</span> size <span class="token operator">=</span> futures<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// Interleave time checks and calls to execute in case</span>            <span class="token comment" spellcheck="true">// executor doesn't have any/much parallelism.</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Runnable<span class="token punctuation">)</span>futures<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                nanos <span class="token operator">=</span> deadline <span class="token operator">-</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nanos <span class="token operator">&lt;=</span> 0L<span class="token punctuation">)</span>                    <span class="token keyword">return</span> futures<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                Future<span class="token operator">&lt;</span>T<span class="token operator">></span> f <span class="token operator">=</span> futures<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>f<span class="token punctuation">.</span><span class="token function">isDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>nanos <span class="token operator">&lt;=</span> 0L<span class="token punctuation">)</span>                        <span class="token keyword">return</span> futures<span class="token punctuation">;</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        f<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>nanos<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>NANOSECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">CancellationException</span> ignore<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ExecutionException</span> ignore<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">TimeoutException</span> toe<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">return</span> futures<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    nanos <span class="token operator">=</span> deadline <span class="token operator">-</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            done <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> futures<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>done<span class="token punctuation">)</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> size <span class="token operator">=</span> futures<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>                    futures<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>AbstractExecutorService是一个抽象类，它实现了ExecutorService接口。</p><p>我们接着看ExecutorService接口的实现：</p></blockquote><pre><code>package java.util.concurrent;import java.util.List;import java.util.Collection;public interface ExecutorService extends Executor {    void shutdown();    List&lt;Runnable&gt; shutdownNow();    boolean isShutdown();    boolean isTerminated();    boolean awaitTermination(long timeout, TimeUnit unit)        throws InterruptedException;    &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);    &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);    Future&lt;?&gt; submit(Runnable task);    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)        throws InterruptedException;    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,                                  long timeout, TimeUnit unit)        throws InterruptedException;    &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)        throws InterruptedException, ExecutionException;    &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,                    long timeout, TimeUnit unit)        throws InterruptedException, ExecutionException, TimeoutException;}</code></pre><blockquote><p>而ExecutorService又是继承了Executor接口，我们看一下Executor接口的实现：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Executor</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span>Runnable command<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>到这里，大家应该明白了ThreadPoolExecutor、AbstractExecutorService、ExecutorService和Executor几个之间的关系了。</p><p>　　Executor是一个顶层接口，在它里面只声明了一个方法execute(Runnable)，返回值为void，参数为Runnable类型，从字面意思可以理解，就是用来执行传进去的任务的；</p><p>　　然后ExecutorService接口继承了Executor接口，并声明了一些方法：submit、invokeAll、invokeAny以及shutDown等；</p><p>　　抽象类AbstractExecutorService实现了ExecutorService接口，基本实现了ExecutorService中声明的所有方法；</p><p>　　然后ThreadPoolExecutor继承了类AbstractExecutorService。</p><p>　　在ThreadPoolExecutor类中有几个非常重要的方法：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">shutdownNow</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><blockquote><p>execute()方法实际上是Executor中声明的方法，在ThreadPoolExecutor进行了具体的实现，这个方法是ThreadPoolExecutor的核心方法，通过这个方法可以向线程池提交一个任务，交由线程池去执行。</p><p>　　submit()方法是在ExecutorService中声明的方法，在AbstractExecutorService就已经有了具体的实现，在ThreadPoolExecutor中并没有对其进行重写，这个方法也是用来向线程池提交任务的，但是它和execute()方法不同，它能够返回任务执行的结果，去看submit()方法的实现，会发现它实际上还是调用的execute()方法，只不过它利用了Future来获取任务执行结果（Future相关内容将在下一篇讲述）。</p><p>　　shutdown()和shutdownNow()是用来关闭线程池的。</p><p>　　还有很多其他的方法：</p><p>　　比如：getQueue() 、getPoolSize() 、getActiveCount()、getCompletedTaskCount()等获取与线程池相关属性的方法</p></blockquote><h3 id="二-深入剖析线程池实现原理"><a href="#二-深入剖析线程池实现原理" class="headerlink" title="二.深入剖析线程池实现原理"></a>二.深入剖析线程池实现原理</h3><blockquote><p>在上一节我们从宏观上介绍了ThreadPoolExecutor，下面我们来深入解析一下线程池的具体实现原理，将从下面几个方面讲解：</p><p>　　<strong>1.线程池状态</strong></p><p>　　<strong>2.任务的执行</strong></p><p>　　<strong>3.线程池中的线程初始化</strong></p><p>　　<strong>4.任务缓存队列及排队策略</strong></p><p>　　<strong>5.任务拒绝策略</strong></p><p>　　<strong>6.线程池的关闭</strong></p><p>　　<strong>7.线程池容量的动态调整</strong></p></blockquote><h4 id="1-线程池状态"><a href="#1-线程池状态" class="headerlink" title="1.线程池状态"></a><strong>1.线程池状态</strong></h4><blockquote><p>在ThreadPoolExecutor中定义了一个volatile变量，另外定义了几个static final变量表示线程池的各个状态：</p></blockquote><pre><code>        private static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;    private static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;    private static final int STOP       =  1 &lt;&lt; COUNT_BITS;    private static final int TIDYING    =  2 &lt;&lt; COUNT_BITS;    private static final int TERMINATED =  3 &lt;&lt; COUNT_BITS;</code></pre><blockquote><p>runState表示当前线程池的状态，它是一个volatile变量用来保证线程之间的可见性；</p><p>　　下面的几个static final变量表示runState可能的几个取值。</p><p>　　当创建线程池后，初始时，线程池处于RUNNING状态；</p><p>　　如果调用了shutdown()方法，则线程池处于SHUTDOWN状态，此时线程池不能够接受新的任务，它会等待所有任务执行完毕；</p><p>　　如果调用了shutdownNow()方法，则线程池处于STOP状态，此时线程池不能接受新的任务，并且会去尝试终止正在执行的任务；</p><p>　　当线程池处于SHUTDOWN或STOP状态，并且所有工作线程已经销毁，任务缓存队列已经清空或执行结束后，线程池被设置为TERMINATED状态。</p></blockquote><h4 id="2-任务的执行"><a href="#2-任务的执行" class="headerlink" title="2.任务的执行"></a><strong>2.任务的执行</strong></h4><blockquote><p>在了解将任务提交给线程池到任务执行完毕整个过程之前，我们先来看一下ThreadPoolExecutor类中其他的一些比较重要成员变量：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue<span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">//任务缓存队列，用来存放等待执行的任务</span><span class="token keyword">private</span> <span class="token keyword">final</span> ReentrantLock mainLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//线程池的主要状态锁，对线程池状态（比如线程池大小</span>                                                              <span class="token comment" spellcheck="true">//、runState等）的改变都要使用这个锁</span><span class="token keyword">private</span> <span class="token keyword">final</span> HashSet<span class="token operator">&lt;</span>Worker<span class="token operator">></span> workers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span>Worker<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//用来存放工作集</span><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">long</span>  keepAliveTime<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//线程存货时间   </span><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> allowCoreThreadTimeOut<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//是否允许为核心线程设置存活时间</span><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span>   corePoolSize<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//核心池的大小（即线程池中的线程数目大于这个参数时，提交的任务会被放进任务缓存队列）</span><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span>   maximumPoolSize<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//线程池最大能容忍的线程数</span><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span>   poolSize<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//线程池中当前的线程数</span><span class="token keyword">private</span> <span class="token keyword">volatile</span> RejectedExecutionHandler handler<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//任务拒绝策略</span><span class="token keyword">private</span> <span class="token keyword">volatile</span> ThreadFactory threadFactory<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//线程工厂，用来创建线程</span><span class="token keyword">private</span> <span class="token keyword">int</span> largestPoolSize<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//用来记录线程池中曾经出现过的最大线程数</span><span class="token keyword">private</span> <span class="token keyword">long</span> completedTaskCount<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//用来记录已经执行完毕的任务个数</span></code></pre><blockquote><p>每个变量的作用都已经标明出来了，这里要重点解释一下corePoolSize、maximumPoolSize、largestPoolSize三个变量。</p><p>　　corePoolSize在很多地方被翻译成核心池大小，其实我的理解这个就是线程池的大小。举个简单的例子：</p><p>　　假如有一个工厂，工厂里面有10个工人，每个工人同时只能做一件任务。</p><p>　　因此只要当10个工人中有工人是空闲的，来了任务就分配给空闲的工人做；</p><p>　　当10个工人都有任务在做时，如果还来了任务，就把任务进行排队等待；</p><p>　　如果说新任务数目增长的速度远远大于工人做任务的速度，那么此时工厂主管可能会想补救措施，比如重新招4个临时工人进来；</p><p>　　然后就将任务也分配给这4个临时工人做；</p><p>　　如果说着14个工人做任务的速度还是不够，此时工厂主管可能就要考虑不再接收新的任务或者抛弃前面的一些任务了。</p><p>　　当这14个工人当中有人空闲时，而新任务增长的速度又比较缓慢，工厂主管可能就考虑辞掉4个临时工了，只保持原来的10个工人，毕竟请额外的工人是要花钱的。</p><p>　　这个例子中的corePoolSize就是10，而maximumPoolSize就是14（10+4）。</p><p>　　也就是说corePoolSize就是线程池大小，maximumPoolSize在我看来是线程池的一种补救措施，即任务量突然过大时的一种补救措施。</p><p>　　不过为了方便理解，在本文后面还是将corePoolSize翻译成核心池大小。</p><p>　　largestPoolSize只是一个用来起记录作用的变量，用来记录线程池中曾经有过的最大线程数目，跟线程池的容量没有任何关系。</p><p>　　下面我们进入正题，看一下任务从提交到最终执行完毕经历了哪些过程。</p><p>　　在ThreadPoolExecutor类中，最核心的任务提交方法是execute()方法，虽然通过submit也可以提交任务，但是实际上submit方法里面最终调用的还是execute()方法，所以我们只需要研究execute()方法的实现原理即可：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span>Runnable command<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>command <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>poolSize <span class="token operator">>=</span> corePoolSize <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">addIfUnderCorePoolSize</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>runState <span class="token operator">==</span> RUNNING <span class="token operator">&amp;&amp;</span> workQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>runState <span class="token operator">!=</span> RUNNING <span class="token operator">||</span> poolSize <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token function">ensureQueuedTaskHandled</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">addIfUnderMaximumPoolSize</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// is shutdown or saturated</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>上面的代码可能看起来不是那么容易理解，下面我们一句一句解释：</p><p>　　首先，判断提交的任务command是否为null，若是null，则抛出空指针异常；</p><p>　　接着是这句，这句要好好理解一下：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>poolSize <span class="token operator">>=</span> corePoolSize <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">addIfUnderCorePoolSize</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><blockquote><p>由于是或条件运算符，所以先计算前半部分的值，如果线程池中当前线程数不小于核心池大小，那么就会直接进入下面的if语句块了。</p><p>　　如果线程池中当前线程数小于核心池大小，则接着执行后半部分，也就是执行</p></blockquote><pre><code>addIfUnderCorePoolSize(command)</code></pre><blockquote><p>如果执行完addIfUnderCorePoolSize这个方法返回false，则继续执行下面的if语句块，否则整个方法就直接执行完毕了。</p><p>　　如果执行完addIfUnderCorePoolSize这个方法返回false，然后接着判断：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>runState <span class="token operator">==</span> RUNNING <span class="token operator">&amp;&amp;</span> workQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><blockquote><p>如果当前线程池处于RUNNING状态，则将任务放入任务缓存队列；如果当前线程池不处于RUNNING状态或者任务放入缓存队列失败，则执行：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token function">addIfUnderMaximumPoolSize</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span></code></pre><blockquote><p>如果执行addIfUnderMaximumPoolSize方法失败，则执行reject()方法进行任务拒绝处理。</p><p>　　回到前面：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>runState <span class="token operator">==</span> RUNNING <span class="token operator">&amp;&amp;</span> workQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><blockquote><p>这句的执行，如果说当前线程池处于RUNNING状态且将任务放入任务缓存队列成功，则继续进行判断：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>runState <span class="token operator">!=</span> RUNNING <span class="token operator">||</span> poolSize <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span></code></pre><blockquote><p>这句判断是为了防止在将此任务添加进任务缓存队列的同时其他线程突然调用shutdown或者shutdownNow方法关闭了线程池的一种应急措施。如果是这样就执行：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token function">ensureQueuedTaskHandled</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span></code></pre><blockquote><p>进行应急处理，从名字可以看出是保证 添加到任务缓存队列中的任务得到处理。</p><p>　　我们接着看2个关键方法的实现：addIfUnderCorePoolSize和addIfUnderMaximumPoolSize：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">addIfUnderCorePoolSize</span><span class="token punctuation">(</span>Runnable firstTask<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Thread t <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">final</span> ReentrantLock mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>    mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>poolSize <span class="token operator">&lt;</span> corePoolSize <span class="token operator">&amp;&amp;</span> runState <span class="token operator">==</span> RUNNING<span class="token punctuation">)</span>            t <span class="token operator">=</span> <span class="token function">addThread</span><span class="token punctuation">(</span>firstTask<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//创建线程去执行firstTask任务   </span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>这个是addIfUnderCorePoolSize方法的具体实现，从名字可以看出它的意图就是当低于核心吃大小时执行的方法。下面看其具体实现，首先获取到锁，因为这地方涉及到线程池状态的变化，先通过if语句判断当前线程池中的线程数目是否小于核心池大小，有朋友也许会有疑问：前面在execute()方法中不是已经判断过了吗，只有线程池当前线程数目小于核心池大小才会执行addIfUnderCorePoolSize方法的，为何这地方还要继续判断？原因很简单，前面的判断过程中并没有加锁，因此可能在execute方法判断的时候poolSize小于corePoolSize，而判断完之后，在其他线程中又向线程池提交了任务，就可能导致poolSize不小于corePoolSize了，所以需要在这个地方继续判断。然后接着判断线程池的状态是否为RUNNING，原因也很简单，因为有可能在其他线程中调用了shutdown或者shutdownNow方法。然后就是执行</p></blockquote><pre class=" language-java"><code class="language-java">t <span class="token operator">=</span> <span class="token function">addThread</span><span class="token punctuation">(</span>firstTask<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>这个方法也非常关键，传进去的参数为提交的任务，返回值为Thread类型。然后接着在下面判断t是否为空，为空则表明创建线程失败（即poolSize&gt;=corePoolSize或者runState不等于RUNNING），否则调用t.start()方法启动线程。</p><p>　　我们来看一下addThread方法的实现：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> Thread <span class="token function">addThread</span><span class="token punctuation">(</span>Runnable firstTask<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Worker w <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span>firstTask<span class="token punctuation">)</span><span class="token punctuation">;</span>    Thread t <span class="token operator">=</span> threadFactory<span class="token punctuation">.</span><span class="token function">newThread</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//创建一个线程，执行任务   </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        w<span class="token punctuation">.</span>thread <span class="token operator">=</span> t<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//将创建的线程的引用赋值为w的成员变量       </span>        workers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> nt <span class="token operator">=</span> <span class="token operator">++</span>poolSize<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//当前线程数加1       </span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nt <span class="token operator">></span> largestPoolSize<span class="token punctuation">)</span>            largestPoolSize <span class="token operator">=</span> nt<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> t<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>在addThread方法中，首先用提交的任务创建了一个Worker对象，然后调用线程工厂threadFactory创建了一个新的线程t，然后将线程t的引用赋值给了Worker对象的成员变量thread，接着通过workers.add(w)将Worker对象添加到工作集当中。</p><p>　　下面我们看一下Worker类的实现：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Worker</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> ReentrantLock runLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> Runnable firstTask<span class="token punctuation">;</span>    <span class="token keyword">volatile</span> <span class="token keyword">long</span> completedTasks<span class="token punctuation">;</span>    Thread thread<span class="token punctuation">;</span>    <span class="token function">Worker</span><span class="token punctuation">(</span>Runnable firstTask<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>firstTask <span class="token operator">=</span> firstTask<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">boolean</span> <span class="token function">isActive</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> runLock<span class="token punctuation">.</span><span class="token function">isLocked</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">interruptIfIdle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> ReentrantLock runLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>runLock<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>runLock<span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>thread <span class="token operator">!=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        thread<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                runLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">interruptNow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        thread<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">runTask</span><span class="token punctuation">(</span>Runnable task<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> ReentrantLock runLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>runLock<span class="token punctuation">;</span>        runLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>runState <span class="token operator">&lt;</span> STOP <span class="token operator">&amp;&amp;</span>                Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                runState <span class="token operator">>=</span> STOP<span class="token punctuation">)</span>            <span class="token keyword">boolean</span> ran <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token function">beforeExecute</span><span class="token punctuation">(</span>thread<span class="token punctuation">,</span> task<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//beforeExecute方法是ThreadPoolExecutor类的一个方法，没有具体实现，用户可以根据</span>            <span class="token comment" spellcheck="true">//自己需要重载这个方法和后面的afterExecute方法来进行一些统计信息，比如某个任务的执行时间等           </span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                task<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                ran <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token function">afterExecute</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">++</span>completedTasks<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RuntimeException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ran<span class="token punctuation">)</span>                    <span class="token function">afterExecute</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">throw</span> ex<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            runLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Runnable task <span class="token operator">=</span> firstTask<span class="token punctuation">;</span>            firstTask <span class="token operator">=</span> null<span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>task <span class="token operator">!=</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>task <span class="token operator">=</span> <span class="token function">getTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">runTask</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>                task <span class="token operator">=</span> null<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            <span class="token function">workerDone</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//当任务队列中没有任务时，进行清理工作       </span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>它实际上实现了Runnable接口，因此上面的Thread t = threadFactory.newThread(w);效果跟下面这句的效果基本一样：</p></blockquote><pre class=" language-java"><code class="language-java">Thread t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>相当于传进去了一个Runnable任务，在线程t中执行这个Runnable。</p><p>　　既然Worker实现了Runnable接口，那么自然最核心的方法便是run()方法了：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        Runnable task <span class="token operator">=</span> firstTask<span class="token punctuation">;</span>        firstTask <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>task <span class="token operator">!=</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>task <span class="token operator">=</span> <span class="token function">getTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">runTask</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>            task <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token function">workerDone</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>从run方法的实现可以看出，它首先执行的是通过构造器传进来的任务firstTask，在调用runTask()执行完firstTask之后，在while循环里面不断通过getTask()去取新的任务来执行，那么去哪里取呢？自然是从任务缓存队列里面去取，getTask是ThreadPoolExecutor类中的方法，并不是Worker类中的方法，下面是getTask方法的实现：</p></blockquote><pre class=" language-java"><code class="language-java">Runnable <span class="token function">getTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> state <span class="token operator">=</span> runState<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>state <span class="token operator">></span> SHUTDOWN<span class="token punctuation">)</span>                <span class="token keyword">return</span> null<span class="token punctuation">;</span>            Runnable r<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>state <span class="token operator">==</span> SHUTDOWN<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// Help drain queue</span>                r <span class="token operator">=</span> workQueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>poolSize <span class="token operator">></span> corePoolSize <span class="token operator">||</span> allowCoreThreadTimeOut<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//如果线程数大于核心池大小或者允许为核心池线程设置空闲时间，</span>                <span class="token comment" spellcheck="true">//则通过poll取任务，若等待一定的时间取不到任务，则返回null</span>                r <span class="token operator">=</span> workQueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span>keepAliveTime<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>NANOSECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span>                r <span class="token operator">=</span> workQueue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">!=</span> null<span class="token punctuation">)</span>                <span class="token keyword">return</span> r<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCanExit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//如果没取到任务，即r为null，则判断当前的worker是否可以退出</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>runState <span class="token operator">>=</span> SHUTDOWN<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// Wake up others</span>                    <span class="token function">interruptIdleWorkers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//中断处于空闲状态的worker</span>                <span class="token keyword">return</span> null<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// Else retry</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> ie<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// On interruption, re-check runState</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>在getTask中，先判断当前线程池状态，如果runState大于SHUTDOWN（即为STOP或者TERMINATED），则直接返回null。</p><p>　　如果runState为SHUTDOWN或者RUNNING，则从任务缓存队列取任务。</p><p>　　如果当前线程池的线程数大于核心池大小corePoolSize或者允许为核心池中的线程设置空闲存活时间，则调用poll(time,timeUnit)来取任务，这个方法会等待一定的时间，如果取不到任务就返回null。</p><p>　　然后判断取到的任务r是否为null，为null则通过调用workerCanExit()方法来判断当前worker是否可以退出，我们看一下workerCanExit()的实现：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">workerCanExit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> ReentrantLock mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>    mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> canExit<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//如果runState大于等于STOP，或者任务缓存队列为空了</span>    <span class="token comment" spellcheck="true">//或者  允许为核心池线程设置空闲存活时间并且线程池中的线程数目大于1</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        canExit <span class="token operator">=</span> runState <span class="token operator">>=</span> STOP <span class="token operator">||</span>            workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span>            <span class="token punctuation">(</span>allowCoreThreadTimeOut <span class="token operator">&amp;&amp;</span>             poolSize <span class="token operator">></span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> corePoolSize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> canExit<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>也就是说如果线程池处于STOP状态、或者任务队列已为空或者允许为核心池线程设置空闲存活时间并且线程数大于1时，允许worker退出。如果允许worker退出，则调用interruptIdleWorkers()中断处于空闲状态的worker，我们看一下interruptIdleWorkers()的实现：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">interruptIdleWorkers</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> ReentrantLock mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>    mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Worker w <span class="token operator">:</span> workers<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//实际上调用的是worker的interruptIfIdle()方法</span>            w<span class="token punctuation">.</span><span class="token function">interruptIfIdle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>从实现可以看出，它实际上调用的是worker的interruptIfIdle()方法，在worker的interruptIfIdle()方法中：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">interruptIfIdle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> ReentrantLock runLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>runLock<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>runLock<span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//注意这里，是调用tryLock()来获取锁的，因为如果当前worker正在执行任务，锁已经被获取了，是无法获取到锁的</span>                                <span class="token comment" spellcheck="true">//如果成功获取了锁，说明当前worker处于空闲状态</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>thread <span class="token operator">!=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      thread<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            runLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>这里有一个非常巧妙的设计方式，假如我们来设计线程池，可能会有一个任务分派线程，当发现有线程空闲时，就从任务缓存队列中取一个任务交给空闲线程执行。但是在这里，并没有采用这样的方式，因为这样会要额外地对任务分派线程进行管理，无形地会增加难度和复杂度，这里直接让执行完任务的线程去任务缓存队列里面取任务来执行。</p><p>　　我们再看addIfUnderMaximumPoolSize方法的实现，这个方法的实现思想和addIfUnderCorePoolSize方法的实现思想非常相似，唯一的区别在于addIfUnderMaximumPoolSize方法是在线程池中的线程数达到了核心池大小并且往任务队列中添加任务失败的情况下执行的：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">addIfUnderMaximumPoolSize</span><span class="token punctuation">(</span>Runnable firstTask<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Thread t <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">final</span> ReentrantLock mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>    mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>poolSize <span class="token operator">&lt;</span> maximumPoolSize <span class="token operator">&amp;&amp;</span> runState <span class="token operator">==</span> RUNNING<span class="token punctuation">)</span>            t <span class="token operator">=</span> <span class="token function">addThread</span><span class="token punctuation">(</span>firstTask<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>看到没有，其实它和addIfUnderCorePoolSize方法的实现基本一模一样，只是if语句判断条件中的poolSize &lt; maximumPoolSize不同而已。</p><p>　　到这里，大部分朋友应该对任务提交给线程池之后到被执行的整个过程有了一个基本的了解，下面总结一下：</p><p>　　1）首先，要清楚corePoolSize和maximumPoolSize的含义；</p><p>　　2）其次，要知道Worker是用来起到什么作用的；</p><p>　　3）要知道任务提交给线程池之后的处理策略，这里总结一下主要有4点：</p><ul><li>如果当前线程池中的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务；</li><li>如果当前线程池中的线程数目&gt;=corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程去执行这个任务；</li><li>如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理；</li><li>如果线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过keepAliveTime，线程也会被终止。</li></ul></blockquote><h4 id="3-线程池中的线程初始化"><a href="#3-线程池中的线程初始化" class="headerlink" title="3.线程池中的线程初始化"></a><strong>3.线程池中的线程初始化</strong></h4><blockquote><p>默认情况下，创建线程池之后，线程池中是没有线程的，需要提交任务之后才会创建线程。</p><p>　　在实际中如果需要线程池创建之后立即创建线程，可以通过以下两个方法办到：</p><ul><li>prestartCoreThread()：初始化一个核心线程；</li><li>prestartAllCoreThreads()：初始化所有核心线程</li></ul><p>　　下面是这2个方法的实现：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">prestartCoreThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">addIfUnderCorePoolSize</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//注意传进去的参数是null</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">prestartAllCoreThreads</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">addIfUnderCorePoolSize</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//注意传进去的参数是null</span>        <span class="token operator">++</span>n<span class="token punctuation">;</span>    <span class="token keyword">return</span> n<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>注意上面传进去的参数是null，根据第2小节的分析可知如果传进去的参数为null，则最后执行线程会阻塞在getTask方法中的</p></blockquote><pre class=" language-java"><code class="language-java">r <span class="token operator">=</span> workQueue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>即等待任务队列中有任务。</p></blockquote><h4 id="4-任务缓存队列及排队策略"><a href="#4-任务缓存队列及排队策略" class="headerlink" title="4.任务缓存队列及排队策略"></a><strong>4.任务缓存队列及排队策略</strong></h4><blockquote><p>在前面我们多次提到了任务缓存队列，即workQueue，它用来存放等待执行的任务。</p><p>　　workQueue的类型为BlockingQueue<runnable>，通常可以取下面三种类型：</runnable></p><p>　　1）ArrayBlockingQueue：基于数组的先进先出队列，此队列创建时必须指定大小；</p><p>　　2）LinkedBlockingQueue：基于链表的先进先出队列，如果创建时没有指定此队列大小，则默认为Integer.MAX_VALUE；</p><p>　　3）synchronousQueue：这个队列比较特殊，它不会保存提交的任务，而是将直接新建一个线程来执行新来的任务。</p></blockquote><h4 id="5-任务拒绝策略"><a href="#5-任务拒绝策略" class="headerlink" title="5.任务拒绝策略"></a><strong>5.任务拒绝策略</strong></h4><blockquote><p>当线程池的任务缓存队列已满并且线程池中的线程数目达到maximumPoolSize，如果还有任务到来就会采取任务拒绝策略，通常有以下四种策略：</p></blockquote><pre class=" language-java"><code class="language-java">ThreadPoolExecutor<span class="token punctuation">.</span>AbortPolicy<span class="token operator">:</span>丢弃任务并抛出RejectedExecutionException异常。ThreadPoolExecutor<span class="token punctuation">.</span>DiscardPolicy：也是丢弃任务，但是不抛出异常。ThreadPoolExecutor<span class="token punctuation">.</span>DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）ThreadPoolExecutor<span class="token punctuation">.</span>CallerRunsPolicy：由调用线程处理该任务</code></pre><h4 id="6-线程池的关闭"><a href="#6-线程池的关闭" class="headerlink" title="6.线程池的关闭"></a><strong>6.线程池的关闭</strong></h4><blockquote><p>ThreadPoolExecutor提供了两个方法，用于线程池的关闭，分别是shutdown()和shutdownNow()，其中：</p><ul><li>shutdown()：不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务</li><li>shutdownNow()：立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务</li></ul></blockquote><h4 id="7-线程池容量的动态调整"><a href="#7-线程池容量的动态调整" class="headerlink" title="7.线程池容量的动态调整"></a><strong>7.线程池容量的动态调整</strong></h4><blockquote><p>ThreadPoolExecutor提供了动态调整线程池容量大小的方法：setCorePoolSize()和setMaximumPoolSize()，</p><ul><li>setCorePoolSize：设置核心池大小</li><li>setMaximumPoolSize：设置线程池最大能创建的线程数目大小</li></ul><p>　　当上述参数从小变大时，ThreadPoolExecutor进行线程赋值，还可能立即创建新的线程来执行任务。</p></blockquote><h3 id="三-代码示例"><a href="#三-代码示例" class="headerlink" title="三.代码示例"></a>三.代码示例</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>springboot<span class="token punctuation">.</span>executor<span class="token punctuation">.</span>executortest<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>springboot<span class="token punctuation">.</span>executor<span class="token punctuation">.</span>executordemo<span class="token punctuation">.</span>MyTask<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ArrayBlockingQueue<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ThreadPoolExecutor<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeUnit<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019-07-30 * @Time: 15:55 * @Vsersion: 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExecutorTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ThreadPoolExecutor executor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">200</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">15</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            MyTask myTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyTask</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>myTask<span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程池中线程数目："</span><span class="token operator">+</span>executor<span class="token punctuation">.</span><span class="token function">getPoolSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"，队列中等待执行的任务数目："</span><span class="token operator">+</span>                    executor<span class="token punctuation">.</span><span class="token function">getQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"，已执行完别的任务数目："</span><span class="token operator">+</span>executor<span class="token punctuation">.</span><span class="token function">getCompletedTaskCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        executor<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>springboot<span class="token punctuation">.</span>executor<span class="token punctuation">.</span>executordemo<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019-07-30 * @Time: 16:01 * @Vsersion: 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyTask</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> taskNum<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">MyTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">MyTask</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>taskNum <span class="token operator">=</span> num<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"正在执行task"</span><span class="token operator">+</span>taskNum<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">4000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"task"</span><span class="token operator">+</span>taskNum<span class="token operator">+</span><span class="token string">"执行完毕"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>执行结果：</p></blockquote><p><img src="//zongmansheng.club/2019/07/30/xian-cheng-chi/001.png" alt></p><blockquote><p>从执行结果可以看出，当线程池中线程的数目大于5时，便将任务放入任务缓存队列里面，当任务缓存队列满了之后，便创建新的线程。如果上面程序中，将for循环中改成执行20个任务，就会抛出任务拒绝异常了。</p><p>　　不过在java doc中，并不提倡我们直接使用ThreadPoolExecutor，而是使用Executors类中提供的几个静态方法来创建线程池：</p></blockquote><pre class=" language-java"><code class="language-java">Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//创建一个缓冲池，缓冲池容量大小为Integer.MAX_VALUE</span>Executors<span class="token punctuation">.</span><span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//创建容量为1的缓冲池</span>Executors<span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//创建固定容量大小的缓冲池</span></code></pre><blockquote><p>下面是这三个静态方法的具体实现;</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> nThreads<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>nThreads<span class="token punctuation">,</span> nThreads<span class="token punctuation">,</span>                                  0L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>                                  <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FinalizableDelegatedExecutorService</span>        <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span>                                0L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>                                <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span>                                  60L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>                                  <span class="token keyword">new</span> <span class="token class-name">SynchronousQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>从它们的具体实现来看，它们实际上也是调用了ThreadPoolExecutor，只不过参数都已配置好了。</p><p>　　newFixedThreadPool创建的线程池corePoolSize和maximumPoolSize值是相等的，它使用的LinkedBlockingQueue；</p><p>　　newSingleThreadExecutor将corePoolSize和maximumPoolSize都设置为1，也使用的LinkedBlockingQueue；</p><p>　　newCachedThreadPool将corePoolSize设置为0，将maximumPoolSize设置为Integer.MAX_VALUE，使用的SynchronousQueue，也就是说来了任务就创建线程运行，当线程空闲超过60秒，就销毁线程。</p><p>　　实际中，如果Executors提供的三个静态方法能满足要求，就尽量使用它提供的三个方法，因为自己去手动配置ThreadPoolExecutor的参数有点麻烦，要根据实际任务的类型和数量来进行配置。</p><p>　　另外，如果ThreadPoolExecutor达不到要求，可以自己继承ThreadPoolExecutor类进行重写。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;线程池的使用&quot;&gt;&lt;a href=&quot;#线程池的使用&quot; class=&quot;headerlink&quot; title=&quot;线程池的使用&quot;&gt;&lt;/a&gt;线程池的使用&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;​        我们有两种常见的创建线程的方法，一种是继承Thread类，一种是
      
    
    </summary>
    
      <category term="java高级" scheme="http://zongmansheng.club/categories/java%E9%AB%98%E7%BA%A7/"/>
    
    
      <category term="executor" scheme="http://zongmansheng.club/tags/executor/"/>
    
      <category term="ThreadPoolExecutor" scheme="http://zongmansheng.club/tags/ThreadPoolExecutor/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot（五）</title>
    <link href="http://zongmansheng.club/2019/07/29/springboot-wu/"/>
    <id>http://zongmansheng.club/2019/07/29/springboot-wu/</id>
    <published>2019-07-29T00:23:05.000Z</published>
    <updated>2019-07-30T00:22:56.476Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Springboot整合sharding-jdbc中间件，实现数据分库分表"><a href="#Springboot整合sharding-jdbc中间件，实现数据分库分表" class="headerlink" title="Springboot整合sharding-jdbc中间件，实现数据分库分表"></a>Springboot整合sharding-jdbc中间件，实现数据分库分表</h1><h3 id="一、什么sharding-jdbc"><a href="#一、什么sharding-jdbc" class="headerlink" title="一、什么sharding-jdbc"></a>一、什么sharding-jdbc</h3><blockquote><p>当当开源的，属于 client 层方案，目前已经更名为 [<code>ShardingSphere</code>]。确实之前用的还比较多一些，因为 SQL 语法支持也比较多，没有太多限制，而且截至 2019.4，已经推出到了 <code>4.0.0-RC1</code> 版本，支持分库分表、读写分离、分布式 id 生成、柔性事务（最大努力送达型事务、TCC 事务）。而且确实之前使用的公司会比较多一些（这个在官网有登记使用的公司，可以看到从 2017 年一直到现在，是有不少公司在用的），目前社区也还一直在开发和维护，还算是比较活跃。</p></blockquote><h3 id="二、水平分割"><a href="#二、水平分割" class="headerlink" title="二、水平分割"></a>二、水平分割</h3><h4 id="1、水平分库"><a href="#1、水平分库" class="headerlink" title="1、水平分库"></a>1、水平分库</h4><blockquote><p>1)、概念：<br>以字段为依据，按照一定策略，将一个库中的数据拆分到多个库中。<br>2)、结果<br>每个库的结构都一样；数据都不一样；<br>所有库的并集是全量数据；</p></blockquote><h4 id="2、水平分表"><a href="#2、水平分表" class="headerlink" title="2、水平分表"></a>2、水平分表</h4><blockquote><p>1)、概念<br>以字段为依据，按照一定策略，将一个表中的数据拆分到多个表中。<br>2)、结果<br>每个表的结构都一样；数据都不一样；<br>所有表的并集是全量数据；</p></blockquote><h3 id="三、Shard-jdbc-中间件"><a href="#三、Shard-jdbc-中间件" class="headerlink" title="三、Shard-jdbc 中间件"></a>三、Shard-jdbc 中间件</h3><h4 id="1、架构图"><a href="#1、架构图" class="headerlink" title="1、架构图"></a>1、架构图</h4><p><img src="//zongmansheng.club/2019/07/29/springboot-wu/002.png" alt></p><h4 id="2、特点"><a href="#2、特点" class="headerlink" title="2、特点"></a>2、特点</h4><blockquote><p>1)、Sharding-JDBC直接封装JDBC API，旧代码迁移成本几乎为零。<br>2)、适用于任何基于Java的ORM框架，如Hibernate、Mybatis等 。<br>3)、可基于任何第三方的数据库连接池，如DBCP、C3P0、 BoneCP、Druid等。<br>4)、以jar包形式提供服务，无proxy代理层，无需额外部署，无其他依赖。<br>5)、分片策略灵活，可支持等号、between、in等多维度分片，也可支持多分片键。<br>6)、SQL解析功能完善，支持聚合、分组、排序、limit、or等查询。</p></blockquote><h3 id="四、创建Springboot工程"><a href="#四、创建Springboot工程" class="headerlink" title="四、创建Springboot工程"></a>四、创建Springboot工程</h3><h4 id="1、pom依赖"><a href="#1、pom依赖" class="headerlink" title="1、pom依赖"></a>1、pom依赖</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Springboot整合sharding-jdbc中间件，实现数据分库分表&quot;&gt;&lt;a href=&quot;#Springboot整合sharding-jdbc中间件，实现数据分库分表&quot; class=&quot;headerlink&quot; title=&quot;Springboot整合shardi
      
    
    </summary>
    
      <category term="SpringBoot" scheme="http://zongmansheng.club/categories/SpringBoot/"/>
    
    
      <category term="springboot2.0" scheme="http://zongmansheng.club/tags/springboot2-0/"/>
    
      <category term="sharding-jdbc" scheme="http://zongmansheng.club/tags/sharding-jdbc/"/>
    
  </entry>
  
  <entry>
    <title>数据结构——单链表</title>
    <link href="http://zongmansheng.club/2019/07/26/shu-ju-jie-gou-dan-lian-biao/"/>
    <id>http://zongmansheng.club/2019/07/26/shu-ju-jie-gou-dan-lian-biao/</id>
    <published>2019-07-26T00:27:55.000Z</published>
    <updated>2019-07-26T00:52:34.132Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构—单链表"><a href="#数据结构—单链表" class="headerlink" title="数据结构—单链表"></a>数据结构—单链表</h1><h3 id="一、什么是链表？"><a href="#一、什么是链表？" class="headerlink" title="一、什么是链表？"></a>一、什么是链表？</h3><blockquote><p>​        链表是一种最常见的数据结构，其内部数据呈线性排列，属于线性表结构，什么是线性表？表中的数据按顺序依次排列，就像用一条线把数据串联起来一样。</p></blockquote><p><img src="/Volumes/work/hexo/source/_posts/数据结构——单链表/001.png" alt></p><blockquote><p>​        链表就是这种排布方式，特点是添加数据和删除数据速度快，但是查询数据会比较耗时，这是因为链表在内存中的存储结构造成的。</p><p>​        这里我们可以将数组与链表进行对比，数组大家应该都很熟悉，学过 Java 的都会用，但是你真的了解它在内存中的存储结构吗？数组的特点是查询数据很快，添加数据和删除数据效率低，这一特征与链表恰好相反，数组的缺陷正是链表的优势，数组的优势则是链表的缺陷，所以二者对比着来记，效果会更好。</p><p>​        来说说为什么数组和链表的特点恰好相反，首先来看看二者在内存中的存储结构。</p><p>​        数组和链表都是线性表结构，数组在内存中是一串连续的内存空间，比如定义一个 int 类型数组，int[] array = new int[6]，计算机会为 array 分配一块连续的空间，如下图所示。</p></blockquote><p><img src="//zongmansheng.club/2019/07/26/shu-ju-jie-gou-dan-lian-biao/002.png" alt></p><blockquote><p>​        1000-1003 这段空间用来存储数组中的第一个元素 array[0]，1004-1007 的空间用来存储 array[1]，以此类推数组中的每个元素都对应一块大小为 4 byte 的空间，这种结构就决定了数组查询数据速度很快，只需要知道首地址（在栈内存中记录的就是数组的首地址，可以直接获取），再结合寻址公式就可以很快找到对应元素的地址，从而取出数据。</p><p>数组的寻址公式：i_address = first_address + data_size*i</p><p>​        带入上述案例中，比如要找到数组中第 3 个元素，也就是下标为 2 ，该元素的首地址即 2_address = 1000 + 2*4 = 1008，计算机只需要执行一个简单的数学运算就可以找到元素的首地址，进而取出对应的值，对于计算机来讲，简单数学运算的耗时几乎可以忽略不计，所以数组查询数据速度非常快。</p><p>​        也正是因为这种结构导致数组添加和删除数据效率很低，因为这两种操作不仅仅是在数组中添加或者移除一个元素那么简单，同时还需要移动其他已存在的元素。</p><p>​        数组中各个元素的内存地址都是连续，不间断的，删除某个元素之后需要保证数组仍然是连续的，所以就需要移动数据，比如要删除 array[2]，删除之后需要依次将 array[3]、array[4]、array[5] 向前移动一位，如下图所示。</p></blockquote><p><img src="//zongmansheng.club/2019/07/26/shu-ju-jie-gou-dan-lian-biao/003.png" alt></p><blockquote><p>同理，如果此时将 0 添加到数组中的第 2 位，即 array[1] 的位置，同样需要先将 array[1] 及其之后的各个元素依次向后移动 1 位，给新数据腾出位置才能添加，如下图所示。</p></blockquote><p><img src="//zongmansheng.club/2019/07/26/shu-ju-jie-gou-dan-lian-biao/004.png" alt></p><blockquote><p>因为要移动元素，所以无论是添加数据还是删除数据，效率都不高。</p><p>搞清楚数组的存储结构之后，我们再来看看链表的存储结构，在内存中，链表中的数据是分散的，无须存储在一块连续的内存空间中，如下图所示。</p></blockquote><p><img src="//zongmansheng.club/2019/07/26/shu-ju-jie-gou-dan-lian-biao/005.png" alt></p><blockquote><p>链表中存储了 3 个元素分别是 1、2、3，每个元素都有一个指针，指向下一个元素的内存地址，1 的指针就指向 2 的内存地址 1008，2 的指针就指向 3 的内存地址 1020，依次类推。</p><p>不同元素之间的物理空间间隔也是不确定的，所以这样的结构就无法通过一个固定的公式来求出某个元素的内存地址，只能从首元素开始依次向后查找，直到找到目标元素。如果目标元素位于链表的最后一位，则需要遍历整个链表才能找到它，效率很低。</p><p>同样，正是因为这样的结构，使得链表添加和删除元素效率很高，无须移动其他已存在的元素，只需要修改元素指针即可。比如，删除 2，则只需要将 1 的指针指向 3 即可，如下图所示。</p></blockquote><p><img src="//zongmansheng.club/2019/07/26/shu-ju-jie-gou-dan-lian-biao/006.png" alt></p><blockquote><p>添加元素也是一样，要在 2 和 3 之间添加元素 0 ，只需要随机分配一块空间存储 0，然后将 2 的指针指向 0，0 的指针指向 3 即可，如下图所示。</p></blockquote><p><img src="//zongmansheng.club/2019/07/26/shu-ju-jie-gou-dan-lian-biao/007.png" alt></p><blockquote><p>所以在链表中，无论是添加还是删除元素，都只需要修改相关节点的指针即可，效率很高。</p><p>搞清楚链表的结构之后，我们使用 Java 语言来实现一个单链表的结构。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据结构—单链表&quot;&gt;&lt;a href=&quot;#数据结构—单链表&quot; class=&quot;headerlink&quot; title=&quot;数据结构—单链表&quot;&gt;&lt;/a&gt;数据结构—单链表&lt;/h1&gt;&lt;h3 id=&quot;一、什么是链表？&quot;&gt;&lt;a href=&quot;#一、什么是链表？&quot; class=&quot;head
      
    
    </summary>
    
      <category term="数据结构" scheme="http://zongmansheng.club/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="单链表" scheme="http://zongmansheng.club/tags/%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Java分布式锁三种实现方案</title>
    <link href="http://zongmansheng.club/2019/07/24/java-fen-bu-shi-suo-san-chong-shi-xian-fang-an/"/>
    <id>http://zongmansheng.club/2019/07/24/java-fen-bu-shi-suo-san-chong-shi-xian-fang-an/</id>
    <published>2019-07-24T13:43:59.000Z</published>
    <updated>2019-07-25T00:25:15.593Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java分布式锁三种实现方案"><a href="#Java分布式锁三种实现方案" class="headerlink" title="Java分布式锁三种实现方案"></a>Java分布式锁三种实现方案</h1><h3 id="方案一：数据库乐观锁"><a href="#方案一：数据库乐观锁" class="headerlink" title="方案一：数据库乐观锁"></a>方案一：数据库乐观锁</h3><blockquote><p>​        乐观锁通常实现基于数据版本(version)的记录机制实现的，比如有一张红包表（t_bonus），有一个字段(left_count)记录礼物的剩余个数，用户每领取一个奖品，对应的left_count减1，在并发的情况下如何要保证left_count不为负数，乐观锁的实现方式为在红包表上添加一个版本号字段（version），默认为0。</p></blockquote><h4 id="异常实现流程"><a href="#异常实现流程" class="headerlink" title="异常实现流程"></a>异常实现流程</h4><pre><code>-- 可能会发生的异常情况-- 线程1查询，当前left_count为1，则有记录select * from t_bonus where id = 10001 and left_count &gt; 0-- 线程2查询，当前left_count为1，也有记录select * from t_bonus where id = 10001 and left_count &gt; 0-- 线程1完成领取记录，修改left_count为0,update t_bonus set left_count = left_count - 1 where id = 10001-- 线程2完成领取记录，修改left_count为-1，产生脏数据update t_bonus set left_count = left_count - 1 where id = 10001</code></pre><h4 id="通过乐观锁实现"><a href="#通过乐观锁实现" class="headerlink" title="通过乐观锁实现"></a>通过乐观锁实现</h4><pre><code>-- 添加版本号控制字段ALTER TABLE table ADD COLUMN version INT DEFAULT &#39;0&#39; NOT NULL AFTER t_bonus;-- 线程1查询，当前left_count为1，则有记录，当前版本号为1234select left_count, version from t_bonus where id = 10001 and left_count &gt; 0-- 线程2查询，当前left_count为1，有记录，当前版本号为1234select left_count, version from t_bonus where id = 10001 and left_count &gt; 0-- 线程1,更新完成后当前的version为1235，update状态为1，更新成功update t_bonus set version = 1235, left_count = left_count-1 where id = 10001 and version = 1234-- 线程2,更新由于当前的version为1235，udpate状态为0，更新失败，再针对相关业务做异常处理update t_bonus set version = 1235, left_count = left_count-1 where id = 10001 and version = 1234</code></pre><h3 id="方案二：基于Redis的分布式锁"><a href="#方案二：基于Redis的分布式锁" class="headerlink" title="方案二：基于Redis的分布式锁"></a>方案二：基于Redis的分布式锁</h3><pre><code>SETNX命令（SET if Not eXists）语法：SETNX key value功能：原子性操作，当且仅当 key 不存在，将 key 的值设为 value ，并返回1；若给定的 key 已经存在，则 SETNX 不做任何动作，并返回0。Expire命令语法：expire(key, expireTime)功能：key设置过期时间GETSET命令语法：GETSET key value功能：将给定 key 的值设为 value ，并返回 key 的旧值 (old value)，当 key 存在但不是字符串类型时，返回一个错误，当key不存在时，返回nil。GET命令语法：GET key功能：返回 key 所关联的字符串值，如果 key 不存在那么返回特殊值 nil 。DEL命令语法：DEL key [KEY …]功能：删除给定的一个或多个 key ,不存在的 key 会被忽略。</code></pre><h5 id="第一种：使用redis的setnx-、expire-方法，用于分布式锁"><a href="#第一种：使用redis的setnx-、expire-方法，用于分布式锁" class="headerlink" title="第一种：使用redis的setnx()、expire()方法，用于分布式锁"></a>第一种：使用redis的setnx()、expire()方法，用于分布式锁</h5><blockquote><ol><li>setnx(lockkey, 1) 如果返回0，则说明占位失败；如果返回1，则说明占位成功</li><li>expire()命令对lockkey设置超时时间，为的是避免死锁问题。</li><li>执行完业务代码后，可以通过delete命令删除key。</li></ol></blockquote><pre><code>        这个方案其实是可以解决日常工作中的需求的，但从技术方案的探讨上来说，可能还有一些可以完善的地方。比如，如果在第一步setnx执行成功后，在expire()命令执行成功前，发生了宕机的现象，那么就依然会出现死锁的问题</code></pre><h5 id="第二种：使用redis的setnx-、get-、getset-方法，用于分布式锁，解决死锁问题"><a href="#第二种：使用redis的setnx-、get-、getset-方法，用于分布式锁，解决死锁问题" class="headerlink" title="第二种：使用redis的setnx()、get()、getset()方法，用于分布式锁，解决死锁问题"></a>第二种：使用redis的setnx()、get()、getset()方法，用于分布式锁，解决死锁问题</h5><blockquote><ol><li>setnx(lockkey, 当前时间+过期超时时间) ，如果返回1，则获取锁成功；如果返回0则没有获取到锁，转向2。</li><li>get(lockkey)获取值oldExpireTime ，并将这个value值与当前的系统时间进行比较，如果小于当前系统时间，则认为这个锁已经超时，可以允许别的请求重新获取，转向3。</li><li>计算newExpireTime=当前时间+过期超时时间，然后getset(lockkey, newExpireTime) 会返回当前lockkey的值currentExpireTime。</li><li>判断currentExpireTime与oldExpireTime 是否相等，如果相等，说明当前getset设置成功，获取到了锁。如果不相等，说明这个锁又被别的请求获取走了，那么当前请求可以直接返回失败，或者继续重试。</li><li>在获取到锁之后，当前线程可以开始自己的业务处理，当处理完毕后，比较自己的处理时间和对于锁设置的超时时间，如果小于锁设置的超时时间，则直接执行delete释放锁；如果大于锁设置的超时时间，则不需要再锁进行处理。</li></ol></blockquote><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><blockquote><p>使用的是jedis来连接Redis。</p></blockquote><h4 id="实现思想"><a href="#实现思想" class="headerlink" title="实现思想"></a>实现思想</h4><blockquote><ul><li>获取锁的时候，使用setnx加锁，并使用expire命令为锁添加一个超时时间，超过该时间则自动释放锁，锁的value值为一个随机生成的UUID，通过此在释放锁的时候进行判断。</li><li>获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。</li><li>释放锁的时候，通过UUID判断是不是该锁，若是该锁，则执行delete进行锁释放。</li></ul></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>springboot<span class="token punctuation">.</span>lock<span class="token punctuation">.</span>redislock<span class="token punctuation">;</span><span class="token keyword">import</span> redis<span class="token punctuation">.</span>clients<span class="token punctuation">.</span>jedis<span class="token punctuation">.</span>Jedis<span class="token punctuation">;</span><span class="token keyword">import</span> redis<span class="token punctuation">.</span>clients<span class="token punctuation">.</span>jedis<span class="token punctuation">.</span>JedisPool<span class="token punctuation">;</span><span class="token keyword">import</span> redis<span class="token punctuation">.</span>clients<span class="token punctuation">.</span>jedis<span class="token punctuation">.</span>Transaction<span class="token punctuation">;</span><span class="token keyword">import</span> redis<span class="token punctuation">.</span>clients<span class="token punctuation">.</span>jedis<span class="token punctuation">.</span>exceptions<span class="token punctuation">.</span>JedisException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>List<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>UUID<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019-07-25 * @Time: 07:38 * @Vsersion: 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DistributedLock</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> JedisPool jedisPool<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">DistributedLock</span><span class="token punctuation">(</span>JedisPool jedisPool<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>jedisPool <span class="token operator">=</span> jedisPool<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 加锁     * @param localName  锁的key     * @param acquireTimeout  获取超时时间     * @param timeout   锁的超时时间     * @return 锁标识     */</span>    <span class="token keyword">public</span> String <span class="token function">lockWithTimeout</span><span class="token punctuation">(</span>String localName<span class="token punctuation">,</span> Long acquireTimeout<span class="token punctuation">,</span> Long timeout<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Jedis conn <span class="token operator">=</span> null<span class="token punctuation">;</span>        String retIdentifier <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 获取连接</span>            conn <span class="token operator">=</span> jedisPool<span class="token punctuation">.</span><span class="token function">getResource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 随机生成一个value</span>            String identifier <span class="token operator">=</span> UUID<span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 锁名，即key值</span>            String lockKey <span class="token operator">=</span> <span class="token string">"lock:"</span> <span class="token operator">+</span> localName<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 超时时间，上锁后超过此时间则自动释放锁</span>            <span class="token keyword">int</span> lockExpire <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>timeout <span class="token operator">/</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 获取锁的超时时间，超过这个时间则放弃获取锁</span>            <span class="token keyword">long</span> end <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> acquireTimeout<span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>conn<span class="token punctuation">.</span><span class="token function">setnx</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">,</span> identifier<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    conn<span class="token punctuation">.</span><span class="token function">expire</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">,</span> lockExpire<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 返回value值，用于释放锁时间确认</span>                    retIdentifier <span class="token operator">=</span> identifier<span class="token punctuation">;</span>                    <span class="token keyword">return</span> retIdentifier<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// 返回-1代表key没有设置超时时间，为key设置一个超时时间</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>conn<span class="token punctuation">.</span><span class="token function">ttl</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    conn<span class="token punctuation">.</span><span class="token function">expire</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">,</span> lockExpire<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">JedisException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>conn <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                conn<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> retIdentifier<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 释放锁     * @param lockName 锁的key     * @param identifier    释放锁的标识     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">releaseLock</span><span class="token punctuation">(</span>String lockName<span class="token punctuation">,</span> String identifier<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Jedis conn <span class="token operator">=</span> null<span class="token punctuation">;</span>        String lockKey <span class="token operator">=</span> <span class="token string">"lock:"</span> <span class="token operator">+</span> lockName<span class="token punctuation">;</span>        <span class="token keyword">boolean</span> retFlag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            conn <span class="token operator">=</span> jedisPool<span class="token punctuation">.</span><span class="token function">getResource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 监视lock，准备开始事务</span>                conn<span class="token punctuation">.</span><span class="token function">watch</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 通过前面返回的value值判断是不是该锁，若是该锁，则删除，释放锁</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>identifier<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    Transaction transaction <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">multi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    transaction<span class="token punctuation">.</span><span class="token function">del</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">)</span><span class="token punctuation">;</span>                    List<span class="token operator">&lt;</span>Object<span class="token operator">></span> results <span class="token operator">=</span> transaction<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>results <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">continue</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    retFlag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                conn<span class="token punctuation">.</span><span class="token function">unwatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">JedisException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>conn <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                conn<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> retFlag<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>测试分布式锁；<br>例子中使用50个线程模拟秒杀一个商品，使用–运算符来实现商品减少，从结果有序性就可以看出是否为加锁状态。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>springboot<span class="token punctuation">.</span>lock<span class="token punctuation">.</span>redislock<span class="token punctuation">;</span><span class="token keyword">import</span> redis<span class="token punctuation">.</span>clients<span class="token punctuation">.</span>jedis<span class="token punctuation">.</span>JedisPool<span class="token punctuation">;</span><span class="token keyword">import</span> redis<span class="token punctuation">.</span>clients<span class="token punctuation">.</span>jedis<span class="token punctuation">.</span>JedisPoolConfig<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019-07-24 * @Time: 21:54 * @Vsersion: 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedisService</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> JedisPool pool <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        JedisPoolConfig config <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JedisPoolConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 设置最大连接数</span>        config<span class="token punctuation">.</span><span class="token function">setMaxTotal</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 设置最大空闲数</span>        config<span class="token punctuation">.</span><span class="token function">setMaxIdle</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 设置最大等待时间</span>        config<span class="token punctuation">.</span><span class="token function">setMaxWaitMillis</span><span class="token punctuation">(</span><span class="token number">1000</span> <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 在borrow一个jedis实例时，是否需要验证，若为true，则所有jedis实例均是可用的</span>        config<span class="token punctuation">.</span><span class="token function">setTestOnBorrow</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        pool <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JedisPool</span><span class="token punctuation">(</span>config<span class="token punctuation">,</span> <span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span> <span class="token number">6379</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    DistributedLock lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DistributedLock</span><span class="token punctuation">(</span>pool<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">500</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">seckill</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 返回锁的value值，供释放锁时候进行判断</span>        String indentifier <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">lockWithTimeout</span><span class="token punctuation">(</span><span class="token string">"resource"</span><span class="token punctuation">,</span> 5000L<span class="token punctuation">,</span> 1000L<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"获得了锁"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token operator">--</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        lock<span class="token punctuation">.</span><span class="token function">releaseLock</span><span class="token punctuation">(</span><span class="token string">"resource"</span><span class="token punctuation">,</span> indentifier<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="基于ZooKeeper实现分布式锁"><a href="#基于ZooKeeper实现分布式锁" class="headerlink" title="基于ZooKeeper实现分布式锁"></a>基于ZooKeeper实现分布式锁</h3><blockquote><p>ZooKeeper是一个分布式的，开放源码的<strong>分布式应用程序协调服务</strong>，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。它是<strong>一个为分布式应用提供一致性服务的软件</strong>，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。</p><p>ZooKeeper的架构通过<strong>冗余服务</strong>实现高可用性。因此，如果第一次无应答，客户端就可以询问另一台ZooKeeper主机。ZooKeeper节点将它们的数据存储于一个<strong>分层的命名空间</strong>，非常类似于一个文件系统或一个前缀树结构。客户端可以在节点读写，从而以这种方式拥有一个共享的配置服务。更新是全序的。</p></blockquote><h4 id="基于ZooKeeper分布式锁的流程"><a href="#基于ZooKeeper分布式锁的流程" class="headerlink" title="基于ZooKeeper分布式锁的流程"></a>基于ZooKeeper分布式锁的流程</h4><blockquote><ul><li>在zookeeper指定节点（locks）下创建临时顺序节点node_n</li><li>获取locks下所有子节点children</li><li>对子节点按节点自增序号从小到大排序</li><li>判断本节点是不是第一个子节点，若是，则获取锁；若不是，则监听比该节点小的那个节点的删除事件</li><li>若监听事件生效，则回到第二步重新进行判断，直到获取到锁</li></ul></blockquote><blockquote><p>这里推荐一个Apache的开源库Curator，它是一个ZooKeeper客户端，Curator提供的InterProcessMutex是分布式锁的实现，acquire方法用于获取锁，release方法用于释放锁。</p><p>优点：具备高可用、可重入、阻塞锁特性，可解决失效死锁问题。<br>缺点：因为需要频繁的创建和删除节点，性能上不如Redis方式。</p><p>使用zookeeper的<strong>可靠性和稳定性</strong>是要大于使用redis实现的分布式锁的，但是相比而言，redis的<strong>性能</strong>更好。</p></blockquote><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><blockquote><p>下面就具体使用java和zookeeper实现分布式锁，操作zookeeper使用的是apache提供的zookeeper的包。</p><ul><li>通过实现Watch接口，实现process(WatchedEvent event)方法来实施监控，使CountDownLatch来完成监控，在等待锁的时候使用CountDownLatch来计数，等到后进行countDown，停止等待，继续运行。</li><li>以下整体流程基本与上述描述流程一致，只是在监听的时候使用的是CountDownLatch来监听前一个节点。</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java分布式锁三种实现方案&quot;&gt;&lt;a href=&quot;#Java分布式锁三种实现方案&quot; class=&quot;headerlink&quot; title=&quot;Java分布式锁三种实现方案&quot;&gt;&lt;/a&gt;Java分布式锁三种实现方案&lt;/h1&gt;&lt;h3 id=&quot;方案一：数据库乐观锁&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="分布式" scheme="http://zongmansheng.club/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="乐观锁" scheme="http://zongmansheng.club/tags/%E4%B9%90%E8%A7%82%E9%94%81/"/>
    
      <category term="redis" scheme="http://zongmansheng.club/tags/redis/"/>
    
      <category term="zookeeper" scheme="http://zongmansheng.club/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>Mac下安装Kafka</title>
    <link href="http://zongmansheng.club/2019/07/21/mac-xia-an-zhuang-kafka/"/>
    <id>http://zongmansheng.club/2019/07/21/mac-xia-an-zhuang-kafka/</id>
    <published>2019-07-21T13:07:50.000Z</published>
    <updated>2019-07-23T04:21:45.138Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mac下安装Kafka"><a href="#Mac下安装Kafka" class="headerlink" title="Mac下安装Kafka"></a>Mac下安装Kafka</h1><blockquote><p>使用brew安装</p></blockquote><p><img src="//zongmansheng.club/2019/07/21/mac-xia-an-zhuang-kafka/001.png" alt></p><p>安装完之后，安装目录为：</p><pre><code># kafka安装目录/usr/local/Cellar/kafka/2.2.1# 配置文件目录/usr/local/etc/kafka/</code></pre><blockquote><p>如果需要修改配置，可以进入对应目录，修改配置文件就好</p></blockquote><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><blockquote><p>kafka<code>是基于zookeeper的，启动</code>kafka<code>之前，需要先启动</code>zookeeper</p></blockquote><pre><code>zkServer start</code></pre><blockquote><p>启动后，查看启动是否成功</p></blockquote><pre><code>ps aux|grep zookeeper</code></pre><blockquote><p>启动kafka</p></blockquote><pre><code>kafka-server-start /usr/local/etc/kafka/server.properties &amp;</code></pre><blockquote><p>查看启动是否成功</p></blockquote><pre><code>ps aux | grep kafka</code></pre><h4 id="创建一个topic"><a href="#创建一个topic" class="headerlink" title="创建一个topic"></a>创建一个topic</h4><pre><code># 命令行参数含义，后续补充，当前页不是很清楚，约莫能猜出个大概kafka-topics --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic ZongMan</code></pre><h4 id="查看topic列表"><a href="#查看topic列表" class="headerlink" title="查看topic列表"></a>查看topic列表</h4><pre><code>kafka-topics --list --zookeeper localhost:2181</code></pre><h4 id="创建一个生产者"><a href="#创建一个生产者" class="headerlink" title="创建一个生产者"></a>创建一个生产者</h4><pre><code>kafka-console-producer --broker-list localhost:9092 --topic ZongMan</code></pre><h4 id="创建二个消费者"><a href="#创建二个消费者" class="headerlink" title="创建二个消费者"></a>创建二个消费者</h4><pre><code>kafka-console-consumer --bootstrap-server localhost:9092 --topic test --from-beginning</code></pre><h4 id="服务的关闭"><a href="#服务的关闭" class="headerlink" title="服务的关闭"></a>服务的关闭</h4><blockquote><p>服务关闭的顺序是先<code>kafka</code>，然后<code>zookeeper</code></p></blockquote><pre><code># 关闭kafka/usr/local/Cellar/kafka/2.2.1/bin/kafka-server-stop#关闭zookeeper/usr/local/Cellar/kafka/2.2.1/bin/zookeeper-server-stop</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Mac下安装Kafka&quot;&gt;&lt;a href=&quot;#Mac下安装Kafka&quot; class=&quot;headerlink&quot; title=&quot;Mac下安装Kafka&quot;&gt;&lt;/a&gt;Mac下安装Kafka&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;使用brew安装&lt;/p&gt;
&lt;/blockq
      
    
    </summary>
    
      <category term="中间件" scheme="http://zongmansheng.club/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="MQ" scheme="http://zongmansheng.club/tags/MQ/"/>
    
      <category term="kafka" scheme="http://zongmansheng.club/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>JVM如何判断对象是否还存活</title>
    <link href="http://zongmansheng.club/2019/07/18/jvm-ru-he-pan-duan-dui-xiang-shi-fou-huan-cun-huo/"/>
    <id>http://zongmansheng.club/2019/07/18/jvm-ru-he-pan-duan-dui-xiang-shi-fou-huan-cun-huo/</id>
    <published>2019-07-18T00:50:50.000Z</published>
    <updated>2019-07-18T23:58:56.678Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM如何判断对象是否还存活"><a href="#JVM如何判断对象是否还存活" class="headerlink" title="JVM如何判断对象是否还存活"></a>JVM如何判断对象是否还存活</h1><blockquote><p>在java堆中存活着几乎所有的对象实例，垃圾收集器在回收之前需要判断哪些对象还存活着，哪些对象已经死去。</p></blockquote><h3 id="一、引用计数法"><a href="#一、引用计数法" class="headerlink" title="一、引用计数法"></a>一、引用计数法</h3><blockquote><p>引用计算法的算法大致如下：给对象添加一个引用计数器，每当有地方引用它时，计数器就加1；当引用失效时，计数器就减1；当计数器为0时就表示该对象已经死去。</p><p>客观的说，引用计数法的实现简单，判定效率也很高，在大多数情况下是一种不错的算法，也有很多经典的应用案例，比如微软公司的COM（Component Object Model）技术、使用ActionScript 3的FlashPlayer、Python语言和在游戏脚本领域广泛应用的Squirrel中都使用了引用计数算法进行了内存管理。<strong>但在主流的java虚拟机中没有选用引用计数法来管理内存，主要是因为它很难解决对象之间相互循环引用的问题</strong>。</p><p>现在我们就通过对象循环引用的例子来测试java虚拟机是否会回收？</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>jvm<span class="token punctuation">.</span>demo<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019-07-18 * @Time: 21:42 * @Vsersion: 1.0 * 测试java虚拟机会否用引用计数法进行垃圾回收 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReferenceCountTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> Object instance <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> oneMB<span class="token operator">=</span><span class="token number">1024</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bigSize <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token operator">*</span>oneMB<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 该成员属性用来占点内存，方便gc日志中观察内存回收过程     * @param args     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ReferenceCountTest a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceCountTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ReferenceCountTest b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceCountTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        a<span class="token punctuation">.</span>instance <span class="token operator">=</span> b<span class="token punctuation">;</span>        b<span class="token punctuation">.</span>instance <span class="token operator">=</span> a<span class="token punctuation">;</span>        a <span class="token operator">=</span> null<span class="token punctuation">;</span>        b <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//当发生gc时，对象a和对象b能否被回收？</span>        System<span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="二、可达性分析算法"><a href="#二、可达性分析算法" class="headerlink" title="二、可达性分析算法"></a>二、可达性分析算法</h3><blockquote><p>在主流的商用语言中（例如Java、C#）的主流实现中，都是通过可达性分析（Reachability Analysis）来判定对象是否存活的。这个算法的思路就是：</p><p>通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连时（也就是从GC Roots到这个对象不可达时 ），则说明此对象是不可用的。如下图所示，虽然Object5、Object6、Object7之间是相互关联的，但它们与GC Roots是断开的，所以它们被判定为可回收的对象。</p></blockquote><p><img src="//zongmansheng.club/2019/07/18/jvm-ru-he-pan-duan-dui-xiang-shi-fou-huan-cun-huo/001.png" alt></p><blockquote><p>在java中，可作为GC Roots的对象有以下几种：</p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li><li>方法区中类静态属性引用的对象。</li><li>方法区中常量引用的对象。</li><li>本地方法栈中JNI（即一般说的Native方法）引用的对象。</li></ul></blockquote><h3 id="三、四种引用类型"><a href="#三、四种引用类型" class="headerlink" title="三、四种引用类型"></a>三、四种引用类型</h3><blockquote><p>在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）四种，这四种引用强度依次逐渐减弱。以下是它们的定义：</p><ul><li><strong>强引用</strong>就是指在程序代码中普遍存在的，类型“Object object = new Object()”这类的引用，垃圾回收器永远不会回收这类被引用的对象。</li><li><strong>软引用</strong>用来描述一些还有用但并非必须的对象。对于软引用关联的对象，在系统将要发生内存溢出之前，将会将这些对象列进回收范围进行第二次回收。若这次回收后还没有足够的内存，才会抛出内存溢出异常，在JDK1.2后，提供了SoftReference类来实现软引用。</li><li><strong>弱引用</strong>也用来描述非必须对象，但它的强度比软引用更弱些，被弱引用关联的对象只能生存到下一次垃圾回收之前。无论当前内存是否足够，垃圾回收都会回收掉被弱引用的对象。JDK1.2后，专门用WeakReference类来实现弱引用。</li><li><strong>虚引用</strong>也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设立虚引用的目的就是在这个对象被垃圾回收前收到一条系统通知。JDK1.2后，提供了PhantomRerence类来实现虚引用。</li></ul></blockquote><h3 id="四、对象生存或死亡"><a href="#四、对象生存或死亡" class="headerlink" title="四、对象生存或死亡"></a>四、对象生存或死亡</h3><blockquote><p>在可达性分析算法中不可达的对象，并非一定会垃圾回收的，这时候它们暂时处于“缓刑“阶段，要真正宣告一个对象的死亡，至少要经历两次标记过程：</p><ol><li><strong>如果对象在进行可达性分析时发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选</strong>，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。</li><li><strong>如果这个对象被判定为有必要执行finalize()方法，那么这个对象将被放置在一个叫做F-Queue的队列之中，并在稍后由虚拟机自动建立的、低优先级的Finalizer线程去执行它</strong>。这里所谓的执行是指虚拟机会触发这个方法，但它不会承诺会等待它运行结束。这样做的原因是，如果对象在finalize()方法中运行缓慢，或者发生了死循环或更糟糕的情况，这将可能导致F-Queue队列中其他对象永久处于等待，甚至整个内存回收系统崩溃。finalize方法是对象逃脱被回收的最后一次机会，稍后GC将对F-Queue队列中的对象进行第二次小规模的标记，如果对象要在finalize中成功拯救自己——只要重新与GC Roots重新建立关联即可，这样在第二次标记时它将被移出“即将回收”集合，否则将会被回收。</li></ol></blockquote><h3 id="五、回收方法区"><a href="#五、回收方法区" class="headerlink" title="五、回收方法区"></a>五、回收方法区</h3><blockquote><p>在堆中，尤其在新生代中，常规进行一次垃圾回收一般可以回收70%~95%的空间，而方法区（或者HotSpot虚拟机中的永久代）的垃圾回收效率远低于此。</p><p>方法区的垃圾回收主要回收两部分内容：<strong>废弃常量和无用的类</strong>。</p><p>判断一个常量是否为废弃常量的条件比较简单，以常量池中字面量的回收为例，假如一个字符串“a”已经进入了常量池中，但当前系统没有任何一个String对象是叫做“a”的，也就是说没有任何String对象引用长常量池中的“a”变量，也没有其他地方引用了这个字面量，那么垃圾回收时，这个“a”常量就会被系统清理出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。</p><p>判断一个类是否是无用的类条件就苛刻些，需要满足以下三个条件才可以被回收，而不是像对象一样不使用了，必然被回收，是否被类进行回收，Hotspot虚拟机提供了相关参数进行控制：</p><ul><li>该类的所有实例都已经被回收。</li><li>加载该类的ClassLoader已经被回收</li><li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><p>在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGI这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证方法区（永久代）不溢出。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JVM如何判断对象是否还存活&quot;&gt;&lt;a href=&quot;#JVM如何判断对象是否还存活&quot; class=&quot;headerlink&quot; title=&quot;JVM如何判断对象是否还存活&quot;&gt;&lt;/a&gt;JVM如何判断对象是否还存活&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;在java堆中存活
      
    
    </summary>
    
      <category term="虚拟机" scheme="http://zongmansheng.club/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM" scheme="http://zongmansheng.club/tags/JVM/"/>
    
      <category term="回收机制" scheme="http://zongmansheng.club/tags/%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>分布式全局ID生成方案</title>
    <link href="http://zongmansheng.club/2019/07/17/fen-bu-shi-quan-ju-id-sheng-cheng-fang-an/"/>
    <id>http://zongmansheng.club/2019/07/17/fen-bu-shi-quan-ju-id-sheng-cheng-fang-an/</id>
    <published>2019-07-17T04:58:06.000Z</published>
    <updated>2019-07-17T05:00:59.161Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式全局ID生成方案"><a href="#分布式全局ID生成方案" class="headerlink" title="分布式全局ID生成方案"></a>分布式全局ID生成方案</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;分布式全局ID生成方案&quot;&gt;&lt;a href=&quot;#分布式全局ID生成方案&quot; class=&quot;headerlink&quot; title=&quot;分布式全局ID生成方案&quot;&gt;&lt;/a&gt;分布式全局ID生成方案&lt;/h1&gt;
      
    
    </summary>
    
      <category term="分布式" scheme="http://zongmansheng.club/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式id" scheme="http://zongmansheng.club/tags/%E5%88%86%E5%B8%83%E5%BC%8Fid/"/>
    
  </entry>
  
  <entry>
    <title>分布式锁</title>
    <link href="http://zongmansheng.club/2019/07/16/fen-bu-shi-suo/"/>
    <id>http://zongmansheng.club/2019/07/16/fen-bu-shi-suo/</id>
    <published>2019-07-16T03:08:44.000Z</published>
    <updated>2019-07-16T13:37:25.010Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><h3 id="一、什么是锁？"><a href="#一、什么是锁？" class="headerlink" title="一、什么是锁？"></a>一、什么是锁？</h3><blockquote><ul><li>在单进程的系统中，当存在多个线程可以同时改变某个变量（可变共享变量）时，就需要对变量或代码块做同步，使其在修改这种变量时能够线性执行消除并发修改变量。</li><li>而同步的本质是通过锁来实现的。为了实现多个线程在一个时刻同一个代码块只能有一个线程可执行，那么需要在某个地方做个标记，这个标记必须每个线程都能看到，当标记不存在时可以设置该标记，其余后续线程发现已经有标记了则等待拥有标记的线程结束同步代码块取消标记后再去尝试设置标记。这个标记可以理解为锁。</li><li>不同地方实现锁的方式也不一样，只要能满足所有线程都能看得到标记即可。如 Java 中 synchronize 是在对象头设置标记，Lock 接口的实现类基本上都只是某一个 volitile 修饰的 int 型变量其保证每个线程都能拥有对该 int 的可见性和原子修改，linux 内核中也是利用互斥量或信号量等内存数据做标记。</li><li>除了利用内存数据做锁其实任何互斥的都能做锁（只考虑互斥情况），如流水表中流水号与时间结合做幂等校验可以看作是一个不会释放的锁，或者使用某个文件是否存在作为锁等。只需要满足在对标记进行修改能保证原子性和内存可见性即可。</li></ul></blockquote><h3 id="二、什么是分布式？"><a href="#二、什么是分布式？" class="headerlink" title="二、什么是分布式？"></a>二、什么是分布式？</h3><blockquote><p>分布式的 CAP 理论告诉我们:</p></blockquote><blockquote><p>任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance），最多只能同时满足两项。</p><p>目前很多大型网站及应用都是分布式部署的，分布式场景中的数据一致性问题一直是一个比较重要的话题。基于 CAP理论，很多系统在设计之初就要对这三者做出取舍。在互联网领域的绝大多数的场景中，都需要牺牲强一致性来换取系统的高可用性，系统往往只需要保证最终一致性。</p><p>分布式场景</p><p><strong>此处主要指集群模式下，多个相同服务同时开启.</strong></p></blockquote><blockquote><p>在许多的场景中，我们为了保证数据的最终一致性，需要很多的技术方案来支持，比如<code>分布式事务</code>、<code>分布式锁</code>等。很多时候我们需要保证一个方法在同一时间内只能被同一个线程执行。在单机环境中，通过 Java 提供的并发 API 我们可以解决，但是在分布式环境下，就没有那么简单啦。</p><ul><li>分布式与单机情况下最大的不同在于其不是多线程而是<code>多进程</code>。</li><li>多线程由于可以共享堆内存，因此可以简单的采取内存作为标记存储位置。而进程之间甚至可能都不在同一台物理机上，因此需要将标记存储在一个所有进程都能看到的地方。</li></ul></blockquote><h3 id="三、什么是分布式锁？"><a href="#三、什么是分布式锁？" class="headerlink" title="三、什么是分布式锁？"></a>三、什么是分布式锁？</h3><blockquote><ul><li>当在分布式模型下，数据只有一份（或有限制），此时需要利用锁的技术控制某一时刻修改数据的进程数。</li><li>与单机模式下的锁不仅需要保证进程可见，还需要考虑进程与锁之间的网络问题。（我觉得分布式情况下之所以问题变得复杂，主要就是需要考虑到网络的延时和不可靠。。。一个大坑）</li><li>分布式锁还是可以将标记存在内存，只是该内存不是某个进程分配的内存而是公共内存如 Redis、Memcache。至于利用数据库、文件等做锁与单机的实现是一样的，只要保证标记能互斥就行。</li></ul></blockquote><h3 id="四、我们需要怎样的分布式锁？"><a href="#四、我们需要怎样的分布式锁？" class="headerlink" title="四、我们需要怎样的分布式锁？"></a>四、我们需要怎样的分布式锁？</h3><blockquote><ul><li>可以保证在分布式部署的应用集群中，同一个方法在同一时间只能被一台机器-上的一个线程执行。</li><li>这把锁要是一把可重入锁（避免死锁）</li><li>这把锁最好是一把阻塞锁（根据业务需求考虑要不要这条）</li><li>这把锁最好是一把公平锁（根据业务需求考虑要不要这条）</li><li>有高可用的获取锁和释放锁功能</li><li>获取锁和释放锁的性能要好</li></ul></blockquote><h3 id="五、基于数据库做分布式锁"><a href="#五、基于数据库做分布式锁" class="headerlink" title="五、基于数据库做分布式锁"></a>五、基于数据库做分布式锁</h3><h4 id="基于乐观锁"><a href="#基于乐观锁" class="headerlink" title="基于乐观锁"></a>基于乐观锁</h4><h6 id="基于表主键唯一做分布式锁"><a href="#基于表主键唯一做分布式锁" class="headerlink" title="基于表主键唯一做分布式锁"></a>基于表主键唯一做分布式锁</h6><blockquote><p><strong>思路：</strong>利用主键唯一的特性，如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功，那么我们就可以认为操作成功的那个线程获得了该方法的锁，当方法执行完毕之后，想要释放锁的话，删除这条数据库记录即可。</p><p>上面这种简单的实现有以下几个问题：</p><ul><li>这把锁强依赖数据库的可用性，数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。</li><li>这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。</li><li>这把锁只能是非阻塞的，因为数据的 insert操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。</li><li>这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。</li><li>这把锁是非公平锁，所有等待锁的线程凭运气去争夺锁。</li><li>在 MySQL 数据库中采用主键冲突防重，在大并发情况下有可能会造成锁表现象。</li></ul><h5 id="当然，我们也可以有其他方式解决上面的问题。"><a href="#当然，我们也可以有其他方式解决上面的问题。" class="headerlink" title="当然，我们也可以有其他方式解决上面的问题。"></a>当然，我们也可以有其他方式解决上面的问题。</h5><ul><li>数据库是单点？搞两个数据库，数据之前双向同步，一旦挂掉快速切换到备库上。</li><li>没有失效时间？只要做一个定时任务，每隔一定时间把数据库中的超时数据清理一遍。</li><li>非阻塞的？搞一个 while 循环，直到 insert 成功再返回成功。</li><li>非重入的？在数据库表中加个字段，记录当前获得锁的机器的主机信息和线程信息，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了。</li><li>非公平的？再建一张中间表，将等待锁的线程全记录下来，并根据创建时间排序，只有最先创建的允许获取锁。</li><li>比较好的办法是在程序中生产主键进行防重。</li></ul></blockquote><h4 id="基于表字段版本号做分布式锁"><a href="#基于表字段版本号做分布式锁" class="headerlink" title="基于表字段版本号做分布式锁"></a>基于表字段版本号做分布式锁</h4><blockquote><p>这个策略源于 mysql 的 mvcc 机制，使用这个策略其实本身没有什么问题，唯一的问题就是对数据表侵入较大，我们要为每个表设计一个版本号字段，然后写一条判断 sql 每次进行判断，增加了数据库操作的次数，在高并发的要求下，对数据库连接的开销也是无法忍受的。</p><p>基于悲观锁</p></blockquote><h4 id="基于数据库排他锁做分布式锁"><a href="#基于数据库排他锁做分布式锁" class="headerlink" title="基于数据库排他锁做分布式锁"></a>基于数据库排他锁做分布式锁</h4><blockquote><p>在查询语句后面增加<code>for update</code>，数据库会在查询过程中给数据库表增加排他锁 (注意： InnoDB 引擎在加锁的时候，只有通过索引进行检索的时候才会使用行级锁，否则会使用表级锁。这里我们希望使用行级锁，就要给要执行的方法字段名添加索引，值得注意的是，这个索引一定要创建成唯一索引，否则会出现多个重载方法之间无法同时被访问的问题。重载方法的话建议把参数类型也加上。)。当某条记录被加上排他锁之后，其他线程无法再在该行记录上增加排他锁。</p><p>我们可以认为获得排他锁的线程即可获得分布式锁，当获取到锁之后，可以执行方法的业务逻辑，执行完方法之后，通过<code>connection.commit()</code>操作来释放锁。</p><p>这种方法可以有效的解决上面提到的无法释放锁和阻塞锁的问题。</p><ul><li>阻塞锁？ <code>for update</code>语句会在执行成功后立即返回，在执行失败时一直处于阻塞状态，直到成功。</li><li>锁定之后服务宕机，无法释放？使用这种方式，服务宕机之后数据库会自己把锁释放掉。</li></ul><p>但是还是无法直接解决数据库单点和可重入问题。</p><p>这里还可能存在另外一个问题，虽然我们对方法字段名使用了唯一索引，并且显示使用 for update 来使用行级锁。但是，MySQL 会对查询进行优化，即便在条件中使用了索引字段，但是否使用索引来检索数据是由 MySQL 通过判断不同执行计划的代价来决定的，如果 MySQL 认为全表扫效率更高，比如对一些很小的表，它就不会使用索引，这种情况下 InnoDB 将使用表锁，而不是行锁。如果发生这种情况就悲剧了。。。</p><p>还有一个问题，就是我们要使用排他锁来进行分布式锁的 lock，那么一个排他锁长时间不提交，就会占用数据库连接。一旦类似的连接变得多了，就可能把数据库连接池撑爆。</p></blockquote><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><blockquote><p><strong>优点</strong>：简单，易于理解</p><p><strong>缺点</strong>：会有各种各样的问题（操作数据库需要一定的开销，使用数据库的行级锁并不一定靠谱，性能不靠谱）</p></blockquote><h3 id="基于-Redis-做分布式锁"><a href="#基于-Redis-做分布式锁" class="headerlink" title="基于 Redis 做分布式锁"></a>基于 Redis 做分布式锁</h3><blockquote><p>基于 REDIS 的 SETNX()、EXPIRE() 方法做分布式锁</p></blockquote><blockquote><p>目前几乎很多大型网站及应用都是分布式部署的，分布式场景中的数据一致性问题一直是一个比较重要的话题。分布式的CAP理论告诉我们“任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance），最多只能同时满足两项。”所以，很多系统在设计之初就要对这三者做出取舍。在互联网领域的绝大多数的场景中，都需要牺牲强一致性来换取系统的高可用性，系统往往只需要保证“最终一致性”，只要这个最终时间是在用户可以接受的范围内即可。</p><p>在很多场景中，我们为了保证数据的最终一致性，需要很多的技术方案来支持，比如分布式事务、分布式锁等。</p></blockquote><h4 id="1-选用Redis实现分布式锁原因"><a href="#1-选用Redis实现分布式锁原因" class="headerlink" title="1.选用Redis实现分布式锁原因"></a>1.选用Redis实现分布式锁原因</h4><blockquote><p>Redis有很高的性能</p><p>Redis命令对此支持较好，实现起来比较方便</p></blockquote><h4 id="2-Redis常用命令"><a href="#2-Redis常用命令" class="headerlink" title="2.Redis常用命令"></a>2.Redis常用命令</h4><blockquote><p>SETNX key val</p><p>setnx 的含义就是 SET if Not Exists，其主要有两个参数 setnx(key, value)。该方法是原子的，如果 key 不存在，则设置当前 key 成功，返回 1；如果当前 key 已经存在，则设置当前 key 失败，返回 0。</p></blockquote><blockquote><p>expire()</p><p>expire key timeout<br>为key设置一个超时时间，单位为second，超过这个时间锁会自动释放，避免死锁。</p></blockquote><blockquote><p>delete<br>delete key<br>删除key</p></blockquote><h4 id="3-实现"><a href="#3-实现" class="headerlink" title="3.实现"></a>3.实现</h4><blockquote><p>使用的是jedis来连接Redis。</p></blockquote><h4 id="4-实现思想"><a href="#4-实现思想" class="headerlink" title="4.实现思想"></a>4.实现思想</h4><blockquote><p>获取锁的时候，使用setnx加锁，并使用expire命令为锁添加一个超时时间，超过该时间则自动释放锁，锁的value值为一个随机生成的UUID，通过此在释放锁的时候进行判断。</p><p>获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。</p><p>释放锁的时候，通过UUID判断是不是该锁，若是该锁，则执行delete进行锁释放。</p></blockquote><h4 id="5-使用步骤"><a href="#5-使用步骤" class="headerlink" title="5.使用步骤"></a>5.使用步骤</h4><blockquote><p>1、setnx(lockkey, 1) 如果返回 0，则说明占位失败；如果返回 1，则说明占位成功</p><p>2、expire() 命令对 lockkey 设置超时时间，为的是避免死锁问题。</p><p>3、执行完业务代码后，可以通过 delete 命令删除 key。</p><p>这个方案其实是可以解决日常工作中的需求的，但从技术方案的探讨上来说，可能还有一些可以完善的地方。</p><p>比如，如果在第一步 setnx 执行成功后，在 expire() 命令执行成功前，发生了宕机的现象，那么就依然会出现死锁的问题，所以如果要对其进行完善的话，可以使用 redis 的 setnx()、get() 和 getset() 方法来实现分布式锁。</p></blockquote><h3 id="基于-REDIS-的-SETNX-、GET-、GETSET-方法做分布式锁"><a href="#基于-REDIS-的-SETNX-、GET-、GETSET-方法做分布式锁" class="headerlink" title="基于 REDIS 的 SETNX()、GET()、GETSET()方法做分布式锁"></a>基于 REDIS 的 SETNX()、GET()、GETSET()方法做分布式锁</h3><blockquote><p>这个方案的背景主要是在 setnx() 和 expire() 的方案上针对可能存在的死锁问题，做了一些优化。</p></blockquote><h5 id="getset"><a href="#getset" class="headerlink" title="getset()"></a>getset()</h5><blockquote><p>这个命令主要有两个参数 getset(key，newValue)。该方法是原子的，对 key 设置 newValue 这个值，并且返回 key 原来的旧值。假设 key 原来是不存在的，那么多次执行这个命令，会出现下边的效果：</p><ul><li>getset(key, “value1”) 返回 null 此时 key 的值会被设置为 value1</li><li>getset(key, “value2”) 返回 value1 此时 key 的值会被设置为 value2</li><li>依次类推！</li></ul></blockquote><h4 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤:"></a>使用步骤:</h4><blockquote><ul><li>setnx(lockkey, 当前时间+过期超时时间)，如果返回 1，则获取锁成功；如果返回 0 则没有获取到锁，转向 2。</li><li>get(lockkey) 获取值 oldExpireTime ，并将这个 value 值与当前的系统时间进行比较，如果小于当前系统时间，则认为这个锁已经超时，可以允许别的请求重新获取，转向 3。</li><li>计算 newExpireTime = 当前时间+过期超时时间，然后 getset(lockkey, newExpireTime) 会返回当前 lockkey 的值currentExpireTime。</li><li>判断 currentExpireTime 与 oldExpireTime 是否相等，如果相等，说明当前 getset 设置成功，获取到了锁。如果不相等，说明这个锁又被别的请求获取走了，那么当前请求可以直接返回失败，或者继续重试。</li><li>在获取到锁之后，当前线程可以开始自己的业务处理，当处理完毕后，比较自己的处理时间和对于锁设置的超时时间，如果小于锁设置的超时时间，则直接执行 delete 释放锁；如果大于锁设置的超时时间，则不需要再锁进行处理。</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;分布式锁&quot;&gt;&lt;a href=&quot;#分布式锁&quot; class=&quot;headerlink&quot; title=&quot;分布式锁&quot;&gt;&lt;/a&gt;分布式锁&lt;/h1&gt;&lt;h3 id=&quot;一、什么是锁？&quot;&gt;&lt;a href=&quot;#一、什么是锁？&quot; class=&quot;headerlink&quot; title=&quot;一、什
      
    
    </summary>
    
      <category term="分布式" scheme="http://zongmansheng.club/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="redis" scheme="http://zongmansheng.club/tags/redis/"/>
    
      <category term="zookeeper" scheme="http://zongmansheng.club/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud（五）</title>
    <link href="http://zongmansheng.club/2019/07/15/springcloud-wu/"/>
    <id>http://zongmansheng.club/2019/07/15/springcloud-wu/</id>
    <published>2019-07-15T11:15:30.000Z</published>
    <updated>2019-07-15T11:15:30.524Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JSONWeb令牌</title>
    <link href="http://zongmansheng.club/2019/07/15/jsonweb-ling-pai/"/>
    <id>http://zongmansheng.club/2019/07/15/jsonweb-ling-pai/</id>
    <published>2019-07-15T03:21:03.000Z</published>
    <updated>2019-07-15T07:55:47.793Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JSON-Web令牌（JWT）"><a href="#JSON-Web令牌（JWT）" class="headerlink" title="JSON Web令牌（JWT）"></a>JSON Web令牌（JWT）</h1><p><img src="//zongmansheng.club/2019/07/15/jsonweb-ling-pai/001.png" alt></p><blockquote><p>JSON Web Token（JWT）是目前最流行的跨域身份验证解决方案。</p></blockquote><h4 id="1-跨域身份验证"><a href="#1-跨域身份验证" class="headerlink" title="1.跨域身份验证"></a>1.跨域身份验证</h4><blockquote><p>Internet服务无法与用户身份验证分开。一般过程如下。</p><p>1.用户向服务器发送用户名和密码。</p><p>2.验证服务器后，相关数据（如用户角色，登录时间等）将保存在当前会话中。</p><p>3.服务器向用户返回session_id，session信息都会写入到用户的Cookie。</p><p>4.用户的每个后续请求都将通过在Cookie中取出session_id传给服务器。</p><p>5.服务器收到session_id并对比之前保存的数据，确认用户的身份。</p></blockquote><p><img src="//zongmansheng.club/2019/07/15/jsonweb-ling-pai/002.png" alt></p><blockquote><p>这种模式最大的问题是，没有分布式架构，无法支持横向扩展。如果使用一个服务器，该模式完全没有问题。但是，如果它是服务器群集或面向服务的跨域体系结构的话，则需要一个统一的session数据库库来保存会话数据实现共享，这样负载均衡下的每个服务器才可以正确的验证用户身份。</p><p>例如:举一个实际中常见的单点登陆的需求：站点A和站点B提供同一公司的相关服务。现在要求用户只需要登录其中一个网站，然后它就会自动登录到另一个网站。怎么做？</p><p>一种解决方案是听过持久化session数据，写入数据库或文件持久层等。收到请求后，验证服务从持久层请求数据。该解决方案的优点在于架构清晰，而缺点是架构修改比较费劲，整个服务的验证逻辑层都需要重写，工作量相对较大。而且由于依赖于持久层的数据库或者问题系统，会有单点风险，如果持久层失败，整个认证体系都会挂掉。</p></blockquote><p><img src="//zongmansheng.club/2019/07/15/jsonweb-ling-pai/003.png" alt></p><blockquote><p>本文给大家介绍另外一种灵活的解决方案，通过客户端保存数据，而服务器根本不保存会话数据，每个请求都被发送回服务器。 JWT是这种解决方案的代表。</p></blockquote><p><img src="//zongmansheng.club/2019/07/15/jsonweb-ling-pai/004.png" alt></p><h4 id="2-JWT的原则"><a href="#2-JWT的原则" class="headerlink" title="2. JWT的原则"></a>2. JWT的原则</h4><blockquote><p>JWT的原则是在服务器身份验证之后，将生成一个JSON对象并将其发送回用户，如下所示。</p><p>{</p><p>“UserName”: “ZongMan”,</p><p>“Role”: “Admin”,</p><p>“Expire”: “2018-08-08 20:15:56”</p><p>}</p><p>之后，当用户与服务器通信时，客户在请求中发回JSON对象。服务器仅依赖于这个JSON对象来标识用户。为了防止用户篡改数据，服务器将在生成对象时添加签名（有关详细信息，请参阅下文）。</p><p>服务器不保存任何会话数据，即服务器变为无状态，使其更容易扩展。</p></blockquote><h4 id="3-JWT的数据结构"><a href="#3-JWT的数据结构" class="headerlink" title="3. JWT的数据结构"></a>3. JWT的数据结构</h4><blockquote><p>典型的，一个JWT看起来如下图。</p><p>改对象为一个很长的字符串，字符之间通过”.”分隔符分为三个子串。注意JWT对象为一个长字串，各字串之间也没有换行符，此处为了演示需要，我们特意分行并用不同颜色表示了。每一个子串表示了一个功能块，总共有以下三个部分：</p><p>JWT的三个部分如下。JWT头、有效载荷和签名，将它们写成一行如下。</p></blockquote><p><img src="//zongmansheng.club/2019/07/15/jsonweb-ling-pai/005.png" alt></p><blockquote><p>我们将在下面介绍这三个部分。</p></blockquote><h5 id="3-1-JWT头"><a href="#3-1-JWT头" class="headerlink" title="3.1 JWT头"></a>3.1 JWT头</h5><blockquote><p>JWT头部分是一个描述JWT元数据的JSON对象，通常如下所示。</p><p>{</p><p>“alg”: “HS256”,</p><p>“typ”: “JWT”</p><p>}</p><p>在上面的代码中，alg属性表示签名使用的算法，默认为HMAC SHA256（写为HS256）；typ属性表示令牌的类型，JWT令牌统一写为JWT。</p><p>最后，使用Base64 URL算法将上述JSON对象转换为字符串保存。</p></blockquote><h5 id="3-2-有效载荷"><a href="#3-2-有效载荷" class="headerlink" title="3.2 有效载荷"></a>3.2 有效载荷</h5><blockquote><p>有效载荷部分，是JWT的主体内容部分，也是一个JSON对象，包含需要传递的数据。 JWT指定七个默认字段供选择。</p><p>iss：发行人</p><p>exp：到期时间</p><p>sub：主题</p><p>aud：用户</p><p>nbf：在此之前不可用</p><p>iat：发布时间</p><p>jti：JWT ID用于标识该JWT</p><p>除以上默认字段外，我们还可以自定义私有字段，如下例：</p><p>{</p><p>“sub”: “1234567890”,</p><p>“name”: “chongchong”,</p><p>“admin”: true</p><p>}</p><p>请注意，默认情况下JWT是未加密的，任何人都可以解读其内容，因此不要构建隐私信息字段，存放保密信息，以防止信息泄露。</p><p>JSON对象也使用Base64 URL算法转换为字符串保存。</p></blockquote><h5 id="3-3签名哈希"><a href="#3-3签名哈希" class="headerlink" title="3.3签名哈希"></a>3.3签名哈希</h5><blockquote><p>签名哈希部分是对上面两部分数据签名，通过指定的算法生成哈希，以确保数据不会被篡改。</p><p>首先，需要指定一个密码（secret）。该密码仅仅为保存在服务器中，并且不能向用户公开。然后，使用标头中指定的签名算法（默认情况下为HMAC SHA256）根据以下公式生成签名。</p><p>HMACSHA256(base64UrlEncode(header) + “.” + base64UrlEncode(payload),</p><p>secret)</p><p>在计算出签名哈希后，JWT头，有效载荷和签名哈希的三个部分组合成一个字符串，每个部分用”.”分隔，就构成整个JWT对象。</p></blockquote><h5 id="3-4-Base64URL算法"><a href="#3-4-Base64URL算法" class="headerlink" title="3.4 Base64URL算法"></a>3.4 Base64URL算法</h5><blockquote><p>如前所述，JWT头和有效载荷序列化的算法都用到了Base64URL。该算法和常见Base64算法类似，稍有差别。</p><p>作为令牌的JWT可以放在URL中（例如api.example/?token=xxx）。 Base64中用的三个字符是”+”，”/“和”=”，由于在URL中有特殊含义，因此Base64URL中对他们做了替换：”=”去掉，”+”用”-“替换，”/“用”_”替换，这就是Base64URL算法，很简单把。</p></blockquote><h4 id="4-JWT的用法"><a href="#4-JWT的用法" class="headerlink" title="4.JWT的用法"></a>4.JWT的用法</h4><blockquote><p>客户端接收服务器返回的JWT，将其存储在Cookie或localStorage中。</p><p>此后，客户端将在与服务器交互中都会带JWT。如果将它存储在Cookie中，就可以自动发送，但是不会跨域，因此一般是将它放入HTTP请求的Header Authorization字段中。</p><p>Authorization: Bearer</p><p>当跨域时，也可以将JWT被放置于POST请求的数据主体中。</p></blockquote><h4 id="5-JWT问题和趋势"><a href="#5-JWT问题和趋势" class="headerlink" title="5.JWT问题和趋势"></a>5.JWT问题和趋势</h4><blockquote><p>1、JWT默认不加密，但可以加密。生成原始令牌后，可以使用改令牌再次对其进行加密。</p><p>2、当JWT未加密方法是，一些私密数据无法通过JWT传输。</p><p>3、JWT不仅可用于认证，还可用于信息交换。善用JWT有助于减少服务器请求数据库的次数。</p><p>4、JWT的最大缺点是服务器不保存会话状态，所以在使用期间不可能取消令牌或更改令牌的权限。也就是说，一旦JWT签发，在有效期内将会一直有效。</p><p>5、JWT本身包含认证信息，因此一旦信息泄露，任何人都可以获得令牌的所有权限。为了减少盗用，JWT的有效期不宜设置太长。对于某些重要操作，用户在使用时应该每次都进行进行身份验证。</p><p>6、为了减少盗用和窃取，JWT不建议使用HTTP协议来传输代码，而是使用加密的HTTPS协议进行传输。</p></blockquote><h4 id="6-JWT工具类"><a href="#6-JWT工具类" class="headerlink" title="6.JWT工具类"></a>6.JWT工具类</h4><blockquote><p>用于生成Token和Token验证</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JwtUtils</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 签发JWT     * @param id     * @param subject 可以是JSON数据 尽可能少     * @param ttlMillis     * @return  String     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">createJWT</span><span class="token punctuation">(</span>String id<span class="token punctuation">,</span> String subject<span class="token punctuation">,</span> <span class="token keyword">long</span> ttlMillis<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SignatureAlgorithm signatureAlgorithm <span class="token operator">=</span> SignatureAlgorithm<span class="token punctuation">.</span>HS256<span class="token punctuation">;</span>        <span class="token keyword">long</span> nowMillis <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Date now <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span>nowMillis<span class="token punctuation">)</span><span class="token punctuation">;</span>        SecretKey secretKey <span class="token operator">=</span> <span class="token function">generalKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        JwtBuilder builder <span class="token operator">=</span> Jwts<span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">setSubject</span><span class="token punctuation">(</span>subject<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">// 主题</span>                <span class="token punctuation">.</span><span class="token function">setIssuer</span><span class="token punctuation">(</span><span class="token string">"user"</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">// 签发者</span>                <span class="token punctuation">.</span><span class="token function">setIssuedAt</span><span class="token punctuation">(</span>now<span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">// 签发时间</span>                <span class="token punctuation">.</span><span class="token function">signWith</span><span class="token punctuation">(</span>signatureAlgorithm<span class="token punctuation">,</span> secretKey<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 签名算法以及密匙</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ttlMillis <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">long</span> expMillis <span class="token operator">=</span> nowMillis <span class="token operator">+</span> ttlMillis<span class="token punctuation">;</span>            Date expDate <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span>expMillis<span class="token punctuation">)</span><span class="token punctuation">;</span>            builder<span class="token punctuation">.</span><span class="token function">setExpiration</span><span class="token punctuation">(</span>expDate<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 过期时间</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> builder<span class="token punctuation">.</span><span class="token function">compact</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 验证JWT     * @param jwtStr     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> CheckResult <span class="token function">validateJWT</span><span class="token punctuation">(</span>String jwtStr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        CheckResult checkResult <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CheckResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Claims claims <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            claims <span class="token operator">=</span> <span class="token function">parseJWT</span><span class="token punctuation">(</span>jwtStr<span class="token punctuation">)</span><span class="token punctuation">;</span>            checkResult<span class="token punctuation">.</span><span class="token function">setSuccess</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            checkResult<span class="token punctuation">.</span><span class="token function">setClaims</span><span class="token punctuation">(</span>claims<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ExpiredJwtException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            checkResult<span class="token punctuation">.</span><span class="token function">setErrCode</span><span class="token punctuation">(</span>SystemConstant<span class="token punctuation">.</span>JWT_ERRCODE_EXPIRE<span class="token punctuation">)</span><span class="token punctuation">;</span>            checkResult<span class="token punctuation">.</span><span class="token function">setSuccess</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SignatureException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            checkResult<span class="token punctuation">.</span><span class="token function">setErrCode</span><span class="token punctuation">(</span>SystemConstant<span class="token punctuation">.</span>JWT_ERRCODE_FAIL<span class="token punctuation">)</span><span class="token punctuation">;</span>            checkResult<span class="token punctuation">.</span><span class="token function">setSuccess</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            checkResult<span class="token punctuation">.</span><span class="token function">setErrCode</span><span class="token punctuation">(</span>SystemConstant<span class="token punctuation">.</span>JWT_ERRCODE_FAIL<span class="token punctuation">)</span><span class="token punctuation">;</span>            checkResult<span class="token punctuation">.</span><span class="token function">setSuccess</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> checkResult<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> SecretKey <span class="token function">generalKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> encodedKey <span class="token operator">=</span> Base64<span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span>SystemConstant<span class="token punctuation">.</span>JWT_SECERT<span class="token punctuation">)</span><span class="token punctuation">;</span>        SecretKey key <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SecretKeySpec</span><span class="token punctuation">(</span>encodedKey<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> encodedKey<span class="token punctuation">.</span>length<span class="token punctuation">,</span> <span class="token string">"AES"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> key<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     *      * 解析JWT字符串     * @param jwt     * @return     * @throws Exception     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Claims <span class="token function">parseJWT</span><span class="token punctuation">(</span>String jwt<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        SecretKey secretKey <span class="token operator">=</span> <span class="token function">generalKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> Jwts<span class="token punctuation">.</span><span class="token function">parser</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">setSigningKey</span><span class="token punctuation">(</span>secretKey<span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">parseClaimsJws</span><span class="token punctuation">(</span>jwt<span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>如何使用？<br>代码实例：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LoginController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    UserRepository userRepository<span class="token punctuation">;</span>    <span class="token annotation punctuation">@ApiOperation</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">"用户登陆"</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">"login"</span><span class="token punctuation">,</span>method <span class="token operator">=</span> RequestMethod<span class="token punctuation">.</span>POST<span class="token punctuation">)</span>    <span class="token keyword">public</span> ReturnVo <span class="token function">login</span><span class="token punctuation">(</span>String username<span class="token punctuation">,</span> String password<span class="token punctuation">,</span>HttpServletResponse            response<span class="token punctuation">)</span> <span class="token punctuation">{</span>        User user <span class="token operator">=</span>  userRepository<span class="token punctuation">.</span><span class="token function">findByUsername</span><span class="token punctuation">(</span>username<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>user<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">getPassword</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>password<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//把token返回给客户端-->客户端保存至cookie-->客户端每次请求附带cookie参数</span>                String JWT <span class="token operator">=</span> JwtUtils<span class="token punctuation">.</span><span class="token function">createJWT</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">,</span> username<span class="token punctuation">,</span> SystemConstant<span class="token punctuation">.</span>JWT_TTL<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> ReturnVo<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span>JWT<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> ReturnVo<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> ReturnVo<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@ApiOperation</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">"获取用户信息"</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">"description"</span><span class="token punctuation">,</span>method <span class="token operator">=</span> RequestMethod<span class="token punctuation">.</span>POST<span class="token punctuation">)</span>    <span class="token keyword">public</span> ReturnVo <span class="token function">description</span><span class="token punctuation">(</span>String username<span class="token punctuation">)</span> <span class="token punctuation">{</span>        User user <span class="token operator">=</span>  userRepository<span class="token punctuation">.</span><span class="token function">findByUsername</span><span class="token punctuation">(</span>username<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ReturnVo<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JSON-Web令牌（JWT）&quot;&gt;&lt;a href=&quot;#JSON-Web令牌（JWT）&quot; class=&quot;headerlink&quot; title=&quot;JSON Web令牌（JWT）&quot;&gt;&lt;/a&gt;JSON Web令牌（JWT）&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;//zongma
      
    
    </summary>
    
      <category term="日常学习" scheme="http://zongmansheng.club/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="JSON WEB" scheme="http://zongmansheng.club/tags/JSON-WEB/"/>
    
      <category term="JWT" scheme="http://zongmansheng.club/tags/JWT/"/>
    
  </entry>
  
  <entry>
    <title>java源代码的执行原理</title>
    <link href="http://zongmansheng.club/2019/07/13/java-yuan-dai-ma-de-zhi-xing-yuan-li/"/>
    <id>http://zongmansheng.club/2019/07/13/java-yuan-dai-ma-de-zhi-xing-yuan-li/</id>
    <published>2019-07-13T00:00:06.000Z</published>
    <updated>2019-07-23T04:23:07.174Z</updated>
    
    <content type="html"><![CDATA[<h1 id="解析java执行内幕"><a href="#解析java执行内幕" class="headerlink" title="解析java执行内幕"></a>解析java执行内幕</h1><p><img src="//zongmansheng.club/2019/07/13/java-yuan-dai-ma-de-zhi-xing-yuan-li/Snipaste_2019-07-16_08-02-00.png" alt></p><h4 id="一-编写java源程序"><a href="#一-编写java源程序" class="headerlink" title="一 编写java源程序"></a>一 编写java源程序</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test02</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>Test02被public修饰，故存储该java源码的文件名为Test02</p><p>一个java源文件可以包含多个类，但只允许一个类为public</p></blockquote><h4 id="二-编译java源代码"><a href="#二-编译java源代码" class="headerlink" title="二 编译java源代码"></a>二 编译java源代码</h4><blockquote><p>idea自带命令行工具切换到Test02目录下：</p></blockquote><p><img src="//zongmansheng.club/2019/07/13/java-yuan-dai-ma-de-zhi-xing-yuan-li/001.png" alt></p><blockquote><p>Javac 编译Test02.java文件</p><p>Tip:当javac.exe编译java源代码时，java源代码有几个类，就会编译成一个对应的字节码文件(.class文件)，</p><p>其中，字节码文件的文件名就是每个类的类名。需要注意的是，类即使不在源文件中定义，但被源文件引用，</p><p>编译后，也会编程相应的字节码文件，如类A引用类C，但类C不定义在类A的源文件中，编译后，类C也被编</p><p>译成对应的字节码文件C.class</p></blockquote><h4 id="三-执行java源文件"><a href="#三-执行java源文件" class="headerlink" title="三 执行java源文件"></a>三 执行java源文件</h4><blockquote><p>执行步骤：</p></blockquote><p><img src="//zongmansheng.club/2019/07/13/java-yuan-dai-ma-de-zhi-xing-yuan-li/003.png" alt></p><blockquote><p>如上总结，已经抽象化了在JVM中的执行，接下来，我们将分析，字节码文件（.calss文件）如何在虚拟机中一步一执行的。</p></blockquote><h4 id="四-JVM如何执行字节码文件"><a href="#四-JVM如何执行字节码文件" class="headerlink" title="四 JVM如何执行字节码文件"></a>四 JVM如何执行字节码文件</h4><h5 id="（一）-装载字节码文件"><a href="#（一）-装载字节码文件" class="headerlink" title="（一） 装载字节码文件"></a><strong>（一） 装载字节码文件</strong></h5><blockquote><p>当.java源码被javac.exe编译器编译成.class字节码文件后，接下来的工作就交给JVM处理，JVM首先通过类加载器(ClassLoader)</p><p>将class文件和相关Java API加载装入JVM，以供JVM后续处理。</p><p>在该阶段中，涉及到如下一些基本概念和知识。</p></blockquote><h6 id="1-JDK-JRE和JVM关系"><a href="#1-JDK-JRE和JVM关系" class="headerlink" title="1.JDK,JRE和JVM关系"></a>1.JDK,JRE和JVM关系</h6><blockquote><p>（1）JDK（Java Development Kit），Java开发工具包，主要用于开发，在JDK7前，JDK包括JRE</p><p>（2）JRE（Java Runtime Environment），Java程序运行的核心环境，包括JVM和一些核心库</p><p>（3）JVM（Java Virtual Machine），VM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟</p><p>各种计算机功能来实现的，是JRE核心模块。</p></blockquote><h6 id="2-JVM"><a href="#2-JVM" class="headerlink" title="2.JVM"></a>2.JVM</h6><blockquote><p>JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。Java虚拟机</p><p>虚拟机的主要任务是装载class文件并执行其中的字节码，不同的Java虚拟机中，执行引擎可能由不同的实现，大致有如下几种引擎：</p><ul><li>一次性解释字节码引擎</li><li>即时编译引擎</li><li>自适应优化器</li></ul><p>关于虚拟机的实现方式，采用软件方式、硬件方式和软件硬件结合方式，这个要根据具体厂商而定。</p></blockquote><h6 id="3-什么是ClassLoader"><a href="#3-什么是ClassLoader" class="headerlink" title="3.什么是ClassLoader"></a>3.什么是ClassLoader</h6><blockquote><p>虚拟机的主要任务是装载class文件并执行其中的字节码，而class文件是由虚拟机的类加载器(ClassLoader)完成的，在一个Java虚拟机，</p><p>有可能存在多个类加载器。</p><p>任何java运用程序，可能会使用两种类加载器，即启动类加载器(bootstrap)和用户自定义类加载器。</p><p>启动类加载器是Java虚拟机唯一实现的一部分，它又可分为原始类装载器，系统类装载器或默认类装载器，它的主要作用是从操作系统的</p><p>磁盘装载相应的类，如Java API类等。</p><p>用户自定义装载类，按照用户自定义的方式来装载类。</p></blockquote><p><img src="//zongmansheng.club/2019/07/13/java-yuan-dai-ma-de-zhi-xing-yuan-li/004.png" alt></p><h5 id="（二）将字节码文件存储在JVM内存区"><a href="#（二）将字节码文件存储在JVM内存区" class="headerlink" title="（二）将字节码文件存储在JVM内存区"></a><strong>（二）将字节码文件存储在JVM内存区</strong></h5><blockquote><p>当JAVA虚拟机运行一个程序时，它需要内存来存储许多东西，如字节码，从已装载的class文件中得到的其他信息，程序创建的对象，传递给</p><p>方法的参数，返回值，局部变量以及运算的中间结果等，这些相关信息被组织到“运行时数据区”。</p><p>根据厂商的不同，在Java虚拟机中，运行时数据区也有所不同，有些运行时数据区由线程共享，有些只能由某个特定线程共享。运行时数据区</p><p>大致可分几个区：方法区，堆区，栈区，PC寄存器区和本地方法栈区。</p><p>在该阶段中，涉及到如下基本概念和知识。</p></blockquote><h6 id="1-方法区"><a href="#1-方法区" class="headerlink" title="1.方法区"></a>1.方法区</h6><blockquote><p>方法区用来存储解析被加载的class文件的相关信息。当虚拟装载一个class文件后，它会从这个class文件包含的二进制数据中解析类型信息，然后将</p><p>该相关信息存储到方法区中。</p></blockquote><h6 id="2-堆"><a href="#2-堆" class="headerlink" title="2.堆"></a>2.堆</h6><blockquote><p>堆是用来存储相关引用类型的，如new对象。当程序运行时，虚拟机会把所有该程序在运行时创建的对象都放到堆中。</p></blockquote><h6 id="3-PC寄存器"><a href="#3-PC寄存器" class="headerlink" title="3.PC寄存器"></a>3.PC寄存器</h6><blockquote><p>PC寄存器主要用来存储线程。当新创建一个线程时，该线程都将得到一个自己的PC寄存器(程序计数器)以及一个java栈。</p><p>Java虚拟机没有寄存器，其指令集使用Java栈来存储中间数据。</p></blockquote><h6 id="4-栈区"><a href="#4-栈区" class="headerlink" title="4.栈区"></a>4.栈区</h6><blockquote><p>栈区主要用来存储值类型的，如基本数据类型，需要注意的时，String为引用类型，是存在堆中的。Java栈是由许多栈</p><p>帧组成的，一个栈帧包含一个Java方法调用的状态，当线程调用一个方法时，虚拟机压入一个新的栈帧到该线程的Java栈中，当该方法返回时，这个栈帧从Java栈中弹出。</p></blockquote><p><img src="//zongmansheng.club/2019/07/13/java-yuan-dai-ma-de-zhi-xing-yuan-li/005.png" alt></p><h5 id="（三）执行引擎与运行时数据区交互"><a href="#（三）执行引擎与运行时数据区交互" class="headerlink" title="（三）执行引擎与运行时数据区交互"></a><strong>（三）执行引擎与运行时数据区交互</strong></h5><blockquote><p>运行时数据区为执行引擎提供了执行环境和相关数据，执行引擎通过与运行时数据区交互，从而获取</p><p>执行时需要的相关信息，存储执行的中间结果等</p></blockquote><p><img src="//zongmansheng.club/2019/07/13/java-yuan-dai-ma-de-zhi-xing-yuan-li/006.png" alt></p><h5 id="（四）执行引擎与本地方法接口"><a href="#（四）执行引擎与本地方法接口" class="headerlink" title="（四）执行引擎与本地方法接口"></a><strong>（四）执行引擎与本地方法接口</strong></h5><blockquote><p>当要执行本地方法时，执行引擎将调用本地方法接口来获取相关OS本地方法，需要注意的是，本地方法与操作系统强耦合的。</p></blockquote><p><img src="//zongmansheng.club/2019/07/13/java-yuan-dai-ma-de-zhi-xing-yuan-li/007.png" alt></p><h5 id="（五）JVM在具体操作系统上执行"><a href="#（五）JVM在具体操作系统上执行" class="headerlink" title="（五）JVM在具体操作系统上执行"></a><strong>（五）JVM在具体操作系统上执行</strong></h5><blockquote><p>JVM通过调用本地接口来获取本地方法，从而实现在具体的平台上执行，如在Linux系统上执行，在Window系统上执行和在Unix系统上执行。</p></blockquote><p><img src="//zongmansheng.club/2019/07/13/java-yuan-dai-ma-de-zhi-xing-yuan-li/008.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;解析java执行内幕&quot;&gt;&lt;a href=&quot;#解析java执行内幕&quot; class=&quot;headerlink&quot; title=&quot;解析java执行内幕&quot;&gt;&lt;/a&gt;解析java执行内幕&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;//zongmansheng.club/2019/07/
      
    
    </summary>
    
      <category term="日常学习" scheme="http://zongmansheng.club/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="java底层" scheme="http://zongmansheng.club/tags/java%E5%BA%95%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>MySQL索引为什么要用B+树实现</title>
    <link href="http://zongmansheng.club/2019/07/12/mysql-suo-yin-wei-shi-me-yao-yong-b-shu-shi-xian/"/>
    <id>http://zongmansheng.club/2019/07/12/mysql-suo-yin-wei-shi-me-yao-yong-b-shu-shi-xian/</id>
    <published>2019-07-12T00:14:09.000Z</published>
    <updated>2019-07-12T00:44:48.174Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL索引为什么要用B-树实现"><a href="#MySQL索引为什么要用B-树实现" class="headerlink" title="MySQL索引为什么要用B+树实现"></a>MySQL索引为什么要用B+树实现</h1><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><blockquote><p>在从一堆数据中查找指定的数据时，我们常用的数据结构是哈希表和二叉查找树，表本质上就是一堆数据的集合，所以MySQL数据库用了B+树和哈希表来实现索引</p><p>B+树是通过二叉查找树，再由平衡二叉树，B树（又名B-树）演化而来的，B+树中的B不是代表二叉（binary），而是代表平衡（balance），因为B+树是从最早的平衡二叉树演化而来，但是B+树不是一个二叉树</p></blockquote><h3 id="二、二叉查找树和平衡二叉树"><a href="#二、二叉查找树和平衡二叉树" class="headerlink" title="二、二叉查找树和平衡二叉树"></a>二、二叉查找树和平衡二叉树</h3><blockquote><p>二叉查找树的效率和平衡二叉树的查找效率已经很高了，为什么不用这两种数据结构来实现索引呢？慢慢来分析</p><p>二叉查找树是带有特殊属性的二叉树，需要满足以下属性</p><ol><li>非叶子节点最多拥有两个子节点</li><li>非叶子节值大于左边子节点、小于右边子节点</li><li>没有值相等重复的节点;</li></ol></blockquote><p><img src="//zongmansheng.club/2019/07/12/mysql-suo-yin-wei-shi-me-yao-yong-b-shu-shi-xian/001.png" alt></p><blockquote><p>对上图这个二叉树进行查找，如查键值为5的记录，先找到根，其值时6，大于5，查找6的左子树，找到3，5大于3，再找其右子树，一共找了3次。同理，查找键值为8的记录，用了3次。所有键值平均查找次数为(1+2+2+3+3+3)/6=2.3次，假如对这些键值进行顺序查找，平均查找次数为(1+2+3+4+5+6)/6=3.3（查找顺序摆放的数，第一个数肯定是1次，而第2个数是2次，以此类推），显然二叉查找树的平均查找速度比顺序查找更快</p><p>二叉查找树可以任意的构造，假如二叉查找树按照如下方式构造</p></blockquote><p><img src="//zongmansheng.club/2019/07/12/mysql-suo-yin-wei-shi-me-yao-yong-b-shu-shi-xian/002.png" alt></p><blockquote><p>平均查找速度为(1+2+3+4+5+5)/6=3.16次，和顺序查找差不多。为了提高二叉查找树的查询效率，需要二叉查找数是平衡的，这就引出了平衡二叉树。</p><p>平衡二叉树除了满足上面3个属性，还要满足如下1个属性</p><ol><li>树的左右两边的层级数相差不会大于1</li></ol><p>平衡二叉树的查找效率确实很快，但维护一颗平衡二叉树的代价是非常大的，需要1次或多次左旋和右旋来得到插入或更新后树的平衡性。简单举个例子。</p><p>初始平衡二叉树</p></blockquote><p><img src="//zongmansheng.club/2019/07/12/mysql-suo-yin-wei-shi-me-yao-yong-b-shu-shi-xian/003.png" alt></p><blockquote><p>插入3</p></blockquote><p><img src="//zongmansheng.club/2019/07/12/mysql-suo-yin-wei-shi-me-yao-yong-b-shu-shi-xian/004.png" alt></p><blockquote><p>右旋一次</p></blockquote><p><img src="//zongmansheng.club/2019/07/12/mysql-suo-yin-wei-shi-me-yao-yong-b-shu-shi-xian/005.png" alt></p><blockquote><p>再左旋一次</p></blockquote><p><img src="//zongmansheng.club/2019/07/12/mysql-suo-yin-wei-shi-me-yao-yong-b-shu-shi-xian/006.png" alt></p><blockquote><p>作为一个科普性的文章，这里不对左旋的右旋的细节进行分析，放几个图片能理解左旋和右旋即可</p></blockquote><p><img src="//zongmansheng.club/2019/07/12/mysql-suo-yin-wei-shi-me-yao-yong-b-shu-shi-xian/3b0f670f16c8413e8cfa0011fe85c98f.gif" alt></p><blockquote><p>对x进行左旋，意味着将x变为一个左结点</p></blockquote><p><img src="//zongmansheng.club/2019/07/12/mysql-suo-yin-wei-shi-me-yao-yong-b-shu-shi-xian/007.png" alt></p><p><img src="//zongmansheng.club/2019/07/12/mysql-suo-yin-wei-shi-me-yao-yong-b-shu-shi-xian/008.gif" alt></p><blockquote><p>对y进行右旋，意味着将y变为一个右节点</p></blockquote><p><img src="//zongmansheng.club/2019/07/12/mysql-suo-yin-wei-shi-me-yao-yong-b-shu-shi-xian/009.png" alt></p><blockquote><p>回头看上面例子的左旋和右旋，是不是很清楚了？</p></blockquote><h3 id="B树和B-树"><a href="#B树和B-树" class="headerlink" title="B树和B+树"></a>B树和B+树</h3><blockquote><p>B树和B-树是同一种树，假如用平衡二叉树实现索引，效率已经很高了，查找一个节点所做的IO次数是这个节点所处的树的高度，因为我们无法把整个索引都加载到内存，并且节点数据在磁盘中不是顺序排放的。所以最坏情况下，磁盘的IO次数为树的高度。</p><p>虽然平衡二叉树查找效率确实很高，但是频繁的IO才是阻碍提高性能的瓶颈，怎样减少IO次数呢？前辈们很聪明的提出了局部性原理，分为时间局部性原理，即假如你查询id为1的用户数据，过一段时间你还会查询id为1的数据，所以会将这部分数据缓存下来。空间局部性原理，当你查询id为1的用户数据的时候，你有很大的概率会去查询id为2，3，4的用户的数据，所以会一次性的把id为1，2，3，4的数据都读到内存中去，这个最小的单位就是页。</p><p>B树和B+树的概念比较复杂，有兴趣的小伙伴可以点原文链接看看知乎上写的一篇文章，这里只做一个宏观的介绍，前文已经提到树高决定着IO的次数，那么降低树高不就能减少IO的次数吗，怎么减少呢，每个节点的数据多放一点不就行了，并且这个数据是存放在一块的，对应的是数据库中的读取的最小单位页，一次IO就可以将这些数据读取出来，虽然比较的次数有可能会增加，但是在内存中的比较和磁盘IO相比差几个数量级，整体上效率还是提高了。</p><p>所以你看到的B树是这样的</p></blockquote><p><img src="//zongmansheng.club/2019/07/12/mysql-suo-yin-wei-shi-me-yao-yong-b-shu-shi-xian/010.png" alt></p><blockquote><p>B+树是这样的</p></blockquote><p><img src="//zongmansheng.club/2019/07/12/mysql-suo-yin-wei-shi-me-yao-yong-b-shu-shi-xian/011.png" alt></p><blockquote><p>那么B树和B+树的区别在哪呢？</p><ol><li>B+跟B树不同B+树的非叶子节点不保存键值对应的数据，这样使得B+树每个节点所能保存的键值大大增加；</li><li>B+树叶子节点保存了父节点的所有键值和键值对应的数据，每个叶子节点的键值从小到大链接；</li><li>B+树的根节点键值数量和其子节点个数相等;</li><li>B+的非叶子节点只进行数据索引，不会存实际的键值对应的数据，所有数据必须要到叶子节点才能获取到，所以每次数据查询的次数都一样；</li></ol><p>放个图理解的更清楚一点，B树</p></blockquote><p><img src="//zongmansheng.club/2019/07/12/mysql-suo-yin-wei-shi-me-yao-yong-b-shu-shi-xian/012.png" alt></p><blockquote><p>B+树</p></blockquote><p><img src="//zongmansheng.club/2019/07/12/mysql-suo-yin-wei-shi-me-yao-yong-b-shu-shi-xian/013.png" alt></p><blockquote><p>在B+树的基础上每个节点存储的关键字数更多，树的层级更少所以查询数据更快，所有关键字数据都存在叶子节点，所以每次查找的次数都相同，查询速度比B树更稳定。除此之外，B+树的叶子节点是跟后序节点相连接的，这对范围查找是非常有用的。</p></blockquote><h3 id="聚集索引和联合索引"><a href="#聚集索引和联合索引" class="headerlink" title="聚集索引和联合索引"></a>聚集索引和联合索引</h3><blockquote><p>在InnoDB存储引擎中，是以主键为索引来组织数据的。在InnoDB存储引擎中，每张表都有个主键，如果在创建表时没有显示的定义主键，则InnoDB存储引擎会按如下方式选择或创建主键。</p><ol><li>首先判断表中是否有非空的唯一索引，如果有，则该列即为主键</li><li>如果不符合上述条件，InnoDB存储引擎自动创建一个6字节大小的指针作为索引</li><li>如果有多个非空唯一索引时，InnoDB存储引擎将选择建表时第一个定义的非空唯一索引作为主键</li></ol><p>假如说有如下数据，用户id为主键（1， tom），（2，mike），（3，sam），（4，lisa），（5，li）则数据是这样存储的，图1</p></blockquote><p><img src="//zongmansheng.club/2019/07/12/mysql-suo-yin-wei-shi-me-yao-yong-b-shu-shi-xian/014.png" alt></p><blockquote><p>假如说我们现在对用户名建索引，用户名索引是怎么存的呢？图2</p></blockquote><p><img src="//zongmansheng.club/2019/07/12/mysql-suo-yin-wei-shi-me-yao-yong-b-shu-shi-xian/015.png" alt></p><blockquote><p>用户名索引叶子节点数据存储的是主键，所以当我们运行如下sql语句时</p></blockquote><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">table</span> <span class="token keyword">where</span> name <span class="token operator">=</span><span class="token string">"sam"</span></code></pre><blockquote><p>过程是这样的，先在name索引上找到对应的主键，在根据对应的主键去建表时建立的B+树上找到对应的记录，即先在图1上找，再到图2上找。</p><p>聚集索引：数据行的物理顺序与列值（一般是主键的那一列）的逻辑顺序相同，一个表中只能拥有一个聚集索引。图1用的就是聚集索引</p><p>非聚集索引：定义：该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同，一个表中可以拥有多个非聚集索引。图2用的就是非聚集索引</p><p>最后再说一个联合索引，联合索引是指对表上的多个列进行索引。创建方式如下：</p></blockquote><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>t<span class="token punctuation">`</span> <span class="token punctuation">(</span> <span class="token punctuation">`</span><span class="token number">a</span><span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">`</span><span class="token number">b</span><span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span><span class="token number">a</span><span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_a_b<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span><span class="token number">a</span><span class="token punctuation">`</span><span class="token punctuation">,</span><span class="token punctuation">`</span><span class="token number">b</span><span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span><span class="token punctuation">;</span></code></pre><blockquote><p>联合索引也是一颗B+树，不同的是联合索引的键值的数量不是1，而是大于等于2，多个键值的B+树是如下存的</p></blockquote><p><img src="//zongmansheng.club/2019/07/12/mysql-suo-yin-wei-shi-me-yao-yong-b-shu-shi-xian/016.png" alt></p><blockquote><p>可以看到键值都是排序的，就上面的例子来说（1，1）（1，2）（2，1）（2，4）（3，1）（3，2），数据按照（a，b）的顺序进行了存放。</p><p>因此对于查询select <em> from table where a = xxx and b = xxx，显然是可以使用（a，b）这个联合索引的。对于单个的a列查询select </em> from table where a = xxx，也可以使用（a，b）这个索引。但对于b列的查询select * from table where b = xxx，则不可以使用这颗B+树索引。可以发现叶子节点上的b值为1，2，1，4，1，2，显然不是排序的，因此对于b列的查询使用不到（a，b）的索引</p></blockquote><h3 id="自适应哈希索引"><a href="#自适应哈希索引" class="headerlink" title="自适应哈希索引"></a>自适应哈希索引</h3><blockquote><p>InnoDB存储引擎会监控对表上各项索引页的查询。如果观察到建立哈希索引可以带来速度提升，则建立哈希索引，称之为自适应哈希索引，DBA不能对建立哈希索引的过程进行干预，只能启动或禁用自适应哈希索引</p><p>数据库一般采用除法散列的方法，即取k除以m的余数，将关键词k映射到m个槽的某一个去，即哈希函数为h(k) = k mod m，当发生冲突时，即两个关键字可能映射到同一个槽上，采用链接法，即以链表的形式保存冲突的关键字，和HashMap类似</p><p>当对热点数据建立了哈希索引以后，省去在B+树上进行查找，可以极大地提高服务的性能，自适应哈希索引对于字典类型的查找非常迅速，如select * from table where id = xxx，但是对于范围查找就无能无力了</p></blockquote><p><img src="//zongmansheng.club/2019/07/12/mysql-suo-yin-wei-shi-me-yao-yong-b-shu-shi-xian/017.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL索引为什么要用B-树实现&quot;&gt;&lt;a href=&quot;#MySQL索引为什么要用B-树实现&quot; class=&quot;headerlink&quot; title=&quot;MySQL索引为什么要用B+树实现&quot;&gt;&lt;/a&gt;MySQL索引为什么要用B+树实现&lt;/h1&gt;&lt;h3 id=&quot;一、前言&quot;
      
    
    </summary>
    
      <category term="数据库" scheme="http://zongmansheng.club/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySql，B+" scheme="http://zongmansheng.club/tags/MySql%EF%BC%8CB/"/>
    
  </entry>
  
  <entry>
    <title>面试题集锦</title>
    <link href="http://zongmansheng.club/2019/07/11/mian-shi-ti-ji-jin/"/>
    <id>http://zongmansheng.club/2019/07/11/mian-shi-ti-ji-jin/</id>
    <published>2019-07-11T00:06:04.000Z</published>
    <updated>2019-07-25T01:42:08.033Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面试必刷真题（持续更新中）"><a href="#面试必刷真题（持续更新中）" class="headerlink" title="面试必刷真题（持续更新中）"></a>面试必刷真题（持续更新中）</h1><h3 id="一、Java-基础"><a href="#一、Java-基础" class="headerlink" title="一、Java 基础"></a>一、Java 基础</h3><p><img src="//zongmansheng.club/2019/07/11/mian-shi-ti-ji-jin/001.png" alt></p><h4 id="1-JDK-和-JRE-有什么区别？"><a href="#1-JDK-和-JRE-有什么区别？" class="headerlink" title="1.JDK 和 JRE 有什么区别？"></a>1.JDK 和 JRE 有什么区别？</h4><blockquote><p>JDK是Java Development Kit，它是功能齐全的Java SDK。它拥有JRE所拥有的一切，还有编译器（javac）和工具（如javadoc和jdb）。它能够创建和编译程序。</p><p>JRE 是 Java运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java虚拟机（JVM），Java类库，java命令和其他的一些基础构件。但是，它不能用于创建新程序。</p><p>如果你只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。如果你需要进行一些 Java 编程方面的工作，那么你就需要安装JDK了。但是，这不是绝对的。有时，即使您不打算在计算机上进行任何Java开发，仍然需要安装JDK。例如，如果要使用JSP部署Web应用程序，那么从技术上讲，您只是在应用程序服务器中运行Java程序。那你为什么需要JDK呢？因为应用程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译 servlet。</p></blockquote><h4 id="2-和-equals-的区别是什么？"><a href="#2-和-equals-的区别是什么？" class="headerlink" title="2.== 和 equals 的区别是什么？"></a>2.== 和 equals 的区别是什么？</h4><blockquote><p><strong>==</strong> : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)</p><p><strong>equals()</strong> : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p><ul><li>情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。</li><li>情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。</li></ul></blockquote><blockquote><p>举个例子：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">test01</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"ab"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// a 为一个引用</span>        String b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"ab"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// b为另一个引用,对象的内容一样</span>        String aa <span class="token operator">=</span> <span class="token string">"ab"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 放在常量池中</span>        String bb <span class="token operator">=</span> <span class="token string">"ab"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 从常量池中查找</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>aa <span class="token operator">==</span> bb<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// true</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"aa==bb"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// false，非同一对象</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"a==b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// true</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"aEQb"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">42</span> <span class="token operator">==</span> <span class="token number">42.0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// true</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"true"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p><strong>说明：</strong></p><ul><li>String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。</li><li>当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。</li></ul></blockquote><h4 id="3-hashCode-相同，则-equals-也一定为-true，对吗？"><a href="#3-hashCode-相同，则-equals-也一定为-true，对吗？" class="headerlink" title="3. hashCode()相同，则 equals()也一定为 true，对吗？"></a>3. hashCode()相同，则 equals()也一定为 true，对吗？</h4><blockquote><ol><li>如果两个对象相等，则hashcode一定也是相同的</li><li>两个对象相等,对两个对象分别调用equals方法都返回true</li><li>两个对象有相同的hashcode值，它们也不一定是相等的</li><li><strong>因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</strong></li><li>hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li></ol></blockquote><h4 id="4-hashCode（）介绍"><a href="#4-hashCode（）介绍" class="headerlink" title="4.hashCode（）介绍"></a>4.hashCode（）介绍</h4><blockquote><p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数。</p><p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p></blockquote><h4 id="5-为什么要有-hashCode"><a href="#5-为什么要有-hashCode" class="headerlink" title="5.为什么要有 hashCode"></a>5.为什么要有 hashCode</h4><h5 id="我们以“HashSet-如何检查重复”为例子来说明为什么要有-hashCode："><a href="#我们以“HashSet-如何检查重复”为例子来说明为什么要有-hashCode：" class="headerlink" title="我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode："></a><strong>我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：</strong></h5><blockquote><p>当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals（）方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的Java启蒙书《Head first java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p></blockquote><h4 id="6-final-在-java-中有什么作用？"><a href="#6-final-在-java-中有什么作用？" class="headerlink" title="6.final 在 java 中有什么作用？"></a>6.final 在 java 中有什么作用？</h4><blockquote><p>final关键字主要用在三个地方：变量、方法、类。</p><ol><li>对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。</li><li>当用final修饰一个类时，表明这个类不能被继承。final类中的所有成员方法都会被隐式地指定为final方法。</li><li>使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的Java版本已经不需要使用final方法进行这些优化了）。类中所有的private方法都隐式地指定为final。</li></ol></blockquote><h4 id="7-java-中的-Math-round-1-5-等于多少？"><a href="#7-java-中的-Math-round-1-5-等于多少？" class="headerlink" title="7.java 中的 Math.round(-1.5) 等于多少？"></a>7.java 中的 Math.round(-1.5) 等于多少？</h4><blockquote><p>Math.round(1.5)的返回值是2，Math.round(-1.5)的返回值是-1。四舍五入的原理是在参数上加0.5然后做向下取整。</p></blockquote><h4 id="8-String-属于基础的数据类型吗？"><a href="#8-String-属于基础的数据类型吗？" class="headerlink" title="8.String 属于基础的数据类型吗？"></a>8.String 属于基础的数据类型吗？</h4><blockquote><p>String不是基本的数据类型，是final修饰的java类，java中的基本类型一共有8个，它们分别为：</p><p>1 字符类型：byte，char</p><p>2 基本整型：short，int，long</p><p>3 浮点型：float，double</p><p>4 布尔类型：boolean</p></blockquote><h4 id="9-java-中操作字符串都有哪些类？它们之间有什么区别？"><a href="#9-java-中操作字符串都有哪些类？它们之间有什么区别？" class="headerlink" title="9.java 中操作字符串都有哪些类？它们之间有什么区别？"></a>9.java 中操作字符串都有哪些类？它们之间有什么区别？</h4><blockquote><p>String、StringBuffer、StringBuilder</p><p>String : final修饰，String类的方法都是返回new String。即对String对象的任何改变都不影响到原对象，对字符串的修改操作都会生成新的对象。<br>StringBuffer : 对字符串的操作的方法都加了synchronized，保证线程安全。</p><p>StringBuilder : 不保证线程安全，在方法体内需要进行字符串的修改操作，可以new StringBuilder对象，调用StringBuilder对象的append、replace、delete等方法修改字符串。</p></blockquote><h4 id="10-Java中String直接赋字符串和new-String的区别-如String-str-new-String-“a”-和String-str-“a”有什么区别"><a href="#10-Java中String直接赋字符串和new-String的区别-如String-str-new-String-“a”-和String-str-“a”有什么区别" class="headerlink" title="10.Java中String直接赋字符串和new String的区别 如String str=new String(“a”)和String str = “a”有什么区别?"></a>10.Java中String直接赋字符串和new String的区别 如String str=new String(“a”)和String str = “a”有什么区别?</h4><blockquote><p>String A=”ABC”;</p><p>String B=new String(“ABC”);</p><p>这两个值，A,B 是否相等，如果都往HashSet里面放，能放下吗？</p><p>答：(a)A==B 的判断为false;</p><p>​         (b)A.equals(B)为true ；因为值相等，所以都往HashSet里面放不下，只能放一个 </p><h3 id="问题：-与equals-的区别："><a href="#问题：-与equals-的区别：" class="headerlink" title="问题：==与equals()的区别："></a>问题：==与equals()的区别：</h3><ol><li>==:比较引用类型比较的是地址值是否相同</li><li>equals:比较引用类型默认也是比较地址值是否相同，注意:<strong>String类重写了equals()方法</strong>，比较的是内容是否相同。</li></ol><p><strong>String A = “ABC”;内存会去查找永久代(常量池) ，如果没有的话，在永久代中中开辟一块儿内存空间，把地址赋给栈指针，如果已经有了”ABC”的内存，直接把地址赋给栈指针；</strong></p><p><strong>因此</strong></p><p><strong>String str1=”aa”;</strong></p><p><strong>Srting str2=”aa”;</strong></p><p><strong>String Str3=”aa”;</strong></p><p><strong>….</strong></p><p><strong>这样下去，str1==Str2==str3;会一直相等下去，(a) ==的判断， (b) equals()的判断；都相等，因为他们的地址都相等，因此只在常量池中有一份内存空间，地址全部相同；</strong> </p><p> <strong>而String str = new String(“a”);是根据”a”这个String对象再次构造一个String对象;在堆中从新new一块儿内存，把指针赋给栈，</strong></p><p><strong>将新构造出来的String对象的引用赋给str。 因此 只要是new String()，则，栈中的地址都是指向最新的new出来的堆中的地址，</strong></p><p><strong>(a)“”==“” 是判断地址的，当然不相同；</strong></p><p><strong>(b)至于equals,String类型重写了 equals()方法，判断值是否相等，明显相等，因此 equals 是相等的；</strong></p><p>这是String 重写的equals:</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token operator">*</span> <span class="token annotation punctuation">@see</span>  #<span class="token function">compareTo</span><span class="token punctuation">(</span>String<span class="token punctuation">)</span>     <span class="token operator">*</span> <span class="token annotation punctuation">@see</span>  #<span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span>String<span class="token punctuation">)</span>     <span class="token operator">*</span><span class="token operator">/</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>Object anObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> anObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>anObject <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            String anotherString <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span> anObject<span class="token punctuation">;</span>            <span class="token keyword">int</span> n <span class="token operator">=</span> value<span class="token punctuation">.</span>length<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> anotherString<span class="token punctuation">.</span>value<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">char</span> v1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>                <span class="token keyword">char</span> v2<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> anotherString<span class="token punctuation">.</span>value<span class="token punctuation">;</span>                <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token operator">--</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>v1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> v2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    i<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StringDemo2</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String s2 <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// false</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// true</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">*</span><span class="token operator">*</span>运行结果：<span class="token operator">*</span><span class="token operator">*</span><span class="token operator">></span> <span class="token boolean">false</span> <span class="token operator">></span> <span class="token boolean">true</span></code></pre><p><strong>代码详解</strong></p><blockquote><ol><li>首先，通过main（）方法进栈。</li><li>然后再栈中定义一个对象s1,去堆中开辟一个内存空间，将内存空间的引用赋值给s1，“hello”是常量，然后去字符串常量池 查看是否有hello字符串对象，没有的话分配一个空间存放hello，并且将其空间地址存入堆中new出来的空间中。</li><li>在栈中定义一个对象s2，然后去字符串常量池中查看是否有”hello”字符串对象，有，直接把”hello”的地址赋值给s2.</li><li>即s1中存的是堆中分配的空间，堆中分配的空间中存的是字符串常量池中分配空间存放”hello”的空间的地址值。而s2中之间存的是字符串常量池中分配空间存放”hello”的空间的地址值。</li><li>由于s1与s2中存放的地址不同，所以输出false。因为，类String重写了equals()方法，它比较的是引用类型的 的值是否相等，所以输出true。即结果为false、true。</li></ol></blockquote><p><img src="//zongmansheng.club/2019/07/11/mian-shi-ti-ji-jin/020.png" alt></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StringDemo1</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String s2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// false</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// true</span>        String s3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String s4 <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s3 <span class="token operator">==</span> s4<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// false</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s3<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>s4<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// true</span>        String s5 <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>        String s6 <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s5 <span class="token operator">==</span> s6<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// true</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s5<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>s6<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// true</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>s1~s6用equals()的比较不解释，都是比较的值，均为true。以下讲解==</p><ol><li>s1、s2：二者均为new出来的，各自在堆中分配有空间，并各自将内存地址赋值给s1、s2。空间地址不同，==比较为false。但是各自在堆中空间中保存的值均为在字符串常量池中的同一个对象的地址。根据Demo处的图即解释不难理解。</li><li>s3、s4同上Demo出解释。</li><li>s5、s6都是在常量池中取值，二者都指向常量池中同一对象，其地址值相同，所以结果为true。</li></ol></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StringDemo4</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String s1 <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>        String s2 <span class="token operator">=</span> <span class="token string">"world"</span><span class="token punctuation">;</span>        String s3 <span class="token operator">=</span> <span class="token string">"helloworld"</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s3 <span class="token operator">==</span> s1 <span class="token operator">+</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// false</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s3<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s1 <span class="token operator">+</span> s2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// true</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s3 <span class="token operator">==</span> <span class="token string">"hello"</span> <span class="token operator">+</span> <span class="token string">"world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//false</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s3<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"hello"</span> <span class="token operator">+</span> <span class="token string">"world"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// true</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="Demo2详解"><a href="#Demo2详解" class="headerlink" title="Demo2详解"></a>Demo2详解</h5><blockquote><p>equals()比较方法不解释，比较值，均相等，均为true。</p><ol><li>s1与s2相加是先在字符串常量池中开一个空间，然后拼接，这个空间的地址就是s1与s2拼接后的地址。与s3的地址不同，所以输出为false。</li><li>s3与”hello”+”world”作比较，”hello”+”world”先拼接成”helloworld”,然后再去字符串常量池中找是否有”helloworld”,有，所以和s3共用一个字符串对象，则为true。</li></ol></blockquote><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li><blockquote><ol><li>String s = new String(“hello”)会创建2（1）个对象，String s = “hello”创建1（0）个对象。<br>注：当字符串常量池中有对象hello时括号内成立！</li><li>字符串如果是变量相加，先开空间，在拼接。</li><li>字符串如果是常量相加，是先加，然后在常量池找，如果有就直接返回，否则，就创建。</li></ol></blockquote></li></ol><h4 id="11、如何将字符串反转？"><a href="#11、如何将字符串反转？" class="headerlink" title="11、如何将字符串反转？"></a>11、如何将字符串反转？</h4><h4 id="12、String-类的常用方法都有那些？"><a href="#12、String-类的常用方法都有那些？" class="headerlink" title="12、String 类的常用方法都有那些？"></a>12、String 类的常用方法都有那些？</h4><h4 id="13、抽象类必须要有抽象方法吗？"><a href="#13、抽象类必须要有抽象方法吗？" class="headerlink" title="13、抽象类必须要有抽象方法吗？"></a>13、抽象类必须要有抽象方法吗？</h4><h4 id="14、普通类和抽象类有哪些区别？"><a href="#14、普通类和抽象类有哪些区别？" class="headerlink" title="14、普通类和抽象类有哪些区别？"></a>14、普通类和抽象类有哪些区别？</h4><h4 id="15、抽象类能使用-final-修饰吗？"><a href="#15、抽象类能使用-final-修饰吗？" class="headerlink" title="15、抽象类能使用 final 修饰吗？"></a>15、抽象类能使用 final 修饰吗？</h4><h4 id="16、接口和抽象类有什么区别？"><a href="#16、接口和抽象类有什么区别？" class="headerlink" title="16、接口和抽象类有什么区别？"></a>16、接口和抽象类有什么区别？</h4><h4 id="17、java-中-IO-流分为几种？"><a href="#17、java-中-IO-流分为几种？" class="headerlink" title="17、java 中 IO 流分为几种？"></a>17、java 中 IO 流分为几种？</h4><h4 id="18、BIO、NIO、AIO-有什么区别？"><a href="#18、BIO、NIO、AIO-有什么区别？" class="headerlink" title="18、BIO、NIO、AIO 有什么区别？"></a>18、BIO、NIO、AIO 有什么区别？</h4><h4 id="19、Files的常用方法都有哪些？"><a href="#19、Files的常用方法都有哪些？" class="headerlink" title="19、Files的常用方法都有哪些？"></a>19、Files的常用方法都有哪些？</h4><h4 id="20、Arraylist-与-LinkedList-异同"><a href="#20、Arraylist-与-LinkedList-异同" class="headerlink" title="20、Arraylist 与 LinkedList 异同"></a>20、Arraylist 与 LinkedList 异同</h4><blockquote><ul><li><ol><li>是否保证线程安全：** ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；</li></ol></li><li><strong>2. 底层数据结构：</strong> Arraylist 底层使用的是Object数组；LinkedList 底层使用的是双向链表数据结构（JDK1.6之前为循环链表，JDK1.7取消了循环。注意双向链表和双向循环链表的区别：）； 详细可阅读<a href="https://www.cnblogs.com/xingele0917/p/3696593.html" target="_blank" rel="noopener">JDK1.7-LinkedList循环链表优化</a></li><li><strong>3. 插入和删除是否受元素位置的影响：</strong> ① <strong>ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。</strong> 比如：执行<code>add(E e)</code>方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。 ② <strong>LinkedList 采用链表存储，所以插入，删除元素时间复杂度不受元素位置的影响，都是近似 O（1）而数组为近似 O（n）。</strong></li><li><strong>4. 是否支持快速随机访问：</strong> LinkedList 不支持高效的随机元素访问，而 ArrayList 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</li><li><strong>5. 内存空间占用：</strong> ArrayList的空 间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）。 </li><li>补充内容:RandomAccess接口**</li></ul></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">RandomAccess</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><blockquote><p>查看源码我们发现实际上 RandomAccess 接口中什么都没有定义。所以，在我看来 RandomAccess 接口不过是一个标识罢了。标识什么？ 标识实现这个接口的类具有随机访问功能。</p><p>在binarySearch（）方法中，它要判断传入的list 是否RamdomAccess的实例，如果是，调用indexedBinarySearch（）方法，如果不是，那么调用iteratorBinarySearch（）方法</p></blockquote><pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span>    <span class="token keyword">int</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> T<span class="token operator">>></span> list<span class="token punctuation">,</span> T key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>list <span class="token keyword">instanceof</span> <span class="token class-name">RandomAccess</span> <span class="token operator">||</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>BINARYSEARCH_THRESHOLD<span class="token punctuation">)</span>            <span class="token keyword">return</span> Collections<span class="token punctuation">.</span><span class="token function">indexedBinarySearch</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token keyword">return</span> Collections<span class="token punctuation">.</span><span class="token function">iteratorBinarySearch</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><blockquote><p>ArraysList 实现了 RandomAccess 接口， 而 LinkedList 没有实现。为什么呢？我觉得还是和底层数据结构有关！ArraysList 底层是数组，而 LinkedList 底层是链表。数组天然支持随机访问，时间复杂度为 O（1），所以称为快速随机访问。链表需要遍历到特定位置才能访问特定位置的元素，时间复杂度为 O（n），所以不支持快速随机访问。，ArraysList 实现了 RandomAccess 接口，就表明了他具有快速随机访问功能。 RandomAccess 接口只是标识，并不是说 ArraysList 实现 RandomAccess 接口才具有快速随机访问功能的！</p><p><strong>下面再总结一下 list 的遍历方式选择：</strong></p><ul><li>实现了RandomAccess接口的list，优先选择普通for循环 ，其次foreach,</li><li>未实现RandomAccess接口的ist， 优先选择iterator遍历（foreach遍历底层也是通过iterator实现的），大size的数据，千万不要使用普通for循环</li></ul><h3 id="补充：数据结构基础之双向链表"><a href="#补充：数据结构基础之双向链表" class="headerlink" title="补充：数据结构基础之双向链表"></a>补充：数据结构基础之双向链表</h3><p>双向链表也叫双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。一般我们都构造双向循环链表，如下图所示，同时下图也是LinkedList 底层使用的是双向循环链表数据结构。</p></blockquote><h3 id="二、容器"><a href="#二、容器" class="headerlink" title="二、容器"></a>二、容器</h3><p><img src="//zongmansheng.club/2019/07/11/mian-shi-ti-ji-jin/002.png" alt></p><ol><li>java 容器都有哪些？</li><li>Collection 和 Collections 有什么区别？</li><li>List、Set、Map 之间的区别是什么？</li><li>HashMap 和 Hashtable 有什么区别？</li><li>如何决定使用 HashMap 还是 TreeMap？</li><li>说一下 HashMap 的实现原理？</li><li>说一下 HashSet 的实现原理？</li><li>ArrayList 和 LinkedList 的区别是什么？</li><li>如何实现数组和 List 之间的转换？</li><li>ArrayList 和 Vector 的区别是什么？</li><li>Array 和 ArrayList 有何区别？</li><li>在 Queue 中 poll()和 remove()有什么区别？</li><li>哪些集合类是线程安全的？</li><li>迭代器 Iterator 是什么？</li><li>Iterator 怎么使用？有什么特点？</li><li>Iterator 和 ListIterator 有什么区别？</li><li>怎么确保一个集合不能被修改？</li></ol><h3 id="三、多线程"><a href="#三、多线程" class="headerlink" title="三、多线程"></a>三、多线程</h3><p><img src="//zongmansheng.club/2019/07/11/mian-shi-ti-ji-jin/003.png" alt></p><ol><li>并行和并发有什么区别？</li><li>线程和进程的区别？</li><li>守护线程是什么？</li><li>创建线程有哪几种方式？</li><li>说一下 runnable 和 callable 有什么区别？</li><li>线程有哪些状态？</li><li>sleep() 和 wait() 有什么区别？</li><li>notify()和 notifyAll()有什么区别？</li><li>线程的 run()和 start()有什么区别？</li><li>创建线程池有哪几种方式？</li><li>线程池都有哪些状态？</li><li>线程池中 submit()和 execute()方法有什么区别？</li><li>在 java 程序中怎么保证多线程的运行安全？</li><li>多线程锁的升级原理是什么？</li><li>什么是死锁？</li><li>怎么防止死锁？</li><li>ThreadLocal 是什么？有哪些使用场景？</li><li>说一下 synchronized 底层实现原理？</li><li>synchronized 和 volatile 的区别是什么？</li><li>synchronized 和 Lock 有什么区别？</li><li>synchronized 和 ReentrantLock 区别是什么？</li><li>说一下 atomic 的原理？</li></ol><h3 id="四、反射"><a href="#四、反射" class="headerlink" title="四、反射"></a>四、反射</h3><p><img src="//zongmansheng.club/2019/07/11/mian-shi-ti-ji-jin/004.png" alt></p><ol><li>什么是反射？</li><li>什么是 java 序列化？什么情况下需要序列化？</li><li>动态代理是什么？有哪些应用？</li><li>怎么实现动态代理？</li></ol><h3 id="五、对象拷贝"><a href="#五、对象拷贝" class="headerlink" title="五、对象拷贝"></a>五、对象拷贝</h3><p><img src="//zongmansheng.club/2019/07/11/mian-shi-ti-ji-jin/005.png" alt></p><ol><li>为什么要使用克隆？</li><li>如何实现对象克隆？</li><li>深拷贝和浅拷贝区别是什么？</li></ol><h3 id="六、Java-Web"><a href="#六、Java-Web" class="headerlink" title="六、Java Web"></a>六、Java Web</h3><p><img src="//zongmansheng.club/2019/07/11/mian-shi-ti-ji-jin/006.png" alt></p><ol><li>jsp 和 servlet 有什么区别？</li><li>jsp 有哪些内置对象？作用分别是什么？</li><li>说一下 jsp 的 4 种作用域？</li><li>session 和 cookie 有什么区别？</li><li>说一下 session 的工作原理？</li><li>如果客户端禁止 cookie 能实现 session 还能用吗？</li><li>spring mvc 和 struts 的区别是什么？</li><li>如何避免 sql 注入？</li><li>什么是 XSS 攻击，如何避免？</li><li>什么是 CSRF 攻击，如何避免？</li></ol><h3 id="七、异常"><a href="#七、异常" class="headerlink" title="七、异常"></a>七、异常</h3><p><img src="//zongmansheng.club/2019/07/11/mian-shi-ti-ji-jin/007.png" alt></p><ol><li>throw 和 throws 的区别？</li><li>final、finally、finalize 有什么区别？</li><li>try-catch-finally 中哪个部分可以省略？</li><li>try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</li><li>常见的异常类有哪些？</li></ol><h3 id="八、网络"><a href="#八、网络" class="headerlink" title="八、网络"></a>八、网络</h3><p><img src="//zongmansheng.club/2019/07/11/mian-shi-ti-ji-jin/008.png" alt></p><ol><li>http 响应码 301 和 302 代表的是什么？有什么区别？</li><li>forward 和 redirect 的区别？</li><li>简述 tcp 和 udp的区别？</li><li>tcp 为什么要三次握手，两次不行吗？为什么？</li><li>说一下 tcp 粘包是怎么产生的？</li><li>OSI 的七层模型都有哪些？</li><li>get 和 post 请求有哪些区别？</li><li>如何实现跨域？</li><li>说一下 JSONP 实现原理？</li></ol><h3 id="九、设计模式"><a href="#九、设计模式" class="headerlink" title="九、设计模式"></a>九、设计模式</h3><p><img src="//zongmansheng.club/2019/07/11/mian-shi-ti-ji-jin/009.png" alt></p><ol><li>说一下你熟悉的设计模式？</li></ol><ul><li>简单工厂和抽象工厂有什么区别？</li></ul><h3 id="十、Spring-Spring-MVC"><a href="#十、Spring-Spring-MVC" class="headerlink" title="十、Spring/Spring MVC"></a>十、Spring/Spring MVC</h3><p><img src="//zongmansheng.club/2019/07/11/mian-shi-ti-ji-jin/010.png" alt></p><ol><li>为什么要使用 spring？</li><li>解释一下什么是 aop？</li><li>解释一下什么是 ioc？</li><li>spring 有哪些主要模块？</li><li>spring 常用的注入方式有哪些？</li><li>spring 中的 bean 是线程安全的吗？</li><li>spring 支持几种 bean 的作用域？</li><li>spring 自动装配 bean 有哪些方式？</li><li>spring 事务实现方式有哪些？</li><li>说一下 spring 的事务隔离？</li><li>说一下 spring mvc 运行流程？</li><li>spring mvc 有哪些组件？</li><li>@RequestMapping 的作用是什么？</li><li>@Autowired 的作用是什么？</li></ol><h3 id="十一、Spring-Boot-Spring-Cloud"><a href="#十一、Spring-Boot-Spring-Cloud" class="headerlink" title="十一、Spring Boot/Spring Cloud"></a>十一、Spring Boot/Spring Cloud</h3><p><img src="//zongmansheng.club/2019/07/11/mian-shi-ti-ji-jin/011.png" alt></p><ol><li>什么是 spring boot？</li><li>为什么要用 spring boot？</li><li>spring boot 核心配置文件是什么？</li><li>spring boot 配置文件有哪几种类型？它们有什么区别？</li><li>spring boot 有哪些方式可以实现热部署？</li><li>jpa 和 hibernate 有什么区别？</li><li>什么是 spring cloud？</li><li>spring cloud 断路器的作用是什么？</li><li>spring cloud 的核心组件有哪些？</li></ol><h3 id="十二、Hibernate"><a href="#十二、Hibernate" class="headerlink" title="十二、Hibernate"></a>十二、Hibernate</h3><p><img src="//zongmansheng.club/2019/07/11/mian-shi-ti-ji-jin/012.png" alt></p><ol><li>为什么要使用 hibernate？</li><li>什么是 ORM 框架？</li><li>hibernate 中如何在控制台查看打印的 sql 语句？</li><li>hibernate 有几种查询方式？</li><li>hibernate 实体类可以被定义为 final 吗？</li><li>在 hibernate 中使用 Integer 和 int 做映射有什么区别？</li><li>hibernate 是如何工作的？</li><li>get()和 load()的区别？</li><li>说一下 hibernate 的缓存机制？</li><li>hibernate 对象有哪些状态？</li><li>在 hibernate 中 getCurrentSession 和 openSession 的区别是什么？</li><li>hibernate 实体类必须要有无参构造函数吗？为什么？</li></ol><h3 id="十三、Mybatis"><a href="#十三、Mybatis" class="headerlink" title="十三、Mybatis"></a>十三、Mybatis</h3><p><img src="//zongmansheng.club/2019/07/11/mian-shi-ti-ji-jin/013.png" alt></p><ol><li>mybatis 中 #{}和 ${}的区别是什么？</li><li>mybatis 有几种分页方式？</li><li>RowBounds 是一次性查询全部结果吗？为什么？</li><li>mybatis 逻辑分页和物理分页的区别是什么？</li><li>mybatis 是否支持延迟加载？延迟加载的原理是什么？</li><li>说一下 mybatis 的一级缓存和二级缓存？</li><li>mybatis 和 hibernate 的区别有哪些？</li><li>mybatis 有哪些执行器（Executor）？</li><li>mybatis 分页插件的实现原理是什么？</li><li>mybatis 如何编写一个自定义插件？</li></ol><h4 id="十四、RabbitMQ"><a href="#十四、RabbitMQ" class="headerlink" title="十四、RabbitMQ"></a>十四、RabbitMQ</h4><p><img src="//zongmansheng.club/2019/07/11/mian-shi-ti-ji-jin/014.png" alt></p><ol><li>rabbitmq 的使用场景有哪些？</li><li>rabbitmq 有哪些重要的角色？</li><li>rabbitmq 有哪些重要的组件？</li><li>rabbitmq 中 vhost 的作用是什么？</li><li>rabbitmq 的消息是怎么发送的？</li><li>rabbitmq 怎么保证消息的稳定性？</li><li>rabbitmq 怎么避免消息丢失？</li><li>要保证消息持久化成功的条件有哪些？</li><li>rabbitmq 持久化有什么缺点？</li><li>rabbitmq 有几种广播类型？</li><li>rabbitmq 怎么实现延迟消息队列？</li><li>rabbitmq 集群有什么用？</li><li>rabbitmq 节点的类型有哪些？</li><li>rabbitmq 集群搭建需要注意哪些问题？</li><li>rabbitmq 每个节点是其他节点的完整拷贝吗？为什么？</li><li>rabbitmq 集群中唯一一个磁盘节点崩溃了会发生什么情况？</li><li>rabbitmq 对集群节点停止顺序有要求吗？</li></ol><h3 id="十五、Kafka"><a href="#十五、Kafka" class="headerlink" title="十五、Kafka"></a>十五、Kafka</h3><p><img src="//zongmansheng.club/2019/07/11/mian-shi-ti-ji-jin/015.png" alt></p><ol><li>kafka 可以脱离 zookeeper 单独使用吗？为什么？</li><li>kafka 有几种数据保留的策略？</li><li>kafka 同时设置了 7 天和 10G 清除数据，到第五天的时候消息达到了 10G，这个时候 kafka 将如何处理？</li><li>什么情况会导致 kafka 运行变慢？</li><li>使用 kafka 集群需要注意什么？</li></ol><h3 id="十六、Zookeeper"><a href="#十六、Zookeeper" class="headerlink" title="十六、Zookeeper"></a>十六、Zookeeper</h3><p><img src="//zongmansheng.club/2019/07/11/mian-shi-ti-ji-jin/016.png" alt></p><ol><li>zookeeper 是什么？</li><li>zookeeper 都有哪些功能？</li><li>zookeeper 有几种部署模式？</li><li>zookeeper 怎么保证主从节点的状态同步？</li><li>集群中为什么要有主节点？</li><li>集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？</li><li>说一下 zookeeper 的通知机制？</li></ol><h3 id="十七、MySql"><a href="#十七、MySql" class="headerlink" title="十七、MySql"></a>十七、MySql</h3><p><img src="//zongmansheng.club/2019/07/11/mian-shi-ti-ji-jin/017.png" alt></p><ol><li>数据库的三范式是什么？</li><li>一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 mysql 数据库，又插入了一条数据，此时 id 是几？</li><li>如何获取当前数据库版本？</li><li>说一下 ACID 是什么？</li><li>char 和 varchar 的区别是什么？</li><li>float 和 double 的区别是什么？</li><li>mysql 的内连接、左连接、右连接有什么区别？</li><li>mysql 索引是怎么实现的？</li><li>怎么验证 mysql 的索引是否满足需求？</li><li>说一下数据库的事务隔离？</li><li>说一下 mysql 常用的引擎？</li><li>说一下 mysql 的行锁和表锁？</li><li>说一下乐观锁和悲观锁？</li><li>mysql 问题排查都有哪些手段？</li><li>如何做 mysql 的性能优化？</li></ol><h3 id="十八、Redis"><a href="#十八、Redis" class="headerlink" title="十八、Redis"></a>十八、Redis</h3><p><img src="//zongmansheng.club/2019/07/11/mian-shi-ti-ji-jin/018.png" alt></p><ol><li><h4 id="redis-是什么？都有哪些使用场景？"><a href="#redis-是什么？都有哪些使用场景？" class="headerlink" title="redis 是什么？都有哪些使用场景？"></a>redis 是什么？都有哪些使用场景？</h4><blockquote><p>Redis 的全称是：Remote Dictionary.Server，本质上是一个 Key-Value 类型的内存数据库，很像memcached，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据 flush 到硬盘上进行保存。因为是纯内存操作，Redis 的性能非常出色，每秒可以处理超过 10 万次读写操作，是已知性能最快的Key-Value DB。</p><p>Redis 的出色之处不仅仅是性能，Redis 最大的魅力是支持保存多种数据结构，此外单个 value 的最大限制是 1GB，不像 memcached 只能保存 1MB 的数据，因此 Redis 可以用来实现很多有用的功能。</p><p>比方说用他的 List 来做 FIFO 双向链表，实现一个轻量级的高性 能消息队列服务，用他的 Set 可以做高性能的 tag 系统等等。</p><p>另外 Redis 也可以对存入的 Key-Value 设置 expire 时间，因此也可以被当作一 个功能加强版的memcached 来用。 Redis 的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此 Redis 适合的场景主要局限在较小数据量的高性能操作和运算上。</p></blockquote><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><h5 id="（1）会话缓存（Session-Cache）"><a href="#（1）会话缓存（Session-Cache）" class="headerlink" title="（1）会话缓存（Session Cache）"></a>（1）会话缓存（Session Cache）</h5><blockquote><p>最常用的一种使用 Redis 的情景是会话缓存（sessioncache），用 Redis 缓存会话比其他存储（如Memcached）的优势在于：Redis 提供持久化。当维护一个不是严格要求一致性的缓存时，如果用户的购物车信息全部丢失，大部分人都会不高兴的，现在，他们还会这样吗？</p><p>幸运的是，随着 Redis 这些年的改进，很容易找到怎么恰当的使用 Redis 来缓存会话的文档。甚至广为人知的商业平台 Magento 也提供 Redis 的插件。</p></blockquote><h5 id="2）全页缓存（FPC）"><a href="#2）全页缓存（FPC）" class="headerlink" title="(2）全页缓存（FPC）"></a>(2）全页缓存（FPC）</h5><blockquote><p>除基本的会话 token 之外，Redis 还提供很简便的 FPC 平台。回到一致性问题，即使重启了 Redis 实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似 PHP 本地FPC。</p><p>再次以 Magento 为例，Magento 提供一个插件来使用 Redis 作为全页缓存后端。</p><p>此外，对 WordPress 的用户来说，Pantheon 有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。</p></blockquote><h5 id="（3）队列"><a href="#（3）队列" class="headerlink" title="（3）队列"></a>（3）队列</h5><blockquote><p>Reids 在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得 Redis 能作为一个很好的消息队列平台来使用。Redis 作为队列使用的操作，就类似于本地程序语言（如 Python）对 list 的 push/pop操作。</p><p>如果你快速的在 Google 中搜索“Redis queues”，你马上就能找到大量的开源项目，这些项目的目的就是利用 Redis 创建非常好的后端工具，以满足各种队列需求。例如，Celery 有一个后台就是使用Redis 作为 broker，你可以从这里去查看。</p></blockquote><h5 id="4）排行榜-计数器"><a href="#4）排行榜-计数器" class="headerlink" title="(4）排行榜/计数器"></a>(4）排行榜/计数器</h5><blockquote><p>Redis 在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（SortedSet）也使得我们在执行这些操作的时候变的非常简单，Redis 只是正好提供了这两种数据结构。</p><p>所以，我们要从排序集合中获取到排名最靠前的 10 个用户–我们称之为“user_scores”，我们只需要像下面一样执行即可：</p><p>当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你需要这样执行：</p><p>ZRANGE user_scores 0 10 WITHSCORESAgora Games 就是一个很好的例子，用 Ruby 实现的，它的排行榜就是使用 Redis 来存储数据的，你可以在这里看到。</p></blockquote><h5 id="（5）发布-订阅"><a href="#（5）发布-订阅" class="headerlink" title="（5）发布/订阅"></a>（5）发布/订阅</h5><blockquote><p>Redis 的发布/订阅功能。发布/订阅的使用场景确实非常多。我已看见人们在社交网络连接中使用，还可作为基于发布/订阅的脚本触发器，甚至用 Redis 的发布/订阅功能来建立聊天系统！</p></blockquote></li><li><h4 id="redis-有哪些功能？"><a href="#redis-有哪些功能？" class="headerlink" title="redis 有哪些功能？"></a>redis 有哪些功能？</h4></li><li><h4 id="redis-和-memecache-有什么区别？"><a href="#redis-和-memecache-有什么区别？" class="headerlink" title="redis 和 memecache 有什么区别？"></a>redis 和 memecache 有什么区别？</h4><blockquote><ul><li>memcached 所有的值均是简单的字符串，redis 作为其替代者，支持更为丰富的数据类型</li><li>redis 的速度比 memcached 快很多 redis 的速度比 memcached 快很多</li><li>redis 可以持久化其数据 redis 可以持久化其数据</li></ul></blockquote></li><li><h4 id="redis-为什么是单线程的？"><a href="#redis-为什么是单线程的？" class="headerlink" title="redis 为什么是单线程的？"></a>redis 为什么是单线程的？</h4></li><li><h4 id="什么是缓存穿透？怎么解决？"><a href="#什么是缓存穿透？怎么解决？" class="headerlink" title="什么是缓存穿透？怎么解决？"></a>什么是缓存穿透？怎么解决？</h4></li><li><h4 id="redis-支持的数据类型有哪些？"><a href="#redis-支持的数据类型有哪些？" class="headerlink" title="redis 支持的数据类型有哪些？"></a>redis 支持的数据类型有哪些？</h4><blockquote><p>String、List、Set、Sorted Set、hashes</p></blockquote></li><li><h4 id="redis-支持的-java-客户端都有哪些？"><a href="#redis-支持的-java-客户端都有哪些？" class="headerlink" title="redis 支持的 java 客户端都有哪些？"></a>redis 支持的 java 客户端都有哪些？</h4><blockquote><p>Redisson、Jedis、lettuce 等等，官方推荐使用 Redisson。</p></blockquote></li><li><h4 id="jedis-和-redisson-有哪些区别？"><a href="#jedis-和-redisson-有哪些区别？" class="headerlink" title="jedis 和 redisson 有哪些区别？"></a>jedis 和 redisson 有哪些区别？</h4><blockquote><p>Jedis 是 Redis 的 Java 实现的客户端，其 API 提供了比较全面的 Redis 命令的支持；</p><p>Redisson 实现了分布式和可扩展的 Java 数据结构，和 Jedis 相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等 Redis 特性。Redisson 的宗旨是促进使用者对 Redis 的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</p></blockquote></li><li><h4 id="怎么保证缓存和数据库数据的一致性？"><a href="#怎么保证缓存和数据库数据的一致性？" class="headerlink" title="怎么保证缓存和数据库数据的一致性？"></a>怎么保证缓存和数据库数据的一致性？</h4></li><li><h4 id="redis-持久化有几种方式？"><a href="#redis-持久化有几种方式？" class="headerlink" title="redis 持久化有几种方式？"></a>redis 持久化有几种方式？</h4></li><li><h4 id="redis-怎么实现分布式锁？"><a href="#redis-怎么实现分布式锁？" class="headerlink" title="redis 怎么实现分布式锁？"></a>redis 怎么实现分布式锁？</h4></li><li><h4 id="redis-分布式锁有什么缺陷？"><a href="#redis-分布式锁有什么缺陷？" class="headerlink" title="redis 分布式锁有什么缺陷？"></a>redis 分布式锁有什么缺陷？</h4></li><li><h4 id="redis-如何做内存优化？"><a href="#redis-如何做内存优化？" class="headerlink" title="redis 如何做内存优化？"></a>redis 如何做内存优化？</h4></li><li><h4 id="redis-淘汰策略有哪些？"><a href="#redis-淘汰策略有哪些？" class="headerlink" title="redis 淘汰策略有哪些？"></a>redis 淘汰策略有哪些？</h4></li><li><h4 id="redis-常见的性能问题有哪些？该如何解决？"><a href="#redis-常见的性能问题有哪些？该如何解决？" class="headerlink" title="redis 常见的性能问题有哪些？该如何解决？"></a>redis 常见的性能问题有哪些？该如何解决？</h4></li></ol><h3 id="十九、JVM"><a href="#十九、JVM" class="headerlink" title="十九、JVM"></a>十九、JVM</h3><p><img src="//zongmansheng.club/2019/07/11/mian-shi-ti-ji-jin/019.png" alt></p><ol><li>说一下 jvm 的主要组成部分？及其作用？</li><li>说一下 jvm 运行时数据区？</li><li>说一下堆栈的区别？</li><li>队列和栈是什么？有什么区别？</li><li>什么是双亲委派模型？</li><li>说一下类加载的执行过程？</li><li>怎么判断对象是否可以被回收？</li><li>java 中都有哪些引用类型？</li><li>说一下 jvm 有哪些垃圾回收算法？</li><li>说一下 jvm 有哪些垃圾回收器？</li><li>详细介绍一下 CMS 垃圾回收器？</li><li>新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？</li><li>简述分代垃圾回收器是怎么工作的？</li><li>说一下 jvm 调优的工具？</li><li>常用的 jvm 调优的参数都有哪些？</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;面试必刷真题（持续更新中）&quot;&gt;&lt;a href=&quot;#面试必刷真题（持续更新中）&quot; class=&quot;headerlink&quot; title=&quot;面试必刷真题（持续更新中）&quot;&gt;&lt;/a&gt;面试必刷真题（持续更新中）&lt;/h1&gt;&lt;h3 id=&quot;一、Java-基础&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
      <category term="面试" scheme="http://zongmansheng.club/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="容器，多线程，反射，对象拷贝" scheme="http://zongmansheng.club/tags/%E5%AE%B9%E5%99%A8%EF%BC%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%8F%8D%E5%B0%84%EF%BC%8C%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D/"/>
    
  </entry>
  
  <entry>
    <title>Mac下安装Nginx</title>
    <link href="http://zongmansheng.club/2019/07/10/mac-xia-an-zhuang-nginx/"/>
    <id>http://zongmansheng.club/2019/07/10/mac-xia-an-zhuang-nginx/</id>
    <published>2019-07-10T06:59:05.000Z</published>
    <updated>2019-07-15T06:32:26.478Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mac下安装Nginx"><a href="#Mac下安装Nginx" class="headerlink" title="Mac下安装Nginx"></a>Mac下安装Nginx</h1><h4 id="一、检查更新"><a href="#一、检查更新" class="headerlink" title="一、检查更新"></a>一、检查更新</h4><pre><code>brew update</code></pre><h4 id="二、查询要安装的软件是否存在"><a href="#二、查询要安装的软件是否存在" class="headerlink" title="二、查询要安装的软件是否存在"></a>二、查询要安装的软件是否存在</h4><pre><code>brew search nginx</code></pre><h4 id="三、安装软件"><a href="#三、安装软件" class="headerlink" title="三、安装软件"></a>三、安装软件</h4><pre><code>brew install nginx</code></pre><p><img src="//zongmansheng.club/2019/07/10/mac-xia-an-zhuang-nginx/001.png" alt></p><p><img src="//zongmansheng.club/2019/07/10/mac-xia-an-zhuang-nginx/002.png" alt></p><blockquote><p>我们可以看到，nginx在本地还未安装（Not installed），nginx的来源（From），Docroot默认为/usr/local/var/www，在/usr/local/etc/nginx/nginx.conf配置文件中默认端口被配置为8080从而使nginx运行时不需要加sudo，nginx将在/usr/local/etc/nginx/servers/目录中加载所有文件，以及我们可以通过最简单的命令 ‘nginx’ 来启动nginx。</p></blockquote><h4 id="四、查看nginx安装目录"><a href="#四、查看nginx安装目录" class="headerlink" title="四、查看nginx安装目录"></a>四、查看nginx安装目录</h4><pre><code>open /usr/local/etc/nginx/</code></pre><pre><code>open /usr/local/Cellar/nginx  //其实这个才是nginx被安装到的目录</code></pre><h4 id="五、启动nginx，终端输入如下命令："><a href="#五、启动nginx，终端输入如下命令：" class="headerlink" title="五、启动nginx，终端输入如下命令："></a>五、启动nginx，终端输入如下命令：</h4><pre><code>nginx</code></pre><h4 id="六、浏览器访问"><a href="#六、浏览器访问" class="headerlink" title="六、浏览器访问"></a>六、浏览器访问</h4><pre><code>localhost:8080</code></pre><p><img src="//zongmansheng.club/2019/07/10/mac-xia-an-zhuang-nginx/003.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Mac下安装Nginx&quot;&gt;&lt;a href=&quot;#Mac下安装Nginx&quot; class=&quot;headerlink&quot; title=&quot;Mac下安装Nginx&quot;&gt;&lt;/a&gt;Mac下安装Nginx&lt;/h1&gt;&lt;h4 id=&quot;一、检查更新&quot;&gt;&lt;a href=&quot;#一、检查更新&quot; cla
      
    
    </summary>
    
      <category term="中间件" scheme="http://zongmansheng.club/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="Nginx，负载均衡" scheme="http://zongmansheng.club/tags/Nginx%EF%BC%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Mac下安装Redis</title>
    <link href="http://zongmansheng.club/2019/07/09/mac-xia-an-zhuang-redis/"/>
    <id>http://zongmansheng.club/2019/07/09/mac-xia-an-zhuang-redis/</id>
    <published>2019-07-09T03:41:35.000Z</published>
    <updated>2019-07-16T13:37:43.023Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mac下安装Redis"><a href="#Mac下安装Redis" class="headerlink" title="Mac下安装Redis"></a>Mac下安装Redis</h1><h4 id="1-下载"><a href="#1-下载" class="headerlink" title="1.下载"></a>1.下载</h4><blockquote><p>打开官网：<a href="https://redis.io/" target="_blank" rel="noopener">https://redis.io/</a></p><p>这里下载的是最新版本</p></blockquote><p><img src="//zongmansheng.club/2019/07/09/mac-xia-an-zhuang-redis/001.png" alt></p><h4 id="2-安装"><a href="#2-安装" class="headerlink" title="2.安装"></a>2.安装</h4><blockquote><p>下载完成后，打开命令行工具，执行解压命令</p></blockquote><pre><code>tar zxvf redis-5.0.5.tar.gz</code></pre><blockquote><p>将解压后文件夹放到/usr/local</p></blockquote><pre><code>mv redis-5.0.5 /usr/local/</code></pre><blockquote><p>切换到相应目录</p></blockquote><pre><code>cd /usr/local/redis-5.0.5/</code></pre><blockquote><p>编译测试</p></blockquote><pre><code>sudo make test</code></pre><p><img src="//zongmansheng.club/2019/07/09/mac-xia-an-zhuang-redis/002.png" alt></p><blockquote><p>编译安装</p></blockquote><pre><code>sudo make install</code></pre><p><img src="//zongmansheng.club/2019/07/09/mac-xia-an-zhuang-redis/003.png" alt></p><blockquote><p>启动Redis</p></blockquote><pre><code>redis-server</code></pre><p><img src="//zongmansheng.club/2019/07/09/mac-xia-an-zhuang-redis/004.png" alt></p><h4 id="3-配置"><a href="#3-配置" class="headerlink" title="3.配置"></a>3.配置</h4><blockquote><p>在redis目录下建立bin，etc，db三个目录</p></blockquote><p><img src="//zongmansheng.club/2019/07/09/mac-xia-an-zhuang-redis/005.png" alt></p><blockquote><p>拷贝 redis.conf 到 /usr/local/redis/etc下</p></blockquote><pre><code>cp /usr/local/redis/redis.conf /usr/local/redis/etc/</code></pre><blockquote><p>把/usr/local/redis/src目录下的mkreleasehdr.sh，redis-benchmark， redis-check-rdb， redis-cli， redis-server拷贝到bin目录</p></blockquote><pre><code>cp redis-benchmark /usr/local/redis/bin/cp redis-check-rdb /usr/local/redis/bin/cp redis-cli /usr/local/redis/bin/cp redis-server /usr/local/redis/bin/</code></pre><blockquote><p>修改redis.conf</p></blockquote><pre class=" language-xml"><code class="language-xml">#修改为守护模式daemonize yes#设置进程锁文件pidfile /usr/local/redis/redis.pid#端口port 6379#客户端超时时间timeout 300#日志级别loglevel debug#日志文件位置logfile /usr/local/redis/log-redis.log#设置数据库的数量，默认数据库为0，可以使用SELECT <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dbid</span><span class="token punctuation">></span></span>命令在连接上指定数据库iddatabases 16##指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合#save <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>seconds</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>changes</span><span class="token punctuation">></span></span>#Redis默认配置文件中提供了三个条件：save 900 1save 300 10save 60 10000#指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，#可以关闭该#选项，但会导致数据库文件变的巨大rdbcompression yes#指定本地数据库文件名dbfilename dump.rdb#指定本地数据库路径dir /usr/local/redis/db/#指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能#会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有#的数据会在一段时间内只存在于内存中appendonly no#指定更新日志条件，共有3个可选值：#no：表示等操作系统进行数据缓存同步到磁盘（快）#always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）#everysec：表示每秒同步一次（折衷，默认值）appendfsync everysec</code></pre><blockquote><p>启动服务</p></blockquote><pre><code>./bin/redis-server etc/redis.conf</code></pre><p><img src="//zongmansheng.club/2019/07/09/mac-xia-an-zhuang-redis/007.png" alt></p><blockquote><p>查看日志</p></blockquote><pre><code>tail -f log-redis.log</code></pre><blockquote><p>打开redis客户端</p></blockquote><pre><code>./bin/redis-cli</code></pre><p><img src="//zongmansheng.club/2019/07/09/mac-xia-an-zhuang-redis/008.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Mac下安装Redis&quot;&gt;&lt;a href=&quot;#Mac下安装Redis&quot; class=&quot;headerlink&quot; title=&quot;Mac下安装Redis&quot;&gt;&lt;/a&gt;Mac下安装Redis&lt;/h1&gt;&lt;h4 id=&quot;1-下载&quot;&gt;&lt;a href=&quot;#1-下载&quot; class=&quot;
      
    
    </summary>
    
      <category term="中间件" scheme="http://zongmansheng.club/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="Redis" scheme="http://zongmansheng.club/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot启动原理</title>
    <link href="http://zongmansheng.club/2019/07/08/springboot-qi-dong-yuan-li/"/>
    <id>http://zongmansheng.club/2019/07/08/springboot-qi-dong-yuan-li/</id>
    <published>2019-07-08T04:45:53.000Z</published>
    <updated>2019-07-09T15:04:18.824Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot启动原理"><a href="#SpringBoot启动原理" class="headerlink" title="SpringBoot启动原理"></a>SpringBoot启动原理</h1><blockquote><p>熟悉而又陌生的启动类：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>springcloud<span class="token punctuation">.</span>eureka<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>SpringApplication<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>SpringBootApplication<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>cloud<span class="token punctuation">.</span>netflix<span class="token punctuation">.</span>eureka<span class="token punctuation">.</span>server<span class="token punctuation">.</span>EnableEurekaServer<span class="token punctuation">;</span><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EurekaApplication</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>EurekaApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>可以看到，此类中添加了注解 @SpringBootApplication，main 方法里通过 SpringApplication.run 来启动整个应用程序。因此要研究 Spring Boot 的启动原理，我们就需要从这个注解和这个run方法入手。</p></blockquote><h4 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="SpringBootApplication"></a>SpringBootApplication</h4><blockquote><p>首先，我们先来看看 SpringBootApplication 源码是怎么定义这个注解的：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Inherited</span><span class="token annotation punctuation">@SpringBootConfiguration</span><span class="token annotation punctuation">@EnableAutoConfiguration</span><span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span>excludeFilters <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token annotation punctuation">@Filter</span><span class="token punctuation">(</span>type <span class="token operator">=</span> FilterType<span class="token punctuation">.</span>CUSTOM<span class="token punctuation">,</span> classes <span class="token operator">=</span> TypeExcludeFilter<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token annotation punctuation">@Filter</span><span class="token punctuation">(</span>type <span class="token operator">=</span> FilterType<span class="token punctuation">.</span>CUSTOM<span class="token punctuation">,</span> classes <span class="token operator">=</span> AutoConfigurationExcludeFilter<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">SpringBootApplication</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@AliasFor</span><span class="token punctuation">(</span>annotation <span class="token operator">=</span> EnableAutoConfiguration<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">exclude</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@AliasFor</span><span class="token punctuation">(</span>annotation <span class="token operator">=</span> EnableAutoConfiguration<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">excludeName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@AliasFor</span><span class="token punctuation">(</span>annotation <span class="token operator">=</span> ComponentScan<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> attribute <span class="token operator">=</span> <span class="token string">"basePackages"</span><span class="token punctuation">)</span>    String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">scanBasePackages</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@AliasFor</span><span class="token punctuation">(</span>annotation <span class="token operator">=</span> ComponentScan<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> attribute <span class="token operator">=</span> <span class="token string">"basePackageClasses"</span><span class="token punctuation">)</span>    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">scanBasePackageClasses</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>可以看到，除了最基础的注解外，还增加了三个</p><ul><li>@SpringBootConfiguration</li><li>@EnableAutoConfiguration</li><li>@ComponentScan</li></ul><p>这里我们可以将 SpringBootApplication 替换成上面三个注解也是相同的效果：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>springcloud<span class="token punctuation">.</span>eureka<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>SpringApplication<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>SpringBootApplication<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>cloud<span class="token punctuation">.</span>netflix<span class="token punctuation">.</span>eureka<span class="token punctuation">.</span>server<span class="token punctuation">.</span>EnableEurekaServer<span class="token punctuation">;</span><span class="token annotation punctuation">@SpringBootConfiguration</span><span class="token annotation punctuation">@EnableAutoConfiguration</span><span class="token annotation punctuation">@ComponentScan</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EurekaApplication</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>EurekaApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>但是如果咱们每次都写这三个注解那岂不是很麻烦吗？所以我们只要写一个注解 @SpringBootApplication 就ok了。</p><p>下面，我们分别来介绍这三个注解。</p></blockquote><h4 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="SpringBootConfiguration"></a>SpringBootConfiguration</h4><blockquote><p>我们先来看看SpringBootConfiguration的源码：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Documented<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>ElementType<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Retention<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>RetentionPolicy<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Target<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Configuration<span class="token punctuation">;</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">SpringBootConfiguration</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><blockquote><p>该注解上有个注解@Configuration ，所以可以得知@SpringBootConfiguration 就是 @Configuration ，但是Spring Boot推荐用 SpringBootConfiguration 来代替 Configuration。同时Spring Boot 社区推荐使用 JavaConfig 配置，所以要用到 @Configuration。</p><p>回到配置Spring的年代，我们来看看是如何实现的。先从 SpringMVC 中基于 xml是如何配置开始：</p></blockquote><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd<span class="token punctuation">"</span></span> <span class="token attr-name">default-lazy-init</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--bean定义--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">></span></span></code></pre><blockquote><p>而 EurekaConfig 的配置是这样的</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>SpringBootConfiguration<span class="token punctuation">;</span><span class="token annotation punctuation">@SpringBootConfiguration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EurekaConfig</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//bean定义</span> <span class="token annotation punctuation">@Bean</span> <span class="token keyword">public</span> UserService <span class="token function">service</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>             <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">UserServiceImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>任何标注了 Bean 的方法都被定义为一个 Bean，我们可以在任何 Spring 的 IoC 容器中注入进去。</p></blockquote><h4 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="EnableAutoConfiguration"></a>EnableAutoConfiguration</h4><blockquote><p>这个注解的作用就是自动将 EurekaConfig中的 Bean 装载到 IoC 容器中。</p><p>先看看期源码：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Inherited</span><span class="token annotation punctuation">@AutoConfigurationPackage</span><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span>AutoConfigurationImportSelector<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">EnableAutoConfiguration</span> <span class="token punctuation">{</span>    String ENABLED_OVERRIDE_PROPERTY <span class="token operator">=</span> <span class="token string">"spring.boot.enableautoconfiguration"</span><span class="token punctuation">;</span>    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">exclude</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">excludeName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>该注解引入了 @AutoConfigurationPackage 注解，通过其字面意思，就知道它的作用是自动配置 Package，即它会默认配置启动类所在包及其子包下的所有标注了 Configuration 注解的类。</p><p>而以上注解使用 @Import 注解，该注解的作用是自动执行该注解指定的类。在上述注解中，其导入了 AutoConfigurationImportSelector 类，通过其类名就知道该类的作用是自动配置选择器，因此，我们使用了 @EnableAutoConfiguration 注解后，它就会自动执行 AutoConfigurationImportSelector 类，最终会调用哪个方法呢？请看它的源码：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Group</span><span class="token operator">></span> <span class="token function">getImportGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">return</span> AutoConfigurationGroup<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>程序启动后，只要标注了 @EnableAutoConfiguration 注解，那么最后会调用 getImportGroup 方法，它返回的是一个 Group 对象。而上述代码中 AutoConfigurationGroup 继承的是 Group 接口，通过查看 Group 源码得知，Group 接口被定义在 DeferredImportSelector 接口中，继续查看 AutoConfigurationGroup 类的代码，我们发现以下源码：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span>AnnotationMetadata annotationMetadata<span class="token punctuation">,</span>                        DeferredImportSelector deferredImportSelector<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Assert<span class="token punctuation">.</span><span class="token function">state</span><span class="token punctuation">(</span>                deferredImportSelector <span class="token keyword">instanceof</span> <span class="token class-name">AutoConfigurationImportSelector</span><span class="token punctuation">,</span>                <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> String<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"Only %s implementations are supported, got %s"</span><span class="token punctuation">,</span>                        AutoConfigurationImportSelector<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getSimpleName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                        deferredImportSelector<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        AutoConfigurationEntry autoConfigurationEntry <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>AutoConfigurationImportSelector<span class="token punctuation">)</span> deferredImportSelector<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">getAutoConfigurationEntry</span><span class="token punctuation">(</span><span class="token function">getAutoConfigurationMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                        annotationMetadata<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>autoConfigurationEntries<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>autoConfigurationEntry<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>String importClassName <span class="token operator">:</span> autoConfigurationEntry<span class="token punctuation">.</span><span class="token function">getConfigurations</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>entries<span class="token punctuation">.</span><span class="token function">putIfAbsent</span><span class="token punctuation">(</span>importClassName<span class="token punctuation">,</span> annotationMetadata<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Iterable<span class="token operator">&lt;</span>Entry<span class="token operator">></span> <span class="token function">selectImports</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>autoConfigurationEntries<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> Collections<span class="token punctuation">.</span><span class="token function">emptyList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        Set<span class="token operator">&lt;</span>String<span class="token operator">></span> allExclusions <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>autoConfigurationEntries<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>AutoConfigurationEntry<span class="token operator">:</span><span class="token operator">:</span>getExclusions<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span>Collection<span class="token operator">:</span><span class="token operator">:</span>stream<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Set<span class="token operator">&lt;</span>String<span class="token operator">></span> processedConfigurations <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>autoConfigurationEntries<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>AutoConfigurationEntry<span class="token operator">:</span><span class="token operator">:</span>getConfigurations<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span>Collection<span class="token operator">:</span><span class="token operator">:</span>stream<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toCollection</span><span class="token punctuation">(</span>LinkedHashSet<span class="token operator">:</span><span class="token operator">:</span><span class="token keyword">new</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        processedConfigurations<span class="token punctuation">.</span><span class="token function">removeAll</span><span class="token punctuation">(</span>allExclusions<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">sortAutoConfigurations</span><span class="token punctuation">(</span>processedConfigurations<span class="token punctuation">,</span>                <span class="token function">getAutoConfigurationMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span>importClassName<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">(</span>                        <span class="token keyword">this</span><span class="token punctuation">.</span>entries<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>importClassName<span class="token punctuation">)</span><span class="token punctuation">,</span> importClassName<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><blockquote><p>也就是说最终会自动执行 process 和 selectImports 方法。</p><p>可以注意到 autoConfigurationEntry.getConfigurations()，它就是获取所有标注了 @Configuration 注解的类，并加入到 Map 中。</p><p>需要注意的是，AutoConfigurationImportSelector 类实现的是 DeferredImportSelector 接口，而 process 是 DeferredImportSelector.Group 接口定义的方法。</p></blockquote><h4 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="ComponentScan"></a>ComponentScan</h4><blockquote><p>这个注解的作用是自动扫描并加载符合条件的组件（如：Component、Bean 等），我们可以通过 basePakcages 来指定其扫描的范围，如果不指定，则默认从标注了 @ComponentScan 注解的类所在包开始扫描。如下代码：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span>basePackages <span class="token operator">=</span> <span class="token string">"com.lawt"</span><span class="token punctuation">)</span></code></pre><blockquote><p>因此，Spring Boot 的启动类最好放在 root package 下面，因为默认不指定 basePackages，这样能保证扫描到所有包。</p></blockquote><h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><p><img src="//zongmansheng.club/2019/07/08/springboot-qi-dong-yuan-li/001.jpeg" alt></p><blockquote><p>启动类先调用了 SpringApplication 的静态方法 run，跟踪进去后发现，它会先实例化 SpringApplication，然后调用 run 方法。</p></blockquote><pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> <span class="token keyword">static</span> ConfigurableApplicationContext <span class="token function">run</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> primarySources<span class="token punctuation">,</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SpringApplication</span><span class="token punctuation">(</span>primarySources<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><blockquote><p>所以，要分析它的启动源码，首先要分析 SpringApplicaiton 的构造过程。</p></blockquote><h4 id="SpringApplication-构造器"><a href="#SpringApplication-构造器" class="headerlink" title="SpringApplication 构造器"></a>SpringApplication 构造器</h4><blockquote><p>在 SpringApplication 构造函数内部，他会初始化一些信息：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">SpringApplication</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> primarySources<span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token keyword">this</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> primarySources<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token function">SpringApplication</span><span class="token punctuation">(</span>ResourceLoader resourceLoader<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> primarySources<span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token keyword">this</span><span class="token punctuation">.</span>resourceLoader <span class="token operator">=</span> resourceLoader<span class="token punctuation">;</span>            Assert<span class="token punctuation">.</span><span class="token function">notNull</span><span class="token punctuation">(</span>primarySources<span class="token punctuation">,</span> <span class="token string">"PrimarySources must not be null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token keyword">this</span><span class="token punctuation">.</span>primarySources <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>primarySources<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token keyword">this</span><span class="token punctuation">.</span>webApplicationType <span class="token operator">=</span> WebApplicationType<span class="token punctuation">.</span><span class="token function">deduceFromClasspath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token function">setInitializers</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Collection<span class="token punctuation">)</span> <span class="token function">getSpringFactoriesInstances</span><span class="token punctuation">(</span>             ApplicationContextInitializer<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token function">setListeners</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Collection<span class="token punctuation">)</span> <span class="token function">getSpringFactoriesInstances</span><span class="token punctuation">(</span>ApplicationListener<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token keyword">this</span><span class="token punctuation">.</span>mainApplicationClass <span class="token operator">=</span> <span class="token function">deduceMainApplicationClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><blockquote><p>通过上述代码，我们分析到 SpringApplication 实例化时有以下几个步骤：</p><p>1.将所有 sources 加入到全局 sources 中，目前只有一个 Application。</p><p>2.判断是否为 Web 程序（javax.servlet.Servlet、</p><p>org.springframework.web.context.ConfigurableWebApplicationContext 这两个类必须存在于类加载器中）。</p><p>判断过程可以参看以下源码：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> WebApplicationType <span class="token function">deduceFromClasspath</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ClassUtils<span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token string">"org.springframework.web.reactive.DispatcherHandler"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>ClassLoader<span class="token punctuation">)</span>null<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>ClassUtils<span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token string">"org.springframework.web.servlet.DispatcherServlet"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>ClassLoader<span class="token punctuation">)</span>null<span class="token punctuation">)</span>  <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>ClassUtils<span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token string">"org.glassfish.jersey.servlet.ServletContainer"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>ClassLoader<span class="token punctuation">)</span>null<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> REACTIVE<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> var0 <span class="token operator">=</span> SERVLET_INDICATOR_CLASSES<span class="token punctuation">;</span> <span class="token keyword">int</span> var1 <span class="token operator">=</span> var0<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> var2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> var2 <span class="token operator">&lt;</span> var1<span class="token punctuation">;</span> <span class="token operator">++</span>var2<span class="token punctuation">)</span> <span class="token punctuation">{</span> String className <span class="token operator">=</span> var0<span class="token punctuation">[</span>var2<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ClassUtils<span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span>className<span class="token punctuation">,</span> <span class="token punctuation">(</span>ClassLoader<span class="token punctuation">)</span>null<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> NONE<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span> <span class="token keyword">return</span> SERVLET<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><blockquote><p>3.设置应用程序初始化器 ApplicationContextInitializer，做一些初始化的工作。</p><p>4.设置应用程序事件监听器 ApplicationListener。</p><p>5.找出启动类，设置到 mainApplicationClass 中。</p></blockquote><h4 id="SpringApplication-的执行流程"><a href="#SpringApplication-的执行流程" class="headerlink" title="SpringApplication 的执行流程"></a>SpringApplication 的执行流程</h4><blockquote><p>SpringApplication 构造完成后，就会调用 run 方法，这时才真正的开始应用程序的执行。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> ConfigurableApplicationContext <span class="token function">run</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        StopWatch stopWatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StopWatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stopWatch<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ConfigurableApplicationContext context <span class="token operator">=</span> null<span class="token punctuation">;</span>        FailureAnalyzers analyzers <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token function">configureHeadlessProperty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        SpringApplicationRunListeners listeners <span class="token operator">=</span> <span class="token function">getRunListeners</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//1.获取监听器</span>        listeners<span class="token punctuation">.</span><span class="token function">starting</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// -->启动！</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            ApplicationArguments applicationArguments <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultApplicationArguments</span><span class="token punctuation">(</span>                    args<span class="token punctuation">)</span><span class="token punctuation">;</span>            ConfigurableEnvironment environment <span class="token operator">=</span> <span class="token function">prepareEnvironment</span><span class="token punctuation">(</span>listeners<span class="token punctuation">,</span><span class="token comment" spellcheck="true">//2.准备好环境，触发ApplicationEnvironmentPreparedEvent事件</span>                    applicationArguments<span class="token punctuation">)</span><span class="token punctuation">;</span>            Banner printedBanner <span class="token operator">=</span> <span class="token function">printBanner</span><span class="token punctuation">(</span>environment<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//打印启动提示字符，默认spring的字符图</span>            context <span class="token operator">=</span> <span class="token function">createApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//实例化一个可配置应用上下文</span>            analyzers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FailureAnalyzers</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">prepareContext</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> environment<span class="token punctuation">,</span> listeners<span class="token punctuation">,</span> applicationArguments<span class="token punctuation">,</span><span class="token comment" spellcheck="true">//3.准备上下文</span>                    printedBanner<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">refreshContext</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//4.刷新上下文</span>            <span class="token function">afterRefresh</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> applicationArguments<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//5.刷新上下文后</span>            listeners<span class="token punctuation">.</span><span class="token function">finished</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">--</span>关闭！            stopWatch<span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>logStartupInfo<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">new</span> <span class="token class-name">StartupInfoLogger</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>mainApplicationClass<span class="token punctuation">)</span>                        <span class="token punctuation">.</span><span class="token function">logStarted</span><span class="token punctuation">(</span><span class="token function">getApplicationLog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> stopWatch<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> context<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">handleRunFailure</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> listeners<span class="token punctuation">,</span> analyzers<span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p><img src="//zongmansheng.club/2019/07/08/springboot-qi-dong-yuan-li/002.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SpringBoot启动原理&quot;&gt;&lt;a href=&quot;#SpringBoot启动原理&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot启动原理&quot;&gt;&lt;/a&gt;SpringBoot启动原理&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;熟悉而又陌生的启动
      
    
    </summary>
    
      <category term="Spring" scheme="http://zongmansheng.club/categories/Spring/"/>
    
    
      <category term="SpringBoot" scheme="http://zongmansheng.club/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>负载均衡</title>
    <link href="http://zongmansheng.club/2019/07/07/fu-zai-jun-heng/"/>
    <id>http://zongmansheng.club/2019/07/07/fu-zai-jun-heng/</id>
    <published>2019-07-06T23:56:45.000Z</published>
    <updated>2019-07-23T04:23:44.538Z</updated>
    
    <content type="html"><![CDATA[<h1 id="负载神器-LVS、Nginx及HAProxy工作原理"><a href="#负载神器-LVS、Nginx及HAProxy工作原理" class="headerlink" title="负载神器 LVS、Nginx及HAProxy工作原理"></a>负载神器 LVS、Nginx及HAProxy工作原理</h1><blockquote><p>​        当前大多数的互联网系统都使用了服务器集群技术，集群是将相同服务部署在多台服务器上构成一个集群整体对外提供服务，这些集群可以是 Web 应用服务器集群，也可以是数据库服务器集群，还可以是分布式缓存服务器集群等等。</p></blockquote><p><img src="//zongmansheng.club/2019/07/07/fu-zai-jun-heng/001.png" alt></p><blockquote><p>​        在实际应用中，在 Web 服务器集群之前总会有一台负载均衡服务器，负载均衡设备的任务就是作为 Web 服务器流量的入口，挑选最合适的一台 Web 服务器，将客户端的请求转发给它处理，实现客户端到真实服务端的透明转发。</p><p>​        最近几年很火的「云计算」以及分布式架构，本质上也是将后端服务器作为计算资源、存储资源，由某台管理服务器封装成一个服务对外提供，客户端不需要关心真正提供服务的是哪台机器，在它看来，就好像它面对的是一台拥有近乎无限能力的服务器，而本质上，真正提供服务的，是后端的集群。</p></blockquote><h3 id="LVS、Nginx、HAProxy-是目前使用最广泛的三种负载均衡软件。"><a href="#LVS、Nginx、HAProxy-是目前使用最广泛的三种负载均衡软件。" class="headerlink" title="LVS、Nginx、HAProxy 是目前使用最广泛的三种负载均衡软件。"></a>LVS、Nginx、HAProxy 是目前使用最广泛的三种负载均衡软件。</h3><blockquote><p>​        一般对负载均衡的使用是随着网站规模的提升根据不同的阶段来使用不同的技术。具体的应用需求还得具体分析，如果是中小型的 Web 应用，比如日 PV 小于1000万，用 Nginx 就完全可以了；如果机器不少，可以用 DNS 轮询，LVS 所耗费的机器还是比较多的；大型网站或重要的服务，且服务器比较多时，可以考虑用 LVS。</p><p>​        目前关于网站架构一般比较合理流行的架构方案：Web 前端采用 Nginx/HAProxy+Keepalived 作负载均衡器；后端采用 MySQ L数据库一主多从和读写分离，采用 LVS+Keepalived 的架构。</p></blockquote><h4 id="一、LVS"><a href="#一、LVS" class="headerlink" title="一、LVS"></a>一、LVS</h4><blockquote><p>​        LVS 是 Linux Virtual Server 的简称，也就是 Linux 虚拟服务器。现在 LVS 已经是 Linux 标准内核的一部分，从 Linux2.4 内核以后，已经完全内置了 LVS 的各个功能模块，无需给内核打任何补丁，可以直接使用 LVS 提供的各种功能。</p><p>​        LVS 自从1998年开始，发展到现在已经是一个比较成熟的技术项目了。</p></blockquote><h5 id="1、LVS-的体系结构"><a href="#1、LVS-的体系结构" class="headerlink" title="1、LVS 的体系结构"></a>1、LVS 的体系结构</h5><p><img src="//zongmansheng.club/2019/07/07/fu-zai-jun-heng/002.png" alt></p><blockquote><p>LVS 架设的服务器集群系统有三个部分组成：</p><p>(1) 最前端的负载均衡层，用 Load Balancer 表示</p><p>(2) 中间的服务器集群层，用 Server Array 表示</p><p>(3) 最底端的数据共享存储层，用 Shared Storage 表示</p></blockquote><h5 id="2、LVS-负载均衡机制"><a href="#2、LVS-负载均衡机制" class="headerlink" title="2、LVS 负载均衡机制"></a>2、LVS 负载均衡机制</h5><blockquote><p>LVS 不像 HAProxy 等七层软负载面向的是 HTTP 包，所以七层负载可以做的 URL 解析等工作，LVS 无法完成。</p><p>LVS 是四层负载均衡，也就是说建立在 OSI 模型的第四层——传输层之上，传输层上有我们熟悉的 TCP/UDP，LVS 支持 TCP/UDP 的负载均衡。因为 LVS 是四层负载均衡，因此它相对于其它高层负载均衡的解决办法，比如 DNS 域名轮流解析、应用层负载的调度、客户端的调度等，它的效率是非常高的。</p><p>所谓四层负载均衡 ，也就是主要通过报文中的目标地址和端口。七层负载均衡 ，也称为“内容交换”，也就是主要通过报文中的真正有意义的应用层内容。</p></blockquote><p><img src="//zongmansheng.club/2019/07/07/fu-zai-jun-heng/003.png" alt></p><blockquote><p>LVS 的转发主要通过修改 IP 地址（NAT 模式，分为源地址修改 SNAT 和目标地址修改 DNAT）、修改目标 MAC（DR 模式）来实现。</p></blockquote><h5 id="3、NAT-模式：网络地址转换"><a href="#3、NAT-模式：网络地址转换" class="headerlink" title="3、NAT 模式：网络地址转换"></a>3、NAT 模式：网络地址转换</h5><blockquote><p>NAT（Network Address Translation）是一种外网和内网地址映射的技术。</p><p>NAT 模式下，网络数据报的进出都要经过 LVS 的处理。LVS 需要作为 RS（真实服务器）的网关。</p><p>当包到达 LVS 时，LVS 做目标地址转换（DNAT），将目标 IP 改为 RS 的 IP。RS 接收到包以后，仿佛是客户端直接发给它的一样。RS 处理完，返回响应时，源 IP 是 RS IP，目标 IP 是客户端的 IP。这时 RS 的包通过网关（LVS）中转，LVS 会做源地址转换（SNAT），将包的源地址改为 VIP，这样，这个包对客户端看起来就仿佛是 LVS 直接返回给它的。</p></blockquote><p><img src="//zongmansheng.club/2019/07/07/fu-zai-jun-heng/004.png" alt></p><h5 id="4、DR-模式：直接路由"><a href="#4、DR-模式：直接路由" class="headerlink" title="4、DR 模式：直接路由"></a>4、DR 模式：直接路由</h5><blockquote><p>DR 模式下需要 LVS 和 RS 集群绑定同一个 VIP（RS 通过将 VIP 绑定在 loopback 实现），但与 NAT 的不同点在于：请求由 LVS 接受，由真实提供服务的服务器（RealServer，RS）直接返回给用户，返回的时候不经过 LVS。</p><p>详细来看，一个请求过来时，LVS 只需要将网络帧的 MAC 地址修改为某一台 RS 的 MAC，该包就会被转发到相应的 RS 处理，注意此时的源 IP 和目标 IP 都没变，LVS 只是做了一下移花接木。RS 收到 LVS 转发来的包时，链路层发现 MAC 是自己的，到上面的网络层，发现 IP 也是自己的，于是这个包被合法地接受，RS 感知不到前面有 LVS 的存在。而当 RS 返回响应时，只要直接向源 IP（即用户的 IP）返回即可，不再经过 LVS。</p></blockquote><p><img src="//zongmansheng.club/2019/07/07/fu-zai-jun-heng/005.png" alt></p><blockquote><p>DR 负载均衡模式数据分发过程中不修改 IP 地址，只修改 mac 地址，由于实际处理请求的真实物理 IP 地址和数据请求目的 IP 地址一致，所以不需要通过负载均衡服务器进行地址转换，可将响应数据包直接返回给用户浏览器，避免负载均衡服务器网卡带宽成为瓶颈。因此，DR 模式具有较好的性能，也是目前大型网站使用最广泛的一种负载均衡手段。</p></blockquote><h5 id="5、LVS-的优点"><a href="#5、LVS-的优点" class="headerlink" title="5、LVS 的优点"></a>5、LVS 的优点</h5><blockquote><ul><li>抗负载能力强、是工作在传输层上仅作分发之用，没有流量的产生，这个特点也决定了它在负载均衡软件里的性能最强的，对内存和 cpu 资源消耗比较低。</li><li>配置性比较低，这是一个缺点也是一个优点，因为没有可太多配置的东西，所以并不需要太多接触，大大减少了人为出错的几率。</li><li>工作稳定，因为其本身抗负载能力很强，自身有完整的双机热备方案，如 LVS + Keepalived。</li><li>无流量，LVS 只分发请求，而流量并不从它本身出去，这点保证了均衡器 IO 的性能不会受到大流量的影响。</li><li>应用范围比较广，因为 LVS 工作在传输层，所以它几乎可以对所有应用做负载均衡，包括 http、数据库、在线聊天室等等。</li></ul></blockquote><h5 id="6、LVS-的缺点"><a href="#6、LVS-的缺点" class="headerlink" title="6、LVS 的缺点"></a>6、LVS 的缺点</h5><blockquote><ul><li>软件本身不支持正则表达式处理，不能做动静分离；而现在许多网站在这方面都有较强的需求，这个是 Nginx、HAProxy + Keepalived 的优势所在。</li><li>如果是网站应用比较庞大的话，LVS/DR + Keepalived 实施起来就比较复杂了，相对而言，Nginx / HAProxy + Keepalived 就简单多了。</li></ul></blockquote><h4 id="二、Nginx"><a href="#二、Nginx" class="headerlink" title="二、Nginx"></a>二、Nginx</h4><blockquote><p>Nginx 是一个强大的 Web 服务器软件，用于处理高并发的 HTTP 请求和作为反向代理服务器做负载均衡。具有高性能、轻量级、内存消耗少，强大的负载均衡能力等优势。</p></blockquote><p><img src="//zongmansheng.club/2019/07/07/fu-zai-jun-heng/006.png" alt></p><h5 id="1、Nignx-的架构设计"><a href="#1、Nignx-的架构设计" class="headerlink" title="1、Nignx 的架构设计"></a>1、Nignx 的架构设计</h5><blockquote><p>​        相对于传统基于进程或线程的模型（Apache就采用这种模型）在处理并发连接时会为每一个连接建立一个单独的进程或线程，且在网络或者输入/输出操作时阻塞。这将导致内存和 CPU 的大量消耗，因为新起一个单独的进程或线程需要准备新的运行时环境，包括堆和栈内存的分配，以及新的执行上下文，当然，这些也会导致多余的 CPU 开销。最终，会由于过多的上下文切换而导致服务器性能变差。</p><p>反过来，Nginx 的架构设计是采用模块化的、基于事件驱动、异步、单线程且非阻塞。</p><p>​        Nginx 大量使用多路复用和事件通知，Nginx 启动以后，会在系统中以 daemon 的方式在后台运行，其中包括一个 master 进程，n(n&gt;=1) 个 worker 进程。所有的进程都是单线程（即只有一个主线程）的，且进程间通信主要使用共享内存的方式。</p><p>​        其中，master 进程用于接收来自外界的信号，并给 worker 进程发送信号，同时监控 worker 进程的工作状态。worker 进程则是外部请求真正的处理者，每个 worker 请求相互独立且平等的竞争来自客户端的请求。请求只能在一个 worker 进程中被处理，且一个 worker 进程只有一个主线程，所以同时只能处理一个请求。（原理同 Netty 很像）</p></blockquote><p><img src="//zongmansheng.club/2019/07/07/fu-zai-jun-heng/007.png" alt></p><h5 id="2、Nginx-负载均衡"><a href="#2、Nginx-负载均衡" class="headerlink" title="2、Nginx 负载均衡"></a>2、Nginx 负载均衡</h5><blockquote><p>Nginx 负载均衡主要是对七层网络通信模型中的第七层应用层上的 http、https 进行支持。</p><p>Nginx 是以反向代理的方式进行负载均衡的。反向代理（Reverse Proxy）方式是指以代理服务器来接受 Internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 Internet 上请求连接的客户端，此时代理服务器对外就表现为一个服务器。</p><p>Nginx 实现负载均衡的分配策略有很多，Nginx 的 upstream 目前支持以下几种方式：</p><ul><li>轮询（默认）：每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器 down 掉，能自动剔除。</li><li>weight：指定轮询几率，weight 和访问比率成正比，用于后端服务器性能不均的情况。</li><li>ip_hash：每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器，可以解决 session 的问题。</li><li>fair（第三方）：按后端服务器的响应时间来分配请求，响应时间短的优先分配。</li><li>url_hash（第三方）：按访问 url 的 hash 结果来分配请求，使每个 url 定向到同一个后端服务器，后端服务器为缓存时比较有效。</li></ul></blockquote><h5 id="3、Nginx-的优点"><a href="#3、Nginx-的优点" class="headerlink" title="3、Nginx 的优点"></a>3、Nginx 的优点</h5><blockquote><ul><li>跨平台：Nginx 可以在大多数 Unix like OS编译运行，而且也有 Windows 的移植版本；</li><li>配置异常简单：非常容易上手。配置风格跟程序开发一样，神一般的配置；</li><li>非阻塞、高并发连接：官方测试能够支撑5万并发连接，在实际生产环境中跑到2～3万并发连接数；</li><li>事件驱动：通信机制采用 epoll 模型，支持更大的并发连接；</li><li>Master/Worker 结构：一个 master 进程，生成一个或多个 worker 进程；</li><li>内存消耗小：处理大并发的请求内存消耗非常小。在3万并发连接下，开启的10个 Nginx 进程才消耗150M 内存（15M*10=150M）；</li><li>内置的健康检查功能：如果 Nginx 代理的后端的某台 Web 服务器宕机了，不会影响前端访问；</li><li>节省带宽：支持 GZIP 压缩，可以添加浏览器本地缓存的 Header 头；</li><li>稳定性高：用于反向代理，宕机的概率微乎其微</li></ul></blockquote><h5 id="4、Nginx-的缺点"><a href="#4、Nginx-的缺点" class="headerlink" title="4、Nginx 的缺点"></a>4、Nginx 的缺点</h5><blockquote><ul><li>Nginx 仅能支 持http、https 、tcp、 Email等协议，这样就在适用范围上面小些，这个是它的缺点；</li><li>对后端服务器的健康检查，只支持通过端口来检测，不支持通过 ur l来检测。不支持 Session 的直接保持，但能通过 ip_hash 来解决；</li></ul></blockquote><h4 id="三、HAProxy"><a href="#三、HAProxy" class="headerlink" title="三、HAProxy"></a>三、HAProxy</h4><blockquote><p>HAProxy 支持两种代理模式 TCP（四层）和HTTP（七层），也是支持虚拟主机的。</p><p>HAProxy 的优点能够补充 Nginx 的一些缺点，比如支持 Session 的保持，Cookie 的引导；同时支持通过获取指定的 url 来检测后端服务器的状态。</p><p>HAProxy 跟 LVS 类似，本身就只是一款负载均衡软件；单纯从效率上来讲 HAProxy 会比 Nginx 有更出色的负载均衡速度，在并发处理上也是优于 Nginx 的。</p><p>HAProxy 支持 TCP 协议的负载均衡转发，可以对 MySQL 读进行负载均衡，对后端的 MySQL 节点进行检测和负载均衡，大家可以用 LVS+Keepalived 对 MySQL 主从做负载均衡。</p><p>HAProxy 负载均衡策略非常多：Round-robin（轮循）、Weight-round-robin（带权轮循）、source（原地址保持）、RI（请求URL）、rdp-cookie（根据cookie）。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;负载神器-LVS、Nginx及HAProxy工作原理&quot;&gt;&lt;a href=&quot;#负载神器-LVS、Nginx及HAProxy工作原理&quot; class=&quot;headerlink&quot; title=&quot;负载神器 LVS、Nginx及HAProxy工作原理&quot;&gt;&lt;/a&gt;负载神器 LVS
      
    
    </summary>
    
      <category term="集群" scheme="http://zongmansheng.club/categories/%E9%9B%86%E7%BE%A4/"/>
    
    
      <category term="LVS" scheme="http://zongmansheng.club/tags/LVS/"/>
    
      <category term="Nginx" scheme="http://zongmansheng.club/tags/Nginx/"/>
    
      <category term="HAProxy" scheme="http://zongmansheng.club/tags/HAProxy/"/>
    
  </entry>
  
  <entry>
    <title>Java虚拟机jvm类加载初始化</title>
    <link href="http://zongmansheng.club/2019/07/05/java-xu-ni-ji-jvm-lei-jia-zai-chu-shi-hua/"/>
    <id>http://zongmansheng.club/2019/07/05/java-xu-ni-ji-jvm-lei-jia-zai-chu-shi-hua/</id>
    <published>2019-07-05T00:45:14.000Z</published>
    <updated>2019-07-07T10:24:14.731Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java虚拟机jvm类加载初始化"><a href="#Java虚拟机jvm类加载初始化" class="headerlink" title="Java虚拟机jvm类加载初始化"></a>Java虚拟机jvm类加载初始化</h1><h4 id="一、Classloader的作用"><a href="#一、Classloader的作用" class="headerlink" title="一、Classloader的作用"></a>一、Classloader的作用</h4><blockquote><p>概括来说就是将编译后的class装载、加载到机器内存中，为了以后的程序的执行提供前提条件。</p></blockquote><h4 id="二、java类在虚拟机（jvm）中的工作原理"><a href="#二、java类在虚拟机（jvm）中的工作原理" class="headerlink" title="二、java类在虚拟机（jvm）中的工作原理"></a>二、java类在虚拟机（jvm）中的工作原理</h4><blockquote><p>1）类加载load：从字节码二进制文件——.class文件将类加载到内存，从而达到类的从硬盘上到内存上的一个迁移，所有的程序必须加载到内存才能工作。将内存中的class放到运行时数据区的方法区内，之后在堆区建立一个java.lang.Class对象，用来封装方法区的数据结构。这个时候就体现出了万事万物皆对象了，干什么事情都得有个对象。就是到了最底层究竟是鸡生蛋，还是蛋生鸡呢？类加载的最终产物就是堆中的一个java.lang.Class对象。</p></blockquote><blockquote><p><strong>2）连接：连接又分为以下小步骤</strong></p><p><strong>验证：</strong>出于安全性的考虑，验证内存中的字节码是否符合JVM的规范，类的结构规范、语义检查、字节码操作是否合法、这个是为了防止用户自己建立一个非法的XX.class文件就进行工作了，或者是JVM版本冲突的问题，比如在JDK6下面编译通过的class（其中包含注解特性的类），是不能在JDK1.4的JVM下运行的。</p><p><strong>准备：</strong>将类的静态变量进行分配内存空间、初始化默认值。（对象还没生成呢，所以这个时候没有实例变量什么事情）</p><p><strong>解析：</strong>把类的符号引用转为直接引用（保留）</p></blockquote><blockquote><p><strong>3）类的初始化：</strong> 将类的静态变量赋予正确的初始值，这个初始值是开发者自己定义时赋予的初始值，而不是默认值。</p></blockquote><h4 id="三、类的主动使用与被动使用"><a href="#三、类的主动使用与被动使用" class="headerlink" title="三、类的主动使用与被动使用"></a>三、类的主动使用与被动使用</h4><blockquote><p>以下是视为主动使用一个类，其他情况均视为被动使用！</p><p>1）初学者最为常用的new一个类的实例对象（声明不叫主动使用）</p><p>2）对类的静态变量进行读取、赋值操作的。</p><p>3）直接调用类的静态方法。</p><p>4）反射调用一个类的方法。</p><p>5）初始化一个类的子类的时候，父类也相当于被程序主动调用了（如果调用子类的静态变量是从父类继承过来并没有复写的，那么也就相当于只用到了父类的东东，和子类无关，所以这个时候子类不需要进行类初始化）。</p><p>6）直接运行一个main函数入口的类。</p></blockquote><p><img src="//zongmansheng.club/2019/07/05/java-xu-ni-ji-jvm-lei-jia-zai-chu-shi-hua/001.png" alt></p><blockquote><p>所有的JVM实现（不同的厂商有不同的实现，有人就说IBM的实现比Sun的要好……）在首次主动调用类和接口的时候才会初始化他们。</p></blockquote><h4 id="四、-类的加载方式"><a href="#四、-类的加载方式" class="headerlink" title="四、 类的加载方式"></a>四、 类的加载方式</h4><blockquote><p>1）：本地编译好的class中直接加载</p><p>2）：网络加载：java.net.URLClassLoader可以加载url指定的类</p><p>3）：从jar、zip等等压缩文件加载类，自动解析jar文件找到class文件去加载util类</p><p>4）：从java源代码文件动态编译成为class文件</p></blockquote><h4 id="五、类加载器"><a href="#五、类加载器" class="headerlink" title="五、类加载器"></a>五、类加载器</h4><blockquote><p>JVM自带的默认加载器</p><p>1）：根类加载器：bootstrap，由C++编写，所有Java程序无法获得。</p><p>2）：扩展类加载器：由Java编写。</p><p>3）：系统类、应用类加载器：由Java编写。</p><p>用户自定义的类加载器：java.lang.ClassLoader的子类，用户可以定制类的加载方式。每一个类都包含了加载他的ClassLoader的一个引用——getClass().getClassLoader()。如果返回的是null，证明加载他的ClassLoader是根加载器bootstrap。</p><p>如下代码</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException <span class="token punctuation">{</span>         Class <span class="token class-name">clazz</span> <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"java.lang.String"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>clazz<span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><blockquote><p>结果是null，证明java.lang.String是根类加载器去加载的。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>         Singleton mysingleton <span class="token operator">=</span> Singleton<span class="token punctuation">.</span><span class="token function">GetInstence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>mysingleton<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><blockquote><p>结果是sun.misc.Launcher$AppClassLoader@19821f，证明是AppClassLoader（系统类、应用类加载器）去加载的。像jre的rt.jar下面的java.lang.*都是默认的根类加载器去加载这些运行时的类。</p></blockquote><h4 id="六、解释类连接阶段的准备"><a href="#六、解释类连接阶段的准备" class="headerlink" title="六、解释类连接阶段的准备"></a>六、解释类连接阶段的准备</h4><blockquote><p>类的如下代码片段</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> a<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></code></pre><blockquote><p>在这个阶段，加载器会按照结构化似的，从上到下流程将静态变量int类型分配4个字节的空间，并且为其赋予默认值0，而像b = 10这段代码在此阶段是不起作用的，b仍然是默认值0。</p></blockquote><h4 id="七、解释类连接阶段的解析"><a href="#七、解释类连接阶段的解析" class="headerlink" title="七、解释类连接阶段的解析"></a>七、解释类连接阶段的解析</h4><blockquote><p>这里面的指针就是C++的指针</p></blockquote><h4 id="八、ClassLoader的剖析"><a href="#八、ClassLoader的剖析" class="headerlink" title="八、ClassLoader的剖析"></a>八、ClassLoader的剖析</h4><blockquote><p>ClassLoader的loadClass方法加载一个类不属于主动调用，不会导致类的初始化。如下代码块</p></blockquote><pre class=" language-java"><code class="language-java">  ClassLoader classLoader <span class="token operator">=</span> ClassLoader<span class="token punctuation">.</span><span class="token function">getSystemClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> clazz <span class="token operator">=</span> classLoader<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token string">"test01.ClassDemo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>并不会让类加载器初始化test01.ClassDemo，因为这不属于主动调用此类。</p></blockquote><p><strong>lassLoader的关系：</strong></p><blockquote><p><strong>根加载器——》扩展类加载器——》应用类加载器——》用户自定义类加载器</strong></p></blockquote><blockquote><p><strong>加载类的过程是首先从根加载器开始加载、根加载器加载不了的，由扩展类加载器加载，再加载不了的有应用加载器加载，应用加载器如果还加载不了就由自定义的加载器（一定继承自java.lang. ClassLoader）加载、如果自定义的加载器还加载不了。</strong>而且下面已经没有再特殊的类加载器了，就会抛出ClassNotFoundException，表面上异常是类找不到，实际上是class加载失败，更不能创建该类的Class对象。</p><p>若一个类能在某一层类加载器成功加载，那么这一层的加载器称为定义类加载器。那么在这层类生成的Class引用返回下一层加载器叫做初始类加载器。因为加载成功后返回一个Class引用给它的服务对象——也就是调用它的类加载器。考虑到安全，父委托加载机制。</p><p>ClassLoader加载类的原代码如下</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">synchronized</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">loadClass</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> resolve<span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException<span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// First, check if the class has already been loaded</span>        Class <span class="token class-name">c</span> <span class="token operator">=</span> <span class="token function">findLoadedClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    c <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    c <span class="token operator">=</span> <span class="token function">findBootstrapClassOrNull</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// ClassNotFoundException thrown if class not found</span>                <span class="token comment" spellcheck="true">// from the non-null parent class loader</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// If still not found, then invoke findClass in order</span>                <span class="token comment" spellcheck="true">// to find the class.</span>                c <span class="token operator">=</span> <span class="token function">findClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">resolveClass</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> c<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><blockquote><p>初始化系统ClassLoader代码如下</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">initSystemClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>sclSet<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>scl <span class="token operator">!=</span> null<span class="token punctuation">)</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"recursive invocation"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>Launcher l <span class="token operator">=</span> sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>Launcher<span class="token punctuation">.</span><span class="token function">getLauncher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                Throwable oops <span class="token operator">=</span> null<span class="token punctuation">;</span>                scl <span class="token operator">=</span> l<span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    PrivilegedExceptionAction a<span class="token punctuation">;</span>                    a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SystemClassLoaderAction</span><span class="token punctuation">(</span>scl<span class="token punctuation">)</span><span class="token punctuation">;</span>                    scl <span class="token operator">=</span> <span class="token punctuation">(</span>ClassLoader<span class="token punctuation">)</span> AccessController<span class="token punctuation">.</span><span class="token function">doPrivileged</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">PrivilegedActionException</span> pae<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    oops <span class="token operator">=</span> pae<span class="token punctuation">.</span><span class="token function">getCause</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>oops <span class="token keyword">instanceof</span> <span class="token class-name">InvocationTargetException</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        oops <span class="token operator">=</span> oops<span class="token punctuation">.</span><span class="token function">getCause</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>oops <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>oops <span class="token keyword">instanceof</span> <span class="token class-name">Error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">throw</span> <span class="token punctuation">(</span>Error<span class="token punctuation">)</span> oops<span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">// wrap the exception</span>                        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>oops<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            sclSet <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><blockquote><p>它里面调用了很多native的方法，也就是通过JNI调用底层C++的代码。</p></blockquote><h4 id="九、类（class）的生命周期"><a href="#九、类（class）的生命周期" class="headerlink" title="九、类（class）的生命周期"></a>九、类（class）的生命周期</h4><blockquote><p>当一个类被加载、连接、初始化后，它的生命周期就开始了，当代表该类的Class对象不再被引用、即已经不可触及的时候，Class对象的生命周期结束。那么该类的方法区内的数据也会被卸载，从而结束该类的生命周期。一个类的生命周期取决于它Class对象的生命周期。由Java虚拟机自带的默认加载器（根加载器、扩展加载器、系统加载器）所加载的类在JVM生命周期中始终不被卸载。所以这些类的Class对象（我称其为实例的模板对象）始终能被触及！而由用户自定义的类加载器所加载的类会被卸载掉！</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java虚拟机jvm类加载初始化&quot;&gt;&lt;a href=&quot;#Java虚拟机jvm类加载初始化&quot; class=&quot;headerlink&quot; title=&quot;Java虚拟机jvm类加载初始化&quot;&gt;&lt;/a&gt;Java虚拟机jvm类加载初始化&lt;/h1&gt;&lt;h4 id=&quot;一、Classlo
      
    
    </summary>
    
      <category term="日常学习" scheme="http://zongmansheng.club/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="JVM" scheme="http://zongmansheng.club/tags/JVM/"/>
    
  </entry>
  
</feed>
