<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>晓笙的BLOG</title>
  
  <subtitle>一个来自IT界的菜鸟007</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zongmansheng.club/"/>
  <updated>2019-06-30T07:50:29.949Z</updated>
  <id>http://zongmansheng.club/</id>
  
  <author>
    <name>ZongMan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySql主从复制与读写分离</title>
    <link href="http://zongmansheng.club/2019/06/30/mysql-zhu-cong-fu-zhi-yu-du-xie-fen-chi/"/>
    <id>http://zongmansheng.club/2019/06/30/mysql-zhu-cong-fu-zhi-yu-du-xie-fen-chi/</id>
    <published>2019-06-30T07:39:46.000Z</published>
    <updated>2019-06-30T07:50:29.949Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySql主从复制与读写分离"><a href="#MySql主从复制与读写分离" class="headerlink" title="MySql主从复制与读写分离"></a>MySql主从复制与读写分离</h1><p><img src="//zongmansheng.club/2019/06/30/mysql-zhu-cong-fu-zhi-yu-du-xie-fen-chi/Snipaste_2019-06-30_15-40-57.png" alt></p><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><blockquote><p>影响MySQL-A数据库的操作，在数据库执行后，都会写入本地的日志系统A中。</p><p>假设，实时的将变化了的日志系统中的数据库事件操作，在MYSQL-A的3306端口，通过网络发给MYSQL-B。</p><p>MYSQL-B收到后，写入本地日志系统B，然后一条条的将数据库事件在数据库中完成。</p><p>那么，MYSQL-A的变化，MYSQL-B也会变化，这样就是所谓的MYSQL的复制，即MYSQL replication。</p><p>在上面的模型中，MYSQL-A就是主服务器，即master，MYSQL-B就是从服务器，即slave。</p><p>日志系统A，其实它是MYSQL的日志类型中的二进制日志，也就是专门用来保存修改数据库表的所有动作，即bin log。【注意MYSQL会在执行语句之后，释放锁之前，写入二进制日志，确保事务安全】</p><p>日志系统B，并不是二进制日志，由于它是从MYSQL-A的二进制日志复制过来的，并不是自己的数据库变化产生的，有点接力的感觉，称为中继日志，即relay log。</p><p>可以发现，通过上面的机制，可以保证MYSQL-A和MYSQL-B的数据库数据一致，但是时间上肯定有延迟，即MYSQL-B的数据是滞后的。</p><p>【即便不考虑什么网络的因素，MYSQL-A的数据库操作是可以并发的执行的，但是MYSQL-B只能从relay log中读一条，执行下。因此MYSQL-A的写操作很频繁，MYSQL-B很可能跟不上。】</p></blockquote><h4 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h4><blockquote><p>数据如何不被丢失</p><p>备份</p><p>读写分离</p><p>数据库负载均衡</p><p>高可用</p></blockquote><h4 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a><strong>环境搭建</strong></h4><blockquote><p>1.准备环境</p><p>两台windows操作系统 ip分别为: 172.27.185.1(主)、172.27.185.2(从)</p><p>2.连接到主服务(172.27.185.1)服务器上，给从节点分配账号权限。</p><p>GRANT REPLICATION SLAVE ON <em>.</em> TO ‘root’@‘172.27.185.2’ IDENTIFIED BY ‘root’;</p><p>3.在主服务my.ini文件新增</p></blockquote><pre class=" language-mysql"><code class="language-mysql">server-id=200log-bin=mysql-binrelay-log=relay-binrelay-log-index=relay-bin-index</code></pre><blockquote><p>重启mysql服务</p><p>4.在从服务my.ini文件新增</p></blockquote><pre class=" language-mysql"><code class="language-mysql">server-id = 210replicate-do-db =itmayiedu #需要同步数据库</code></pre><blockquote><p>重启mysql服务</p><p>5.从服务同步主数据库</p></blockquote><pre class=" language-mysql"><code class="language-mysql">stop slave;changemaster to master_host='172.27.185.1',master_user='root',master_password='root';start slave;show slave status;</code></pre><blockquote><p>注意事项</p><p>①一定要在同一个局域网中</p><p>②使用360WiFi创建局域网</p><p>③最好把防火墙全部关闭掉</p></blockquote><h4 id="什么是读写分离"><a href="#什么是读写分离" class="headerlink" title="什么是读写分离"></a>什么是读写分离</h4><blockquote><p>在数据库集群架构中，让主库负责处理事务性查询，而从库只负责处理select查询，让两者分工明确达到提高数据库整体读写性能。当然，主数据库另外一个功能就是负责将事务性查询导致的数据变更同步到从库中，也就是写操作。</p></blockquote><h4 id="读写分离的好处"><a href="#读写分离的好处" class="headerlink" title="读写分离的好处"></a>读写分离的好处</h4><blockquote><p>1）分摊服务器压力，提高机器的系统处理效率</p><p>读写分离适用于读远比写的场景，如果有一台服务器，当select很多时，update和delete会被这些select访问中的数据堵塞，等待select结束，并发性能并不高，而主从只负责各自的写和读，极大程度的缓解X锁和S锁争用；</p><p>假如我们有1主3从，不考虑上述1中提到的从库单方面设置，假设现在1分钟内有10条写入，150条读取。那么，1主3从相当于共计40条写入，而读取总数没变，因此平均下来每台服务器承担了10条写入和50条读取（主库不承担读取操作）。因此，虽然写入没变，但是读取大大分摊了，提高了系统性能。另外，当读取被分摊后，又间接提高了写入的性能。所以，总体性能提高了，说白了就是拿机器和带宽换性能；</p><p>2）增加冗余，提高服务可用性，当一台数据库服务器宕机后可以调整另外一台从库以最快速度恢复服务</p></blockquote><h4 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h4><blockquote><p>依赖于二进制日志，binary-log.</p><p>二进制日志中记录引起数据库发生改变的语句</p><p>Insert 、delete、update、create table</p><p><strong>Scale-up与Scale-out区别</strong></p><p>Scale Out是指Application可以在水平方向上扩展。一般对数据中心的应用而言，Scale out指的是当添加更多的机器时，应用仍然可以很好的利用这些机器的资源来提升自己的效率从而达到很好的扩展性。</p><p>Scale Up是指Application可以在垂直方向上扩展。一般对单台机器而言，Scale Up值得是当某个计算节点（机器）添加更多的CPU Cores，存储设备，使用更大的内存时，应用可以很充分的利用这些资源来提升自己的效率从而达到很好的扩展性。</p></blockquote><h4 id="MyCat"><a href="#MyCat" class="headerlink" title="MyCat"></a>MyCat</h4><h5 id="什么是-Mycat"><a href="#什么是-Mycat" class="headerlink" title="什么是 Mycat"></a>什么是 Mycat</h5><blockquote><p>是一个开源的分布式数据库系统，但是因为数据库一般都有自己的数据库引擎，而Mycat并没有属于自己的独有数据库引擎，所有严格意义上说并不能算是一个完整的数据库系统，只能说是一个在应用和数据库之间起桥梁作用的中间件。</p><p>在Mycat中间件出现之前，MySQL主从复制集群，如果要实现读写分离，一般是在程序段实现，这样就带来了一个问题，即数据段和程序的耦合度太高，如果数据库的地址发生了改变，那么我的程序也要进行相应的修改，如果数据库不小心挂掉了，则同时也意味着程序的不可用，而对于很多应用来说，并不能接受；</p><p>引入Mycat中间件能很好地对程序和数据库进行解耦，这样，程序只需关注数据库中间件的地址，而无需知晓底层数据库是如何提供服务的，大量的通用数据聚合、事务、数据源切换等工作都由中间件来处理；</p><p>Mycat中间件的原理是对数据进行分片处理，从原有的一个库，被切分为多个分片数据库，所有的分片数据库集群构成完成的数据库存储，有点类似磁盘阵列中的RAID0.</p></blockquote><h5 id="Mycat安装"><a href="#Mycat安装" class="headerlink" title="Mycat安装"></a>Mycat安装</h5><blockquote><p><strong>创建表结构</strong></p><p>CREATE DATABASE IF NOT EXISTS <code>weibo_simple</code>;</p><hr><p>– Table structure for <code>t_users</code> 用户表</p><hr><p>DROP TABLE IF EXISTS <code>t_users</code>;</p><p>CREATE TABLE <code>t_users</code> (</p><p><code>user_id</code> varchar(64) NOT NULL COMMENT ‘注册用户ID’,</p><p><code>user_email</code> varchar(64) NOT NULL COMMENT ‘注册用户邮箱’,</p><p><code>user_password</code> varchar(64) NOT NULL COMMENT ‘注册用户密码’,</p><p><code>user_nikename</code> varchar(64) NOT NULL COMMENT ‘注册用户昵称’,</p><p><code>user_creatime</code> datetime NOT NULL COMMENT ‘注册时间’,</p><p><code>user_status</code> tinyint(1) NOT NULL COMMENT ‘验证状态 1：已验证 0：未验证’,</p><p><code>user_deleteflag</code> tinyint(1) NOT NULL COMMENT ‘删除标记 1：已删除 0：未删除’,</p><p>PRIMARY KEY (<code>user_id</code>)</p><p>) ENGINE=InnoDB DEFAULT CHARSET=utf8;</p><hr><p>– Table structure for <code>t_message</code>微博表</p><hr><p>DROP TABLE IF EXISTS <code>t_message</code>;</p><p>CREATE TABLE <code>t_message</code> (</p><p><code>messages_id</code> varchar(64) NOT NULL COMMENT ‘微博ID’,</p><p><code>user_id</code> varchar(64) NOT NULL COMMENT ‘发表用户’,</p><p><code>messages_info</code> varchar(255) DEFAULT NULL COMMENT ‘微博内容’,</p><p><code>messages_time</code> datetime DEFAULT NULL COMMENT ‘发布时间’,</p><p><code>messages_commentnum</code> int(12) DEFAULT NULL COMMENT ‘评论次数’,</p><p><code>message_deleteflag</code> tinyint(1) NOT NULL COMMENT ‘删除标记 1：已删除 0：未删除’,</p><p><code>message_viewnum</code> int(12) DEFAULT NULL COMMENT ‘被浏览量’,</p><p>PRIMARY KEY (<code>messages_id</code>),</p><p>KEY <code>user_id</code> (<code>user_id</code>),</p><p>CONSTRAINT <code>t_message_ibfk_1</code> FOREIGN KEY (<code>user_id</code>) REFERENCES <code>t_users</code> (<code>user_id</code>)</p><p>) ENGINE=InnoDB DEFAULT CHARSET=utf8;</p></blockquote><h5 id="配置server-xml"><a href="#配置server-xml" class="headerlink" title="配置server.xml"></a>配置server.xml</h5><pre class=" language-xml"><code class="language-xml">    <span class="token comment" spellcheck="true">&lt;!-- 添加user --></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>user</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mycat<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>mycat<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>schemas<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>mycat<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>user</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 添加user --></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>user</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mycat_red<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>mycat_red<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>schemas<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>mycat<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>readOnly<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>user</span><span class="token punctuation">></span></span></code></pre><h5 id="配置schema-xml"><a href="#配置schema-xml" class="headerlink" title="配置schema.xml"></a>配置schema.xml</h5><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0"?></span><span class="token doctype">&lt;!DOCTYPE mycat:schema SYSTEM "schema.dtd"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mycat:</span>schema</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>mycat</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://org.opencloudb/<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!-- 与server.xml中user的schemas名一致 --></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>schema</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mycat<span class="token punctuation">"</span></span> <span class="token attr-name">checkSQLschema</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token attr-name">sqlMaxLimit</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>t_users<span class="token punctuation">"</span></span> <span class="token attr-name">primaryKey</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user_id<span class="token punctuation">"</span></span> <span class="token attr-name">dataNode</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn1<span class="token punctuation">"</span></span> <span class="token attr-name">rule</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>rule1<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>t_message<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>global<span class="token punctuation">"</span></span> <span class="token attr-name">primaryKey</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>messages_id<span class="token punctuation">"</span></span> <span class="token attr-name">dataNode</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn1<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>schema</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataNode</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn1<span class="token punctuation">"</span></span> <span class="token attr-name">dataHost</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jdbchost<span class="token punctuation">"</span></span> <span class="token attr-name">database</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>weibo_simple<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataHost</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jdbchost<span class="token punctuation">"</span></span> <span class="token attr-name">maxCon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1000<span class="token punctuation">"</span></span> <span class="token attr-name">minCon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>10<span class="token punctuation">"</span></span> <span class="token attr-name">balance</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span> <span class="token attr-name">writeType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token attr-name">dbType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mysql<span class="token punctuation">"</span></span> <span class="token attr-name">dbDriver</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>native<span class="token punctuation">"</span></span> <span class="token attr-name">switchType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span> <span class="token attr-name">slaveThreshold</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>heartbeat</span><span class="token punctuation">></span></span>select user()<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>heartbeat</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>writeHost</span> <span class="token attr-name">host</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>hostMaster<span class="token punctuation">"</span></span> <span class="token attr-name">url</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>172.27.185.1:3306<span class="token punctuation">"</span></span> <span class="token attr-name">user</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span> <span class="token attr-name">password</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>writeHost</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>writeHost</span> <span class="token attr-name">host</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>hostSlave<span class="token punctuation">"</span></span> <span class="token attr-name">url</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>172.27.185.2:3306<span class="token punctuation">"</span></span> <span class="token attr-name">user</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span> <span class="token attr-name">password</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dataHost</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">mycat:</span>schema</span><span class="token punctuation">></span></span></code></pre><h5 id="配置rule-xml文件"><a href="#配置rule-xml文件" class="headerlink" title="配置rule.xml文件"></a>配置rule.xml文件</h5><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token comment" spellcheck="true">&lt;!-- - - Licensed under the Apache License, Version 2.0 (the "License");     - you may not use this file except in compliance with the License. - You     may obtain a copy of the License at - - http://www.apache.org/licenses/LICENSE-2.0     - - Unless required by applicable law or agreed to in writing, software -     distributed under the License is distributed on an "AS IS" BASIS, - WITHOUT     WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. - See the     License for the specific language governing permissions and - limitations     under the License. --></span><span class="token doctype">&lt;!DOCTYPE mycat:rule SYSTEM "rule.dtd"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mycat:</span>rule</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>mycat</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://org.opencloudb/<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tableRule</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>rule1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>rule</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>columns</span><span class="token punctuation">></span></span>user_id<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>columns</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>algorithm</span><span class="token punctuation">></span></span>func1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>algorithm</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>rule</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tableRule</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>function</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>func1<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.opencloudb.route.function.AutoPartitionByLong<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mapFile<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>autopartition-long.txt<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>function</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">mycat:</span>rule</span><span class="token punctuation">></span></span></code></pre><blockquote><p><strong>为了更好地定位错误，修改log4j.xml</strong></p><p>双击startup_nowrap.bat开始启动</p><p><strong>常见问题</strong></p><p>SHOW MASTER STATUS 如果为，则在my.ini文件中添加一行</p><p>log-bin=mysql-bin</p><p>给账号分配权限</p><p>grant all privileges on <em>.</em> to ‘root’@‘172.27.185.1’ identified by ‘root’;</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySql主从复制与读写分离&quot;&gt;&lt;a href=&quot;#MySql主从复制与读写分离&quot; class=&quot;headerlink&quot; title=&quot;MySql主从复制与读写分离&quot;&gt;&lt;/a&gt;MySql主从复制与读写分离&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;//zongmanshe
      
    
    </summary>
    
    
      <category term="MySql" scheme="http://zongmansheng.club/tags/MySql/"/>
    
      <category term="MyCat" scheme="http://zongmansheng.club/tags/MyCat/"/>
    
  </entry>
  
  <entry>
    <title>平衡二叉树、B树、B+树，B*树的区别</title>
    <link href="http://zongmansheng.club/2019/06/30/ping-heng-er-cha-shu-b-shu-b-shu-b-shu-de-qu-bie/"/>
    <id>http://zongmansheng.club/2019/06/30/ping-heng-er-cha-shu-b-shu-b-shu-b-shu-de-qu-bie/</id>
    <published>2019-06-30T07:12:33.000Z</published>
    <updated>2019-06-30T07:29:15.971Z</updated>
    
    <content type="html"><![CDATA[<h1 id="平衡二叉树、B树、B-树，B-树的区别"><a href="#平衡二叉树、B树、B-树，B-树的区别" class="headerlink" title="平衡二叉树、B树、B+树，B*树的区别"></a>平衡二叉树、B树、B+树，B*树的区别</h1><h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><blockquote><p>定义：<strong>基于</strong>二分法<strong>的策略</strong>提高数据的查找速度**的一种二叉树数据结构；</p><p><strong>特点：</strong>平衡二叉树是采用<strong>二分法</strong>思想把数据按规则组装成一个树形结构的数据，用这个树形结构的数据减少无关数据的检索，大大的提升了数据检索的速度；平衡二叉树的数据结构组装过程遵循以下规则：</p><p>（1）<strong>非叶子节点</strong>只能允许<strong>最多两个子节点</strong>存在。</p><p>（2）每一个非叶子节点数据分布规则为<strong>左边的子节点小当前节点的值</strong>，<strong>右边的子节点大于当前节点的值</strong>(这里值是基于自己的算法规则而定的，比如hash值)；</p></blockquote><p><img src="//zongmansheng.club/2019/06/30/ping-heng-er-cha-shu-b-shu-b-shu-b-shu-de-qu-bie/001.png" alt></p><blockquote><p>平衡树的层级结构：因为平衡二叉树<strong>查询复杂度</strong>和<strong>树的层级（h高度）</strong>成反比，h值越小查询越快，为了保证树的左右两端数据大致平衡以<strong>降低二叉树的查询难度</strong>一般会采用一种算法机制实现<strong>节点数据结构的平</strong>衡，实现了这种算法的有比如<strong>AVL</strong>、<strong>Treap</strong>、<strong>红黑树</strong>等，使用平衡二叉树能保证数据的<strong>左右两边的节点层级相差不会大于1</strong>，这样可以避免树形结构由于删除增加变成线性链表进而影响查询效率。保证数据平衡的情况下查找数据的速度近于二分法查找。</p></blockquote><h5 id="总结平衡二叉树特点："><a href="#总结平衡二叉树特点：" class="headerlink" title="总结平衡二叉树特点："></a>总结平衡二叉树特点：</h5><blockquote><ol><li>非叶子节点最多拥有两个子节点；</li><li>非叶子节值大于左边子节点、小于右边子节点；</li><li>树的左右两边的层级数相差不会大于1;</li><li>没有值相等重复的节点;</li></ol></blockquote><h4 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h4><blockquote><p>定义：B树和平衡二叉树稍有不同的是B树属于<strong>多叉树</strong>又名<strong>平衡多路查找树</strong>（查找路径不只两个），<strong>数据库索引</strong>技术里大量使用者B树和B+树的数据结构</p></blockquote><h5 id="规则："><a href="#规则：" class="headerlink" title="规则："></a>规则：</h5><blockquote><ol><li><strong>排序方式</strong>：所有节点关键字是按<strong>递增次序</strong>排列，并遵循<strong>左小右大</strong>原则；</li><li><strong>子节点数</strong>：非叶节点的<strong>子节点数&gt;1</strong>，且<strong>&lt;=M （M&gt;=2）</strong>，空树除外（注：M阶代表一个树节点最多有多少个查找路径，M=M路,当M=2则是2叉树,M=3则是3叉）；</li><li><strong>关键字数</strong>：枝节点的<strong>关键字数量</strong>大于等于ceil(m/2)-1个且小于等于M-1个（注：ceil()是个朝正无穷方向取整的函数 如ceil(1.1)结果为2);</li><li>所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null对应下图最后一层节点的空格子;</li></ol><p>示意图如下图所示，这里假设字母的排序规则为A&gt;B&gt;C…：</p></blockquote><p><img src="//zongmansheng.club/2019/06/30/ping-heng-er-cha-shu-b-shu-b-shu-b-shu-de-qu-bie/002.png" alt></p><blockquote><p>如上图我要从上图中找到E，查找流程如下</p><ol><li>获取根节点的关键字进行比较，当前根节点关键字为M，E&lt;M，所以往找到指向左边的子节点（二分法规则，左小右大，左边放小于当前节点值的子节点、右边放大于当前节点值的子节点）；</li><li>拿到关键字D和G，D&lt;E&lt;G 所以直接找到D和G中间的节点；</li><li>拿到E和F，因为E=E 所以直接返回关键字和指针信息（如果树结构里面没有包含所要查找的节点则返回null）；</li></ol></blockquote><h4 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h4><blockquote><p><strong>概念：</strong>B+树是B树的一个升级版，相对于B树来说B+树更充分的利用了节点的空间，让查询速度更加稳定，其速度完全接近于二分法查找。为什么说B+树查找的效率要比B树更高、更稳定；</p></blockquote><p><img src="//zongmansheng.club/2019/06/30/ping-heng-er-cha-shu-b-shu-b-shu-b-shu-de-qu-bie/003.png" alt></p><blockquote><p>如上图所示，我们看看B+树遵循的规则：</p><ol><li>B+跟B树不同之处在于B+树的<strong>非叶子</strong>节点不保存关键字记录的指针，只进行数据索引，即有k个子树的中间节点包含有k个元素，而B树中是k-1个元素，这样使得B+树每个<strong>非叶子</strong>节点所能保存的关键字大大增加；</li><li>B+树<strong>叶子</strong>节点保存了父节点的所有关键字记录的指针，所有数据地址必须要到叶子节点才能获取到，所以<strong>每次数据查询的次数都一样</strong>；</li><li>B+树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针（如图中红色虚线框中所示）。</li><li>所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素(如图中黑色和红色标出的数字)</li><li>非叶子节点的子节点数=关键字数，另一种规则是非叶节点的关键字数=子节点数-1，虽然这两种规则数据排列结构不一样，但其原理还是一样的<strong>Mysql 的B+树是用第一种方式实现</strong>;</li></ol><p>可能有的读者对上面的第1点不太理解，从图上看B树和B+树的节点中都是数字啊，有什么不一样，为什么说B+树的非叶子节点不保存关键字记录的指针？这里引入一个<strong>“卫星数据”</strong>的概念来给大家解释，所谓卫星数据，指的是<strong>索引元素所指向的数据记录</strong>，也就是我们这里说的<strong>“关键字记录的指针”</strong>，比如数据库中的某一行。在B树中，无论中间节点还是叶子节点都带有卫星数据，而B+树只有叶子节点才带有卫星数据，我们来给一张对比图：</p></blockquote><p><img src="//zongmansheng.club/2019/06/30/ping-heng-er-cha-shu-b-shu-b-shu-b-shu-de-qu-bie/004.png" alt></p><p><img src="//zongmansheng.club/2019/06/30/ping-heng-er-cha-shu-b-shu-b-shu-b-shu-de-qu-bie/005.png" alt></p><blockquote><p>从上面两幅图就可以就看出，B树的每一个节点都有一个<strong>“关键字记录的指针”</strong>（即图中的data部分），而B+树只有叶子节点才有。</p><p><strong>特点：</strong></p><p>1、B+<strong>树的层级更少</strong>：相较于B树B+每个<strong>非叶子</strong>节点存储的关键字数更多，树的层级更少所以查询数据更快；</p><p>2、B+<strong>树查询速度更稳定</strong>：B+所有关键字数据地址都存在<strong>叶子</strong>节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;</p><p>3、B+<strong>树天然具备排序功能：</strong>B+树所有的<strong>叶子</strong>节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。</p><p>4、B+<strong>树全节点遍历更快：</strong>B+树遍历整棵树只需要遍历所有的<strong>叶子</strong>节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。</p><p><strong>B树</strong>相对于<strong>B+树</strong>的优点是，如果经常访问的数据离根节点很近，而<strong>B树</strong>的<strong>非叶子</strong>节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比<strong>B+树</strong>快</p></blockquote><p><img src="//zongmansheng.club/2019/06/30/ping-heng-er-cha-shu-b-shu-b-shu-b-shu-de-qu-bie/006.png" alt></p><blockquote><p>规则：B*树是B+树的变种，相对于B+树他们的不同之处如下：</p><ol><li>首先是关键字个数限制问题，B+树初始化的关键字初始化个数是ceil(m/2)，b*树的初始化个数为$ceil(rac{2}{3}m)$</li><li>B<em>树中**</em>非根<strong><em>和</em></strong>非叶子结点<em>**增加\</em>指向兄弟的指针*，如上图的红色箭头所示。</li><li>B+树节点满时就会分裂，而B<em>树节点满时会**</em>检查兄弟节点是否满<em>**（因为每个节点都有指向兄弟的指针），如果兄弟节点未满则向兄弟节点转移关键字，如果兄弟节点已满，则\</em>从当前节点和兄弟节点各拿出1/3的数据创建一个新的节点出来*；</li></ol><p>特点：</p><p>在B+树的基础上因其初始化的容量变大，使得节点空间使用率更高，而又存有兄弟节点的指针，可以向兄弟节点转移关键字的特性使得B*树的分解次数变得更少；</p></blockquote><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote><p><strong>1、相同思想和策略</strong></p><p>从平衡二叉树、B树、B+树、B*树总体来看它们的贯彻的思想是相同的，都是采用二分法和数据平衡策略来提升查找数据的速度；</p><p><strong>2、不同的方式的磁盘空间利用</strong></p><p>不同点是他们一个一个在演变的过程中通过IO从磁盘读取数据的原理进行一步步的演变，每一次演变都是为了让节点的空间更合理的运用起来，从而使树的层级减少达到快速查找数据的目的；</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;平衡二叉树、B树、B-树，B-树的区别&quot;&gt;&lt;a href=&quot;#平衡二叉树、B树、B-树，B-树的区别&quot; class=&quot;headerlink&quot; title=&quot;平衡二叉树、B树、B+树，B*树的区别&quot;&gt;&lt;/a&gt;平衡二叉树、B树、B+树，B*树的区别&lt;/h1&gt;&lt;h4 i
      
    
    </summary>
    
      <category term="日常学习" scheme="http://zongmansheng.club/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="平衡二叉树 B树 B+树" scheme="http://zongmansheng.club/tags/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91-B%E6%A0%91-B-%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Java8之lambda表达式</title>
    <link href="http://zongmansheng.club/2019/06/17/java8-zhi-lambda-biao-da-shi/"/>
    <id>http://zongmansheng.club/2019/06/17/java8-zhi-lambda-biao-da-shi/</id>
    <published>2019-06-17T12:24:29.000Z</published>
    <updated>2019-06-17T14:56:26.253Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><h4 id="一、java重要的函数式接口"><a href="#一、java重要的函数式接口" class="headerlink" title="一、java重要的函数式接口"></a>一、java重要的函数式接口</h4><h5 id="1、什么是函数式接口"><a href="#1、什么是函数式接口" class="headerlink" title="1、什么是函数式接口"></a><strong>1、什么是函数式接口</strong></h5><pre><code>        函数接口是只有一个抽象方法的接口，用作 Lambda 表达式的类型。使用@FunctionalInterface注解修饰的类，编译器会检测该类是否只有一个抽象方法或接口，否则，会报错。可以有多个默认方法，静态方法。</code></pre><h5 id="2、Java8将函数式接口封装到流中如何高效的帮助我们处理集合。"><a href="#2、Java8将函数式接口封装到流中如何高效的帮助我们处理集合。" class="headerlink" title="2、Java8将函数式接口封装到流中如何高效的帮助我们处理集合。"></a>2、Java8将函数式接口封装到流中如何高效的帮助我们处理集合。</h5><pre><code>本篇所有示例都基于以下三个类。OutstandingClass：班级；Student：学生；SpecialityEnum：特长。</code></pre><p><img src="//zongmansheng.club/2019/06/17/java8-zhi-lambda-biao-da-shi/001.png" alt="001"></p><h6 id="2-1-惰性求值与及早求值"><a href="#2-1-惰性求值与及早求值" class="headerlink" title="2.1 惰性求值与及早求值"></a><strong>2.1 惰性求值与及早求值</strong></h6><pre><code>惰性求值：只描述Stream，操作的结果也是Stream，这样的操作称为惰性求值。惰性求值可以像建造者模式一样链式使用，最后再使用及早求值得到最终结果。及早求值：得到最终的结果而不是Stream，这样的操作称为及早求值</code></pre><h6 id="3、常用的流"><a href="#3、常用的流" class="headerlink" title="3、常用的流"></a>3、常用的流</h6><p>3.1 collect(Collectors.toList())</p><pre><code>将流转换为list。还有toSet()，toMap()等。及早求值。</code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019-06-17 * @Time: 21:26 * @Vsersion: 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestCase</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>Student<span class="token operator">></span> studentList <span class="token operator">=</span> Stream<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"路飞"</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">185</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"红发"</span><span class="token punctuation">,</span><span class="token number">34</span><span class="token punctuation">,</span><span class="token number">178</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"白胡子"</span><span class="token punctuation">,</span><span class="token number">32</span><span class="token punctuation">,</span><span class="token number">189</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>studentList<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>3.2 filter</p><pre><code>顾名思义，起过滤筛选的作用。内部就是Predicate接口。惰性求值。</code></pre><pre><code>比如我们筛选出出身高小于180的同学。</code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019-06-17 * @Time: 22:32 * @Vsersion: 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test02</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>Student<span class="token operator">></span> students <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        students<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"路飞"</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">175</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        students<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"红发"</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">180</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        students<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"白胡子"</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">185</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>Student<span class="token operator">></span> list <span class="token operator">=</span> students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>student <span class="token operator">-</span><span class="token operator">></span> student<span class="token punctuation">.</span><span class="token function">getStature</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token number">180</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>3.3 map</p><pre><code>转换功能，内部就是Function接口。惰性求值</code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019-06-17 * @Time: 22:47 * @Vsersion: 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test03</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>Student<span class="token operator">></span> students <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        students<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"路飞"</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">175</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        students<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"红发"</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">180</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        students<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"白胡子"</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">185</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>String<span class="token operator">></span> names <span class="token operator">=</span> students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>student <span class="token operator">-</span><span class="token operator">></span> student<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>names<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>3.4 flatMap</p><pre><code>将多个Stream合并为一个Stream。惰性求值</code></pre><p><img src="//zongmansheng.club/2019/06/17/java8-zhi-lambda-biao-da-shi/004.png" alt="004"></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019-06-17 * @Time: 22:51 * @Vsersion: 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test04</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>Student<span class="token operator">></span> students <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        students<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"路飞"</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">175</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        students<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"红发"</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">180</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        students<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"白胡子"</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">185</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>Student<span class="token operator">></span> studentList <span class="token operator">=</span> Stream<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>students<span class="token punctuation">,</span>                <span class="token function">asList</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"艾斯"</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">,</span> <span class="token number">183</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                        <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"雷利"</span><span class="token punctuation">,</span> <span class="token number">48</span><span class="token punctuation">,</span> <span class="token number">176</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span>students1 <span class="token operator">-</span><span class="token operator">></span> students1<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>studentList<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>调用Stream.of的静态方法将两个list转换为Stream，再通过flatMap将两个流合并为一个。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Lambda表达式&quot;&gt;&lt;a href=&quot;#Lambda表达式&quot; class=&quot;headerlink&quot; title=&quot;Lambda表达式&quot;&gt;&lt;/a&gt;Lambda表达式&lt;/h1&gt;&lt;h4 id=&quot;一、java重要的函数式接口&quot;&gt;&lt;a href=&quot;#一、java重要的函数
      
    
    </summary>
    
      <category term="日常学习" scheme="http://zongmansheng.club/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Lambda" scheme="http://zongmansheng.club/tags/Lambda/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://zongmansheng.club/2019/06/09/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/"/>
    <id>http://zongmansheng.club/2019/06/09/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/</id>
    <published>2019-06-09T14:21:10.521Z</published>
    <updated>2019-04-26T13:16:33.055Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL事务及ACID特性的实现原理"><a href="#MySQL事务及ACID特性的实现原理" class="headerlink" title="MySQL事务及ACID特性的实现原理"></a>MySQL事务及ACID特性的实现原理</h1><h4 id="一、MySQL-事务基础概念"><a href="#一、MySQL-事务基础概念" class="headerlink" title="一、MySQL 事务基础概念"></a>一、MySQL 事务基础概念</h4><blockquote><p>​    事务(Transaction)是访问和更新数据库的程序执行单元;事务中可能包含一个或多个 sql 语句，这些语句要么都执行，要么都不执行。</p></blockquote><blockquote><p>​    作为一个关系型数据库，MySQL 支持事务，本文介绍基于 MySQL 5.6。首先回顾一下 MySQL 事务的基础知识。</p></blockquote><h4 id="二、逻辑架构和存储引擎"><a href="#二、逻辑架构和存储引擎" class="headerlink" title="二、逻辑架构和存储引擎"></a>二、逻辑架构和存储引擎</h4><p><img src="//zongmansheng.club/2019/06/09/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/001.jpg" alt="001"></p><blockquote><p>如上图所示，MySQL 服务器逻辑架构从上往下可以分为三层：</p></blockquote><p>++++</p><ul><li>第一层：处理客户端连接、授权认证等。</li><li>第二层：服务器层，负责查询语句的解析、优化、缓存以及内置函数的实现、存储过程等。</li><li>第三层：存储引擎，负责 MySQL 中数据的存储和提取。MySQL 中服务器层不管理事务，事务是由存储引擎实现的。</li></ul><blockquote><p>MySQL 支持事务的存储引擎有 InnoDB、NDB Cluster 等，其中 InnoDB 的使用最为广泛;其他存储引擎不支持事务，如 MyIsam、Memory 等。</p></blockquote><blockquote><p>如无特殊说明，后文中描述的内容都是基于 InnoDB。</p></blockquote><h4 id="三、提交和回滚"><a href="#三、提交和回滚" class="headerlink" title="三、提交和回滚"></a>三、提交和回滚</h4><blockquote><p>典型的 MySQL 事务是如下操作的：</p></blockquote><pre class=" language-java"><code class="language-java">start transaction<span class="token punctuation">;</span> …… #一条或多条sql语句 commit<span class="token punctuation">;</span> </code></pre><blockquote><p>其中 start transaction 标识事务开始，commit 提交事务，将执行结果写入到数据库。</p></blockquote><blockquote><p>如果 sql 语句执行出现问题，会调用 rollback，回滚所有已经执行成功的 sql 语句。当然，也可以在事务中直接使用 rollback 语句进行回滚。</p></blockquote><h4 id="四、自动提交"><a href="#四、自动提交" class="headerlink" title="四、自动提交"></a>四、自动提交</h4><blockquote><p>MySQL 中默认采用的是自动提交(autocommit)模式，如下所示：</p></blockquote><p><img src="//zongmansheng.club/2019/06/09/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/002.jpg" alt="002"></p><blockquote><p>在自动提交模式下，如果没有 start transaction 显式地开始一个事务，那么每个 sql 语句都会被当做一个事务执行提交操作。</p></blockquote><blockquote><p>通过如下方式，可以关闭 autocommit;需要注意的是，autocommit 参数是针对连接的，在一个连接中修改了参数，不会对其他连接产生影响。</p></blockquote><blockquote><p><img src="//zongmansheng.club/2019/06/09/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/003.jpg" alt="003"></p></blockquote><blockquote><p>如果关闭了 autocommit，则所有的 sql 语句都在一个事务中，直到执行了 commit 或 rollback，该事务结束，同时开始了另外一个事务。</p></blockquote><h4 id="五、特殊操作"><a href="#五、特殊操作" class="headerlink" title="五、特殊操作"></a>五、特殊操作</h4><blockquote><p>在 MySQL 中，存在一些特殊的命令，如果在事务中执行了这些命令，会马上强制执行 commit 提交事务;如 DDL 语句(create table/drop table/alter/table)、lock tables 语句等等。</p></blockquote><blockquote><p>不过，常用的 select、insert、update 和 delete 命令，都不会强制提交事务。</p></blockquote><h4 id="六、ACID-特性"><a href="#六、ACID-特性" class="headerlink" title="六、ACID 特性"></a>六、ACID 特性</h4><blockquote><p>ACID 是衡量事务的四个特性：</p></blockquote><ul><li><strong>原子性(Atomicity，或称不可分割性)</strong></li><li><strong>一致性(Consistency)</strong></li><li><strong>隔离性(Isolation)</strong></li><li><strong>持久性(Durability)</strong></li></ul><blockquote><p>按照严格的标准，只有同时满足 ACID 特性才是事务;但是在各大数据库厂商的实现中，真正满足 ACID 的事务少之又少。</p></blockquote><blockquote><p>例如 MySQL 的 NDB Cluster 事务不满足持久性和隔离性;InnoDB 默认事务隔离级别是可重复读，不满足隔离性;Oracle 默认的事务隔离级别为 READ COMMITTED，不满足隔离性……</p></blockquote><blockquote><p>因此与其说 ACID 是事务必须满足的条件，不如说它们是衡量事务的四个维度。</p></blockquote><blockquote><p>下面将详细介绍 ACID 特性及其实现原理，为了便于理解，介绍的顺序不是严格按照 A-C-I-D。</p></blockquote><h4 id="七、ACID-特性及其实现原理"><a href="#七、ACID-特性及其实现原理" class="headerlink" title="七、ACID 特性及其实现原理"></a>七、ACID 特性及其实现原理</h4><h5 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a><strong>原子性</strong></h5><p><strong>定义</strong></p><blockquote><p>原子性是指一个事务是一个不可分割的工作单位，其中的操作要么都做，要么都不做。</p></blockquote><blockquote><p>如果事务中一个 sql 语句执行失败，则已执行的语句也必须回滚，数据库退回到事务前的状态。</p></blockquote><p><strong>实现原理：undo log</strong></p><blockquote><p>在说明原子性原理之前，首先介绍一下 MySQL 的事务日志。MySQL 的日志有很多种，如二进制日志、错误日志、查询日志、慢查询日志等。</p></blockquote><blockquote><p>此外 InnoDB 存储引擎还提供了两种事务日志：</p></blockquote><ul><li><strong>redo log(重做日志)</strong></li><li><strong>undo log(回滚日志)</strong></li></ul><blockquote><p>其中 redo log 用于保证事务持久性;undo log 则是事务原子性和隔离性实现的基础。</p></blockquote><blockquote><p>下面说回 undo log。实现原子性的关键，是当事务回滚时能够撤销所有已经成功执行的 sql 语句。</p></blockquote><blockquote><p>InnoDB 实现回滚，靠的是 undo log：</p></blockquote><ul><li>当事务对数据库进行修改时，InnoDB 会生成对应的 undo log。</li><li>如果事务执行失败或调用了 rollback，导致事务需要回滚，便可以利用 undo log 中的信息将数据回滚到修改之前的样子。</li></ul><blockquote><p>undo log 属于逻辑日志，它记录的是 sql 执行相关的信息。当发生回滚时，InnoDB 会根据 undo log 的内容做与之前相反的工作：</p></blockquote><ul><li>对于每个 insert，回滚时会执行 delete。</li><li>对于每个 delete，回滚时会执行 insert。</li><li>对于每个 update，回滚时会执行一个相反的 update，把数据改回去。</li></ul><blockquote><p>以 update 操作为例：当事务执行 update 时，其生成的 undo log 中会包含被修改行的主键(以便知道修改了哪些行)、修改了哪些列、这些列在修改前后的值等信息，回滚时便可以使用这些信息将数据还原到 update 之前的状态。</p></blockquote><h5 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a><strong>持久性</strong></h5><p><strong>定义</strong></p><blockquote><p>持久性是指事务一旦提交，它对数据库的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。</p></blockquote><p><strong>实现原理：redo log</strong></p><blockquote><p>redo log 和 undo log 都属于 InnoDB 的事务日志。下面先聊一下 redo log 存在的背景。</p></blockquote><blockquote><p>InnoDB 作为 MySQL 的存储引擎，数据是存放在磁盘中的，但如果每次读写数据都需要磁盘 IO，效率会很低。</p></blockquote><blockquote><p>为此，InnoDB 提供了缓存(Buffer Pool)，Buffer Pool 中包含了磁盘中部分数据页的映射，作为访问数据库的缓冲：</p></blockquote><ul><li>当从数据库读取数据时，会首先从 Buffer Pool 中读取，如果 Buffer Pool 中没有，则从磁盘读取后放入 Buffer Pool。</li><li>当向数据库写入数据时，会首先写入 Buffer Pool，Buffer Pool 中修改的数据会定期刷新到磁盘中(这一过程称为刷脏)。</li></ul><blockquote><p>Buffer Pool 的使用大大提高了读写数据的效率，但是也带来了新的问题：如果 MySQL 宕机，而此时 Buffer Pool 中修改的数据还没有刷新到磁盘，就会导致数据的丢失，事务的持久性无法保证。</p></blockquote><blockquote><p>于是，redo log 被引入来解决这个问题：当数据修改时，除了修改 Buffer Pool 中的数据，还会在 redo log 记录这次操作;当事务提交时，会调用 fsync 接口对 redo log 进行刷盘。</p></blockquote><blockquote><p>如果 MySQL 宕机，重启时可以读取 redo log 中的数据，对数据库进行恢复。</p></blockquote><blockquote><p>redo log 采用的是 WAL(Write-ahead logging，预写式日志)，所有修改先写入日志，再更新到 Buffer Pool，保证了数据不会因 MySQL 宕机而丢失，从而满足了持久性要求。</p></blockquote><blockquote><p>既然 redo log 也需要在事务提交时将日志写入磁盘，为什么它比直接将 Buffer Pool 中修改的数据写入磁盘(即刷脏)要快呢?</p></blockquote><blockquote><p>主要有以下两方面的原因：</p></blockquote><ul><li>刷脏是随机 IO，因为每次修改的数据位置随机，但写 redo log 是追加操作，属于顺序 IO。</li><li>刷脏是以数据页(Page)为单位的，MySQL 默认页大小是 16KB，一个 Page 上一个小修改都要整页写入;而 redo log 中只包含真正需要写入的部分，无效 IO 大大减少。</li></ul><p><strong>redo log 与 binlog</strong></p><blockquote><p>我们知道，在 MySQL 中还存在 binlog(二进制日志)也可以记录写操作并用于数据的恢复，但二者是有着根本的不同的。</p></blockquote><blockquote><p>作用不同：</p></blockquote><ul><li>redo log 是用于 crash recovery 的，保证 MySQL 宕机也不会影响持久性;</li><li>binlog 是用于 point-in-time recovery 的，保证服务器可以基于时间点恢复数据，此外 binlog 还用于主从复制。</li></ul><blockquote><p>层次不同：</p></blockquote><ul><li>redo log 是 InnoDB 存储引擎实现的，</li><li>而 binlog 是 MySQL 的服务器层(可以参考文章前面对 MySQL 逻辑架构的介绍)实现的，同时支持 InnoDB 和其他存储引擎。</li></ul><blockquote><p>内容不同：</p></blockquote><ul><li>redo log 是物理日志，内容基于磁盘的 Page。</li><li>binlog 是逻辑日志，内容是一条条 sql。</li></ul><blockquote><p>写入时机不同：</p></blockquote><ul><li>redo log 的写入时机相对多元。前面曾提到，当事务提交时会调用 fsync 对 redo log 进行刷盘;这是默认情况下的策略，修改 innodb_flush_log_at_trx_commit 参数可以改变该策略，但事务的持久性将无法保证。</li></ul><blockquote><p>除了事务提交时，还有其他刷盘时机：如 master thread 每秒刷盘一次 redo log 等，这样的好处是不一定要等到 commit 时刷盘，commit 速度大大加快。</p></blockquote><ul><li>binlog 在事务提交时写入。</li></ul><h5 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a><strong>隔离性</strong></h5><p><strong>定义</strong></p><blockquote><p>与原子性、持久性侧重于研究事务本身不同，隔离性研究的是不同事务之间的相互影响。</p></blockquote><blockquote><p>隔离性是指事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p></blockquote><blockquote><p>严格的隔离性，对应了事务隔离级别中的 Serializable(可串行化)，但实际应用中出于性能方面的考虑很少会使用可串行化。</p></blockquote><blockquote><p>隔离性追求的是并发情形下事务之间互不干扰。简单起见，我们仅考虑最简单的读操作和写操作(暂时不考虑带锁读等特殊操作)。</p></blockquote><blockquote><p>那么隔离性的探讨，主要可以分为两个方面：</p></blockquote><ul><li>(一个事务)写操作对(另一个事务)写操作的影响：锁机制保证隔离性。</li><li>(一个事务)写操作对(另一个事务)读操作的影响：MVCC 保证隔离性。</li></ul><h5 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a><strong>锁机制</strong></h5><blockquote><p>首先来看两个事务的写操作之间的相互影响。隔离性要求同一时刻只能有一个事务对数据进行写操作，InnoDB 通过锁机制来保证这一点。</p></blockquote><blockquote><p>锁机制的基本原理可以概括为：</p></blockquote><ul><li>事务在修改数据之前，需要先获得相应的锁。</li><li>获得锁之后，事务便可以修改数据。</li><li>该事务操作期间，这部分数据是锁定的，其他事务如果需要修改数据，需要等待当前事务提交或回滚后释放锁。</li></ul><blockquote><p>行锁与表锁：按照粒度，锁可以分为表锁、行锁以及其他位于二者之间的锁。</p></blockquote><blockquote><p>表锁在操作数据时会锁定整张表，并发性能较差;行锁则只锁定需要操作的数据，并发性能好。</p></blockquote><blockquote><p>但是由于加锁本身需要消耗资源(获得锁、检查锁、释放锁等都需要消耗资源)，因此在锁定数据较多情况下使用表锁可以节省大量资源。</p></blockquote><blockquote><p>MySQL 中不同的存储引擎支持的锁是不一样的，例如 MyIsam 只支持表锁，而 InnoDB 同时支持表锁和行锁，且出于性能考虑，绝大多数情况下使用的都是行锁。</p></blockquote><blockquote><p>如何查看锁信息?有多种方法可以查看 InnoDB 中锁的情况，例如：</p></blockquote><pre class=" language-mysql"><code class="language-mysql">select * from information_schema.innodb_locks; #锁的概况 show engine innodb status; #InnoDB整体状态，其中包括锁的情况 </code></pre><p>下面来看一个例子：</p><pre class=" language-mysql"><code class="language-mysql">#在事务A中执行： start transaction; update account SET balance = 1000 where id = 1; 在事务B中执行： start transaction; update account SET balance = 2000 where id = 1; </code></pre><p>此时查看锁的情况：</p><p><img src="//zongmansheng.club/2019/06/09/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/004.jpg" alt="004"></p><p>show engine innodb status 查看锁相关的部分：</p><p><img src="//zongmansheng.club/2019/06/09/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/005.jpg" alt="005"></p><blockquote><p>通过上述命令可以查看事务 24052 和 24053 占用锁的情况;其中 lock_type 为 RECORD，代表锁为行锁(记录锁);lock_mode 为 X，代表排它锁(写锁)。</p></blockquote><blockquote><p>除了排它锁(写锁)之外，MySQL 中还有共享锁(读锁)的概念。由于本文重点是 MySQL 事务的实现原理，因此对锁的介绍到此为止。</p></blockquote><blockquote><p>介绍完写操作之间的相互影响，下面讨论写操作对读操作的影响。</p></blockquote><h5 id="脏读、不可重复读和幻读"><a href="#脏读、不可重复读和幻读" class="headerlink" title="脏读、不可重复读和幻读"></a><strong>脏读、不可重复读和幻读</strong></h5><blockquote><p>首先来看并发情况下，读操作可能存在的三类问题。</p></blockquote><blockquote><p>①脏读：当前事务(A)中可以读到其他事务(B)未提交的数据(脏数据)，这种现象是脏读。</p></blockquote><p>举例如下(以账户余额表为例)：</p><p><img src="//zongmansheng.club/2019/06/09/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/006.jpg" alt="006"></p><blockquote><p>②不可重复读：在事务 A 中先后两次读取同一个数据，两次读取的结果不一样，这种现象称为不可重复读。</p></blockquote><blockquote><p>脏读与不可重复读的区别在于：前者读到的是其他事务未提交的数据，后者读到的是其他事务已提交的数据。</p></blockquote><p>举例如下：</p><p><img src="//zongmansheng.club/2019/06/09/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/007.jpg" alt="007"></p><blockquote><p>③幻读：在事务 A 中按照某个条件先后两次查询数据库，两次查询结果的条数不同，这种现象称为幻读。</p></blockquote><blockquote><p>不可重复读与幻读的区别可以通俗的理解为：前者是数据变了，后者是数据的行数变了。</p></blockquote><p>举例如下：</p><p><img src="//zongmansheng.club/2019/06/09/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/008.jpg" alt="008"></p><h5 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a><strong>事务隔离级别</strong></h5><blockquote><p>sql 标准中定义了四种隔离级别，并规定了每种隔离级别下上述几个问题是否存在。</p></blockquote><blockquote><p>一般来说，隔离级别越低，系统开销越低，可支持的并发越高，但隔离性也越差。</p></blockquote><blockquote><p>隔离级别与读问题的关系如下：</p></blockquote><p><img src="//zongmansheng.club/2019/06/09/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/009.jpg" alt="009"></p><blockquote><p>在实际应用中，读未提交在并发时会导致很多问题，而性能相对于其他隔离级别提高却很有限，因此使用较少。</p></blockquote><blockquote><p>可串行化强制事务串行，并发效率很低，只有当对数据一致性要求极高且可以接受没有并发时使用，因此使用也较少。</p></blockquote><blockquote><p>因此在大多数数据库系统中，默认的隔离级别是读已提交(如 Oracle)或可重复读(后文简称 RR)。</p></blockquote><blockquote><p>可以通过如下两个命令分别查看全局隔离级别和本次会话的隔离级别：</p></blockquote><p><img src="//zongmansheng.club/2019/06/09/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/010.jpg" alt="010"></p><h4 id="八、MVCC"><a href="#八、MVCC" class="headerlink" title="八、MVCC"></a>八、MVCC</h4><blockquote><p>RR 解决脏读、不可重复读、幻读等问题，使用的是 MVCC：MVCC 全称 Multi-Version Concurrency Control，即多版本的并发控制协议。</p></blockquote><blockquote><p>下面的例子很好的体现了 MVCC 的特点：在同一时刻，不同的事务读取到的数据可能是不同的(即多版本)——在 T5 时刻，事务 A 和事务 C 可以读取到不同版本的数据。</p></blockquote><p><img src="//zongmansheng.club/2019/06/09/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/011.jpg" alt="011"></p><blockquote><p>MVCC 最大的优点是读不加锁，因此读写不冲突，并发性能好。InnoDB 实现 MVCC，多个版本的数据可以共存，主要是依靠数据的隐藏列(也可以称之为标记位)和 undo log。</p></blockquote><blockquote><p>其中数据的隐藏列包括了该行数据的版本号、删除时间、指向 undo log 的指针等等。</p></blockquote><blockquote><p>当读取数据时，MySQL 可以通过隐藏列判断是否需要回滚并找到回滚需要的 undo log，从而实现 MVCC;隐藏列的详细格式不再展开。</p></blockquote><blockquote><p>下面结合前文提到的几个问题分别说明。</p></blockquote><h5 id="①脏读"><a href="#①脏读" class="headerlink" title="①脏读"></a><strong>①脏读</strong></h5><p><img src="//zongmansheng.club/2019/06/09/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/012.jpg" alt="012"></p><blockquote><p>当事务 A 在 T3 时间节点读取 zhangsan 的余额时，会发现数据已被其他事务修改，且状态为未提交。</p></blockquote><blockquote><p>此时事务 A 读取最新数据后，根据数据的 undo log 执行回滚操作，得到事务 B 修改前的数据，从而避免了脏读。</p></blockquote><h5 id="②不可重复读"><a href="#②不可重复读" class="headerlink" title="②不可重复读"></a>②不可重复读</h5><p><img src="//zongmansheng.club/2019/06/09/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/013.jpg" alt="013"></p><blockquote><p>当事务 A 在 T2 节点第一次读取数据时，会记录该数据的版本号(数据的版本号是以 row 为单位记录的)，假设版本号为 1;当事务 B 提交时，该行记录的版本号增加，假设版本号为 2。</p></blockquote><blockquote><p>当事务 A 在 T5 再一次读取数据时，发现数据的版本号(2)大于第一次读取时记录的版本号(1)，因此会根据 undo log 执行回滚操作，得到版本号为 1 时的数据，从而实现了可重复读。</p></blockquote><h5 id="③幻读"><a href="#③幻读" class="headerlink" title="③幻读"></a>③幻读</h5><blockquote><p>InnoDB 实现的 RR 通过 next-keylock 机制避免了幻读现象。</p></blockquote><blockquote><p>next-keylock 是行锁的一种，实现相当于 record lock(记录锁) + gap lock(间隙锁);其特点是不仅会锁住记录本身(record lock 的功能)，还会锁定一个范围(gap lock 的功能)。</p></blockquote><blockquote><p>当然，这里我们讨论的是不加锁读：此时的 next-key lock 并不是真的加锁，只是为读取的数据增加了标记(标记内容包括数据的版本号等);准确起见姑且称之为类 next-key lock 机制。</p></blockquote><blockquote><p>还是以前面的例子来说明：</p></blockquote><p><img src="//zongmansheng.club/2019/06/09/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/014.jpg" alt="014"></p><blockquote><p>当事务 A 在 T2 节点第一次读取 0</p></blockquote><blockquote><p>这样当 T5 时刻再次读取 0</p></blockquote><blockquote><p>小结：概括来说，InnoDB 实现的 RR，通过锁机制、数据的隐藏列、undo log 和类 next-key lock，实现了一定程度的隔离性，可以满足大多数场景的需要。</p></blockquote><blockquote><p>不过需要说明的是，RR 虽然避免了幻读问题，但是毕竟不是 Serializable，不能保证完全的隔离。</p></blockquote><blockquote><p>下面是一个例子，大家可以自己验证一下：</p></blockquote><p><img src="//zongmansheng.club/2019/06/09/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/015.jpg" alt="015"></p><p><strong>一致性</strong></p><p><strong>基本概念</strong></p><p>一致性是指事务执行结束后，数据库的完整性约束没有被破坏，事务执行的前后都是合法的数据状态。</p><p>数据库的完整性约束包括但不限于：</p><ul><li>实体完整性(如行的主键存在且唯一)</li><li>列完整性(如字段的类型、大小、长度要符合要求)</li><li>外键约束</li><li>用户自定义完整性(如转账前后，两个账户余额的和应该不变)</li></ul><p><strong>实现</strong></p><p>可以说，一致性是事务追求的最终目标：前面提到的原子性、持久性和隔离性，都是为了保证数据库状态的一致性。此外，除了数据库层面的保障，一致性的实现也需要应用层面进行保障。</p><p>实现一致性的措施包括：</p><ul><li>保证原子性、持久性和隔离性，如果这些特性无法保证，事务的一致性也无法保证。</li><li>数据库本身提供保障，例如不允许向整形列插入字符串值、字符串长度不能超过列的限制等。</li><li>应用层面进行保障，例如如果转账操作只扣除转账者的余额，而没有增加接收者的余额，无论数据库实现的多么完美，也无法保证状态的一致。</li></ul><p><strong>总结</strong></p><p>下面总结一下 ACID 特性及其实现原理：</p><ul><li>原子性：语句要么全执行，要么全不执行，是事务最核心的特性。事务本身就是以原子性来定义的;实现主要基于 undo log。</li><li>持久性：保证事务提交后不会因为宕机等原因导致数据丢失;实现主要基于 redo log。</li><li>隔离性：保证事务执行尽可能不受其他事务影响;InnoDB 默认的隔离级别是 RR，RR 的实现主要基于锁机制、数据的隐藏列、undo log 和类 next-key lock 机制。</li><li>一致性：事务追求的最终目标，一致性的实现既需要数据库层面的保障，也需要应用层面的保障。</li></ul><h4 id="九、参考文献："><a href="#九、参考文献：" class="headerlink" title="九、参考文献："></a>九、参考文献：</h4><ul><li>《MySQL 技术内幕：InnoDB 存储引擎》</li><li>《高性能 MySQL》</li><li>《MySQL 运维内参》</li><li><a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_acid" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_acid</a></li><li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-next-key-locking.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.6/en/innodb-next-key-locking.html</a></li><li><a href="http://blog.sina.com.cn/s/blog_499740cb0100ugs7.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_499740cb0100ugs7.html</a></li><li><a href="https://mp.weixin.qq.com/s/2dwGBTmu_da2x-HiHlN0vw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/2dwGBTmu_da2x-HiHlN0vw</a></li><li><a href="http://www.cnblogs.com/chenpingzhao/p/5065316.html" target="_blank" rel="noopener">http://www.cnblogs.com/chenpingzhao/p/5065316.html</a></li><li><a href="https://juejin.im/entry/5ba0a254e51d450e735e4a1f" target="_blank" rel="noopener">https://juejin.im/entry/5ba0a254e51d450e735e4a1f</a></li><li><a href="http://hedengcheng.com/?p=771" target="_blank" rel="noopener">http://hedengcheng.com/?p=771</a></li></ul><p>转发自：<a href="https://www.toutiao.com/i6651767011648995843/" target="_blank" rel="noopener">https://www.toutiao.com/i6651767011648995843/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL事务及ACID特性的实现原理&quot;&gt;&lt;a href=&quot;#MySQL事务及ACID特性的实现原理&quot; class=&quot;headerlink&quot; title=&quot;MySQL事务及ACID特性的实现原理&quot;&gt;&lt;/a&gt;MySQL事务及ACID特性的实现原理&lt;/h1&gt;&lt;h4 i
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>建造者模式</title>
    <link href="http://zongmansheng.club/2019/05/10/jian-zao-zhe-mo-shi/"/>
    <id>http://zongmansheng.club/2019/05/10/jian-zao-zhe-mo-shi/</id>
    <published>2019-05-10T12:09:32.000Z</published>
    <updated>2019-05-10T12:49:46.035Z</updated>
    
    <content type="html"><![CDATA[<h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><h4 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h4><blockquote><p><strong>意图：</strong>将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</p><p><strong>主要解决：</strong>主要解决在软件系统中，有时候面临着”一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。</p><p><strong>何时使用：</strong>一些基本部件不会变，而其组合经常变化的时候。</p><p><strong>如何解决：</strong>将变与不变分离开。</p><p><strong>关键代码：</strong>建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。</p><p><strong>应用实例：</strong> 1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的”套餐”。</p></blockquote><h4 id="二、JAVA-中的-StringBuilder"><a href="#二、JAVA-中的-StringBuilder" class="headerlink" title="二、JAVA 中的 StringBuilder"></a>二、JAVA 中的 StringBuilder</h4><blockquote><p><strong>优点：</strong> 1、建造者独立，易扩展。 2、便于控制细节风险。 </p><p><strong>缺点：</strong> 1、产品必须有共同点，范围有限制。 2、如内部变化复杂，会有很多的建造类。 </p><p><strong>使用场景：</strong> 1、需要生成的对象具有复杂的内部结构。 2、需要生成的对象内部属性本身相互依赖。 </p><p><strong>注意事项：</strong>与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。</p></blockquote><h4 id="三、实现"><a href="#三、实现" class="headerlink" title="三、实现"></a>三、实现</h4><blockquote><p>我们假设一个快餐店的商业案例，其中，一个典型的套餐可以是一个汉堡（Burger）和一杯冷饮（Cold drink）。汉堡（Burger）可以是素食汉堡（Veg Burger）或鸡肉汉堡（Chicken Burger），它们是包在纸盒中。冷饮（Cold drink）可以是可口可乐（coke）或百事可乐（pepsi），它们是装在瓶子中。</p><p>我们将创建一个表示食物条目（比如汉堡和冷饮）的 <em>Item</em> 接口和实现 <em>Item</em> 接口的实体类，以及一个表示食物包装的 <em>Packing</em> 接口和实现 <em>Packing</em> 接口的实体类，汉堡是包在纸盒中，冷饮是装在瓶子中。</p><p>然后我们创建一个 <em>Meal</em> 类，带有 <em>Item</em> 的 <em>ArrayList</em> 和一个通过结合 <em>Item</em> 来创建不同类型的 <em>Meal</em> 对象的 <em>MealBuilder</em>。<em>BuilderPatternDemo</em>，我们的演示类使用 <em>MealBuilder</em> 来创建一个 <em>Meal</em>。</p></blockquote><p><img src="//zongmansheng.club/2019/05/10/jian-zao-zhe-mo-shi/001.jpg" alt="001"></p><h5 id="步骤1"><a href="#步骤1" class="headerlink" title="步骤1"></a>步骤1</h5><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>desigpattern<span class="token punctuation">.</span>builderpattern<span class="token punctuation">.</span>dao<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author ZongMan * 食物条目接口 */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Item</span> <span class="token punctuation">{</span>    String <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Packing <span class="token function">packing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">float</span> <span class="token function">price</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 食物包装接口 */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Packing</span> <span class="token punctuation">{</span>    String <span class="token function">pack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h5 id="步骤2"><a href="#步骤2" class="headerlink" title="步骤2"></a>步骤2</h5><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @author ZongMan * 创建实现 Packing 接口的实体类。 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Wrapper</span> <span class="token keyword">implements</span> <span class="token class-name">Packing</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">pack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"Wrapper"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Bottle</span> <span class="token keyword">implements</span> <span class="token class-name">Packing</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">pack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"Bottle"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="步骤3"><a href="#步骤3" class="headerlink" title="步骤3"></a>步骤3</h5><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Burger</span> <span class="token keyword">implements</span> <span class="token class-name">Item</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"------->Burger"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Packing <span class="token function">packing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Wrapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">float</span> <span class="token function">price</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ColdDrink</span> <span class="token keyword">implements</span> <span class="token class-name">Item</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"--------->ColdDrink"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Packing <span class="token function">packing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Bottle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">float</span> <span class="token function">price</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="步骤4"><a href="#步骤4" class="headerlink" title="步骤4"></a>步骤4</h5><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @author ZongMan * 创建扩展了 Burger 和 ColdDrink 的实体类。 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VegBurger</span> <span class="token keyword">extends</span> <span class="token class-name">Burger</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"Veg Burger"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">float</span> <span class="token function">price</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">25.0f</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Pepsi</span> <span class="token keyword">extends</span> <span class="token class-name">ColdDrink</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"Pepsi"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">float</span> <span class="token function">price</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">35.0f</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Coke</span> <span class="token keyword">extends</span> <span class="token class-name">ColdDrink</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"Coke"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">float</span> <span class="token function">price</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">30.0f</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ChickenBurger</span> <span class="token keyword">extends</span> <span class="token class-name">Burger</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"Chicken Burger"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">float</span> <span class="token function">price</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">50.5f</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="步骤5"><a href="#步骤5" class="headerlink" title="步骤5"></a>步骤5</h5><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @author ZongMan * 创建一个 Meal 类，带有上面定义的 Item 对象。 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Meal</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> List<span class="token operator">&lt;</span>Item<span class="token operator">></span> items <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addItem</span><span class="token punctuation">(</span>Item item<span class="token punctuation">)</span> <span class="token punctuation">{</span>        items<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">float</span> <span class="token function">getCost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">float</span> cost <span class="token operator">=</span> <span class="token number">0.0f</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Item item <span class="token operator">:</span> items<span class="token punctuation">)</span> <span class="token punctuation">{</span>            cost <span class="token operator">+=</span> item<span class="token punctuation">.</span><span class="token function">price</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> cost<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">showItems</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Item item <span class="token operator">:</span> items<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Item : "</span><span class="token operator">+</span>item<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">", Packing : "</span><span class="token operator">+</span>item<span class="token punctuation">.</span><span class="token function">packing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">pack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">", Price : "</span><span class="token operator">+</span>item<span class="token punctuation">.</span><span class="token function">price</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="步骤6"><a href="#步骤6" class="headerlink" title="步骤6"></a>步骤6</h5><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @author ZongMan * 创建一个 MealBuilder 类，实际的 builder 类负责创建 Meal 对象。 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MealBuilder</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> Meal <span class="token function">prepareVegMeal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Meal meal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Meal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        meal<span class="token punctuation">.</span><span class="token function">addItem</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">VegBurger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        meal<span class="token punctuation">.</span><span class="token function">addItem</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Coke</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> meal<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> Meal <span class="token function">prepareNonVegMeal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Meal meal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Meal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        meal<span class="token punctuation">.</span><span class="token function">addItem</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChickenBurger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        meal<span class="token punctuation">.</span><span class="token function">addItem</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Pepsi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> meal<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="步骤7"><a href="#步骤7" class="headerlink" title="步骤7"></a>步骤7</h5><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @author ZongMan * BuiderPatternDemo 使用 MealBuider 来演示建造者模式（Builder Pattern） */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BuiderPatternDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        MealBuilder mealBuilder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MealBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Meal vegMeal <span class="token operator">=</span> mealBuilder<span class="token punctuation">.</span><span class="token function">prepareVegMeal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Veg Meal"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vegMeal<span class="token punctuation">.</span><span class="token function">showItems</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Total Cost: "</span> <span class="token operator">+</span> vegMeal<span class="token punctuation">.</span><span class="token function">getCost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Meal nonVegMeal <span class="token operator">=</span> mealBuilder<span class="token punctuation">.</span><span class="token function">prepareNonVegMeal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"\n\nNon-Veg Meal"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        nonVegMeal<span class="token punctuation">.</span><span class="token function">showItems</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Total Cost: "</span> <span class="token operator">+</span> nonVegMeal<span class="token punctuation">.</span><span class="token function">getCost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="步骤-8"><a href="#步骤-8" class="headerlink" title="步骤 8"></a>步骤 8</h5><p>​    执行程序，输出结果：</p><pre class=" language-java"><code class="language-java"><span class="token string">"C:\Program Files\Java\jdk1.8.0_181\bin\java.exe"</span> "<span class="token operator">-</span>javaagent<span class="token operator">:</span>I<span class="token operator">:</span>\Program Veg MealItem <span class="token operator">:</span> Veg Burger<span class="token punctuation">,</span> Packing <span class="token operator">:</span> Wrapper<span class="token punctuation">,</span> Price <span class="token operator">:</span> <span class="token number">25.0</span>Item <span class="token operator">:</span> Coke<span class="token punctuation">,</span> Packing <span class="token operator">:</span> Bottle<span class="token punctuation">,</span> Price <span class="token operator">:</span> <span class="token number">30.0</span>Total Cost<span class="token operator">:</span> <span class="token number">55.0</span>Non<span class="token operator">-</span>Veg MealItem <span class="token operator">:</span> Chicken Burger<span class="token punctuation">,</span> Packing <span class="token operator">:</span> Wrapper<span class="token punctuation">,</span> Price <span class="token operator">:</span> <span class="token number">50.5</span>Item <span class="token operator">:</span> Pepsi<span class="token punctuation">,</span> Packing <span class="token operator">:</span> Bottle<span class="token punctuation">,</span> Price <span class="token operator">:</span> <span class="token number">35.0</span>Total Cost<span class="token operator">:</span> <span class="token number">85.5</span>Process finished with exit code <span class="token number">0</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;建造者模式&quot;&gt;&lt;a href=&quot;#建造者模式&quot; class=&quot;headerlink&quot; title=&quot;建造者模式&quot;&gt;&lt;/a&gt;建造者模式&lt;/h1&gt;&lt;h4 id=&quot;一、介绍&quot;&gt;&lt;a href=&quot;#一、介绍&quot; class=&quot;headerlink&quot; title=&quot;一、介绍&quot;
      
    
    </summary>
    
      <category term="设计模式" scheme="http://zongmansheng.club/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Builder Pattern" scheme="http://zongmansheng.club/tags/Builder-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>线程池底层</title>
    <link href="http://zongmansheng.club/2019/05/09/xian-cheng-chi-di-ceng/"/>
    <id>http://zongmansheng.club/2019/05/09/xian-cheng-chi-di-ceng/</id>
    <published>2019-05-09T00:01:18.000Z</published>
    <updated>2019-05-09T00:22:50.650Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程池底层"><a href="#线程池底层" class="headerlink" title="线程池底层"></a>线程池底层</h1><h4 id="一、ThreadPoolExecutor"><a href="#一、ThreadPoolExecutor" class="headerlink" title="一、ThreadPoolExecutor"></a>一、ThreadPoolExecutor</h4><blockquote><p>在深入源码之前先来看看J.U.C包中的线程池类图：</p></blockquote><p><img src="//zongmansheng.club/2019/05/09/xian-cheng-chi-di-ceng/001.jpg" alt="001"></p><blockquote><p>它们的最顶层是一个Executor接口，它只有一个方法：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Executor</span> <span class="token punctuation">{</span>     <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span>Runnable command<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>​    它提供了一个运行新任务的简单方法，Java线程池也称之为Executor框架。</p><p>ExecutorService扩展了Executor，添加了操控线程池生命周期的方法，如shutDown()，shutDownNow()等。</p><p>​    此外，它扩展了可异步跟踪执行任务生成返回值Future的方法，如submit()等方法。</p><p>​    ThreadPoolExecutor继承自AbstractExecutorService，同时实现了ExecutorService接口，也是Executor框架默认的线程池实现类，也是这篇文章重点分析的对象</p><p>​    一般我们使用线程池，如没有特殊要求，直接创建ThreadPoolExecutor，初始化一个线程池</p><p>​    如果需要特殊的线程池，则直接继承ThreadPoolExecutor，并实现特定的功能。</p><p>​    比如ScheduledThreadPoolExecutor，它是一个具有定时执行任务的线程池。</p><p>​    接下来，我们就开始ThreadPoolExecutor的源码分析（以下源码为JDK8版本）</p></blockquote><h4 id="二、ctl变量"><a href="#二、ctl变量" class="headerlink" title="二、ctl变量"></a>二、ctl变量</h4><blockquote><p>​    ctl是一个Integer值，它是对线程池运行状态和线程池中有效线程数量进行控制的字段</p><p>Integer值一共有32位，<strong>其中高3位表示”线程池状态”，低29位表示”线程池中的任务数量”</strong></p><p>我们看看Doug Lea大神是如何实现的：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> AtomicInteger ctl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token function">ctlOf</span><span class="token punctuation">(</span>RUNNING<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> COUNT_BITS <span class="token operator">=</span> Integer<span class="token punctuation">.</span>SIZE <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CAPACITY <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// runState is stored in the high-order bits</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> RUNNING <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SHUTDOWN <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> STOP <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TIDYING <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TERMINATED <span class="token operator">=</span> <span class="token number">3</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Packing and unpacking ctl</span><span class="token comment" spellcheck="true">// 通过位运算获取线程池运行状态</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> c <span class="token operator">&amp;</span> <span class="token operator">~</span>CAPACITY<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 通过位运算获取线程池中有效的工作线程数</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> c <span class="token operator">&amp;</span> CAPACITY<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 初始化ctl变量值</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">ctlOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> rs<span class="token punctuation">,</span> <span class="token keyword">int</span> wc<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> rs <span class="token operator">|</span> wc<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><blockquote><p>线程池一共有状态5种状态，分别是：</p><p>1.<strong>Running</strong>：线程池初始化时默认的状态，表示线程正处于运行状态，能够接受新提交的任务，同时也能够处理阻塞队列中的任务；</p><p>2.<strong>SHUTDOWN</strong>：调用shutdown()方法会使线程池进入到该状态，该状态下不再继续接受新提交的任务，但是还会处理阻塞队列中的任务；</p><p>3.<strong>STOP</strong>：调用shutdownNow()方法会使线程池进入到该状态，该状态下不再继续接受新提交的任务，同时不再处理阻塞队列中的任务；</p><p>4.<strong>TIDYING</strong>：如果线程池中workerCount=0，即有效线程数量为0时，会进入该状态；</p><p>5.<strong>TERMINATED</strong>：在terminated()方法执行完后进入该状态，只不过terminated()方法需要我们自行实现。</p></blockquote><blockquote><p>我们再来看看位运算：</p><ul><li><strong>COUNT_BITS</strong>表示ctl变量中表示有效线程数量的位数，这里COUNT_BITS=29；</li><li><strong>CAPACITY</strong>表示最大有效线程数，根据位运算得出；</li><li><strong>COUNT_MASK</strong>=11111111111111111111111111111，折算成十进制大约是5亿，在设计之初就已经想到不会开启超过5亿条线程，所以完全够用了；</li></ul><p>线程池状态的位运算得到以下值：</p><p><strong>RUNNING</strong>：高三位值1112.</p><p><strong>SHUTDOWN</strong>：高三位值0003.</p><p><strong>STOP</strong>：高三位值0014.</p><p><strong>TIDYING：</strong>高三位值0105.</p><p><strong>TERMINATED：</strong>高三位值011</p><p>这里简单解释一下Doug Lea大神为什么使用一个Integer变量表示两个值：很多人会想，一个变量表示两个值，就节省了存储空间。</p><p>但是这里很显然不是为了节省空间而设计的，即使将这两个值拆分成两个Integer值，一个线程池也就多了4个字节而已</p><p>为了这4个字节而去大费周章地设计一通，显然不是Doug Lea大神的初衷。</p><p>在多线程的环境下，运行状态和有效线程数量往往需要保证统一，不能出现一个改而另一个没有改的情况。</p><p>如果将他们放在同一个AtomicInteger中，利用AtomicInteger的原子操作，就可以保证这两个值始终是统一的。</p><p><strong>Worker</strong></p><p>Worker类继承了AQS，并实现了Runnable接口，它有两个重要的成员变量：<strong>firstTask</strong>和<strong>thread</strong></p><p>​    firstTask用于保存第一次新建的任务；thread是在调用构造方法时通过ThreadFactory来创建的线程，是用来处理任务的线程。</p></blockquote><h4 id="三、如何在线程池中添加任务？"><a href="#三、如何在线程池中添加任务？" class="headerlink" title="三、如何在线程池中添加任务？"></a>三、如何在线程池中添加任务？</h4><blockquote><p>​    线程池要执行任务，那么必须先添加任务，execute()虽说是执行任务的意思，但里面也包含了添加任务的步骤在里面。</p><p>来看下面源码：</p><p>java.util.concurrent.ThreadPoolExecutor#execute：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span>Runnable command<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果添加订单任务为空，则空指针异常</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>command <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 获取ctl值</span> <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1.如果当前有效线程数小于核心线程数，调用addWorker执行任务（即创建一条线程执行该任务）</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&lt;</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 2.如果当前有效线程大于等于核心线程数，并且当前线程池状态为运行状态，则将任务添加到阻塞队列中，等待空闲线程取出队列执行</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRunning</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> workQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">int</span> recheck <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> <span class="token function">isRunning</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">remove</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">addWorker</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 3.如果阻塞队列已满，则调用addWorker执行任务（即创建一条线程执行该任务）</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 如果创建线程失败，则调用线程拒绝策略</span> <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="四、execute执行任务的流程图"><a href="#四、execute执行任务的流程图" class="headerlink" title="四、execute执行任务的流程图"></a>四、execute执行任务的流程图</h4><p><img src="//zongmansheng.club/2019/05/09/xian-cheng-chi-di-ceng/002.jpg" alt="002"></p><blockquote><p>​    继续往下看，addWorker添加任务，方法源码有点长，我按照逻辑拆分成两部分讲解：</p><p>java.util.concurrent.ThreadPoolExecutor#addWorker：</p></blockquote><pre class=" language-java"><code class="language-java">retry<span class="token operator">:</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 获取线程池当前运行状态</span> <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果rs大于SHUTDOWN，则说明此时线程池不在接受新任务了</span> <span class="token comment" spellcheck="true">// 如果rs等于SHUTDOWN，同时满足firstTask为空，且阻塞队列如果有任务，则继续执行任务</span> <span class="token comment" spellcheck="true">// 也就说明了如果线程池处于SHUTDOWN状态时，可以继续执行阻塞队列中的任务，但不能继续往线程池中添加任务了</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">>=</span> SHUTDOWN <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span> <span class="token punctuation">(</span>rs <span class="token operator">==</span> SHUTDOWN <span class="token operator">&amp;&amp;</span> firstTask <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 获取有效线程数量</span> <span class="token keyword">int</span> wc <span class="token operator">=</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果有效线程数大于等于线程池所容纳的最大线程数（基本不可能发生），不能添加任务</span> <span class="token comment" spellcheck="true">// 或者有效线程数大于等于当前限制的线程数，也不能添加任务</span> <span class="token comment" spellcheck="true">// 限制线程数量有任务是否要核心线程执行决定，core=true使用核心线程执行任务</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>wc <span class="token operator">>=</span> CAPACITY <span class="token operator">||</span> wc <span class="token operator">>=</span> <span class="token punctuation">(</span>core <span class="token operator">?</span> corePoolSize <span class="token operator">:</span> maximumPoolSize<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 使用AQS增加有效线程数量</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndIncrementWorkerCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">break</span> retry<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果再次获取ctl变量值</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Re-read ctl</span> <span class="token comment" spellcheck="true">// 再次对比运行状态，如果不一致，再次循环执行</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">!=</span> rs<span class="token punctuation">)</span> <span class="token keyword">continue</span> retry<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// else CAS failed due to workerCount change; retry inner loop</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p><strong>    这里特别强调：</strong>firstTask是开启线程执行的首个任务，之后常驻在线程池中的线程执行的任务都是从阻塞队列中取出的，需要注意。</p><p>以上for循环代码主要作用是判断 ctl 变量当前的状态是否可以添加任务，特别说明了如果线程池处于SHUTDOWN状态时，可以继续执行阻塞队列中的任务，但不能继续往线程池中添加任务了；</p><p>同时增加工作线程数量使用了AQS作同步，如果同步失败，则继续循环执行。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 任务是否已执行</span><span class="token keyword">boolean</span> workerStarted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 任务是否已添加</span><span class="token keyword">boolean</span> workerAdded <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 任务包装类，我们的任务都需要添加到Worker中</span>Worker w <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 创建一个Worker</span> w <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span>firstTask<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 获取Worker中的Thread值</span> <span class="token keyword">final</span> Thread t <span class="token operator">=</span> w<span class="token punctuation">.</span>thread<span class="token punctuation">;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 操作workers HashSet 数据结构需要同步加锁</span> <span class="token keyword">final</span> ReentrantLock mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span> mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">try</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// Recheck while holding lock.</span> <span class="token comment" spellcheck="true">// Back out on ThreadFactory failure or if</span> <span class="token comment" spellcheck="true">// shut down before lock acquired.</span> <span class="token comment" spellcheck="true">// 获取当前线程池的运行状态</span> <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// rs &lt; SHUTDOWN表示是RUNNING状态；</span> <span class="token comment" spellcheck="true">// 如果rs是RUNNING状态或者rs是SHUTDOWN状态并且firstTask为null，向线程池中添加线程。</span> <span class="token comment" spellcheck="true">// 因为在SHUTDOWN时不会在添加新的任务，但还是会执行workQueue中的任务</span> <span class="token comment" spellcheck="true">// rs是RUNNING状态时，直接创建线程执行任务</span> <span class="token comment" spellcheck="true">// 当rs等于SHUTDOWN时，并且firstTask为空，也可以创建线程执行任务，也说说明了SHUTDOWN状态时不再接受新任务</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">&lt;</span> SHUTDOWN <span class="token operator">||</span> <span class="token punctuation">(</span>rs <span class="token operator">==</span> SHUTDOWN <span class="token operator">&amp;&amp;</span> firstTask <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// precheck that t is startable</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalThreadStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> workers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">int</span> s <span class="token operator">=</span> workers<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">></span> largestPoolSize<span class="token punctuation">)</span> largestPoolSize <span class="token operator">=</span> s<span class="token punctuation">;</span> workerAdded <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span> mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 启动线程执行任务</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>workerAdded<span class="token punctuation">)</span> <span class="token punctuation">{</span> t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> workerStarted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> workerStarted<span class="token punctuation">)</span> <span class="token function">addWorkerFailed</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> workerStarted<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>以上源码主要的作用是创建一个Worker对象，并将新的任务装进Worker中，开启同步将Worker添加进workers中</p><p><strong>这里需要注意workers的数据结构为HashSet，非线程安全，所以操作workers需要加同步锁</strong>。</p><p>添加步骤做完后就启动线程来执行任务了，继续往下看。</p><p>如何执行任务？</p><p>我们注意到上面的代码中：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 启动线程执行任务</span><span class="token keyword">if</span> <span class="token punctuation">(</span>workerAdded<span class="token punctuation">)</span> <span class="token punctuation">{</span> t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> workerStarted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>​    这里的t是w.thread得到的，即是Worker中用于执行任务的线程，该线程由ThreadFactory创建，我们再看看生成Worker的构造方法：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token function">Worker</span><span class="token punctuation">(</span>Runnable firstTask<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token function">setState</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// inhibit interrupts until runWorker</span>     <span class="token keyword">this</span><span class="token punctuation">.</span>firstTask <span class="token operator">=</span> firstTask<span class="token punctuation">;</span>     <span class="token keyword">this</span><span class="token punctuation">.</span>thread <span class="token operator">=</span> <span class="token function">getThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newThread</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p><strong>    newThread传的参数是Worker本身，而Worker实现了Runnable接口</strong></p><p><strong>所以当我们执行t.start()时，执行的是Worker的run()方法</strong>，找到入口了：</p><p>java.util.concurrent.ThreadPoolExecutor.Worker#run：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token function">runWorker</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>java.util.concurrent.ThreadPoolExecutor#runWorker：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">runWorker</span><span class="token punctuation">(</span>Worker w<span class="token punctuation">)</span> <span class="token punctuation">{</span> Thread wt <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> Runnable task <span class="token operator">=</span> w<span class="token punctuation">.</span>firstTask<span class="token punctuation">;</span> w<span class="token punctuation">.</span>firstTask <span class="token operator">=</span> null<span class="token punctuation">;</span> w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// allow interrupts</span> <span class="token keyword">boolean</span> completedAbruptly <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token keyword">try</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 循环从workQueue阻塞队列中获取任务并执行</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>task <span class="token operator">!=</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>task <span class="token operator">=</span> <span class="token function">getTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 加同步锁的目的是为了防止同一个任务出现多个线程执行的问题</span> w<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果线程池正在关闭，须确保中断当前线程</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> STOP<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> STOP<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>wt<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> wt<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">try</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 执行任务前可以做一些操作</span> <span class="token function">beforeExecute</span><span class="token punctuation">(</span>wt<span class="token punctuation">,</span> task<span class="token punctuation">)</span><span class="token punctuation">;</span> Throwable thrown <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token keyword">try</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 执行任务</span> task<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RuntimeException</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span> thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Error</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span> thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span> thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 执行任务后可以做一些操作</span> <span class="token function">afterExecute</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> thrown<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 将task置为空，让线程自行调用getTask()方法从workQueue阻塞队列中获取任务</span> task <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 记录Worker执行了多少次任务</span> w<span class="token punctuation">.</span>completedTasks<span class="token operator">++</span><span class="token punctuation">;</span> w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span> completedAbruptly <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 线程回收过程</span> <span class="token function">processWorkerExit</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> completedAbruptly<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>​    这一步是执行任务的核心方法，首次执行不为空的firstTask任务，之后便一直从workQueue阻塞队列中获取任务并执行</p><p>​    如果你想在任务执行前后做点啥不可告人的小动作，你可以实现ThreadPoolExecutor以下两个方法：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">beforeExecute</span><span class="token punctuation">(</span>Thread t<span class="token punctuation">,</span> Runnable r<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">afterExecute</span><span class="token punctuation">(</span>Runnable r<span class="token punctuation">,</span> Throwable t<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span></code></pre><blockquote><p>这样一来，我们就可以对任务的执行进行实时监控了。</p><p>这里还需要注意，在finally块中，将task置为空，目的是为了让线程自行调用getTask()方法从workQueue阻塞队列中获取任务。</p><p>如何保证核心线程不被销毁？</p><p>我们之前已经知道线程池中可维持corePoolSize数量的常驻核心线程，那么它们是如何保证执行完任务而不被线程池回收的呢？</p><p><strong>在前面的章节中你可能已经会从workQueue队列中阻塞式地获取任务，如果没有获取任务，那么就会一直阻塞下去</strong></p><p>很聪明，你已经知道答案了，现在我们来看Doug Lea大神是如何实现的。</p><p>java.util.concurrent.ThreadPoolExecutor#getTask：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> Runnable <span class="token function">getTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 超时标记，默认为false，如果调用workQueue.poll()方法超时了，会标记为true</span> <span class="token comment" spellcheck="true">// 这个标记非常之重要，下面会说到</span> <span class="token keyword">boolean</span> timedOut <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 获取ctl变量值</span> <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果当前状态大于等于SHUTDOWN，并且workQueue中的任务为空或者状态大于等于STOP</span> <span class="token comment" spellcheck="true">// 则操作AQS减少工作线程数量，并且返回null，线程被回收</span> <span class="token comment" spellcheck="true">// 也说明假设状态为SHUTDOWN的情况下，如果workQueue不为空，那么线程池还是可以继续执行剩下的任务</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">>=</span> SHUTDOWN <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>rs <span class="token operator">>=</span> STOP <span class="token operator">||</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 操作AQS将线程池中的线程数量减一</span> <span class="token function">decrementWorkerCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> null<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 获取线程池中的有效线程数量</span> <span class="token keyword">int</span> wc <span class="token operator">=</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果开发者主动开启allowCoreThreadTimeOut并且获取当前工作线程大于corePoolSize，那么该线程是可以被超时回收的</span> <span class="token comment" spellcheck="true">// allowCoreThreadTimeOut默认为false，即默认不允许核心线程超时回收</span> <span class="token comment" spellcheck="true">// 这里也说明了在核心线程以外的线程都为“临时”线程，随时会被线程池回收</span> <span class="token keyword">boolean</span> timed <span class="token operator">=</span> allowCoreThreadTimeOut <span class="token operator">||</span> wc <span class="token operator">></span> corePoolSize<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 这里说明了两点销毁线程的条件：</span> <span class="token comment" spellcheck="true">// 1.原则上线程池数量不可能大于maximumPoolSize，但可能会出现并发时操作了setMaximumPoolSize方法，如果此时将最大线程数量调少了，很可能会出现当前工作线程大于最大线程的情况，这时就需要线程超时回收，以维持线程池最大线程小于maximumPoolSize，</span> <span class="token comment" spellcheck="true">// 2.timed &amp;&amp; timedOut 如果为true，表示当前操作需要进行超时控制，这里的timedOut为true，说明该线程已经从workQueue.poll()方法超时了</span> <span class="token comment" spellcheck="true">// 以上两点满足其一，都可以触发线程超时回收</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>wc <span class="token operator">></span> maximumPoolSize <span class="token operator">||</span> <span class="token punctuation">(</span>timed <span class="token operator">&amp;&amp;</span> timedOut<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>wc <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">||</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 尝试用AQS将线程池线程数量减一</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndDecrementWorkerCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 减一成功后返回null，线程被回收</span> <span class="token keyword">return</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 否则循环重试</span> <span class="token keyword">continue</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">try</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果timed为true，阻塞超时获取任务，否则阻塞获取任务</span> Runnable r <span class="token operator">=</span> timed <span class="token operator">?</span> workQueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span>keepAliveTime<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>NANOSECONDS<span class="token punctuation">)</span> <span class="token operator">:</span> workQueue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> r<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果poll超时获取任务超时了, 将timeOut设置为true</span> <span class="token comment" spellcheck="true">// 继续循环执行，如果碰巧开发者开启了allowCoreThreadTimeOut，那么该线程就满足超时回收了</span> timedOut <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> retry<span class="token punctuation">)</span> <span class="token punctuation">{</span> timedOut <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>我把我对 getTask() 方法源码的深度解析写在源码对应的地方了，该方法就是实现默认的情况下核心线程不被销毁的核心实现，其实现思路大致是：</p><p><strong>1.将timedOut超时标记默认设置为false；</strong></p><p><strong>2.计算timed的值，该值决定了线程的生死大权</strong></p><p>(timed &amp;&amp; timedOut) 即是线程超时回收的条件之一，需要注意的是第一次(timed &amp;&amp; timedOut) 为false，因为timedOut默认值为false，此时还没到poll超时获取的操作；</p><p><strong>3.根据timed值来决定是用阻塞超时获取任务还是阻塞获取任务</strong></p><p>如果用阻塞超时获取任务，超时后timedOut会被设置为true，接着继续循环，若 (timed &amp;&amp; timedOut) 为true，满足线程超时回收。</p></blockquote><blockquote><p>转自：<a href="https://www.toutiao.com/a6686773038484029955/" target="_blank" rel="noopener">https://www.toutiao.com/a6686773038484029955/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;线程池底层&quot;&gt;&lt;a href=&quot;#线程池底层&quot; class=&quot;headerlink&quot; title=&quot;线程池底层&quot;&gt;&lt;/a&gt;线程池底层&lt;/h1&gt;&lt;h4 id=&quot;一、ThreadPoolExecutor&quot;&gt;&lt;a href=&quot;#一、ThreadPoolExecutor&quot;
      
    
    </summary>
    
      <category term="java高级" scheme="http://zongmansheng.club/categories/java%E9%AB%98%E7%BA%A7/"/>
    
    
      <category term="ThreadPool" scheme="http://zongmansheng.club/tags/ThreadPool/"/>
    
  </entry>
  
  <entry>
    <title>消息队列的高可用</title>
    <link href="http://zongmansheng.club/2019/05/05/xiao-xi-dui-lie-de-gao-ke-yong/"/>
    <id>http://zongmansheng.club/2019/05/05/xiao-xi-dui-lie-de-gao-ke-yong/</id>
    <published>2019-05-05T12:58:37.000Z</published>
    <updated>2019-05-05T13:29:54.128Z</updated>
    
    <content type="html"><![CDATA[<h1 id="消息队列的高可用"><a href="#消息队列的高可用" class="headerlink" title="消息队列的高可用"></a>消息队列的高可用</h1><h4 id="一、RabbitMQ-的高可用性"><a href="#一、RabbitMQ-的高可用性" class="headerlink" title="一、RabbitMQ 的高可用性"></a>一、RabbitMQ 的高可用性</h4><blockquote><p>​    RabbitMQ 是比较有代表性的，因为是基于主从（非分布式）做高可用性的，我们就以 RabbitMQ 为例子讲解第一种 MQ 的高可用性怎么实现。</p><p>RabbitMQ 有三种模式：单机模式、普通集群模式、镜像集群模式。</p></blockquote><h5 id="1-1、单机模式"><a href="#1-1、单机模式" class="headerlink" title="1.1、单机模式"></a>1.1、单机模式</h5><blockquote><p>单机模式，就是 Demo 级别的，一般就是你本地启动了玩玩儿的，没人生产用单机模式。</p><p>普通集群模式（无高可用性）</p><p>普通集群模式，意思就是在多台机器上启动多个 RabbitMQ 实例，每个机器启动一个。你创建的 queue，只会放在一个 RabbitMQ 实例上，但是每个实例都同步 queue 的元数据（元数据可以认为是 queue 的一些配置信息，通过元数据，可以找到 queue 所在实例）。你消费的时候，实际上如果连接到了另外一个实例，那么那个实例会从 queue 所在实例上拉取数据过来。</p></blockquote><p><img src="//zongmansheng.club/2019/05/05/xiao-xi-dui-lie-de-gao-ke-yong/001.jpg" alt="001"></p><h4 id="二、Kafka-的高可用性"><a href="#二、Kafka-的高可用性" class="headerlink" title="二、Kafka 的高可用性"></a>二、Kafka 的高可用性</h4><blockquote><p>​    Kafka 一个最基本的架构认识：由多个 broker 组成，每个 broker 是一个节点；你创建一个 topic，这个 topic 可以划分为多个 partition，每个 partition 可以存在于不同的 broker 上，每个 partition 就放一部分数据。</p><p>​    这就是天然的分布式消息队列，就是说一个 topic 的数据，是分散放在多个机器上的，每个机器就放一部分数据。</p><p>​    实际上 RabbmitMQ 之类的，并不是分布式消息队列，它就是传统的消息队列，只不过提供了一些集群、HA(High Availability, 高可用性) 的机制而已，因为无论怎么玩儿，RabbitMQ 一个 queue 的数据都是放在一个节点里的，镜像集群下，也是每个节点都放这个 queue 的完整数据。</p><p>​    Kafka 0.8 以前，是没有 HA 机制的，就是任何一个 broker 宕机了，那个 broker 上的 partition 就废了，没法写也没法读，没有什么高可用性可言。</p><p>​    比如说，我们假设创建了一个 topic，指定其 partition 数量是 3 个，分别在三台机器上。但是，如果第二台机器宕机了，会导致这个 topic 的 1/3 的数据就丢了，因此这个是做不到高可用的。</p></blockquote><p><img src="//zongmansheng.club/2019/05/05/xiao-xi-dui-lie-de-gao-ke-yong/002.jpg" alt="002"></p><blockquote><p>​    这么搞，就有所谓的高可用性了，因为如果某个 broker 宕机了，没事儿，那个 broker上面的 partition 在其他机器上都有副本的，如果这上面有某个 partition 的 leader，那么此时会从 follower 中重新选举一个新的 leader 出来，大家继续读写那个新的 leader 即可。这就有所谓的高可用性了。</p><p>​    写数据的时候，生产者就写 leader，然后 leader 将数据落地写本地磁盘，接着其他 follower 自己主动从 leader 来 pull 数据。一旦所有 follower 同步好数据了，就会发送 ack 给 leader，leader 收到所有 follower 的 ack 之后，就会返回写成功的消息给生产者。（当然，这只是其中一种模式，还可以适当调整这个行为）</p><p>​    消费的时候，只会从 leader 去读，但是只有当一个消息已经被所有 follower 都同步成功返回 ack 的时候，这个消息才会被消费者读到。</p><p>​    看到这里，相信你大致明白了 Kafka 是如何保证高可用机制的了，对吧？不至于一无所知，现场还能给面试官画画图。要是遇上面试官确实是 Kafka 高手，深挖了问，那你只能说不好意思，太深入的你没研究过。</p><p>​    这种方式确实很麻烦，也不怎么好，没做到所谓的分布式，就是个普通集群。因为这导致你要么消费者每次随机连接一个实例然后拉取数据，要么固定连接那个 queue 所在实例消费数据，前者有数据拉取的开销，后者导致单实例性能瓶颈。</p><p>​    而且如果那个放 queue 的实例宕机了，会导致接下来其他实例就无法从那个实例拉取，如果你开启了消息持久化，让 RabbitMQ 落地存储消息的话，消息不一定会丢，得等这个实例恢复了，然后才可以继续从这个 queue 拉取数据。</p><p>​    所以这个事儿就比较尴尬了，这就没有什么所谓的高可用性，这方案主要是提高吞吐量的，就是说让集群中多个节点来服务某个 queue 的读写操作。</p><p>镜像集群模式（高可用性）</p><p>​    这种模式，才是所谓的 RabbitMQ 的高可用模式。跟普通集群模式不一样的是，在镜像集群模式下，你创建的 queue，无论元数据还是 queue 里的消息都会存在于多个实例上，就是说，每个 RabbitMQ 节点都有这个 queue 的一个完整镜像，包含 queue 的全部数据的意思。然后每次你写消息到 queue 的时候，都会自动把消息同步到多个实例的 queue 上。</p></blockquote><p><img src="//zongmansheng.club/2019/05/05/xiao-xi-dui-lie-de-gao-ke-yong/003.jpg" alt="003"></p><blockquote><p>​    那么如何开启这个镜像集群模式呢？其实很简单，RabbitMQ 有很好的管理控制台，就是在后台新增一个策略，这个策略是镜像集群模式的策略，指定的时候是可以要求数据同步到所有节点的，也可以要求同步到指定数量的节点，再次创建 queue 的时候，应用这个策略，就会自动将数据同步到其他的节点上去了。</p><p>这样的话，好处在于，你任何一个机器宕机了，没事儿，其它机器（节点）还包含了这个 queue 的完整数据，别的 consumer 都可以到其它节点上去消费数据。坏处在于，第一，这个性能开销也太大了吧，消息需要同步到所有机器上，导致网络带宽压力和消耗很重！第二，这么玩儿，不是分布式的，就没有扩展性可言了，如果某个 queue 负载很重，你加机器，新增的机器也包含了这个 queue 的所有数据，并没有办法线性扩展你的 queue。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;消息队列的高可用&quot;&gt;&lt;a href=&quot;#消息队列的高可用&quot; class=&quot;headerlink&quot; title=&quot;消息队列的高可用&quot;&gt;&lt;/a&gt;消息队列的高可用&lt;/h1&gt;&lt;h4 id=&quot;一、RabbitMQ-的高可用性&quot;&gt;&lt;a href=&quot;#一、RabbitMQ-的高
      
    
    </summary>
    
      <category term="java高级" scheme="http://zongmansheng.club/categories/java%E9%AB%98%E7%BA%A7/"/>
    
    
      <category term="分布式，MQ" scheme="http://zongmansheng.club/tags/%E5%88%86%E5%B8%83%E5%BC%8F%EF%BC%8CMQ/"/>
    
  </entry>
  
  <entry>
    <title>在Mac上使用Markdown</title>
    <link href="http://zongmansheng.club/2019/05/05/zai-mac-shang-shi-yong-markdown/"/>
    <id>http://zongmansheng.club/2019/05/05/zai-mac-shang-shi-yong-markdown/</id>
    <published>2019-05-05T07:29:58.000Z</published>
    <updated>2019-06-30T07:37:16.870Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在Mac上使用Markdown"><a href="#在Mac上使用Markdown" class="headerlink" title="在Mac上使用Markdown"></a>在Mac上使用Markdown</h1><h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>MarkDown是一种轻量级的标记语言，他的开发者为John Gruber。通过简单的标记语法，它可以使普通文本具有一定的格式</p><p>​        最近入手一台macbook  pro，已经把这个博客从windows迁移到mac上来了！！！</p></blockquote><h4 id="一、常用语法及快捷键"><a href="#一、常用语法及快捷键" class="headerlink" title="一、常用语法及快捷键"></a>一、常用语法及快捷键</h4><h5 id="1-1标题"><a href="#1-1标题" class="headerlink" title="1.1标题"></a>1.1标题</h5><blockquote><p>##一级标题</p><p>####二级标题</p><p>######三级标题</p><p>########四级标题</p><p>##########五级标题</p><p>############六级标题</p><p>快捷键为cmd+X（X为几级标题就写数字几，如二级标题为：cmd+2）</p></blockquote><h5 id="1-2引用"><a href="#1-2引用" class="headerlink" title="1.2引用"></a>1.2引用</h5><blockquote><p>当你需要引用别人的话时，可以在引用的文字前面添加引用标记 <strong>&gt;</strong>，<br>即表示此后的内容为引用，这时候，文字的背景色也会改变。</p><p>如：&gt;这是一段引用</p></blockquote><h5 id="1-3链接"><a href="#1-3链接" class="headerlink" title="1.3链接"></a>1.3链接</h5><blockquote><p>链接分为图片链接和网址链接。</p><p><strong>图片链接</strong></p><pre><code>![图片描述] (图片地址)</code></pre><p>快捷键为：shift + cmd + I</p><p><strong>网页链接</strong></p><pre><code>[网页描述](网页地址)</code></pre><p>快捷键为 sihft + cmd + k</p></blockquote><h5 id="1-4代码"><a href="#1-4代码" class="headerlink" title="1.4代码"></a>1.4代码</h5><blockquote><p>使用两个 <strong>`</strong>符号把单行代码包裹起来。</p><p>多行代码两个用<strong><code>`</code></strong>包起来。</p></blockquote><h5 id="1-5表格"><a href="#1-5表格" class="headerlink" title="1.5表格"></a>1.5表格</h5><blockquote><p>| 1 | 2 | 3 |</p><p>| —- |:—-:| —:|</p><p>| a | d | g |</p><p>| b | e | h |</p><p>| c | f | I |</p><p><strong>| —- |:—-:| —:|</strong>表示对其方式。:—表示左对齐；—:表示右对齐；:—-:表示中间对齐。</p></blockquote><p>效果为：</p><table><thead><tr><th>1</th><th style="text-align:center">2</th><th style="text-align:right">3</th></tr></thead><tbody><tr><td>a</td><td style="text-align:center">d</td><td style="text-align:right">g</td></tr><tr><td>b</td><td style="text-align:center">e</td><td style="text-align:right">h</td></tr><tr><td>c</td><td style="text-align:center">f</td><td style="text-align:right">I</td></tr></tbody></table><h5 id="1-6其他"><a href="#1-6其他" class="headerlink" title="1.6其他"></a>1.6其他</h5><pre><code>加粗 :**Bold**斜体字 :*Italics*高亮 :==text==段落 : 段落之间空一行画水平线 (HR) :--------方框：- [ ] -</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;在Mac上使用Markdown&quot;&gt;&lt;a href=&quot;#在Mac上使用Markdown&quot; class=&quot;headerlink&quot; title=&quot;在Mac上使用Markdown&quot;&gt;&lt;/a&gt;在Mac上使用Markdown&lt;/h1&gt;&lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="皮一下" scheme="http://zongmansheng.club/categories/%E7%9A%AE%E4%B8%80%E4%B8%8B/"/>
    
    
      <category term="Mac Markdown" scheme="http://zongmansheng.club/tags/Mac-Markdown/"/>
    
  </entry>
  
  <entry>
    <title>nginx惊群</title>
    <link href="http://zongmansheng.club/2019/04/28/nginx-liang-qun/"/>
    <id>http://zongmansheng.club/2019/04/28/nginx-liang-qun/</id>
    <published>2019-04-28T00:04:23.000Z</published>
    <updated>2019-05-03T08:54:07.863Z</updated>
    
    <content type="html"><![CDATA[<h1 id="nginx惊群"><a href="#nginx惊群" class="headerlink" title="nginx惊群"></a>nginx惊群</h1><h4 id="一、什么是惊群"><a href="#一、什么是惊群" class="headerlink" title="一、什么是惊群"></a>一、什么是惊群</h4><blockquote><p>​    多线程/多进程（linux下线程进程也没多大区别）等待同一个socket事件，当这个事件发生时，这些线程/进程被同时唤醒，就是惊群。可以想见，效率很低下，许多进程被内核重新调度唤醒，同时去响应这一个事件，当然只有一个进程能处理事件成功，其他的进程在处理该事件失败后重新休眠（也有其他选择）。这种性能浪费现象就是惊群。</p></blockquote><blockquote><p>​    惊群通常发生在server 上，当父进程绑定一个端口监听socket，然后fork出多个子进程，子进程们开始循环处理（比如accept）这个socket。每当用户发起一个TCP连接时，多个子进程同时被唤醒，然后其中一个子进程accept新连接成功，余者皆失败，重新休眠。</p></blockquote><h4 id="二、如何解决惊群问题-post事件处理机制"><a href="#二、如何解决惊群问题-post事件处理机制" class="headerlink" title="二、如何解决惊群问题-post事件处理机制"></a>二、如何解决惊群问题-post事件处理机制</h4><blockquote><p>​    很多操作系统的最新版本的内核已经在事件驱动机制中解决了惊群问题，但Nginx作为可移植性极高的web服务器，还是在自身的应用层面上较好的解决了这一问题。<br>Nginx规定了同一时刻只有唯一一个worker子进程监听web端口，这一就不会发生惊群了，此时新连接事件只能唤醒唯一的正在监听端口的worker子进程。</p><p>​    如何限制在某一时刻是有一个子进程监听web端口呢？在打开accept_mutex锁的情况下，只有调用ngx_trylock_accept_mutex方法后，当前的worker进程才会去试着监听web端口。</p><p>​    那么，什么时候释放ngx_accept_mutex锁呢？<br>​    显然不能等到这批事件全部执行完。因为这个worker进程上可能有许多活跃的连接，处理这些连接上的事件会占用很长时间，其他worker进程很难得到处理新连接的机会。</p><p>​    如何解决长时间占用ngx_accept_mutex的问题呢？</p><p>​    这就要依靠post事件处理机制，Nginx设计了两个队列：ngx_posted_accept_events队列（存放新连接事件的队列）和ngx_posted_events队列（存放普通事件的队列）。这两个队列都是ngx_event_t类型的双链表。定义如下：</p></blockquote><pre class=" language-java"><code class="language-java">ngx_thread_volatile ngx_event_t  <span class="token operator">*</span>ngx_posted_accept_events<span class="token punctuation">;</span>ngx_thread_volatile ngx_event_t  <span class="token operator">*</span>ngx_posted_events<span class="token punctuation">;</span></code></pre><blockquote><p>​    下面结合具体代码进行分析惊群问题的解决。</p><p>​    首先看worker进程中ngx_process_events_and_timers事件处理函数（src/event/ngx.event.c），它处于worker进程的ngx_worker_process_cycle方法中，循环处理时间，是事件驱动机制的核心，既会处理普通的网络事件，也会处理定时器事件。ngx_process_events_and_timers是Nginx实际处理web业务的方法，所有业务的执行都是由它开始的，它涉及Nginx完整的事件驱动机制！！特别重要~</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span><span class="token function">ngx_process_events_and_timers</span><span class="token punctuation">(</span>ngx_cycle_t <span class="token operator">*</span>cycle<span class="token punctuation">)</span><span class="token punctuation">{</span>    ngx_uint_t  flags<span class="token punctuation">;</span>    ngx_msec_t  timer<span class="token punctuation">,</span> delta<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ngx_timer_resolution<span class="token punctuation">)</span> <span class="token punctuation">{</span>        timer <span class="token operator">=</span> NGX_TIMER_INFINITE<span class="token punctuation">;</span>        flags <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        timer <span class="token operator">=</span> <span class="token function">ngx_event_find_timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        flags <span class="token operator">=</span> NGX_UPDATE_TIME<span class="token punctuation">;</span>#<span class="token keyword">if</span> <span class="token punctuation">(</span>NGX_THREADS<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>timer <span class="token operator">==</span> NGX_TIMER_INFINITE <span class="token operator">||</span> timer <span class="token operator">></span> <span class="token number">500</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            timer <span class="token operator">=</span> <span class="token number">500</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>#endif    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*ngx_use_accept_mutex表示是否需要通过对accept加锁来解决惊群问题。当使用了master模式，nginx worker进程数>1时且配置文件中打开accept_mutex时，这个标志置为1     它在函数ngx_event_process_int中被设置，源代码为：    if (ccf->master &amp;&amp; ccf->worker_processes > 1 &amp;&amp; ecf->accept_mutex) {        ngx_use_accept_mutex = 1;        ngx_accept_mutex_held = 0;        ngx_accept_mutex_delay = ecf->accept_mutex_delay;    } else {        ngx_use_accept_mutex = 0;    }*/</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ngx_use_accept_mutex<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//负载均衡处理</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ngx_accept_disabled <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            ngx_accept_disabled<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//调用ngx_trylock_accept_mutex方法，尝试获取accept锁</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ngx_trylock_accept_mutex</span><span class="token punctuation">(</span>cycle<span class="token punctuation">)</span> <span class="token operator">==</span> NGX_ERROR<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//拿到锁</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ngx_accept_mutex_held<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">/*给flags增加标记NGX_POST_EVENTS，这个标记作为处理时间核心函数ngx_process_events的一个参数，这个函数中所有事件将延后处理。会把accept事件都放到ngx_posted_accept_events链表中，epollin|epollout普通事件都放到ngx_posted_events链表中 */</span>                flags <span class="token operator">|=</span> NGX_POST_EVENTS<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">/*获取锁失败，意味着既不能让当前worker进程频繁的试图抢锁，也不能让它经过太长事件再去抢锁                下面的代码：即使开启了timer_resolution时间精度，牙需要让ngx_process_change方法在没有新事件的时候至少等待ngx_accept_mutex_delay毫秒之后再去试图抢锁                而没有开启时间精度时，如果最近一个定时器事件的超时时间距离现在超过了ngx_accept_mutex_delay毫秒，也要把timer设置为ngx_accept_mutex_delay毫秒，这是因为当前进程虽然没有抢到accept_mutex锁，但也不能让ngx_process_change方法在没有新事件的时候等待的时间超过ngx_accept_mutex_delay，这会影响整个负载均衡机制*/</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>timer <span class="token operator">==</span> NGX_TIMER_INFINITE                    <span class="token operator">||</span> timer <span class="token operator">></span> ngx_accept_mutex_delay<span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    timer <span class="token operator">=</span> ngx_accept_mutex_delay<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//计算ngx_process_events消耗的时间</span>    delta <span class="token operator">=</span> ngx_current_msec<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//事件处理核心函数</span>    <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token function">ngx_process_events</span><span class="token punctuation">(</span>cycle<span class="token punctuation">,</span> timer<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>    delta <span class="token operator">=</span> ngx_current_msec <span class="token operator">-</span> delta<span class="token punctuation">;</span>    <span class="token function">ngx_log_debug1</span><span class="token punctuation">(</span>NGX_LOG_DEBUG_EVENT<span class="token punctuation">,</span> cycle<span class="token operator">-</span><span class="token operator">></span>log<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>                   <span class="token string">"timer delta: %M"</span><span class="token punctuation">,</span> delta<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//ngx_posted_accept_events链表有数据，开始accept新连接</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ngx_posted_accept_events<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">ngx_event_process_posted</span><span class="token punctuation">(</span>cycle<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ngx_posted_accept_events<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//释放锁后再处理ngx_posted_events链表中的普通事件</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ngx_accept_mutex_held<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">ngx_shmtx_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ngx_accept_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//如果ngx_process_events消耗的时间大于0，那么这是可能有新的定时器事件触发</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>delta<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//处理定时器事件</span>        <span class="token function">ngx_event_expire_timers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">ngx_log_debug1</span><span class="token punctuation">(</span>NGX_LOG_DEBUG_EVENT<span class="token punctuation">,</span> cycle<span class="token operator">-</span><span class="token operator">></span>log<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>                   <span class="token string">"posted events %p"</span><span class="token punctuation">,</span> ngx_posted_events<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//ngx_posted_events链表中有数据，进行处理</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ngx_posted_events<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ngx_threaded<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">ngx_wakeup_worker_thread</span><span class="token punctuation">(</span>cycle<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token function">ngx_event_process_posted</span><span class="token punctuation">(</span>cycle<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ngx_posted_events<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>​    上面代码中要进行说明的是，flags被设置后作为函数ngx_process_events方法的一个参数，在epoll模块中这个接口的实现方法是ngx_epoll_process_events（其具体代码见<a href="http://blog.csdn.net/xiajun07061225/article/details/9250341）。当falgs标志位含有nGX_POST_EVENTS时是不会立即调用事件的handler回调方法的，代码如下所示：" target="_blank" rel="noopener">http://blog.csdn.net/xiajun07061225/article/details/9250341）。当falgs标志位含有nGX_POST_EVENTS时是不会立即调用事件的handler回调方法的，代码如下所示：</a></p></blockquote><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//事件需要延后处理</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> NGX_POST_EVENTS<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">/*如果要在post队列中延后处理该事件，首先要判断它是新连接时间还是普通事件                以确定是把它加入到ngx_posted_accept_events队列或者ngx_posted_events队列中。*/</span>                queue <span class="token operator">=</span> <span class="token punctuation">(</span>ngx_event_t <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>rev<span class="token operator">-</span><span class="token operator">></span>accept <span class="token operator">?</span>                               <span class="token operator">&amp;</span>ngx_posted_accept_events <span class="token operator">:</span> <span class="token operator">&amp;</span>ngx_posted_events<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//将该事件添加到相应的延后队列中</span>                <span class="token function">ngx_locked_post_event</span><span class="token punctuation">(</span>rev<span class="token punctuation">,</span> queue<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//立即调用事件回调方法来处理这个事件</span>                rev<span class="token operator">-</span><span class="token operator">></span><span class="token function">handler</span><span class="token punctuation">(</span>rev<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span></code></pre><blockquote><p>通过上面的代码可以看出，先处理ngx_posted_accept_events队列中的事件，处理完毕后立即释放ngx_accept_mutex锁，接着再处理ngx_posted_events队列中事件。这样大大减少了ngx_accept_mutex锁占用的时间</p><p>下面看看ngx_trylock_accept_mutex的具体实现（src/event/ngx_event_accept.c）：</p></blockquote><pre class=" language-java"><code class="language-java">ngx_int_t<span class="token function">ngx_trylock_accept_mutex</span><span class="token punctuation">(</span>ngx_cycle_t <span class="token operator">*</span>cycle<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//尝试获取accept_mutex锁。注意是非阻塞的。返回1表示成功，返回0表示失败。</span>    <span class="token comment" spellcheck="true">//ngx_accept_mutex 定义：ngx_shmtx_t    ngx_accept_mutex;（ngx_shmtx_t是Nginx封装的互斥锁，用于经常间同步）</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ngx_shmtx_trylock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ngx_accept_mutex<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">ngx_log_debug0</span><span class="token punctuation">(</span>NGX_LOG_DEBUG_EVENT<span class="token punctuation">,</span> cycle<span class="token operator">-</span><span class="token operator">></span>log<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>                       <span class="token string">"accept mutex locked"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//获取到锁，但是标志位ngx_accept_mutex_held为1，表示当前进程已经获取到锁了，立即返回。</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ngx_accept_mutex_held            <span class="token operator">&amp;&amp;</span> ngx_accept_events <span class="token operator">==</span> <span class="token number">0</span>            <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>ngx_event_flags <span class="token operator">&amp;</span> NGX_USE_RTSIG_EVENT<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">return</span> NGX_OK<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//将所有监听事件添加到当前的epoll等事件驱动模块中</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ngx_enable_accept_events</span><span class="token punctuation">(</span>cycle<span class="token punctuation">)</span> <span class="token operator">==</span> NGX_ERROR<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//添加失败，必须释放互斥锁</span>            <span class="token function">ngx_shmtx_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ngx_accept_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> NGX_ERROR<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//标志位设置</span>        ngx_accept_events <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//当前进程已经获取到锁</span>        ngx_accept_mutex_held <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> NGX_OK<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">ngx_log_debug1</span><span class="token punctuation">(</span>NGX_LOG_DEBUG_EVENT<span class="token punctuation">,</span> cycle<span class="token operator">-</span><span class="token operator">></span>log<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>                   <span class="token string">"accept mutex lock failed: %ui"</span><span class="token punctuation">,</span> ngx_accept_mutex_held<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//获取锁失败，但是标志位ngx_accept_mutex_held仍然为1，即当前进程还处在获取到锁的状态，这是不正确的</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ngx_accept_mutex_held<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//将所有监听事件从事件驱动模块中移除</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ngx_disable_accept_events</span><span class="token punctuation">(</span>cycle<span class="token punctuation">)</span> <span class="token operator">==</span> NGX_ERROR<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> NGX_ERROR<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//没有获取到锁，设置标志位</span>        ngx_accept_mutex_held <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> NGX_OK<span class="token punctuation">;</span></code></pre><blockquote><p>​    调用这个方法的结果是，要么唯一获取到锁且其epoll等事件驱动模块开始监控web端口上的新连接事件。这种情况下调用process_events方法时就会既处理已有连接上的事件，也处理新连接的事件。要么没有获取到锁，当前进程不会收到新连接事件。这种情况下process_events只处理已有连接上的事件。</p></blockquote><h4 id="三、参考资料"><a href="#三、参考资料" class="headerlink" title="三、参考资料"></a>三、参考资料</h4><blockquote><p><a href="http://russelltao.iteye.com/blog/1405352" target="_blank" rel="noopener">http://russelltao.iteye.com/blog/1405352</a></p><p>《深入理解Nginx》</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;nginx惊群&quot;&gt;&lt;a href=&quot;#nginx惊群&quot; class=&quot;headerlink&quot; title=&quot;nginx惊群&quot;&gt;&lt;/a&gt;nginx惊群&lt;/h1&gt;&lt;h4 id=&quot;一、什么是惊群&quot;&gt;&lt;a href=&quot;#一、什么是惊群&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="进阶" scheme="http://zongmansheng.club/categories/%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="nginx" scheme="http://zongmansheng.club/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>SQL注入XSS和CSRF</title>
    <link href="http://zongmansheng.club/2019/04/25/sql-zhu-ru-xss-he-csrf/"/>
    <id>http://zongmansheng.club/2019/04/25/sql-zhu-ru-xss-he-csrf/</id>
    <published>2019-04-25T00:31:32.000Z</published>
    <updated>2019-04-26T13:34:18.699Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SQL注入、XSS和CSRF"><a href="#SQL注入、XSS和CSRF" class="headerlink" title="SQL注入、XSS和CSRF"></a>SQL注入、XSS和CSRF</h1><h4 id="一、SQL注入"><a href="#一、SQL注入" class="headerlink" title="一、SQL注入"></a>一、SQL注入</h4><pre><code>SQL注入是属于注入式攻击，这种攻击是因为在项目中没有将代码与数据（比如用户敏感数据）隔离，在读取数据的时候，错误的将数据作为代码的一部分执行而导致的。典型的例子就是当对SQL语句进行字符串拼接的时候，直接使用未转义的用户输入内容作为变量。这时，只要在sql语句的中间做修改，比如加上drop、delete等关键字，执行之后后果不堪设想。说到这里，那么该怎么处理这种情况呢？三个方面：1、过滤用户输入参数中的特殊字符，降低风险。2、禁止通过字符串拼接sql语句，要严格使用参数绑定来传入参数。3、合理使用数据库框架提供的机制。就比如Mybatis提供的传入参数的方式 #{}，禁止使用${}，后者相当于是字符串拼接sql，要使用参数化的语句。总结下，就是要正确使用参数化绑定sql变量。</code></pre><h4 id="二、XSS"><a href="#二、XSS" class="headerlink" title="二、XSS"></a>二、XSS</h4><p>​    </p><blockquote><p>​       XSS：跨站脚本攻击，Cross-Site Scripting，为了和前端的css避免重名，简称为XSS，是指通过技术手段，向正常用户请求的HTML页面中插入恶意脚本，执行。</p></blockquote><blockquote><p>​    这种攻击主要是用于信息窃取和破坏等目的。比如2011年的微博XSS攻击事件，攻击者利用了微博发布功能中未对action-data漏洞做有效的过滤，在发布微博信息的时候带上了包含攻击脚本的URL，用户访问就会加载恶意脚本，导致大量用户被攻击。</p></blockquote><blockquote><p>​    关于防范XSS上，主要就是通过对用户输入的数据做过滤或者是转义，可以使用框架提供的工具类HtmlUtil。另外前端在浏览器展示数据的时候，要使用安全的API展示数据。比如使用innerText而不是innerHTML。</p></blockquote><h4 id="三、CSRF"><a href="#三、CSRF" class="headerlink" title="三、CSRF"></a>三、CSRF</h4><blockquote><p>​    跨站请求伪造，在用户并不知情的情况下，冒充用户发送请求，在当前已经登录的web网站上执行恶意操作，比如恶意发帖，修改密码等。</p></blockquote><blockquote><p>​    大致来看，与XSS有重合的地方，前者是黑客盗用用户浏览器中的登录信息，冒充用户去执行操作。后者是在正常用户请求的HTML中放入恶意代码，</p></blockquote><blockquote><p>​    XSS问题出在用户数据没有转义，过滤；CSRF问题出现在HTTP接口没有防范不守信用的调用。</p></blockquote><blockquote><p>防范CSRF的漏洞方式：</p></blockquote><blockquote><p>​    1、CSRF Token验证，利用浏览器的同源限制，在HTTP接口执行前验证Cookie中的Token，验证通过才会继续执行请求。</p></blockquote><blockquote><p>​    2、人机交互，例如短信验证码、界面的滑块。</p></blockquote><blockquote><p>之前在会议上也有一个思考，在人机验证这块，如果不用验证码的方式，用界面上的滑块这种方式，而且滑块还是第三方的。在APP的注册、登录使用这种人机验证的方式的话，如果第三方出现了问题，那么自己的APP就完全崩掉了，发版之后的APP什么也改不了。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SQL注入、XSS和CSRF&quot;&gt;&lt;a href=&quot;#SQL注入、XSS和CSRF&quot; class=&quot;headerlink&quot; title=&quot;SQL注入、XSS和CSRF&quot;&gt;&lt;/a&gt;SQL注入、XSS和CSRF&lt;/h1&gt;&lt;h4 id=&quot;一、SQL注入&quot;&gt;&lt;a href=
      
    
    </summary>
    
      <category term="日常学习" scheme="http://zongmansheng.club/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="SQL" scheme="http://zongmansheng.club/tags/SQL/"/>
    
      <category term="XSS" scheme="http://zongmansheng.club/tags/XSS/"/>
    
      <category term="CSRF" scheme="http://zongmansheng.club/tags/CSRF/"/>
    
  </entry>
  
  <entry>
    <title>一致性Hash</title>
    <link href="http://zongmansheng.club/2019/04/24/yi-zhi-xing-hash/"/>
    <id>http://zongmansheng.club/2019/04/24/yi-zhi-xing-hash/</id>
    <published>2019-04-24T13:17:59.000Z</published>
    <updated>2019-04-26T13:31:08.144Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一致性Hash"><a href="#一致性Hash" class="headerlink" title="一致性Hash"></a>一致性Hash</h1><blockquote><p>一致性Hash是分布式架构最重要最基础的东西，作为一个后端必须要了解，这里以分布式图片缓存服务器为例进行讲述。</p></blockquote><p><strong>原始问题：假设我们需要对一堆图片做缓存，缓存的图片放在了2台服务器上，当到来一个请求，应该如何知道请求的图片在哪台上面呢？</strong></p><blockquote><p>暴力遍历就不要去想了，否则缓存就没有意义了。一个自然的想法就是根据图片的名字做一个映射（Hash），将图片名字映射到0，1两个数字上面，例如有这样的映射函数：</p></blockquote><blockquote><p>f(图片名称) = md5(图片名称) % 2</p></blockquote><blockquote><p>md5是一个典型的哈希函数，会产生128bit的值，模2后只可能是0或1，那么我们就根据这个值把图片存入0、1两台服务器，当请求过来，根据图片名称计算出值，就可以知道图片缓存放在第几号服务器了：</p></blockquote><p><img src="/一致性Hash\001.jpg" alt="001"></p><blockquote><p>但假设现在我们图片太多了，需要再增加一台服务器分担压力，哈希函数必须更改成0、1、2映射，我们改为：</p></blockquote><blockquote><p>f(图片名称) = md5(图片名称) % 3</p></blockquote><blockquote><p>理论上讲，会有(N-1)/N的缓存会失效，其中N是服务器的数量，例如上述图片缓存，除了0图片、1图片，其余图片的存放位置都变了，失效的缓存有 2/3 * 6 = 4张图片：</p></blockquote><p><img src="/一致性Hash\002.jpg" alt="002"></p><p>减少图片服务器数量造成的后果亦是如此——在同一个时刻将会有大量缓存同时失效，称为“缓存雪崩”。失效了就会直接去后端服务器取，大量的请求直接透过缓存打到后端服务器，后端服务器极有可能承受不住压力而接连崩溃，最终造成整个系统瘫痪。</p><p><strong>所以出现进阶问题：当缓存服务器数量发生变化时，如何尽可能避免大量缓存同时失效？</strong></p><p>答案就是一致性Hash。</p><h4 id="一、一致性Hash原理"><a href="#一、一致性Hash原理" class="headerlink" title="一、一致性Hash原理"></a>一、一致性Hash原理</h4><h5 id="1、放置服务器"><a href="#1、放置服务器" class="headerlink" title="1、放置服务器"></a><strong>1、放置服务器</strong></h5><blockquote><p>我们将服务器像图片一样也进行哈希，服务器的“图片名称”一般就使用固定IP地址，Hash取模也不再是服务器数量，而是2^32，Hash的方法也不局限于md5，用一个抽象的函数表示：</p></blockquote><blockquote><p>f(服务器IP地址) = Hash(服务器IP地址) % 2^32</p></blockquote><blockquote><p>于是服务器被放置到了0~2^32-1某个数字对应的位置上去：</p></blockquote><p><img src="/一致性Hash\003.jpg" alt="003"></p><blockquote><p>为什么是2^32-1呢？因为第一次提出一致性Hash的论文是1997年发表的，那时候32位机器还是主流，2^32-1是最大的Integer。而现在64位早就普及了，完全可以将这个值扩大到2^64-1。</p></blockquote><h5 id="2、放置数据"><a href="#2、放置数据" class="headerlink" title="2、放置数据"></a><strong>2、放置数据</strong></h5><blockquote><p>我们将数据也按照相同的方式放到0~2^32-1的某个数字上去：</p></blockquote><blockquote><p>f(图片名称) = Hash(图片名称) % 2^32</p></blockquote><p><img src="//zongmansheng.club/2019/04/24/yi-zhi-xing-hash/004.jpg" alt="004"></p><h5 id="3、把数据放到服务器上"><a href="#3、把数据放到服务器上" class="headerlink" title="3、把数据放到服务器上"></a><strong>3、把数据放到服务器上</strong></h5><blockquote><p>对于每个数据，从映射的位置开始，顺时针行走，放置到碰到的第一个服务器上。例如3、230将会放到0号图片服务器，232将会放到1号图片服务器，4175556547将会放到2号图片服务器：</p></blockquote><p><img src="//zongmansheng.club/2019/04/24/yi-zhi-xing-hash/005.jpg" alt="005"></p><blockquote><p>这样一致性Hash就完成了。查找数据也是先映射、再顺时针行走找到第一台服务器。</p></blockquote><h4 id="二、一致性Hash如何缓解数据失效问题"><a href="#二、一致性Hash如何缓解数据失效问题" class="headerlink" title="二、一致性Hash如何缓解数据失效问题"></a>二、一致性Hash如何缓解数据失效问题</h4><blockquote><p>假设现在1号服务器崩溃，图片232找不到1号服务器，顺时针行走的第一台服务器是2号服务器，于是232的缓存位置发生了改变，变为了2号：</p></blockquote><p><img src="//zongmansheng.club/2019/04/24/yi-zhi-xing-hash/006.jpg" alt="006"></p><blockquote><p>而对于其他图片来说，缓存位置并没有发生变化，影响的数据量从（N-1）/ N 降为了 M，其中M是0号图片服务器到1号图片服务器之间的图片数量。需要重新获取的缓存数据量降低了，雪崩问题自然也就能够得到缓解。</p></blockquote><h4 id="三、Hash环偏斜和虚拟节点"><a href="#三、Hash环偏斜和虚拟节点" class="headerlink" title="三、Hash环偏斜和虚拟节点"></a>三、Hash环偏斜和虚拟节点</h4><blockquote><p>前面讨论得太理想了，实际的服务器分布和数据分布很可能是这样的：</p></blockquote><p><img src="//zongmansheng.club/2019/04/24/yi-zhi-xing-hash/007.jpg" alt="007"></p><blockquote><p>0、1、2三台服务器并没有均匀分布在环上，大量的图片数据都被放到了0号服务器上，而很少数据放到1、2号等其他图片服务器上，这种情况称之为Hash环偏斜。如果存放的是缓存则0号服务器崩溃就会引起缓存雪崩，如果存放的是数据则0号服务器就可能单点故障。</p></blockquote><blockquote><p>很自然可以想到，增加多台服务器就好了嘛。我们在Hash环上生成0、1、2三台服务器的虚拟节点：</p></blockquote><p><img src="//zongmansheng.club/2019/04/24/yi-zhi-xing-hash/008.jpg" alt="008"></p><blockquote><p>具体的做法是，在服务器IP后面增加编号，每一台服务器产生多个Hash值，就能放置在0~2^32-1的多个位置上了。这样一来，顺时针行走能找到不同的服务器概率将会大大提高，避免了偏斜问题。虚拟的服务器节点数越多，偏斜出现的概率就越低。通常都需要设置32或以上的虚拟节点数目，我见过甚至有设置500的。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一致性Hash&quot;&gt;&lt;a href=&quot;#一致性Hash&quot; class=&quot;headerlink&quot; title=&quot;一致性Hash&quot;&gt;&lt;/a&gt;一致性Hash&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;一致性Hash是分布式架构最重要最基础的东西，作为一个后端必须要了解，这里
      
    
    </summary>
    
      <category term="后端" scheme="http://zongmansheng.club/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="算法" scheme="http://zongmansheng.club/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Hash" scheme="http://zongmansheng.club/tags/Hash/"/>
    
  </entry>
  
  <entry>
    <title>三次握手和四次挥手</title>
    <link href="http://zongmansheng.club/2019/04/20/san-ci-wo-shou-he-si-ci-hui-shou/"/>
    <id>http://zongmansheng.club/2019/04/20/san-ci-wo-shou-he-si-ci-hui-shou/</id>
    <published>2019-04-20T12:31:54.000Z</published>
    <updated>2019-04-20T13:04:25.221Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三次握手和四次挥手"><a href="#三次握手和四次挥手" class="headerlink" title="三次握手和四次挥手"></a>三次握手和四次挥手</h1><h4 id="常用的熟知端口号"><a href="#常用的熟知端口号" class="headerlink" title="常用的熟知端口号"></a>常用的熟知端口号</h4><p><img src="//zongmansheng.club/2019/04/20/san-ci-wo-shou-he-si-ci-hui-shou/004.jpg" alt="004"></p><h4 id="TCP的概述"><a href="#TCP的概述" class="headerlink" title="TCP的概述"></a>TCP的概述</h4><pre><code>TCP把连接作为最基本的对象，每一条TCP连接都有两个端点，这种断点我们叫作套接字（socket），它的定义为端口号拼接到IP地址即构成了套接字，例如，若IP地址为192.3.4.16 而端口号为80，那么得到的套接字为192.3.4.16:80。</code></pre><h4 id="TCP报文首部"><a href="#TCP报文首部" class="headerlink" title="TCP报文首部"></a>TCP报文首部</h4><pre><code>1、源端口和目的端口，各占2个字节，分别写入源端口和目的端口；2、序号，占4个字节，TCP连接中传送的字节流中的每个字节都按顺序编号。例如，一段报文的序号字段值是 301 ，而携带的数据共有100字段，显然下一个报文段（如果还有的话）的数据序号应该从401开始；3、确认号，占4个字节，是期望收到对方下一个报文的第一个数据字节的序号。例如，B收到了A发送过来的报文，其序列号字段是501，而数据长度是200字节，这表明B正确的收到了A发送的到序号700为止的数据。因此，B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701；4、数据偏移，占4位，它指出TCP报文的数据距离TCP报文段的起始处有多远；5、保留，占6位，保留今后使用，但目前应都位0；6、紧急URG，当URG=1，表明紧急指针字段有效。告诉系统此报文段中有紧急数据；7、确认ACK，仅当ACK=1时，确认号字段才有效。TCP规定，在连接建立后所有报文的传输都必须把ACK置1；8、推送PSH，当两个应用进程进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应，这时候就将PSH=1；9、复位RST，当RST=1，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立连接；10、同步SYN，在连接建立时用来同步序号。当SYN=1，ACK=0，表明是连接请求报文，若同意连接，则响应报文中应该使SYN=1，ACK=1；11、终止FIN，用来释放连接。当FIN=1，表明此报文的发送方的数据已经发送完毕，并且要求释放；12、窗口，占2字节，指的是通知接收方，发送本报文你需要有多大的空间来接受；13、检验和，占2字节，校验首部和数据这两部分；14、紧急指针，占2字节，指出本报文段中的紧急数据的字节数；15、选项，长度可变，定义一些其他的可选的参数。</code></pre><pre><code>为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。漫画图解：图片来源：《图解HTTP》</code></pre><p><img src="//zongmansheng.club/2019/04/20/san-ci-wo-shou-he-si-ci-hui-shou/001.jpg" alt="001"></p><p>简单示意图：</p><p><img src="//zongmansheng.club/2019/04/20/san-ci-wo-shou-he-si-ci-hui-shou/002.jpg" alt="002"></p><p>动图：</p><p><img src="//zongmansheng.club/2019/04/20/san-ci-wo-shou-he-si-ci-hui-shou/005.gif" alt="005"></p><pre><code>- 客户端–发送带有 SYN 标志的数据包–一次握手–服务端- 服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端- 客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端</code></pre><pre><code>最开始的时候客户端和服务器都是处于CLOSED状态。主动打开连接的为客户端，被动打开连接的是服务器</code></pre><pre><code>1、TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态；2、TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。3、TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。4、TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。5、当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。</code></pre><p><img src="//zongmansheng.club/2019/04/20/san-ci-wo-shou-he-si-ci-hui-shou/006.png" alt="006"></p><h4 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h4><pre><code>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。第一次握手：Client 什么都不能确认；Server 确认了对方发送正常第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己接收正常，对方发送正常第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送接收正常所以三次握手就能确认双发收发功能都正常，缺一不可。</code></pre><h4 id="为什么要传回-SYN"><a href="#为什么要传回-SYN" class="headerlink" title="为什么要传回 SYN"></a>为什么要传回 SYN</h4><pre><code>接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。SYN 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement[汉译：确认字符 ,在数据通信传输中，接收站发给发送站的一种传输控制字符。它表示确认发来的数据已经接受无误。 ]）消息响应。这样在客户机和服务器之间才能建立起可靠的TCP连接，数据才可以在客户机和服务器之间传递。</code></pre><h4 id="传了-SYN-为啥还要传-ACK"><a href="#传了-SYN-为啥还要传-ACK" class="headerlink" title="传了 SYN,为啥还要传 ACK"></a>传了 SYN,为啥还要传 ACK</h4><pre><code>双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证。</code></pre><p><img src="//zongmansheng.club/2019/04/20/san-ci-wo-shou-he-si-ci-hui-shou/003.jpg" alt="003"></p><pre><code>断开一个 TCP 连接则需要“四次挥手”：- 客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送- 服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号- 服务器-关闭与客户端的连接，发送一个FIN给客户端- 客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1</code></pre><h4 id="TCP连接的释放（四次挥手）"><a href="#TCP连接的释放（四次挥手）" class="headerlink" title="TCP连接的释放（四次挥手）"></a>TCP连接的释放（四次挥手）</h4><p><img src="//zongmansheng.club/2019/04/20/san-ci-wo-shou-he-si-ci-hui-shou/007.gif" alt="007"></p><pre><code>数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于ESTABLISHED状态，然后客户端主动关闭，服务器被动关闭。</code></pre><pre><code>1、客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。2、服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。3、客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。4、服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。5、客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗ *∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。6、服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</code></pre><p><img src="//zongmansheng.club/2019/04/20/san-ci-wo-shou-he-si-ci-hui-shou/008.png" alt="008"></p><h4 id="为什么客户端最后还要等待2MSL？"><a href="#为什么客户端最后还要等待2MSL？" class="headerlink" title="为什么客户端最后还要等待2MSL？"></a>为什么客户端最后还要等待2MSL？</h4><pre><code>MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</code></pre><h4 id="为什么建立连接是三次握手，关闭连接确是四次挥手呢？"><a href="#为什么建立连接是三次握手，关闭连接确是四次挥手呢？" class="headerlink" title="为什么建立连接是三次握手，关闭连接确是四次挥手呢？"></a>为什么建立连接是三次握手，关闭连接确是四次挥手呢？</h4><pre><code>建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。</code></pre><h4 id="为什么要四次挥手"><a href="#为什么要四次挥手" class="headerlink" title="为什么要四次挥手"></a>为什么要四次挥手</h4><pre><code>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。</code></pre><h4 id="如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办？</h4><pre><code>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;三次握手和四次挥手&quot;&gt;&lt;a href=&quot;#三次握手和四次挥手&quot; class=&quot;headerlink&quot; title=&quot;三次握手和四次挥手&quot;&gt;&lt;/a&gt;三次握手和四次挥手&lt;/h1&gt;&lt;h4 id=&quot;常用的熟知端口号&quot;&gt;&lt;a href=&quot;#常用的熟知端口号&quot; class=&quot;
      
    
    </summary>
    
      <category term="计算机网络" scheme="http://zongmansheng.club/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="TCP" scheme="http://zongmansheng.club/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>原型模式</title>
    <link href="http://zongmansheng.club/2019/04/19/yuan-xing-mo-shi/"/>
    <id>http://zongmansheng.club/2019/04/19/yuan-xing-mo-shi/</id>
    <published>2019-04-19T14:07:51.000Z</published>
    <updated>2019-04-20T13:56:23.260Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><h4 id="一-原型模式介绍"><a href="#一-原型模式介绍" class="headerlink" title="一 原型模式介绍"></a>一 原型模式介绍</h4><pre><code>在面向对象系统中，使用原型模式来复制一个对象自身，从而克隆出多个与原型对象一模一样的对象。另外在软件系统中，有些对象的创建过程较为复杂，而且有时候需要频繁创建，原型模式通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的办法创建出更多同类型的对象，这就是原型模式的意图所在。</code></pre><p><img src="//zongmansheng.club/2019/04/19/yuan-xing-mo-shi/001.jpg" alt="001"></p><h5 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h5><p>GOF给出的原型模式定义如下：</p><pre class=" language-java"><code class="language-java">Specify the kind of objects to create using a prototypical instance<span class="token punctuation">,</span> and create <span class="token keyword">new</span> <span class="token class-name">objects</span> by copying <span class="token keyword">this</span> prototype<span class="token punctuation">.</span> （使用原型实例指定将要创建的对象类型，通过复制这个实例创建新的对象。）</code></pre><h5 id="1-2-原型模式适用场景"><a href="#1-2-原型模式适用场景" class="headerlink" title="1.2 原型模式适用场景"></a>1.2 原型模式适用场景</h5><pre><code>我们现在一般会使用new关键字指定类名生成类的实例（PS：我们以前使用java.lang.Cloneable的一个很大原因是使用new创建对象的速度相对来说会慢一些，随着JVM性能的提升，new的速度和Object的clone（）方法的速度差不多了。）。使用new关键字创建类的时候必须指定类名，但是在开发过程中也会有“在不指定类名的前提下生成实例”的需求。例如，在下面这些情况下，就需要根据现有的实例来生成新的实例。1) 对象种类繁多，无法将他们整合到一个类的时候；2) 难以根据类生成实例时；3) 想解耦框架与生成的实例时。如果想要让生成实例的框架不再依赖于具体的类，这时，不能指定类名来生成实例，而要事先“注册”一个“原型”实例，然后通过复制该实例来生成新的实例。</code></pre><h5 id="1-3-模式分析"><a href="#1-3-模式分析" class="headerlink" title="1.3 模式分析"></a>1.3 模式分析</h5><pre><code>在原型模式结构中定义了一个抽象原型类，所有的Java类都继承自java.lang.Object，而Object类提供一个clone()方法，可以将一个Java对象复制一份。因此在Java中可以直接使用Object提供的clone()方法来实现对象的克隆，Java语言中的原型模式实现很简单。能够实现克隆的Java类必须实现一个标识接口Cloneable，表示这个Java类支持复制。如果一个类没有实现这个接口但是调用了clone()方法，Java编译器将抛出一个CloneNotSupportedException异常。注意： `java.lang.Cloneable 只是起到告诉程序可以调用clone方法的作用，它本身并没有定义任何方法。在使用原型模式克隆对象时，根据其成员对象是否也克隆，原型模式可以分为两种形式：深克隆 和 浅克隆 。</code></pre><h5 id="1-4-模式优缺点分析"><a href="#1-4-模式优缺点分析" class="headerlink" title="1.4 模式优缺点分析"></a>1.4 模式优缺点分析</h5><p>原型模式的优点：</p><pre><code>1、当创建新的对象实例较为复杂时，使用原型模式可以简化对象的创建过程，通过一个已有实例可以提高新实例的创建效率。2、可以动态增加或减少产品类。3、原型模式提供了简化的创建结构。4、可以使用深克隆的方式保存对象的状态。</code></pre><p>原型模式的缺点：</p><pre><code>1、需要为每一个类配备一个克隆方法，而且这个克隆方法需要对类的功能进行通盘考虑，这对全新的类来说不是很难，但对已有的类进行改造时，不一定是件容易的事，必须修改其源代码，违背了“开闭原则”。2、在实现深克隆时需要编写较为复杂的代码。</code></pre><h4 id="二-示例程序"><a href="#二-示例程序" class="headerlink" title="二 示例程序"></a>二 示例程序</h4><p>下面示例程序的作用是将字符串放入方框中显示出来或者是加了下划线显示出来。</p><p>类和接口一览表：</p><p><img src="//zongmansheng.club/2019/04/19/yuan-xing-mo-shi/002.jpg" alt="002"></p><p>示例程序类图：</p><p><img src="//zongmansheng.club/2019/04/19/yuan-xing-mo-shi/003.jpg" alt="003"></p><h5 id="2-1-Product接口-（Prototype）"><a href="#2-1-Product接口-（Prototype）" class="headerlink" title="2.1 Product接口 （Prototype）"></a>2.1 Product接口 （Prototype）</h5><pre><code>    Product接口是复制功能接口，该接口继承了java.lang.Cloneable(只有实现了该接口的类的实例才可以调用clone()方法复制实例,否则会抛出异常).     另外需要注意：`java.lang.Cloneable 只是起到告诉程序可以调用clone方法的作用，它本身并没有定义任何方法。</code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @author ZongMan */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Product</span> <span class="token keyword">extends</span> <span class="token class-name">Cloneable</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//use方法是用于“使用”的方法，具体怎么“使用”，则被交给子类去实现</span>    <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">use</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//creatClone方法是用于复制实例的方法</span>    <span class="token keyword">abstract</span> Product <span class="token function">creatClone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h5 id="2-2-Manager类（Client）"><a href="#2-2-Manager类（Client）" class="headerlink" title="2.2 Manager类（Client）"></a>2.2 Manager类（Client）</h5><pre><code>Manager类使用Product接口来复制实例。Product接口以及Manager类的代码完全没有出现在MessageBox类和UnderlinePen类的名字，因此这意味着我们可以独立地修改Product接口以及Manager类，不受MessageBox类和UnderlinePen类的影响。这是非常重要的，因为 一旦在类中使用到了别的类名，就意味着该类与其他类紧密的地耦合在了一起 。在Manager类中，并没有写明具体的类名， 仅仅使用了Product这个接口名。也就是说，Product接口成为了连接Manager类与其他具体类之间的桥梁。</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>HashMap<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author ZongMan */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Manager</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//保存实例的“名字”和“实例”之间的对应关系</span>    <span class="token keyword">private</span> HashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Product<span class="token operator">></span> showcase <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*    register方法将接收到的一组“名字”和“Product接口”注册到showcase中。    这里Product是实现Product接口的实例，具体还未确定     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">register</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> Product product<span class="token punctuation">)</span> <span class="token punctuation">{</span>        showcase<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> product<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> Product <span class="token function">create</span><span class="token punctuation">(</span>String productname<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Product p <span class="token operator">=</span> showcase<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>productname<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> p<span class="token punctuation">.</span><span class="token function">creatClone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="2-3-MessageBox类（ConcreteProtorype）"><a href="#2-3-MessageBox类（ConcreteProtorype）" class="headerlink" title="2.3 MessageBox类（ConcreteProtorype）"></a>2.3 MessageBox类（ConcreteProtorype）</h5><p>装饰方框样式的具体原型，实现了Product接口，实现复制现有实例并生成新实例的方法。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @author ZongMan */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MessageBox</span> <span class="token keyword">implements</span> <span class="token class-name">Product</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//保存的是装饰方框使用的字符样式</span>    <span class="token keyword">private</span> <span class="token keyword">char</span> decochar<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">MessageBox</span><span class="token punctuation">(</span><span class="token keyword">char</span> decochar<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>decochar <span class="token operator">=</span> decochar<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">use</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> length <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"--------->"</span> <span class="token operator">+</span> decochar<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>decochar <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> str <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> decochar<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>decochar<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 该方法用于复制自己     * @return     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Product <span class="token function">creatClone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Product p <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            p <span class="token operator">=</span> <span class="token punctuation">(</span>Product<span class="token punctuation">)</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">CloneNotSupportedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> p<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>只有类自己（或是它的子类）能够调用Java语言中定义的clone方法。当其他类要求复制实例时，必须先调用createClone这样的方法，然后在该方法内部在调用clone方法。</code></pre><h5 id="2-4-UnderlinePen类（ConcreteProtorype）"><a href="#2-4-UnderlinePen类（ConcreteProtorype）" class="headerlink" title="2.4 UnderlinePen类（ConcreteProtorype）"></a>2.4 UnderlinePen类（ConcreteProtorype）</h5><pre><code>    下划线样式的具体原型，实现了Product接口，用于实现复制现有实例并生成新实例的方法。UnderlinePen类的实现几乎和MessageBox类一样，不同的可能只是use方法的实现。</code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @author ZongMan */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UnderlinePen</span> <span class="token keyword">implements</span> <span class="token class-name">Product</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">char</span> ulchar<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">UnderlinePen</span><span class="token punctuation">(</span><span class="token keyword">char</span> ulchar<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>ulchar <span class="token operator">=</span> ulchar<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">use</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> length <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"\""</span> <span class="token operator">+</span> str <span class="token operator">+</span> <span class="token string">"\""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>ulchar<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Product <span class="token function">creatClone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Product p <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            p <span class="token operator">=</span> <span class="token punctuation">(</span>Product<span class="token punctuation">)</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">CloneNotSupportedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> p<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span></code></pre><h5 id="2-5-Main类"><a href="#2-5-Main类" class="headerlink" title="2.5 Main类"></a>2.5 Main类</h5><pre><code>Main类首先生成Manager实例。接着，在Manager实例中通过`register方法注册了UnderlinePen类的实例（带名字）和MessageBox类的实例（带名字）。</code></pre><pre><code>package clone;/** * @author ZongMan */public class Main {    public static void main(String[] args) {        Manager manager = new Manager();        UnderlinePen underlinePen=new UnderlinePen(&#39;~&#39;);        MessageBox mbox=new MessageBox(&#39;*&#39;);        MessageBox sbox=new MessageBox(&#39;#&#39;);        manager.register(&quot;Strong message&quot;, underlinePen);        manager.register(&quot;Waring Box&quot;, mbox);        manager.register(&quot;Slash Box&quot;, sbox);        Product p1=manager.create(&quot;Strong message&quot;);        p1.use(&quot;hello world&quot;);        Product p2=manager.create(&quot;Waring Box&quot;);        p2.use(&quot;hello world&quot;);        Product p3=manager.create(&quot;Slash Box&quot;);        p3.use(&quot;hello world&quot;);    }}</code></pre><p>运行结果：</p><p><img src="//zongmansheng.club/2019/04/19/yuan-xing-mo-shi/004.jpg" alt="004"></p><h4 id="三-原型模式的角色分析"><a href="#三-原型模式的角色分析" class="headerlink" title="三 原型模式的角色分析"></a>三 原型模式的角色分析</h4><h5 id="3-1-Prototype（抽象原型类）"><a href="#3-1-Prototype（抽象原型类）" class="headerlink" title="3.1 Prototype（抽象原型类）"></a>3.1 Prototype（抽象原型类）</h5><pre><code>Product角色负责定义用于复制现有实例来生成新实例的方法。在示例程序中的Product接口就是该角色。</code></pre><h5 id="3-2-ConcretePrototype（具体原型类）"><a href="#3-2-ConcretePrototype（具体原型类）" class="headerlink" title="3.2 ConcretePrototype（具体原型类）"></a>3.2 ConcretePrototype（具体原型类）</h5><pre><code>ConcretePrototype角色负责实现复制现有实例并生成新实例的方法。在示例程序中，MessageBox和UnderlinePen都是该角色。</code></pre><h5 id="3-3-Client（客户类-使用者）"><a href="#3-3-Client（客户类-使用者）" class="headerlink" title="3.3 Client（客户类/使用者）"></a>3.3 Client（客户类/使用者）</h5><pre><code>Client角色负责使用复制实例的方法生成新的实例。在示例程序中，Manager类扮演的就是该角色。</code></pre><p>Prototype模式的类图：</p><p><img src="//zongmansheng.club/2019/04/19/yuan-xing-mo-shi/005.jpg" alt="005"></p><h4 id="四-原型模式的实际应用案例"><a href="#四-原型模式的实际应用案例" class="headerlink" title="四 原型模式的实际应用案例"></a>四 原型模式的实际应用案例</h4><pre><code>(1) 原型模式应用于很多软件中，如果每次创建一个对象要花大量时间，原型模式是最好的解决方案。很多软件提供的复制(Ctrl + C)和粘贴(Ctrl + V)操作就是原型模式的应用，复制得到的对象与原型对象是两个类型相同但内存地址不同的对象，通过原型模式可以大大提高对象的创建效率。(2) 在Struts2中为了保证线程的安全性，Action对象的创建使用了原型模式，访问一个已经存在的`Action对象时将通过克隆的方式创建出一个新的对象，从而保证其中定义的变量无须进行加锁实现同步，每一个Action中都有自己的成员变量，避免Struts1因使用单例模式而导致的并发和同步问题。(3) 在Spring中，用户也可以采用原型模式来创建新的bean实例，从而实现每次获取的是通过克隆生成的新实例，对其进行修改时对原有实例对象不造成任何影响。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原型模式&quot;&gt;&lt;a href=&quot;#原型模式&quot; class=&quot;headerlink&quot; title=&quot;原型模式&quot;&gt;&lt;/a&gt;原型模式&lt;/h1&gt;&lt;h4 id=&quot;一-原型模式介绍&quot;&gt;&lt;a href=&quot;#一-原型模式介绍&quot; class=&quot;headerlink&quot; title=&quot;一
      
    
    </summary>
    
      <category term="设计模式" scheme="http://zongmansheng.club/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="原型，复制" scheme="http://zongmansheng.club/tags/%E5%8E%9F%E5%9E%8B%EF%BC%8C%E5%A4%8D%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode</title>
    <link href="http://zongmansheng.club/2019/04/18/leetcode/"/>
    <id>http://zongmansheng.club/2019/04/18/leetcode/</id>
    <published>2019-04-18T14:10:48.000Z</published>
    <updated>2019-04-18T14:16:54.904Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode上的算法题"><a href="#LeetCode上的算法题" class="headerlink" title="LeetCode上的算法题"></a>LeetCode上的算法题</h1><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><pre><code>/** * @author ZongMan * @version 1.0 * @date 2019/4/18 0018 8:31 * 在给定的整数数组中，总有一个最大的元素。查找数组中的最大元素是否至少是数组中每个其他数字的两倍。 * 如果是，则返回最大元素的索引，否则返回-1。例如： * 输入：nums = [3,6,1,0] * 输出：1 * 说明：6是最大的整数，对于数组x中的每个其他数字，6是x的两倍多。 值6的索引是1，所以我们返回1。 * 输入：nums = [1,2,3,4] * 输出：-1 * 说明：4至少不是3的值的两倍，所以我们返回-1。 */</code></pre><h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo01</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">dominantIndex</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"----------------------------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">dominantIndex2</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 题目的要求是返回最大数的索引，所以需要先将最大数找出来，并记录下其索引。     * 然后在次遍历数组中的元素，将最大数之外的其他数都乘以2和最大数比较(在此处我是使用位移处理)，     * 如果大于就返回-1，如果其他元素都满足条件，就返回之前记录的最大数的索引。     *     * @param nums 数组     * @return 相对应的结果     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">dominantIndex</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> max<span class="token punctuation">)</span> <span class="token punctuation">{</span>                max <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                index <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> max <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span> <span class="token operator">></span> max<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> index<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 我们还可以只使用一次循环来解决。并非需要使用每一个元素乘以2后再去和最大元素比较，     * 只需要用第二大的数去比较就行，如果第二大的数不能满足条件，就可以直接做判断了。     * 比如[2,3,4]，3乘以2等于6大于4，不符合题目要求，就不需要比较2了。     * @param nums 数组     * @return 对应结果     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">dominantIndex2</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> second <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> max<span class="token punctuation">)</span> <span class="token punctuation">{</span>                second <span class="token operator">=</span> max<span class="token punctuation">;</span>                max <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                index <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> second<span class="token punctuation">)</span> <span class="token punctuation">{</span>                second <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> second <span class="token operator">&lt;&lt;</span> <span class="token number">1</span> <span class="token operator">&lt;=</span> max <span class="token operator">?</span> index <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;LeetCode上的算法题&quot;&gt;&lt;a href=&quot;#LeetCode上的算法题&quot; class=&quot;headerlink&quot; title=&quot;LeetCode上的算法题&quot;&gt;&lt;/a&gt;LeetCode上的算法题&lt;/h1&gt;&lt;h4 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述
      
    
    </summary>
    
      <category term="每日算法" scheme="http://zongmansheng.club/categories/%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="http://zongmansheng.club/tags/LeetCode/"/>
    
      <category term="算法" scheme="http://zongmansheng.club/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>DNS劫持投毒解析</title>
    <link href="http://zongmansheng.club/2019/04/17/dns-jie-chi-tou-du-jie-xi/"/>
    <id>http://zongmansheng.club/2019/04/17/dns-jie-chi-tou-du-jie-xi/</id>
    <published>2019-04-17T05:08:59.000Z</published>
    <updated>2019-04-17T14:01:39.802Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DNS劫持投毒解析"><a href="#DNS劫持投毒解析" class="headerlink" title="DNS劫持投毒解析"></a>DNS劫持投毒解析</h1><p>本文以第一人称来讲述：</p><h4 id="一、什么是URL和IP"><a href="#一、什么是URL和IP" class="headerlink" title="一、什么是URL和IP"></a>一、什么是URL和IP</h4><pre><code>    我的冒险，要从一张“羊皮卷”说起。那天，浏览器大叔神秘兮兮招呼我过去，告诉我CPU下达了一个命令：派遣使者访问外邦。而我是大叔最得力的门生，也是这类任务最合适的人选。大叔为我准备了一张羊皮卷，上面记录了我这次冒险需要用到的必要信息。当仁不让地，我接过了它，即刻启程。我缓缓展开羊皮卷，第一行赫然写着：URL: https://mail.google.com    什么是“URL”？我在脑中快速回忆着，对了！URL即 Uniform Resource Locator的缩写，翻译成中文便是“统一资源定位符”。因为互联网世界存在着不计其数的资源，每一处资源都需要有一个标记来定位它，正如人类城市中的门牌号。    有人可能会认为，既然有了门牌号，找到指定地点不是轻而易举吗？朋友们，我也希望如此，但现实往往没有这么简单。    即使有了URL，恕我愚笨，我还是无法直接理解它所指向的目的地。因为这是人类的语言，我无法翻译解读。（其实是人类太笨了，记不住IP地址，需要用方便记忆的域名来代替）    对我来说，IP地址才是唯一的坐标。什么是IP？IP即Internet Protocol的缩写，中文译为“互联网协议”，一个如雷贯耳的名字，互联网的基石之一，一切依赖互联网通信的软件都得遵循这个协议。那么，如何才能将域名转换为IP地址呢？    浏览器大叔在平日工作之余，十分细心，他将用户访问过的站点整理了一份“域名-IP对应清单”。假如是一个已被记录的IP地址，那么他会直接告诉我，我可以立即向着目标IP地址出发，这就是浏览器缓存的作用。    假如用户输入的URL不在浏览器的记录范围之内，那么操作系统会查找一个名为“hosts”的文件。它是一份文本，记录了域名和IP地址的映射。如果“hosts”能够告诉我目标IP地址，那也能节省我不少工夫。这就是系统缓存。此外，还有路由器缓存，相信不用我多介绍了，即保存在路由器中的域名-IP映射。    这些缓存都能有效帮助我以最快的速度找到相应的IP地址。但是，互联网世界日新月异，各种资源层出不穷。在很多情况下，用户会想要访问一个全新的、任何缓存都没有记录过的域名。    为此，人类专门设计了DNS。在这次任务中，我的第一站，就是赶往DNS。为了更短的响应时间与更好的用户体验，我快马加鞭。</code></pre><h4 id="二、关于DNS劫持的记忆"><a href="#二、关于DNS劫持的记忆" class="headerlink" title="二、关于DNS劫持的记忆"></a>二、关于DNS劫持的记忆</h4><h5 id="DNS是什么？"><a href="#DNS是什么？" class="headerlink" title="DNS是什么？"></a>DNS是什么？</h5><pre><code>全称Domain Name System，是一个将域名和IP相互映射的分布式数据库。    全球有很多家DNS服务中心，假如你关心过你的计算机，你会发现，在你的网卡上，有着一项“DNS服务器”的配置项，它设定了我将要抵达的目的地。</code></pre><p><img src="//zongmansheng.club/2019/04/17/dns-jie-chi-tou-du-jie-xi/001.png" alt="001"></p><pre><code>一转眼的工夫，我来到了114.114.114.114DNS中心。    这个地方我来过很多次，表面上风平浪静，实则暗流涌动。我小心翼翼地来到办事大厅，不禁想起了我第一次被DNS劫持的经历。那天，我来到办事窗口，柜员热情地接待了我。    “先生，请问你想要查询哪个地址？”当时我还是一位新晋的网络请求，涉世尚浅，不知晓一些不可说的条例，于是毫不避讳地回答：“你好，我要去大名鼎鼎的mail.google.com！”    柜员的表情一下子凝固了，他上下打量了我一番，然后硬挤出一丝微笑，“好的先生，请稍等。”说完，他便向旁边的同事使了个眼色。我正纳闷呢，突然两边窜出身材魁梧的警卫，架着我强行往一处拖拽。我这才意识到大事不妙，“这是怎么回事？！你们凭什么劫持我？”我发疯了一般嘶吼着。    “你好，根据本ISP（电信运营商）颁布的条例，世界上不存在你所说的站点，现怀疑你是一个不合规的网络请求，将把你转发至baidu.com的IP地址。你有权保持沉默！”警卫冷漠地望着我。我知道，现在无论如何解释、挣扎都没有用了，只怪自己太年轻。无奈，我只好乖乖就范。</code></pre><p><img src="//zongmansheng.club/2019/04/17/dns-jie-chi-tou-du-jie-xi/002.png" alt="002"></p><pre><code>    还好当时正在使用计算机的用户有一些网络知识，当他发现自己输入的是google，返回的是baidu的页面时，并没有怪罪于我，大概是他心中已经猜到了原因。于是他将网卡的DNS配置为：8.8.8.8，这是一个国际上“不存在”的公司提供的DNS服务中心。仅仅这样就能畅通无阻地访问互联网了吗？经历了被DNS劫持，我依然不敢放松。</code></pre><h4 id="三、我遇到过DNS投毒"><a href="#三、我遇到过DNS投毒" class="headerlink" title="三、我遇到过DNS投毒"></a>三、我遇到过DNS投毒</h4><pre><code>还未休息片刻，浏览器大叔再一次地给我分配了任务：继续尝试请求mail.google.com的资源。    人类出国要坐飞机，要办护照。我们网络请求也是这样，全国只有在几个主要城市才会部署国际出口，所有访问境外资源的网络请求，都得经过这儿接受检查。与上次不同，因为这次我要访问的DNS服务器位于海外，所以我首先来到了大中华局域网的上海国际出口。我一路奔波到上海真的是又累又乏，正当我火急火燎地准备过安检，通道附近有一位穿着制服的小伙迎了上来。    还没等我开口，他热情地迎了上来：“远道而来的朋友，一定是十分疲惫了吧？天气这么热，先喝杯水吧！”我悄悄地打量着他，看他的打扮应该是一位服务人员。    “国际出口就是不一样啊，服务真到位！”由于确实是太渴了，我放松了警惕。“啊，真清凉，谢……”我一边感叹着，一边接过了小伙递给我的水。可当我第二个“谢”字还没说出口，立即感到一阵头晕目眩。    “不好！遇上了黑客，这是DNS投毒！”我的视线渐渐模糊，小伙的微笑也渐渐似乎变成了狞笑。我尽力搜索着脑海中和这一切有关的知识，想要知道寻求的办法。</code></pre><p><img src="//zongmansheng.club/2019/04/17/dns-jie-chi-tou-du-jie-xi/003.png" alt="003"></p><pre><code> DNS投毒，英文叫DNS cache poisoning，也叫做DNS污染。从客户端向DNS服务器发出查询IP的请求，到响应返回到客户端的这段时间里，如果有黑客或者其他一些不可说的设施伪造返回了一个错误的DNS应答，那么用户将不能访问到真正的资源。想到这里，我已经明显感觉难以控制自己的身体了，眼前一黑，就什么都不知道了。</code></pre><h4 id="四、DNS正常解析"><a href="#四、DNS正常解析" class="headerlink" title="四、DNS正常解析"></a>四、DNS正常解析</h4><pre><code>以前发生过的险情历历在目，如今想起来，我依旧心有余悸。这次，为了确保万无一失，我打起了十二分精神。这次，我已经顺利来到8.8.8.8 DNS服务中心。“你好亲，有什么可以帮到您的嘛”办事窗口内传来了软妹子的声音。“我想查询域名mail.google.com的IP地址。”我试探性地问，依然不敢松懈。“好的呢亲，这边通过树状检索，在顶级域名com下，查询到google目录，在google目录下查询到mail,IP地址是xx.xxx.xx.xx呢。”</code></pre><p><img src="//zongmansheng.club/2019/04/17/dns-jie-chi-tou-du-jie-xi/004.png" alt="004"></p><pre><code>    我松了口气，谢天谢地，终于拿到了结果。可我知道作为一次完整的网络请求，这刚刚开始，这才是万里长征第一步，我得赶紧将这个解析结果带回去，等会还得马不停蹄往返三次建立连接。</code></pre><p><img src="//zongmansheng.club/2019/04/17/dns-jie-chi-tou-du-jie-xi/005.png" alt="005"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DNS劫持投毒解析&quot;&gt;&lt;a href=&quot;#DNS劫持投毒解析&quot; class=&quot;headerlink&quot; title=&quot;DNS劫持投毒解析&quot;&gt;&lt;/a&gt;DNS劫持投毒解析&lt;/h1&gt;&lt;p&gt;本文以第一人称来讲述：&lt;/p&gt;
&lt;h4 id=&quot;一、什么是URL和IP&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="进阶" scheme="http://zongmansheng.club/categories/%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="DNS，劫持，投毒，解析" scheme="http://zongmansheng.club/tags/DNS%EF%BC%8C%E5%8A%AB%E6%8C%81%EF%BC%8C%E6%8A%95%E6%AF%92%EF%BC%8C%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap</title>
    <link href="http://zongmansheng.club/2019/04/16/concurrenthashmap/"/>
    <id>http://zongmansheng.club/2019/04/16/concurrenthashmap/</id>
    <published>2019-04-16T00:42:45.000Z</published>
    <updated>2019-04-17T14:12:53.084Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><pre><code>JDK8 对ConcurrentHashMap 进行了脱胎换骨式的改造，使用了大量的lock-free 技术来减轻因锁的竞争而对性能造成的影响。ConcurrentHashMap 被Segment 分成了很多小区，Segment 就相当于小区保安，HashEntry 列表相当于小区业主，小区保安通过加锁的方式，保证每个Segment 内都不发生冲突。</code></pre><p><img src="//zongmansheng.club/2019/04/16/concurrenthashmap/001.png" alt="001"></p><pre><code>通过分析Hashtable就知道，synchronized是针对整张Hash表的，即每次锁住整张表让线程独占，ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术。它使用了多个锁来控制对hash表的不同部分进行的修改。ConcurrentHashMap内部使用段(Segment)来表示这些不同的部分，每个段其实就是一个小的hash table，它们有自己的锁。只要多个修改操作发生在不同的段上，它们就可以并发进行。有些方法需要跨段，比如size()和containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁。这里“按顺序”是很重要的，否则极有可能出现死锁，在ConcurrentHashMap内部，段数组是final的，并且其成员变量实际上也是final的，但是，仅仅是将数组声明为final的并不保证数组成员也是final的，这需要实现上的保证。这可以确保不会出现死锁，因为获得锁的顺序是固定的。</code></pre><pre><code>数据存储结构分为2种：            链表            红黑树</code></pre><pre><code>当某个槽内的元素个数增加到超过8个，且table的容量大于或者等于64时，由链表转为红黑树；当某个槽内的元素个数减少到6个时，由红黑树重新转回链表。</code></pre><pre><code>table 扩容：当table需要进行扩容时，依次遍历当前table 中的每一个槽位，如果不为null，则需要把其中所有的元素根据 hash 值放入扩容后的 nextTable 中，而元table的槽内会放置一个 ForwardingNode 节点。此节点会把 find() 请求转发到扩容后的 nextTable 上。而执行 put() 方法的线程，如果碰到此节点，也会协助进行迁移。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ConcurrentHashMap&quot;&gt;&lt;a href=&quot;#ConcurrentHashMap&quot; class=&quot;headerlink&quot; title=&quot;ConcurrentHashMap&quot;&gt;&lt;/a&gt;ConcurrentHashMap&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;JD
      
    
    </summary>
    
      <category term="基础底层" scheme="http://zongmansheng.club/categories/%E5%9F%BA%E7%A1%80%E5%BA%95%E5%B1%82/"/>
    
    
      <category term="ConcurrentHashMap" scheme="http://zongmansheng.club/tags/ConcurrentHashMap/"/>
    
      <category term="HashMap" scheme="http://zongmansheng.club/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>sort排序原理</title>
    <link href="http://zongmansheng.club/2019/04/15/sort-pai-xu-yuan-li/"/>
    <id>http://zongmansheng.club/2019/04/15/sort-pai-xu-yuan-li/</id>
    <published>2019-04-15T05:17:48.000Z</published>
    <updated>2019-04-15T05:22:13.168Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java-sort排序原理"><a href="#java-sort排序原理" class="headerlink" title="java sort排序原理"></a>java sort排序原理</h1><pre><code>    事实上Collections.sort方法底层就是调用的Arrays.sort方法，而Arrays.sort使用了两种排序方法，快速排序和优化的归并排序。快速排序主要是对那些基本类型数据（int,short,long等）排序， 而归并排序用于对Object类型进行排序。    使用不同类型的排序算法主要是由于快速排序是不稳定的，而归并排序是稳定的。这里的稳定是指比较相等的数据在排序之后仍然按照排序之前的前后顺序排列。对于基本数据类型，稳定性没有意义，而对于Object类型，稳定性是比较重要的，因为对象相等的判断可能只是判断关键属性，最好保持相等对象的非关键属性的顺序与排序前一致；另外一个原因是由于归并排序相对而言比较次数比快速排序少，移动（对象引用的移动）次数比快速排序多，而对于对象来说，比较一般比移动耗时。    此外，对大数组排序。快速排序的sort()采用递归实现，数组规模太大时会发生堆栈溢出，而归并排序sort()采用非递归实现，不存在此问题。</code></pre><pre><code>总结：首先先判断需要排序的数据量是否大于60。小于60：使用插入排序，插入排序是稳定的大于60的数据量会根据数据类型选择排序方式：基本类型：使用快速排序。因为基本类型。1、2都是指向同一个常量池不需要考虑稳定性。Object类型：使用归并排序。因为归并排序具有稳定性。注意：不管是快速排序还是归并排序。在二分的时候小于60的数据量依旧会使用插入排序</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java-sort排序原理&quot;&gt;&lt;a href=&quot;#java-sort排序原理&quot; class=&quot;headerlink&quot; title=&quot;java sort排序原理&quot;&gt;&lt;/a&gt;java sort排序原理&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;    事实上Collections
      
    
    </summary>
    
      <category term="java基础" scheme="http://zongmansheng.club/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="sort" scheme="http://zongmansheng.club/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>Spring中AOP的两种代理</title>
    <link href="http://zongmansheng.club/2019/04/14/spring-zhong-aop-de-liang-chong-dai-li/"/>
    <id>http://zongmansheng.club/2019/04/14/spring-zhong-aop-de-liang-chong-dai-li/</id>
    <published>2019-04-14T13:23:15.000Z</published>
    <updated>2019-04-14T14:28:33.664Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring中AOP的两种代理"><a href="#Spring中AOP的两种代理" class="headerlink" title="Spring中AOP的两种代理"></a>Spring中AOP的两种代理</h1><h2 id="方式动态代理和CGLIB详解"><a href="#方式动态代理和CGLIB详解" class="headerlink" title="方式动态代理和CGLIB详解"></a>方式动态代理和CGLIB详解</h2><h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><h5 id="1、什么是代理"><a href="#1、什么是代理" class="headerlink" title="1、什么是代理"></a>1、什么是代理</h5><pre><code>    代理的概念容易理解，比如：微商，简单来说微商就是替厂家卖商品。当我们从微商(代理)那里买东西时通常不知道背后的商家究竟是谁，也就是说，委托者对我们来说是不可见的。作为微商，有其自己的目标客户，这也相当于为厂家做了一次过滤。把微商和厂家进一步抽象，微商可以抽象为代理类，厂家可抽象为委托类(被代理类)。通过微商和厂家特点可知，通过使用代理，通常有两个优点：其一:可以隐藏委托类的实现;其二:可以实现客户与委托类间的解耦，在不修改委托类代码的情况下能够做一些额外的处理。</code></pre><h5 id="2、静态代理"><a href="#2、静态代理" class="headerlink" title="2、静态代理"></a>2、静态代理</h5><pre><code>若代理类在程序运行前就已经存在，那么这种代理方式被成为静态代理。这种情况下的代理类通常都是我们在Java代码中定义的。 通常情况下，静态代理中的代理类和委托类会实现同一接口或是派生自相同的父类。 下面我们用Vendor类代表生产厂家，BusinessAgent类代表微商代理，来介绍下静态代理的简单实现。委托类和代理类都实现了Sell接口，Sell接口的定义如下：</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> test<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author ZongMan * @version 1.0 * @date 2019/4/14 0014 21:29 */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Sell</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">sell</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>Vendor类的定义如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> test<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author ZongMan * @version 1.0 * @date 2019/4/14 0014 22:06 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Vendor</span> <span class="token keyword">implements</span> <span class="token class-name">Sell</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sell</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"sell method"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"add method"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>BusinessAgent类的定义如下:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> test<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author ZongMan * @version 1.0 * @date 2019/4/14 0014 22:07 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BusinessAgent</span> <span class="token keyword">implements</span> <span class="token class-name">Sell</span> <span class="token punctuation">{</span>    Vendor vendor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vendor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sell</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isCollegeStudent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            vendor<span class="token punctuation">.</span><span class="token function">sell</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isCollegeStudent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>    从BusinessAgent类的定义我们可以了解到，静态代理可以通过聚合来实现，让代理类持有一个委托类的引用即可。    如果需要增加一个需求：给Vendor类增加一个过滤功能，不可以卖给学生。通过静态代理，我们无需修改Vendor类的代码就可以实现，只需在BusinessAgent类中的sell方法中添加一个判断即可。如上图可以。    这对应着我们上面提到的使用代理的第二个优点：可以实现客户与委托类间的解耦，在不修改委托类代码的情况下能够做一些额外的处理。静态代理的局限在于运行前必须编写好代理类，下面我们重点来介绍下运行时生成代理类的动态代理方式，即动态代理机制。</code></pre><h4 id="二、动态代理"><a href="#二、动态代理" class="headerlink" title="二、动态代理"></a>二、动态代理</h4><pre><code>    代理类在程序运行时创建的代理方式被成为 动态代理。 也就是说，这种情况下，代理类并不是在Java代码中定义的，而是在运行时根据我们在Java代码中的“指示”动态生成的。相比于静态代理， 动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类的函数。 这么说比较抽象，下面我们结合一个实例来介绍一下动态代理的这个优势是怎么体现的。    现在，假设我们要实现这样一个需求：在执行委托类中的方法之前输出“before”，在执行完毕后输出“after”。我们还是以上面例子中的Vendor类作为委托类，BusinessAgent类作为代理类来进行介绍。首先我们来使用静态代理来实现这一需求，相关代码如下：</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> test<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author ZongMan * @version 1.0 * @date 2019/4/14 0014 22:07 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BusinessAgent</span> <span class="token keyword">implements</span> <span class="token class-name">Sell</span> <span class="token punctuation">{</span>    Vendor vendor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vendor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sell</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"before"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isCollegeStudent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            vendor<span class="token punctuation">.</span><span class="token function">sell</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isCollegeStudent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"before"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vendor<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>    从以上代码中我们可以了解到，通过静态代理实现我们的需求需要我们在每个方法中都添加相应的逻辑，这里只存在两个方法所以工作量还不算大，假如Sell接口中包含上百个方法呢?这时候使用静态代理就会编写许多冗余代码。通过使用动态代理，我们可以做一个“统一指示”，从而对所有代理类的方法进行统一处理，而不用逐一修改每个方法。下面我们来具体介绍下如何使用动态代理方式实现我们的需求。</code></pre><h5 id="使用动态代理"><a href="#使用动态代理" class="headerlink" title="使用动态代理"></a>使用动态代理</h5><pre><code>(1)InvocationHandler接口在使用动态代理时，我们需要定义一个位于代理类与委托类之间的中介类，这个中介类被要求实现InvocationHandler接口，这个接口的定义如下：</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> test<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Method<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author ZongMan * @version 1.0 * @date 2019/4/14 0014 22:13 */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">InvocationHandler</span> <span class="token punctuation">{</span>    Object <span class="token function">invoke</span><span class="token punctuation">(</span>Object proxy<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span>Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre><code>从InvocationHandler这个名称我们就可以知道，实现了这个接口的中介类用做“调用处理器”。当我们调用代理类对象的方法时，这个“调用”会转送到invoke方法中，代理类对象作为proxy参数传入，参数method标识了我们具体调用的是代理类的哪个方法，args为这个方法的参数。这样一来，我们对代理类中的所有方法的调用都会变为对invoke的调用，这样我们可以在invoke方法中添加统一的处理逻辑(也可以根据method参数对不同的代理类方法做不同的处理)。因此我们只需在中介类的invoke方法实现中输出“before”，然后调用委托类的invoke方法，再输出“after”。下面我们来一步一步具体实现它。(2)委托类的定义动态代理方式下，要求委托类必须实现某个接口，这里我们实现的是Sell接口。委托类Vendor类的定义如下：</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> test<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author ZongMan * @version 1.0 * @date 2019/4/14 0014 22:06 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Vendor</span> <span class="token keyword">implements</span> <span class="token class-name">Sell</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sell</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"sell method"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"add method"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>(3)中介类上面我们提到过，中介类必须实现InvocationHandler接口，作为调用处理器”拦截“对代理类方法的调用。中介类的定义如下：</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> test<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Method<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author ZongMan * @version 1.0 * @date 2019/4/14 0014 22:17 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DynamicProxy</span> <span class="token keyword">implements</span> <span class="token class-name">InvocationHandler</span><span class="token punctuation">,</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>InvocationHandler <span class="token punctuation">{</span>    <span class="token keyword">private</span> Object object<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">DynamicProxy</span><span class="token punctuation">(</span>Object object<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>object <span class="token operator">=</span> object<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Object <span class="token function">invoke</span><span class="token punctuation">(</span>Object proxy<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"before"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Object result <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>object<span class="token punctuation">,</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>从以上代码中我们可以看到，中介类持有一个委托类对象引用，在invoke方法中调用了委托类对象的相应方法，通过聚合方式持有委托类对象引用，把外部对invoke的调用最终都转为对委托类对象的调用。下面我们来介绍一下如何”指示“以动态生成代理类。(4)动态生成代理类动态生成代理类的相关代码如下：</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> test<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Proxy<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author ZongMan * @version 1.0 * @date 2019/4/14 0014 22:20 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//创建中介类实例</span>        DynamicProxy inter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DynamicProxy</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Vendor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//获取代理类实例sell</span>        Sell sell <span class="token operator">=</span> <span class="token punctuation">(</span>Sell<span class="token punctuation">)</span> Proxy<span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span>Sell<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>Sell<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">,</span>inter<span class="token punctuation">)</span><span class="token punctuation">;</span>        sell<span class="token punctuation">.</span><span class="token function">sell</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sell<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>在以上代码中，我们调用Proxy类的newProxyInstance方法来获取一个代理类实例。这个代理类实现了我们指定的接口并且会把方法调用分发到指定的调用处理器。这个方法的声明如下：</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> Object <span class="token function">newProxyInstance</span><span class="token punctuation">(</span>ClassLoader loader<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> interfaces<span class="token punctuation">,</span> InvocationHandler h<span class="token punctuation">)</span> <span class="token keyword">throws</span> IllegalArgumentException</code></pre><pre><code>方法的三个参数含义分别如下：loader：定义了代理类的ClassLoder;interfaces：代理类实现的接口列表h：调用处理器，也就是我们上面定义的实现了InvocationHandler接口的类实例这里再简单的总结下：首先通过newProxyInstance方法获取代理类实例，而后我们便可以通过这个代理类实例调用代理类的方法，对代理类的方法的调用实际上都会调用中介类(调用处理器)的invoke方法，在invoke方法中我们调用委托类的相应方法，并且可以添加自己的处理逻辑。如上将上面代理、静态代理，动态代理都理解，下面讲解Spring中AOP的两种代理方式（Java动态代理和CGLIB代理）</code></pre><h5 id="1、动态代理"><a href="#1、动态代理" class="headerlink" title="1、动态代理"></a>1、动态代理</h5><pre><code>相关概念及用法上面已经讲到，其具体有如下四步骤：1、通过实现 InvocationHandler 接口创建自己的调用处理器；2、通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来创建动态代理类；3、通过反射机制获得动态代理类的构造函数，其唯一参数类型是调用处理器接口类型；4、通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入。</code></pre><h5 id="2、GCLIB代理"><a href="#2、GCLIB代理" class="headerlink" title="2、GCLIB代理"></a>2、GCLIB代理</h5><pre><code>cglib（Code Generation Library）是一个强大的,高性能,高质量的Code生成类库。它可以在运行期扩展Java类与实现Java接口。cglib封装了asm，可以在运行期动态生成新的class。cglib用于AOP，jdk中的proxy必须基于接口，cglib却没有这个限制。</code></pre><h5 id="3、原理区别："><a href="#3、原理区别：" class="headerlink" title="3、原理区别："></a>3、原理区别：</h5><pre><code>java动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。而cglib动态代理是利用asm开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。1、如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP 2、如果目标对象实现了接口，可以强制使用CGLIB实现AOP 3、如果目标对象没有实现了接口，必须采用CGLIB库，spring会自动在JDK动态代理和CGLIB之间转换Spring自己的CGLIB的实现方式,他是生成了一个被代理类的子类,你也可以在子类中增加父类没有的功能.如何强制使用CGLIB实现AOP？ * 添加CGLIB库，SPRING_HOME/cglib/*.jar * 在spring配置文件中加入&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt;4、JDK动态代理和CGLIB字节码生成的区别？ * JDK动态代理只能对实现了接口的类生成代理，而不能针对类 * CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法 因为是继承，所以该类或方法最好不要声明成final。*要将CGLIB的二进制发行包放在classpath下。5、Spring AOP里面的代理实现方式spring用代理类包裹切面，把他们织入到Spring管理的bean中。也就是说代理类伪装成目标类，它会截取对目标类中方法的调用，让调用者对目标类的调用都先变成调用伪装类，伪装类中就先执行了切面，再把调用转发给真正的目标bean。现在可以自己想一想，怎么搞出来这个伪装类，才不会被调用者发现（过JVM的检查，JAVA是强类型检查，哪里都要检查类型）。1.实现和目标类相同的接口，我也实现和你一样的接口，反正上层都是接口级别的调用，这样我就伪装成了和目标类一样的类（实现了同一接口，咱是兄弟了），也就逃过了类型检查，到java运行期的时候，利用多态的后期绑定（所以spring采用运行时），伪装类（代理类）就变成了接口的真正实现，而他里面包裹了真实的那个目标类，最后实现具体功能的还是目标类，只不过伪装类在之前干了点事情（写日志，安全检查，事物等）。2.生成子类调用，这次用子类来做为伪装类，当然这样也能逃过JVM的强类型检查，我继承的吗，当然查不出来了，子类重写了目标类的所有方法，当然在这些重写的方法中，不仅实现了目标类的功能，还在这些功能之前，实现了一些其他的（写日志，安全检查，事物等）。前一种兄弟模式，spring会使用JDK的java.lang.reflect.Proxy类，它允许Spring动态生成一个新类来实现必要的接口，织入通知，并且把对这些接口的任何调用都转发到目标类。后一种父子模式，spring使用CGLIB库生成目标类的一个子类，在创建这个子类的时候，spring织入通知，并且把对这个子类的调用委托到目标类。相比之下，还是兄弟模式好些，他能更好的实现松耦合，尤其在今天都高喊着面向接口编程的情况下，父子模式只是在没有实现接口的时候，也能织入通知，应当做一种例外。</code></pre><h4 id="三、spring-aop的使用方式："><a href="#三、spring-aop的使用方式：" class="headerlink" title="三、spring aop的使用方式："></a>三、spring aop的使用方式：</h4><h5 id="使用aop的目的："><a href="#使用aop的目的：" class="headerlink" title="使用aop的目的："></a>使用aop的目的：</h5><pre><code>1就是为了方便，看一个国外很有名的大师说，编程的人都是“懒人”，因为他把自己做的事情都让程序做了。用了aop能让你少写很多代码，这点就够充分了吧2就是为了更清晰的逻辑，可以让你的业务逻辑去关注自己本身的业务，而不去想一些其他的事情，这些其他的事情包括：安全，事物，日志等。</code></pre><h5 id="第一种实现方式：使用AspectJ提供的注解package-test-mine-spring-bean"><a href="#第一种实现方式：使用AspectJ提供的注解package-test-mine-spring-bean" class="headerlink" title="第一种实现方式：使用AspectJ提供的注解package test.mine.spring.bean;"></a>第一种实现方式：使用AspectJ提供的注解package test.mine.spring.bean;</h5><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> org<span class="token punctuation">.</span>aspectj<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>AfterReturning<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>aspectj<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Aspect<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>aspectj<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Before<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>aspectj<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Pointcut<span class="token punctuation">;</span><span class="token annotation punctuation">@Aspect</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SleepHelper</span> <span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token function">SleepHelper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Pointcut</span><span class="token punctuation">(</span><span class="token string">"execution(* *.sleep())"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sleeppoint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Before</span><span class="token punctuation">(</span><span class="token string">"sleeppoint()"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">beforeSleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"睡觉前要脱衣服!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@AfterReturning</span><span class="token punctuation">(</span><span class="token string">"sleeppoint()"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterSleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"睡醒了要穿衣服！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>用@Aspect的注解来标识切面,注意不要把它漏了，否则Spring创建代理的时候会找不到它,@Pointcut注解指定了切点，@Before和@AfterReturning指定了运行时的通知，注意的是要在注解中传入切点的名称。然后我们在Spring配置文件上下点功夫,首先是增加AOP的XML命名空间和声明相关schema命名空间:xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;schema声明:http://www.springframework.org/schema/aophttp://www.springframework.org/schema/aop/spring-aop-2.0.xsd然后加上这个标签:&lt;aop:aspectj-autoproxy/&gt; 有了这个Spring就能够自动扫描被@Aspect标注的切面了最后是运行，很简单方便了：</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>ApplicationContext appCtx <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">"applicationContext.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Sleepable human <span class="token operator">=</span> <span class="token punctuation">(</span>Sleepable<span class="token punctuation">)</span>appCtx<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"human"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>human<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="第二种使用方式："><a href="#第二种使用方式：" class="headerlink" title="第二种使用方式："></a>第二种使用方式：</h5><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sleepHelper<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>test.spring.aop.bean.SleepHelper<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">aop:</span>config</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">aop:</span>aspect</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sleepHelper<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">aop:</span>before</span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>beforeSleep<span class="token punctuation">"</span></span> <span class="token attr-name">pointcut</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>execution(* *.sleep(..))<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">aop:</span>after</span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>afterSleep<span class="token punctuation">"</span></span> <span class="token attr-name">pointcut</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>execution(* *.sleep(..))<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">aop:</span>aspect</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">aop:</span>config</span><span class="token punctuation">></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring中AOP的两种代理&quot;&gt;&lt;a href=&quot;#Spring中AOP的两种代理&quot; class=&quot;headerlink&quot; title=&quot;Spring中AOP的两种代理&quot;&gt;&lt;/a&gt;Spring中AOP的两种代理&lt;/h1&gt;&lt;h2 id=&quot;方式动态代理和CGLIB详
      
    
    </summary>
    
      <category term="Spring" scheme="http://zongmansheng.club/categories/Spring/"/>
    
    
      <category term="框架" scheme="http://zongmansheng.club/tags/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="AOP" scheme="http://zongmansheng.club/tags/AOP/"/>
    
      <category term="Spring" scheme="http://zongmansheng.club/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>30道java面试题</title>
    <link href="http://zongmansheng.club/2019/04/13/30-dao-java-mian-shi-ti/"/>
    <id>http://zongmansheng.club/2019/04/13/30-dao-java-mian-shi-ti/</id>
    <published>2019-04-13T14:22:35.000Z</published>
    <updated>2019-04-13T14:34:03.398Z</updated>
    
    <content type="html"><![CDATA[<h1 id="30道java面试题"><a href="#30道java面试题" class="headerlink" title="30道java面试题"></a>30道java面试题</h1><h4 id="1、Spring-DAO-中最常用的类是（）"><a href="#1、Spring-DAO-中最常用的类是（）" class="headerlink" title="1、Spring DAO 中最常用的类是（）"></a>1、Spring DAO 中最常用的类是（）</h4><pre><code>A，JdbcTemplate ，SimpleJdbcTemplateB，SimpleJdbcInsert，SimpleJdbcProcedureC，SimpleJdbcInsert ，SimpleJdbcStoredProcD，SimpleJdbcQuery ，SimpleJdbcExec正确答案：A</code></pre><h4 id="2、Spring-AOP-中，-织入（Weaving）-可以在下面什么时间完成（）"><a href="#2、Spring-AOP-中，-织入（Weaving）-可以在下面什么时间完成（）" class="headerlink" title="2、Spring AOP 中， 织入（Weaving） 可以在下面什么时间完成（）"></a>2、Spring AOP 中， 织入（Weaving） 可以在下面什么时间完成（）</h4><pre><code>A，全部选项B，Run timeC，Load timeD，Compile time正确答案：A</code></pre><h4 id="3、下面关于Spring-MVC-描述正确的是（）"><a href="#3、下面关于Spring-MVC-描述正确的是（）" class="headerlink" title="3、下面关于Spring MVC 描述正确的是（）"></a>3、下面关于Spring MVC 描述正确的是（）</h4><pre><code>A，DispatcherServlet在 Spring MVC 中是核心servlet , 它负责接收请求并将请求分发给适合的控制器B，在Spring MVC 中,可以配置多个DispatcherServletC，全部选项D，要使Spring MVC可用，DispatcherServlet需要在web.xml中配置正确答案：C</code></pre><h4 id="4、下面哪项是Spring自动装载模式（）"><a href="#4、下面哪项是Spring自动装载模式（）" class="headerlink" title="4、下面哪项是Spring自动装载模式（）"></a>4、下面哪项是Spring自动装载模式（）</h4><pre><code>A，autodetectB，全部选项C，constructorD，byname, byType正确答案：B</code></pre><h4 id="5、Spring-中，下面哪一项不是使用事务的方法（）"><a href="#5、Spring-中，下面哪一项不是使用事务的方法（）" class="headerlink" title="5、Spring 中，下面哪一项不是使用事务的方法（）"></a>5、Spring 中，下面哪一项不是使用事务的方法（）</h4><pre><code>A，proxiesB，declarativelyC，programmaticly正确答案：A</code></pre><h4 id="6、Spring提供了JMS层的抽象，正确吗（）"><a href="#6、Spring提供了JMS层的抽象，正确吗（）" class="headerlink" title="6、Spring提供了JMS层的抽象，正确吗（）"></a>6、Spring提供了JMS层的抽象，正确吗（）</h4><pre><code>A，正确B，错误正确答案：A</code></pre><h4 id="7、关于”-Order”注解，最正确的描述是（）"><a href="#7、关于”-Order”注解，最正确的描述是（）" class="headerlink" title="7、关于”@Order”注解，最正确的描述是（）"></a>7、关于”@Order”注解，最正确的描述是（）</h4><pre><code>A，实现org.springframework.core.Ordered接口B，指定一个bean的范围C，通常用于注入域对象的属性D，全不正确正确答案：A</code></pre><h4 id="8、如何在Spring应用中使用SLF4J（）"><a href="#8、如何在Spring应用中使用SLF4J（）" class="headerlink" title="8、如何在Spring应用中使用SLF4J（）"></a>8、如何在Spring应用中使用SLF4J（）</h4><pre><code>A，作为日志框架B，全不正确C，作为一个beanD，作为JDBC框架正确答案：A</code></pre><h4 id="9、Spring-bean-的默认作用范围是（）"><a href="#9、Spring-bean-的默认作用范围是（）" class="headerlink" title="9、Spring bean 的默认作用范围是（）"></a>9、Spring bean 的默认作用范围是（）</h4><pre><code>A，全不正确B，SingletonC，PrototypeD，SessionE， Abstract正确答案：B</code></pre><h4 id="10、Spring中，单例意味着每-只有一个实例（）"><a href="#10、Spring中，单例意味着每-只有一个实例（）" class="headerlink" title="10、Spring中，单例意味着每_只有一个实例（）"></a>10、Spring中，单例意味着每<strong>_</strong>只有一个实例（）</h4><pre><code>A，ContextB， JVMC，Thread正确答案：A</code></pre><h4 id="11、使用Spring-MVC-处理普通页面请求，-下面哪个排序是正确的（）"><a href="#11、使用Spring-MVC-处理普通页面请求，-下面哪个排序是正确的（）" class="headerlink" title="11、使用Spring MVC 处理普通页面请求， 下面哪个排序是正确的（）"></a>11、使用Spring MVC 处理普通页面请求， 下面哪个排序是正确的（）</h4><pre><code>1.请求：请求提交给服务器2.分发：分发器通过web 应用配置信息 ， 将请求分发至适当的控制器3.服务调用：控制器与业务层交互4.响应：控制器更新模型，将执行结果返回给客户端展现A，1-2-3-4B，1-4-3-2C，1-4-2-3D，1-3-2-4正确答案：A</code></pre><h4 id="12、以下哪个不是-Spring-AOP-的注解（）"><a href="#12、以下哪个不是-Spring-AOP-的注解（）" class="headerlink" title="12、以下哪个不是 Spring AOP 的注解（）"></a>12、以下哪个不是 Spring AOP 的注解（）</h4><pre><code>A，@BeforeB，@AroundC，@BeforeReturningD，@AfterThrowing正确答案：C</code></pre><h4 id="13、”-RequestMapping是Spring中的哪一部分（）"><a href="#13、”-RequestMapping是Spring中的哪一部分（）" class="headerlink" title="13、”@RequestMapping是Spring中的哪一部分（）"></a>13、”@RequestMapping是Spring中的哪一部分（）</h4><pre><code>A，DAOB，SecurityC，Web MVCD，Web正确答案：C</code></pre><h4 id="14、下面关于spring和struts2的描述，错误的是（）"><a href="#14、下面关于spring和struts2的描述，错误的是（）" class="headerlink" title="14、下面关于spring和struts2的描述，错误的是（）"></a>14、下面关于spring和struts2的描述，错误的是（）</h4><pre><code>A，spring mvc的入口是filter，而struts2是servletB，spring mvc是基于方法的设计，而struts2是基于类的设计C，struts2有以自己的interceptor机制，spring mvc用的是独立的AOP方式D， spring mvc的方法之间基本上独立的，独享request response数据，struts2所有Action变量是共享的正确答案：A</code></pre><h4 id="15、Spring中，下面哪个选项支持ORM（）"><a href="#15、Spring中，下面哪个选项支持ORM（）" class="headerlink" title="15、Spring中，下面哪个选项支持ORM（）"></a>15、Spring中，下面哪个选项支持ORM（）</h4><pre><code>A，OJBB，TopLinkC，全部选项D，Java Data Objects(JDO)E，iBatis正确答案：C</code></pre><h4 id="16、Spring和Hibernate的集成中，下面哪项是SessionFactory-正确的实现（）"><a href="#16、Spring和Hibernate的集成中，下面哪项是SessionFactory-正确的实现（）" class="headerlink" title="16、Spring和Hibernate的集成中，下面哪项是SessionFactory 正确的实现（）"></a>16、Spring和Hibernate的集成中，下面哪项是SessionFactory 正确的实现（）</h4><pre><code>A，LocalSessionFactoryBeanB，LocalFactoryBeanC，SessionFactoryD，SessionFactoryBean正确答案：A</code></pre><h4 id="17、下面哪个是Spring最核心的servlet（）"><a href="#17、下面哪个是Spring最核心的servlet（）" class="headerlink" title="17、下面哪个是Spring最核心的servlet（）"></a>17、下面哪个是Spring最核心的servlet（）</h4><pre><code>A，WebServletB，SpringServletC，DispatcherServletD，IoCServlet正确答案：C</code></pre><h4 id="18、Spring-test-用什么约定在测试中使用HTTP会话和HTTP-请求对象（）"><a href="#18、Spring-test-用什么约定在测试中使用HTTP会话和HTTP-请求对象（）" class="headerlink" title="18、Spring-test 用什么约定在测试中使用HTTP会话和HTTP 请求对象（）"></a>18、Spring-test 用什么约定在测试中使用HTTP会话和HTTP 请求对象（）</h4><pre><code>A，MVCB，Open-closed principleC，DAOsD，Mock objects正确答案：D</code></pre><h4 id="19、Spring-中，”-Cacheable”的key生成方式，以下哪个是正确的（）"><a href="#19、Spring-中，”-Cacheable”的key生成方式，以下哪个是正确的（）" class="headerlink" title="19、Spring 中，”@Cacheable”的key生成方式，以下哪个是正确的（）"></a>19、Spring 中，”@Cacheable”的key生成方式，以下哪个是正确的（）</h4><pre><code>A，可以是方法参数及其成员变量的任意表达式B，只能使用所有方法参数，但可以调整次序C，只能使用所有方法参数，且不能调整次序D，只能指定方法参数是否参与key的生成，不能控制参数的成员变量正确答案：A</code></pre><h4 id="20、使用-Required但不关联bean-来注解setter方法，将会发生（）"><a href="#20、使用-Required但不关联bean-来注解setter方法，将会发生（）" class="headerlink" title="20、使用@Required但不关联bean 来注解setter方法，将会发生（）"></a>20、使用@Required但不关联bean 来注解setter方法，将会发生（）</h4><pre><code>A，bean被设置为nullB，启动异常C，Spring 将创建beanD，什么也不发生正确答案：B</code></pre><h4 id="21，有关线程的哪些叙述是对的（-）"><a href="#21，有关线程的哪些叙述是对的（-）" class="headerlink" title="21，有关线程的哪些叙述是对的（ ）"></a>21，有关线程的哪些叙述是对的（ ）</h4><pre><code>A，一旦一个线程被创建，它就立即开始运行。B，使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。C，当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。D，一个线程可能因为不同的原因停止并进入就绪状态。答案：BCD在抢占式线程模型中，操作系统可以在任何时候打断线程。通常会在它运行了一段时间（就是所谓的一个时间片）后才打断它。这样的结果自然是没有线程能够不公平地长时间霸占处理器。</code></pre><hr><h4 id="22，哪个关键字可以对对象加互斥锁-（）"><a href="#22，哪个关键字可以对对象加互斥锁-（）" class="headerlink" title="22，哪个关键字可以对对象加互斥锁 （）"></a>22，哪个关键字可以对对象加互斥锁 （）</h4><pre><code>A，serializeB，synchronizedC，transientD，static答案：BA是对象串行化、C是关键字transient修饰的属性将不被串行化、D是静态的</code></pre><h4 id="23，下列关于线程优先级的说法中，正确的是（）"><a href="#23，下列关于线程优先级的说法中，正确的是（）" class="headerlink" title="23，下列关于线程优先级的说法中，正确的是（）"></a>23，下列关于线程优先级的说法中，正确的是（）</h4><pre><code>A、线程的优先级是不能改变的B、线程的优先级是在创建线程时设置的C、在创建线程后的任何时候都可以设置D、B和C答案：C    Java语言中线程的优先级是用一个介于MIN_PRIORITY和MAX_PRIORITY之间的整数来表示的。可以在创建线程后的任何时候修改线程的优先级。</code></pre><h4 id="24，为了使模块尽可能独立，要求"><a href="#24，为了使模块尽可能独立，要求" class="headerlink" title="24，为了使模块尽可能独立，要求( )"></a>24，为了使模块尽可能独立，要求( )</h4><pre><code>A．模块的内聚程度要尽量高，且耦合程度要尽量强B．模块的内聚程度要尽量高，且耦合程度要尽量弱C．模块的内聚程度要尽量低，且耦合程度要尽量弱D．模块的内聚程度要尽量低，且耦合程度要尽量强答案：B    系统设计的质量主要反映在模块的独立性上。评价模块独立性的主要标准有两个：一是模块之间的耦合，它表明两个模块之间互相独立的程度；二是模块内部之间的关系是否紧密，称为内聚。一般来说，要求模块之间的耦合尽可能地弱，即模块尽可能独立，而要求模块的内聚程度尽量高。</code></pre><h4 id="25，下列对于线性链表的描述中正确的是（）"><a href="#25，下列对于线性链表的描述中正确的是（）" class="headerlink" title="25，下列对于线性链表的描述中正确的是（）"></a>25，下列对于线性链表的描述中正确的是（）</h4><pre><code>A．存储空间不一定是连续，且各元素的存储顺序是任意的B．存储空间不一定是连续，且前件元素一定存储在后件元素的前面C．存储空间必须连续，且前件元素一定存储在后件元素的前面D．存储空间必须连续，且各元素的存储顺序是任意的答案：A在链式存储结构中，存储数据结构的存储空间可以不连续，各数据结点的存储顺序与数据元素之间 的逻辑关系可以不一致，而数据元素之间的逻辑关系是由指针域来确定的。</code></pre><h4 id="26，下列叙述中错误的是"><a href="#26，下列叙述中错误的是" class="headerlink" title="26，下列叙述中错误的是( )"></a>26，下列叙述中错误的是( )</h4><pre><code>A.线性表是由n个元素组成的一个有限序列B.线性表是一种线性结构C.线性表的所有结点有且仅有一个前件和后件D.线性表可以是空表答案：C线性表是一种线性结构，由n(n≥0)个元素组成，所以线性表可以是空表。但是在线性表中，第一个结点没有前驱，最后一个结点没有后继，其他结点有且只有一个前驱和后继，所以选项C是错误的。</code></pre><h4 id="27，已知一棵二叉树前序遍历和中序遍历分别为ABDEGCFH和DBGEACHF，则该二叉树的后序遍历为"><a href="#27，已知一棵二叉树前序遍历和中序遍历分别为ABDEGCFH和DBGEACHF，则该二叉树的后序遍历为" class="headerlink" title="27，已知一棵二叉树前序遍历和中序遍历分别为ABDEGCFH和DBGEACHF，则该二叉树的后序遍历为( )"></a>27，已知一棵二叉树前序遍历和中序遍历分别为ABDEGCFH和DBGEACHF，则该二叉树的后序遍历为( )</h4><pre><code>A.GEDHFBCAB.DGEBHFCAC.ABCDEFGHD.ACBFEDHG答案：B二叉树的遍历有3种：前序、中序和后序。先序：先访问根结点、左结点、右结点中序：先访问左结点、根结点、右结点后序：先访问左结点、右结点、根结点本题根据前序遍历和中序遍历的结果可以得出二叉树的结构，然后再对其进行后序遍历。</code></pre><h4 id="28，面向对象方法中，继承是指"><a href="#28，面向对象方法中，继承是指" class="headerlink" title="28，面向对象方法中，继承是指( )"></a>28，面向对象方法中，继承是指( )</h4><pre><code>A.一组对象所具有的相似性质B.一个对象具有另一个对象的性质C.各对象之间的共同性质D.类之间共享属性和操作的机制答案：D继承：在程序设计中，继承是指子类自动享用父类的属性和方法，并可以增加新的属性和方法的一种机制。它是实现代码共享的重要手段，可以使软件更具有开放性、可扩充性，这是信息组织与分类的行之有效的方法，也是面向对象的主要优点之一。继承又分为单重继承和多重继承，单重继承是指子类只能继承一个父类的属性和操作；而多重继承是指子类可以继承了多个父类的属性和操作。扩展：Java是一种单重继承语言，而C++是一种多重继承语言。</code></pre><h4 id="29，栈和队列的共同点是"><a href="#29，栈和队列的共同点是" class="headerlink" title="29，栈和队列的共同点是( )"></a>29，栈和队列的共同点是( )</h4><pre><code>A.都是先进先出B.都是先进后出C.只允许在端点处插入和删除元素D.没有共同特点答案：C栈是只允许在表的一端进行插入和删除的操作，队列是允许在表的一端进行插入，另一端进行删除的操作。</code></pre><h4 id="30，下列关于修饰符混用的说法，错误的是（）"><a href="#30，下列关于修饰符混用的说法，错误的是（）" class="headerlink" title="30，下列关于修饰符混用的说法，错误的是（）"></a>30，下列关于修饰符混用的说法，错误的是（）</h4><pre><code>A.abstract不能与final并列修饰同一个类B.abstract类中不可以有private的成员C.abstract方法必须在abstract类中D.static方法中能处理非static的数据答案：D静态方法是属于类的，而普通方法是属于对象的。属于类的静态方法可以在对象不存在的时候就能访问到，而普通方法必须先new一个对象才能用这个对象访问。当我们访问调用静态方法的时候（使用类名.静态方法名）这个时候就没有对象创建，所以普通方法是访问不到的。为了避免这种错误，所以java就不允许在静态方法中访问非静态方法。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;30道java面试题&quot;&gt;&lt;a href=&quot;#30道java面试题&quot; class=&quot;headerlink&quot; title=&quot;30道java面试题&quot;&gt;&lt;/a&gt;30道java面试题&lt;/h1&gt;&lt;h4 id=&quot;1、Spring-DAO-中最常用的类是（）&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="面试题" scheme="http://zongmansheng.club/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="java" scheme="http://zongmansheng.club/tags/java/"/>
    
      <category term="面试题" scheme="http://zongmansheng.club/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>MySql中锁的理解</title>
    <link href="http://zongmansheng.club/2019/04/12/mysql-zhong-suo-de-li-jie/"/>
    <id>http://zongmansheng.club/2019/04/12/mysql-zhong-suo-de-li-jie/</id>
    <published>2019-04-12T04:34:39.000Z</published>
    <updated>2019-04-13T13:51:53.225Z</updated>
    
    <content type="html"><![CDATA[<p><img src="//zongmansheng.club/2019/04/12/mysql-zhong-suo-de-li-jie/001.png" alt="001"></p><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><pre><code>注：MySQL是一个支持插件式存储引擎的数据库系统。本文下面的所有介绍，都是基于InnoDB存储引擎，其他引擎的表现，会有较大的区别。</code></pre><h4 id="存储引擎查看"><a href="#存储引擎查看" class="headerlink" title="存储引擎查看"></a>存储引擎查看</h4><pre><code>MySQL给开发者提供了查询存储引擎的功能，我这里使用的是MySQL5.6.4，可以使用：SHOW ENGINES</code></pre><p><img src="//zongmansheng.club/2019/04/12/mysql-zhong-suo-de-li-jie/002.png" alt="002"></p><p><img src="//zongmansheng.club/2019/04/12/mysql-zhong-suo-de-li-jie/003.png" alt="003"></p><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><pre><code>    用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加1。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。</code></pre><h5 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h5><h6 id="1、数据库表设计"><a href="#1、数据库表设计" class="headerlink" title="1、数据库表设计"></a>1、数据库表设计</h6><pre><code>三个字段，分别是id,value、version</code></pre><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> id<span class="token punctuation">,</span><span class="token keyword">value</span><span class="token punctuation">,</span>version <span class="token keyword">from</span> <span class="token keyword">TABLE</span> <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token comment" spellcheck="true">#{id}</span></code></pre><h6 id="2、每次更新表中的value字段时，为了防止发生冲突，需要这样操作"><a href="#2、每次更新表中的value字段时，为了防止发生冲突，需要这样操作" class="headerlink" title="2、每次更新表中的value字段时，为了防止发生冲突，需要这样操作"></a>2、每次更新表中的value字段时，为了防止发生冲突，需要这样操作</h6><pre class=" language-sql"><code class="language-sql"><span class="token keyword">update</span> <span class="token keyword">TABLE</span> <span class="token keyword">set</span> <span class="token keyword">value</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span>version<span class="token operator">=</span>version<span class="token operator">+</span><span class="token number">1</span> <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token comment" spellcheck="true">#{id} and version=#{version};</span></code></pre><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><pre><code>    与乐观锁相对应的就是悲观锁了。悲观锁就是在操作数据时，认为此操作会出现数据冲突，所以在进行每次操作时都要通过获取锁才能进行对相同数据的操作，这点跟java中的synchronized很相似，所以悲观锁需要耗费较多的时间。另外与乐观锁相对应的，悲观锁是由数据库自己实现了的，要用的时候，我们直接调用数据库的相关语句就可以了。    说到这里，由悲观锁涉及到的另外两个锁概念就出来了，它们就是共享锁与排它锁。共享锁和排它锁是悲观锁的不同的实现，它俩都属于悲观锁的范畴。使用，排它锁 举例    要使用悲观锁，我们必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。我们可以使用命令设置MySQL为非autocommit模式：</code></pre><pre class=" language-sql"><code class="language-sql"><span class="token keyword">set</span> autocommit<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"># 设置完autocommit后，我们就可以执行我们的正常业务了。具体如下：</span><span class="token comment" spellcheck="true"># 1. 开始事务</span><span class="token keyword">begin</span><span class="token punctuation">;</span><span class="token operator">/</span><span class="token keyword">begin</span> <span class="token keyword">work</span><span class="token punctuation">;</span><span class="token operator">/</span><span class="token keyword">start</span> <span class="token keyword">transaction</span><span class="token punctuation">;</span> <span class="token punctuation">(</span>三者选一就可以<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 2. 查询表信息</span><span class="token keyword">select</span> <span class="token keyword">status</span> <span class="token keyword">from</span> <span class="token keyword">TABLE</span> <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token number">1</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"># 3. 插入一条数据</span><span class="token keyword">insert</span> <span class="token keyword">into</span> <span class="token keyword">TABLE</span> <span class="token punctuation">(</span>id<span class="token punctuation">,</span><span class="token keyword">value</span><span class="token punctuation">)</span> <span class="token keyword">values</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"># 4. 修改数据为</span><span class="token keyword">update</span> <span class="token keyword">TABLE</span> <span class="token keyword">set</span> <span class="token keyword">value</span><span class="token operator">=</span><span class="token number">2</span> <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"># 5. 提交事务</span><span class="token keyword">commit</span><span class="token punctuation">;</span><span class="token operator">/</span><span class="token keyword">commit</span> <span class="token keyword">work</span><span class="token punctuation">;</span></code></pre><h4 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h4><pre><code>共享锁又称读锁 read lock，是读取操作创建的锁。其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排他锁。获得共享锁的事务只能读数据，不能修改数据打开第一个查询窗口</code></pre><pre class=" language-sql"><code class="language-sql"><span class="token keyword">begin</span><span class="token punctuation">;</span><span class="token operator">/</span><span class="token keyword">begin</span> <span class="token keyword">work</span><span class="token punctuation">;</span><span class="token operator">/</span><span class="token keyword">start</span> <span class="token keyword">transaction</span><span class="token punctuation">;</span> <span class="token punctuation">(</span>三者选一就可以<span class="token punctuation">)</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">TABLE</span> <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span> <span class="token keyword">lock</span> <span class="token operator">in</span> <span class="token keyword">share mode</span><span class="token punctuation">;</span></code></pre><p>然后在另一个查询窗口中，对id为1的数据进行更新</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">update</span> <span class="token keyword">TABLE</span> <span class="token keyword">set</span> name<span class="token operator">=</span><span class="token string">"www.souyunku.com"</span> <span class="token keyword">where</span> id <span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span></code></pre><pre><code>此时，操作界面进入了卡顿状态，过了超时间，提示错误信息如果在超时前，执行 commit，此更新语句就会成功。</code></pre><pre class=" language-sql"><code class="language-sql"><span class="token punctuation">[</span>SQL<span class="token punctuation">]</span><span class="token keyword">update</span> test_one <span class="token keyword">set</span> name<span class="token operator">=</span><span class="token string">"www.souyunku.com"</span> <span class="token keyword">where</span> id <span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">[</span>Err<span class="token punctuation">]</span> <span class="token number">1205</span> <span class="token operator">-</span> <span class="token keyword">Lock</span> wait timeout exceeded<span class="token punctuation">;</span> try restarting <span class="token keyword">transaction</span></code></pre><p>加上共享锁后，也提示错误信息</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">update</span> test_one <span class="token keyword">set</span> name<span class="token operator">=</span><span class="token string">"www.souyunku.com"</span> <span class="token keyword">where</span> id <span class="token operator">=</span><span class="token number">1</span> <span class="token keyword">lock</span> <span class="token operator">in</span> <span class="token keyword">share mode</span><span class="token punctuation">;</span><span class="token punctuation">[</span>SQL<span class="token punctuation">]</span><span class="token keyword">update</span> test_one <span class="token keyword">set</span> name<span class="token operator">=</span><span class="token string">"www.souyunku.com"</span> <span class="token keyword">where</span> id <span class="token operator">=</span><span class="token number">1</span> <span class="token keyword">lock</span> <span class="token operator">in</span> <span class="token keyword">share mode</span><span class="token punctuation">;</span><span class="token punctuation">[</span>Err<span class="token punctuation">]</span> <span class="token number">1064</span> <span class="token operator">-</span> You have an error <span class="token operator">in</span> your SQL syntax<span class="token punctuation">;</span> <span class="token keyword">check</span> the manual that corresponds <span class="token keyword">to</span> your MySQL server version <span class="token keyword">for</span> the <span class="token keyword">right</span> syntax <span class="token keyword">to</span> <span class="token keyword">use</span> near <span class="token string">'lock in share mode'</span> at line <span class="token number">1</span></code></pre><pre><code>    在查询语句后面增加 LOCK IN SHARE MODE，Mysql会对查询结果中的每行都加共享锁，当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请共享锁，否则会被阻塞。其他线程也可以读取使用了共享锁的表，而且这些线程读取的是同一个版本的数据。加上共享锁后，对于update,insert,delete语句会自动加排它锁。</code></pre><h4 id="排它锁"><a href="#排它锁" class="headerlink" title="排它锁"></a>排它锁</h4><pre><code>排他锁 exclusive lock（也叫writer lock）又称写锁。排它锁是悲观锁的一种实现，在上面悲观锁也介绍过。若事务 1 对数据对象A加上X锁，事务 1 可以读A也可以修改A，其他事务不能再对A加任何锁，直到事物 1 释放A上的锁。这保证了其他事务在事物 1 释放A上的锁之前不能再读取和修改A。排它锁会阻塞所有的排它锁和共享锁读取为什么要加读锁呢：防止数据在被读取的时候被别的线程加上写锁，使用方式：在需要执行的语句后面加上for update就可以了</code></pre><h4 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h4><pre><code>行锁又分共享锁和排他锁,由字面意思理解，就是给某一行加上锁，也就是一条记录加上锁。注意：行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁。共享锁：名词解释：共享锁又叫做读锁，所有的事务只能对其进行读操作不能写操作，加上共享锁后在事务结束之前其他事务只能再加共享锁，除此之外其他任何类型的锁都不能再加了。</code></pre><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">TABLE</span> <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token string">"1"</span> <span class="token keyword">lock</span> <span class="token operator">in</span> <span class="token keyword">share mode</span><span class="token punctuation">;</span> 结果集的数据都会加共享锁</code></pre><h4 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h4><pre><code>如何加表锁innodb 的行锁是在有索引的情况下,没有索引的表是锁定全表的.</code></pre><h4 id="Innodb中的行锁与表锁"><a href="#Innodb中的行锁与表锁" class="headerlink" title="Innodb中的行锁与表锁"></a>Innodb中的行锁与表锁</h4><pre><code>前面提到过，在Innodb引擎中既支持行锁也支持表锁，那么什么时候会锁住整张表，什么时候或只锁住一行呢？只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！在实际应用中，要特别注意InnoDB行锁的这一特性，不然的话，可能导致大量的锁冲突，从而影响并发性能。行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁。行级锁的缺点是：由于需要请求大量的锁资源，所以速度慢，内存消耗大。</code></pre><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><pre><code>死锁（Deadlock） 所谓死锁：是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。由于资源占用是互斥的，当某个进程提出申请资源后，使得有关进程在无外力协助下，永远分配不到必需的资源而无法继续运行，这就产生了一种特殊现象死锁。解除正在死锁的状态有两种方法：</code></pre><p><strong>第一种</strong>：</p><p>1.查询是否锁表</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">show</span> <span class="token keyword">OPEN</span> <span class="token keyword">TABLES</span> <span class="token keyword">where</span> In_use <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span></code></pre><p>2.查询进程（如果您有SUPER权限，您可以看到所有线程。否则，您只能看到您自己的线程）</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">show</span> processlist</code></pre><p><img src="//zongmansheng.club/2019/04/12/mysql-zhong-suo-de-li-jie/004.png" alt="004"></p><p>3.杀死进程id（就是上面命令的id列）</p><pre><code>kill id</code></pre><p><strong>第二种</strong>：</p><p>1：查看当前的事务</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> INFORMATION_SCHEMA<span class="token punctuation">.</span>INNODB_TRX<span class="token punctuation">;</span></code></pre><p>2：查看当前锁定的事务</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> INFORMATION_SCHEMA<span class="token punctuation">.</span>INNODB_LOCKS<span class="token punctuation">;</span></code></pre><p>3：查看当前等锁的事务</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> INFORMATION_SCHEMA<span class="token punctuation">.</span>INNODB_LOCK_WAITS<span class="token punctuation">;</span></code></pre><p>杀死进程</p><pre><code>kill 进程ID</code></pre><pre><code>如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。其次，进程运行推进顺序与速度不同，也可能产生死锁。产生死锁的四个必要条件：（1） 互斥条件：一个资源每次只能被一个进程使用。（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。（3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。虽然不能完全避免死锁，但可以使死锁的数量减至最少。将死锁减至最少可以增加事务的吞吐量并减少系统开销，因为只有很少的事务回滚，而回滚会取消事务执行的所有工作。由于死锁时回滚而由应用程序重新提交。下列方法有助于最大限度地降低死锁：（1）按同一顺序访问对象。（2）避免事务中的用户交互。（3）保持事务简短并在一个批处理中。（4）使用低隔离级别。（5）使用绑定连接。</code></pre><p>原文：<a href="https://segmentfault.com/a/1190000015815061" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015815061</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;//zongmansheng.club/2019/04/12/mysql-zhong-suo-de-li-jie/001.png&quot; alt=&quot;001&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;锁&quot;&gt;&lt;a href=&quot;#锁&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
      <category term="数据库" scheme="http://zongmansheng.club/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="乐观锁，悲观锁，共享锁，排它锁，行锁，表锁" scheme="http://zongmansheng.club/tags/%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%8C%E6%82%B2%E8%A7%82%E9%94%81%EF%BC%8C%E5%85%B1%E4%BA%AB%E9%94%81%EF%BC%8C%E6%8E%92%E5%AE%83%E9%94%81%EF%BC%8C%E8%A1%8C%E9%94%81%EF%BC%8C%E8%A1%A8%E9%94%81/"/>
    
  </entry>
  
</feed>
