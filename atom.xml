<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>晓笙的BLOG</title>
  
  <subtitle>一个来自IT界的菜鸟007</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zongmansheng.club/"/>
  <updated>2019-07-07T10:24:14.731Z</updated>
  <id>http://zongmansheng.club/</id>
  
  <author>
    <name>ZongMan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java虚拟机jvm类加载初始化</title>
    <link href="http://zongmansheng.club/2019/07/05/java-xu-ni-ji-jvm-lei-jia-zai-chu-shi-hua/"/>
    <id>http://zongmansheng.club/2019/07/05/java-xu-ni-ji-jvm-lei-jia-zai-chu-shi-hua/</id>
    <published>2019-07-05T00:45:14.000Z</published>
    <updated>2019-07-07T10:24:14.731Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java虚拟机jvm类加载初始化"><a href="#Java虚拟机jvm类加载初始化" class="headerlink" title="Java虚拟机jvm类加载初始化"></a>Java虚拟机jvm类加载初始化</h1><h4 id="一、Classloader的作用"><a href="#一、Classloader的作用" class="headerlink" title="一、Classloader的作用"></a>一、Classloader的作用</h4><blockquote><p>概括来说就是将编译后的class装载、加载到机器内存中，为了以后的程序的执行提供前提条件。</p></blockquote><h4 id="二、java类在虚拟机（jvm）中的工作原理"><a href="#二、java类在虚拟机（jvm）中的工作原理" class="headerlink" title="二、java类在虚拟机（jvm）中的工作原理"></a>二、java类在虚拟机（jvm）中的工作原理</h4><blockquote><p>1）类加载load：从字节码二进制文件——.class文件将类加载到内存，从而达到类的从硬盘上到内存上的一个迁移，所有的程序必须加载到内存才能工作。将内存中的class放到运行时数据区的方法区内，之后在堆区建立一个java.lang.Class对象，用来封装方法区的数据结构。这个时候就体现出了万事万物皆对象了，干什么事情都得有个对象。就是到了最底层究竟是鸡生蛋，还是蛋生鸡呢？类加载的最终产物就是堆中的一个java.lang.Class对象。</p></blockquote><blockquote><p><strong>2）连接：连接又分为以下小步骤</strong></p><p><strong>验证：</strong>出于安全性的考虑，验证内存中的字节码是否符合JVM的规范，类的结构规范、语义检查、字节码操作是否合法、这个是为了防止用户自己建立一个非法的XX.class文件就进行工作了，或者是JVM版本冲突的问题，比如在JDK6下面编译通过的class（其中包含注解特性的类），是不能在JDK1.4的JVM下运行的。</p><p><strong>准备：</strong>将类的静态变量进行分配内存空间、初始化默认值。（对象还没生成呢，所以这个时候没有实例变量什么事情）</p><p><strong>解析：</strong>把类的符号引用转为直接引用（保留）</p></blockquote><blockquote><p><strong>3）类的初始化：</strong> 将类的静态变量赋予正确的初始值，这个初始值是开发者自己定义时赋予的初始值，而不是默认值。</p></blockquote><h4 id="三、类的主动使用与被动使用"><a href="#三、类的主动使用与被动使用" class="headerlink" title="三、类的主动使用与被动使用"></a>三、类的主动使用与被动使用</h4><blockquote><p>以下是视为主动使用一个类，其他情况均视为被动使用！</p><p>1）初学者最为常用的new一个类的实例对象（声明不叫主动使用）</p><p>2）对类的静态变量进行读取、赋值操作的。</p><p>3）直接调用类的静态方法。</p><p>4）反射调用一个类的方法。</p><p>5）初始化一个类的子类的时候，父类也相当于被程序主动调用了（如果调用子类的静态变量是从父类继承过来并没有复写的，那么也就相当于只用到了父类的东东，和子类无关，所以这个时候子类不需要进行类初始化）。</p><p>6）直接运行一个main函数入口的类。</p></blockquote><p><img src="//zongmansheng.club/2019/07/05/java-xu-ni-ji-jvm-lei-jia-zai-chu-shi-hua/001.png" alt></p><blockquote><p>所有的JVM实现（不同的厂商有不同的实现，有人就说IBM的实现比Sun的要好……）在首次主动调用类和接口的时候才会初始化他们。</p></blockquote><h4 id="四、-类的加载方式"><a href="#四、-类的加载方式" class="headerlink" title="四、 类的加载方式"></a>四、 类的加载方式</h4><blockquote><p>1）：本地编译好的class中直接加载</p><p>2）：网络加载：java.net.URLClassLoader可以加载url指定的类</p><p>3）：从jar、zip等等压缩文件加载类，自动解析jar文件找到class文件去加载util类</p><p>4）：从java源代码文件动态编译成为class文件</p></blockquote><h4 id="五、类加载器"><a href="#五、类加载器" class="headerlink" title="五、类加载器"></a>五、类加载器</h4><blockquote><p>JVM自带的默认加载器</p><p>1）：根类加载器：bootstrap，由C++编写，所有Java程序无法获得。</p><p>2）：扩展类加载器：由Java编写。</p><p>3）：系统类、应用类加载器：由Java编写。</p><p>用户自定义的类加载器：java.lang.ClassLoader的子类，用户可以定制类的加载方式。每一个类都包含了加载他的ClassLoader的一个引用——getClass().getClassLoader()。如果返回的是null，证明加载他的ClassLoader是根加载器bootstrap。</p><p>如下代码</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException <span class="token punctuation">{</span>         Class <span class="token class-name">clazz</span> <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"java.lang.String"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>clazz<span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><blockquote><p>结果是null，证明java.lang.String是根类加载器去加载的。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>         Singleton mysingleton <span class="token operator">=</span> Singleton<span class="token punctuation">.</span><span class="token function">GetInstence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>mysingleton<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><blockquote><p>结果是sun.misc.Launcher$AppClassLoader@19821f，证明是AppClassLoader（系统类、应用类加载器）去加载的。像jre的rt.jar下面的java.lang.*都是默认的根类加载器去加载这些运行时的类。</p></blockquote><h4 id="六、解释类连接阶段的准备"><a href="#六、解释类连接阶段的准备" class="headerlink" title="六、解释类连接阶段的准备"></a>六、解释类连接阶段的准备</h4><blockquote><p>类的如下代码片段</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> a<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></code></pre><blockquote><p>在这个阶段，加载器会按照结构化似的，从上到下流程将静态变量int类型分配4个字节的空间，并且为其赋予默认值0，而像b = 10这段代码在此阶段是不起作用的，b仍然是默认值0。</p></blockquote><h4 id="七、解释类连接阶段的解析"><a href="#七、解释类连接阶段的解析" class="headerlink" title="七、解释类连接阶段的解析"></a>七、解释类连接阶段的解析</h4><blockquote><p>这里面的指针就是C++的指针</p></blockquote><h4 id="八、ClassLoader的剖析"><a href="#八、ClassLoader的剖析" class="headerlink" title="八、ClassLoader的剖析"></a>八、ClassLoader的剖析</h4><blockquote><p>ClassLoader的loadClass方法加载一个类不属于主动调用，不会导致类的初始化。如下代码块</p></blockquote><pre class=" language-java"><code class="language-java">  ClassLoader classLoader <span class="token operator">=</span> ClassLoader<span class="token punctuation">.</span><span class="token function">getSystemClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> clazz <span class="token operator">=</span> classLoader<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token string">"test01.ClassDemo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>并不会让类加载器初始化test01.ClassDemo，因为这不属于主动调用此类。</p></blockquote><p><strong>lassLoader的关系：</strong></p><blockquote><p><strong>根加载器——》扩展类加载器——》应用类加载器——》用户自定义类加载器</strong></p></blockquote><blockquote><p><strong>加载类的过程是首先从根加载器开始加载、根加载器加载不了的，由扩展类加载器加载，再加载不了的有应用加载器加载，应用加载器如果还加载不了就由自定义的加载器（一定继承自java.lang. ClassLoader）加载、如果自定义的加载器还加载不了。</strong>而且下面已经没有再特殊的类加载器了，就会抛出ClassNotFoundException，表面上异常是类找不到，实际上是class加载失败，更不能创建该类的Class对象。</p><p>若一个类能在某一层类加载器成功加载，那么这一层的加载器称为定义类加载器。那么在这层类生成的Class引用返回下一层加载器叫做初始类加载器。因为加载成功后返回一个Class引用给它的服务对象——也就是调用它的类加载器。考虑到安全，父委托加载机制。</p><p>ClassLoader加载类的原代码如下</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">synchronized</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">loadClass</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> resolve<span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException<span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// First, check if the class has already been loaded</span>        Class <span class="token class-name">c</span> <span class="token operator">=</span> <span class="token function">findLoadedClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    c <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    c <span class="token operator">=</span> <span class="token function">findBootstrapClassOrNull</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// ClassNotFoundException thrown if class not found</span>                <span class="token comment" spellcheck="true">// from the non-null parent class loader</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// If still not found, then invoke findClass in order</span>                <span class="token comment" spellcheck="true">// to find the class.</span>                c <span class="token operator">=</span> <span class="token function">findClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">resolveClass</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> c<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><blockquote><p>初始化系统ClassLoader代码如下</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">initSystemClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>sclSet<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>scl <span class="token operator">!=</span> null<span class="token punctuation">)</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"recursive invocation"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>Launcher l <span class="token operator">=</span> sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>Launcher<span class="token punctuation">.</span><span class="token function">getLauncher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                Throwable oops <span class="token operator">=</span> null<span class="token punctuation">;</span>                scl <span class="token operator">=</span> l<span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    PrivilegedExceptionAction a<span class="token punctuation">;</span>                    a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SystemClassLoaderAction</span><span class="token punctuation">(</span>scl<span class="token punctuation">)</span><span class="token punctuation">;</span>                    scl <span class="token operator">=</span> <span class="token punctuation">(</span>ClassLoader<span class="token punctuation">)</span> AccessController<span class="token punctuation">.</span><span class="token function">doPrivileged</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">PrivilegedActionException</span> pae<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    oops <span class="token operator">=</span> pae<span class="token punctuation">.</span><span class="token function">getCause</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>oops <span class="token keyword">instanceof</span> <span class="token class-name">InvocationTargetException</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        oops <span class="token operator">=</span> oops<span class="token punctuation">.</span><span class="token function">getCause</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>oops <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>oops <span class="token keyword">instanceof</span> <span class="token class-name">Error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">throw</span> <span class="token punctuation">(</span>Error<span class="token punctuation">)</span> oops<span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">// wrap the exception</span>                        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>oops<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            sclSet <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><blockquote><p>它里面调用了很多native的方法，也就是通过JNI调用底层C++的代码。</p></blockquote><h4 id="九、类（class）的生命周期"><a href="#九、类（class）的生命周期" class="headerlink" title="九、类（class）的生命周期"></a>九、类（class）的生命周期</h4><blockquote><p>当一个类被加载、连接、初始化后，它的生命周期就开始了，当代表该类的Class对象不再被引用、即已经不可触及的时候，Class对象的生命周期结束。那么该类的方法区内的数据也会被卸载，从而结束该类的生命周期。一个类的生命周期取决于它Class对象的生命周期。由Java虚拟机自带的默认加载器（根加载器、扩展加载器、系统加载器）所加载的类在JVM生命周期中始终不被卸载。所以这些类的Class对象（我称其为实例的模板对象）始终能被触及！而由用户自定义的类加载器所加载的类会被卸载掉！</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java虚拟机jvm类加载初始化&quot;&gt;&lt;a href=&quot;#Java虚拟机jvm类加载初始化&quot; class=&quot;headerlink&quot; title=&quot;Java虚拟机jvm类加载初始化&quot;&gt;&lt;/a&gt;Java虚拟机jvm类加载初始化&lt;/h1&gt;&lt;h4 id=&quot;一、Classlo
      
    
    </summary>
    
      <category term="日常学习" scheme="http://zongmansheng.club/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="JVM" scheme="http://zongmansheng.club/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Mac下安装RabbitMq</title>
    <link href="http://zongmansheng.club/2019/07/04/mac-xia-an-zhuang-rabbitmq/"/>
    <id>http://zongmansheng.club/2019/07/04/mac-xia-an-zhuang-rabbitmq/</id>
    <published>2019-07-04T04:11:14.000Z</published>
    <updated>2019-07-07T02:09:48.354Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mac下安装RabbitMq"><a href="#Mac下安装RabbitMq" class="headerlink" title="Mac下安装RabbitMq"></a>Mac下安装RabbitMq</h1><blockquote><p>下载地址：<a href="https://www.rabbitmq.com/install-standalone-mac.html" target="_blank" rel="noopener">https://www.rabbitmq.com/install-standalone-mac.html</a></p></blockquote><p>先安装 Homebrew</p><p>ruby -e “$(curl -fsSL <a href="https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;" target="_blank" rel="noopener">https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</a></p><p>安装完查看版本</p><pre><code>brew --version</code></pre><p><img src="//zongmansheng.club/2019/07/04/mac-xia-an-zhuang-rabbitmq/001.png" alt></p><p>安装</p><pre><code>brew install rabbitmq</code></pre><p><img src="//zongmansheng.club/2019/07/04/mac-xia-an-zhuang-rabbitmq/002.png" alt></p><blockquote><p>首次安装，下载一些相关的包</p></blockquote><blockquote><p>真正安装rabbitmq</p></blockquote><p><img src="//zongmansheng.club/2019/07/04/mac-xia-an-zhuang-rabbitmq/003.png" alt></p><pre><code>## 进入安装目录cd /usr/local/Cellar/rabbitmq/3.7.5# 启动brew services start rabbitmq# 当前窗口启动rabbitmq-server</code></pre><p>启动控制台之前需要先开启插件</p><pre><code>./rabbitmq-plugins enable rabbitmq_management</code></pre><p>启动成功</p><p><img src="//zongmansheng.club/2019/07/04/mac-xia-an-zhuang-rabbitmq/005.png" alt></p><blockquote><p>浏览器访问：<a href="http://localhost:15761" target="_blank" rel="noopener">http://localhost:15761</a></p></blockquote><p><img src="//zongmansheng.club/2019/07/04/mac-xia-an-zhuang-rabbitmq/006.png" alt></p><blockquote><p>用户名：guest</p><p>密    码：guest</p></blockquote><p><img src="//zongmansheng.club/2019/07/04/mac-xia-an-zhuang-rabbitmq/007.png" alt></p><h3 id="II-配置与测试"><a href="#II-配置与测试" class="headerlink" title="II. 配置与测试"></a>II. 配置与测试</h3><h4 id="1-添加账号"><a href="#1-添加账号" class="headerlink" title="1. 添加账号"></a>1. 添加账号</h4><blockquote><p>首先是得启动mq</p></blockquote><pre><code>`## 添加账号./rabbitmqctl add_user admin admin## 添加访问权限./rabbitmqctl set_permissions -p &quot;/&quot; admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;## 设置超级权限./rabbitmqctl set_user_tags admin administrator`</code></pre><h4 id="2-编码实测"><a href="#2-编码实测" class="headerlink" title="2. 编码实测"></a>2. 编码实测</h4><blockquote><p>pom引入依赖</p></blockquote><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.rabbitmq<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>amqp-client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><blockquote><p>代码示例</p><p>生产者</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>rabbitmq<span class="token punctuation">.</span>zms<span class="token punctuation">.</span>rabbitmqdemo<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>rabbitmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>Channel<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>rabbitmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>Connection<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>rabbitmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>ConnectionFactory<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>Test<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeoutException<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019-07-07 * @Time: 09:41 * @Vsersion: 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RabbitMqDemo01</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//消息队列名称</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> String QUEUE_NAME <span class="token operator">=</span> <span class="token string">"Hello RabbitMq"</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">producers</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">,</span> TimeoutException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//创建连接工程</span>        ConnectionFactory factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConnectionFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span><span class="token function">setHost</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span><span class="token function">setPort</span><span class="token punctuation">(</span><span class="token number">5672</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span><span class="token string">"admin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">"admin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//创建连接</span>        Connection connection <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">newConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//创建消息通道</span>        Channel channel <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">createChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//生成一个消息队列</span>        channel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span>QUEUE_NAME<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            String message <span class="token operator">=</span> <span class="token string">"Hello World RabbitMQ count: "</span> <span class="token operator">+</span> i<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//发布消息，第一个参数表示路由（Exchange名称），未""则表示使用默认消息路由</span>            channel<span class="token punctuation">.</span><span class="token function">basicPublish</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> QUEUE_NAME<span class="token punctuation">,</span> null<span class="token punctuation">,</span> message<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"生产者------>producers()'"</span> <span class="token operator">+</span> message <span class="token operator">+</span> <span class="token string">"'"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//关闭消息通道和连接</span>        channel<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        connection<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><img src="//zongmansheng.club/2019/07/04/mac-xia-an-zhuang-rabbitmq/008.png" alt></p><blockquote><p>消费者</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>rabbitmq<span class="token punctuation">.</span>zms<span class="token punctuation">.</span>rabbitmqdemo<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>rabbitmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>Test<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeoutException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>atomic<span class="token punctuation">.</span>AtomicInteger<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019-07-07 * @Time: 09:55 * @Vsersion: 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RabbitMqDemo02</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//消息队列名称</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> String QUEUE_NAME <span class="token operator">=</span> <span class="token string">"Hello RabbitMq"</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">,</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>InterruptedException<span class="token punctuation">,</span> TimeoutException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//创建连接工厂</span>        ConnectionFactory factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConnectionFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span><span class="token function">setHost</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span><span class="token function">setPort</span><span class="token punctuation">(</span><span class="token number">5672</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span><span class="token string">"admin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">"admin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//创建连接</span>        Connection connection <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">newConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//创建消息信道</span>        Channel channel <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">createChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//消息队列</span>        channel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span>QUEUE_NAME<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"--------------消费列表----------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        AtomicInteger count <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//消费者用于获取消息信道绑定的消息队列中的信息</span>        Consumer consumer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultConsumer</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleDelivery</span><span class="token punctuation">(</span>String consumerTag<span class="token punctuation">,</span> Envelope envelope<span class="token punctuation">,</span> AMQP<span class="token punctuation">.</span>BasicProperties properties<span class="token punctuation">,</span>                                       <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> body<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>                String message <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>body<span class="token punctuation">,</span> <span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消费者------>consumer()'"</span> <span class="token operator">+</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消费了！！！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    channel<span class="token punctuation">.</span><span class="token function">basicAck</span><span class="token punctuation">(</span>envelope<span class="token punctuation">.</span><span class="token function">getDeliveryTag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        channel<span class="token punctuation">.</span><span class="token function">basicConsume</span><span class="token punctuation">(</span>QUEUE_NAME<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> consumer<span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span> <span class="token operator">*</span> <span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>需要注意的一点是：</p><ul><li>生产消息: <code>channel.queueDeclare(QUEUE_NAME, true, false, false, null);</code></li><li>消费消息: <code>channel.queueDeclare(QUEUE_NAME, true, false, false, null);</code></li><li>生产和消费都声明channel，要求两者的配置参数一致，否则无法消费数据</li></ul></blockquote><h4 id="3-ACK问题"><a href="#3-ACK问题" class="headerlink" title="3. ACK问题"></a>3. ACK问题</h4><blockquote><p>对于ack的问题，如果在消费数据的时候，出现异常，而我不希望数据丢失，这个时候就需要考虑手动ack的机制来保证了</p><p>首先需要设置手动ack</p></blockquote><pre><code>// 设置autoAck为falsechannel.basicConsume(QUEUE_NAME, false, consumer);</code></pre><blockquote><p>其次在消费数据完毕之后，主动ack/nack</p></blockquote><pre><code>if (success) {    channel.basicAck(envelope.getDeliveryTag(), false);} else {    channel.basicNack(envelope.getDeliveryTag(), false, false);}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Mac下安装RabbitMq&quot;&gt;&lt;a href=&quot;#Mac下安装RabbitMq&quot; class=&quot;headerlink&quot; title=&quot;Mac下安装RabbitMq&quot;&gt;&lt;/a&gt;Mac下安装RabbitMq&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;下载地址：&lt;a h
      
    
    </summary>
    
      <category term="中间件" scheme="http://zongmansheng.club/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="rabbitmq" scheme="http://zongmansheng.club/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>并发工具类和并发容器</title>
    <link href="http://zongmansheng.club/2019/07/03/bing-fa-gong-ju-lei-he-bing-fa-rong-qi/"/>
    <id>http://zongmansheng.club/2019/07/03/bing-fa-gong-ju-lei-he-bing-fa-rong-qi/</id>
    <published>2019-07-03T00:29:26.000Z</published>
    <updated>2019-07-03T00:53:58.809Z</updated>
    
    <content type="html"><![CDATA[<h3 id="并发工具类和并发容器"><a href="#并发工具类和并发容器" class="headerlink" title="并发工具类和并发容器"></a>并发工具类和并发容器</h3><h4 id="1-ConcurrentHashMap"><a href="#1-ConcurrentHashMap" class="headerlink" title="1.ConcurrentHashMap"></a>1.ConcurrentHashMap</h4><h5 id="为什么要使用ConcurrentHashMap"><a href="#为什么要使用ConcurrentHashMap" class="headerlink" title="为什么要使用ConcurrentHashMap"></a>为什么要使用ConcurrentHashMap</h5><blockquote><p>在多线程环境下，使用HashMap进行put操作会引起死循环，导致CPU利用率接近100%，HashMap在并发执行put操作时会引起死循环，是因为多线程会导致HashMap的Entry链表</p><p>形成环形数据结构，一旦形成环形数据结构，Entry的next节点永远不为空，就会产生死循环获取Entry。</p><p>HashTable容器使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。因为当一个线程访问HashTable的同步方法，其他线程也访问HashTable的同步方法时，会进入阻塞或轮询状态。如线程1使用put进行元素添加，线程2不但不能使用put方法添加元素，也不能使用get方法来获取元素，所以竞争越激烈效率越低。</p></blockquote><h5 id="ConcurrentHashMap的一些有用的方法"><a href="#ConcurrentHashMap的一些有用的方法" class="headerlink" title="ConcurrentHashMap的一些有用的方法"></a>ConcurrentHashMap的一些有用的方法</h5><blockquote><p>很多时候我们希望在元素不存在时插入元素，我们一般会像下面那样写代码</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">synchronized</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span><span class="token punctuation">{</span>      <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>putIfAbsent(key,value)方法原子性的实现了同样的功能</p><p>V <strong>putIfAbsent</strong>(K key, V value)  </p><p>如果key对应的value不存在，则put进去，返回<strong>null</strong>。否则不put，返回已存在的value。  </p><p><strong>boolean</strong> remove(Object key, Object value)  </p><p> 如果key对应的值是value，则移除K-V，返回<strong>true</strong>。否则不移除，返回<strong>false</strong>。  </p><p><strong>boolean</strong> replace(K key, V oldValue, V newValue)  </p><p>如果key对应的当前值是oldValue，则替换为newValue，返回<strong>true</strong>。否则不替换，返回<strong>false</strong>。</p></blockquote><h4 id="Hash的解释"><a href="#Hash的解释" class="headerlink" title="Hash的解释"></a>Hash的解释</h4><blockquote><p>散列，任意长度的输入，通过一种算法，变换成固定长度的输出。属于压缩的映射。</p></blockquote><blockquote><p>hash算法示例图演示：</p></blockquote><p><img src="//zongmansheng.club/2019/07/03/bing-fa-gong-ju-lei-he-bing-fa-rong-qi/001.png" alt></p><blockquote><p>类似于HaspMap的实现就是使用散列，比如把1000个元素放到长度为10的hashmap里面去，放入之前会把这1000个数经过hash算法映射到10个数组里面去，这时候就会存在相同的映射值在一个数组的相同位置，就会产生hash碰撞，此时hashmap就会在产生碰撞的数组的后面使用Entry链表来存储相同映射的值，然后使用equals方法来判断同一个链表存储的值是否一样来获取值，链表就是hashmap用来解决碰撞的方法，所以我们一般在写一个类的时候要写自己的hashcode方法和equals方法，如果键的hashcode相同，再使用键的equals方法判断键内容是不是一样的，一样的就获取值</p><p>Md5，Sha，取余都是散列算法，ConcurrentHashMap中是wang/jenkins算法</p></blockquote><h4 id="ConcurrentHashMap在1-7下的实现"><a href="#ConcurrentHashMap在1-7下的实现" class="headerlink" title="ConcurrentHashMap在1.7下的实现"></a>ConcurrentHashMap在1.7下的实现</h4><blockquote><p>分段锁的设计思想。</p></blockquote><blockquote><p>分段锁的思想示例图</p></blockquote><p><img src="//zongmansheng.club/2019/07/03/bing-fa-gong-ju-lei-he-bing-fa-rong-qi/002.png" alt></p><blockquote><p>说明：</p><p>a)传统的hashtable是很小空间的数组整段锁住，这样性能比较低</p><p>b)ConcurrentHashMap是在很小空间数组的前面再加一个数组，映射的时候先映射到前面的数组，然后再映射到后面的很小空间的数组；读取的时候只需要把前面的数组锁住就可以了。这就是分段锁的思想</p><p>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment实际是一种可重入锁（ReentrantLock），也就是用于分段的锁。HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组。Segment的结构和HashMap类似，是一种数组和链表结构。一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素，每个Segment守护着一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得与它对应的Segment锁。</p></blockquote><p><img src="//zongmansheng.club/2019/07/03/bing-fa-gong-ju-lei-he-bing-fa-rong-qi/003.png" alt></p><blockquote><p>说明：上图存在两次散列的过程：比如插入一个1000的数，首先是把1000的位数(最多是高16位)做一次散列找到在segments数组中的位置，然后再把1000本身做一次散列找到在table中的位置</p><p>获取值时一样</p><p>ConcurrentHashMap初始化方法是通过initialCapacity、loadFactor和concurrencyLevel(参数concurrencyLevel是用户估计的并发级别，就是说你觉得最多有多少线程共同修改这个map，根据这个来确定Segment数组的大小concurrencyLevel默认是DEFAULT_CONCURRENCY_LEVEL = 16;)。</p><p>ConcurrentHashMap完全允许多个读操作并发进行，读操作并不需要加锁。ConcurrentHashMap实现技术是保证HashEntry几乎是不可变的。HashEntry代表每个hash链中的一个节点，可以看到其中的对象属性要么是final的，要么是volatile的。</p><p>总结：<strong>ConcurrentHashMap在1.7及以下的实现使用数组+链表的方式，采用了分段锁的思想</strong></p></blockquote><h4 id="ConcurrentHashMap在1-8下的实现"><a href="#ConcurrentHashMap在1-8下的实现" class="headerlink" title="ConcurrentHashMap在1.8下的实现"></a>ConcurrentHashMap在1.8下的实现</h4><blockquote><p>改进一：取消segments字段,直接采用transient volatile HashEntry&lt;K,V&gt;[] table保存数据，采用table数组元素作为锁，从而实现了对每一行数据进行加锁，进一步减少并发冲突的概率。</p><p>改进二：将原先table数组＋单向链表的数据结构，变更为table数组＋单向链表＋红黑树的结构。对于个数超过8(默认值)的列表，jdk1.8中采用了红黑树的结构，那么查询的时间复杂度可以降低到O(logN)，可以改进性能。</p><p>总结：ConcurrentHashMap在1.8下的实现使用数组+链表+红黑树的方式，当链表个数超过8的时候就把原来的链表转成红黑树，使用红黑树来存取，采用了元素锁的思想</p></blockquote><h4 id="2-ConcurrentSkipListMap-和ConcurrentSkipListSet"><a href="#2-ConcurrentSkipListMap-和ConcurrentSkipListSet" class="headerlink" title="2. ConcurrentSkipListMap  和ConcurrentSkipListSet"></a>2. ConcurrentSkipListMap  和ConcurrentSkipListSet</h4><blockquote><p>ConcurrentSkipListMap    TreeMap的并发实现</p></blockquote><blockquote><p>ConcurrentSkipListSet     TreeSet的并发实现</p></blockquote><h4 id="了解什么是SkipList？"><a href="#了解什么是SkipList？" class="headerlink" title="了解什么是SkipList？"></a>了解什么是SkipList？</h4><blockquote><p>二分查找和AVL树查找</p></blockquote><blockquote><p>二分查找要求元素可以随机访问，所以决定了需要把元素存储在连续内存。这样查找确实很快，但是插入和删除元素的时候，为了保证元素的有序性，就需要大量的移动元素了。</p></blockquote><blockquote><p>如果需要的是一个能够进行二分查找，又能快速添加和删除元素的数据结构，首先就是二叉查找树，二叉查找树在最坏情况下可能变成一个链表。</p></blockquote><blockquote><p>于是，就出现了平衡二叉树，根据平衡算法的不同有AVL树，B-Tree，B+Tree，红黑树等，但是AVL树实现起来比较复杂，平衡操作较难理解，这时候就可以用SkipList跳跃表结构。</p></blockquote><blockquote><p>传统意义的单链表是一个线性结构，向有序的链表中插入一个节点需要O(n)的时间，查找操作需要O(n)的时间。</p></blockquote><p><img src="//zongmansheng.club/2019/07/03/bing-fa-gong-ju-lei-he-bing-fa-rong-qi/004.png" alt></p><blockquote><p>如果我们使用上图所示的跳跃表，就可以减少查找所需时间为O(n/2)，因为我们可以先通过每个节点的最上面的指针先进行查找，这样子就能跳过一半的节点。</p><p>比如我们想查找19，首先和6比较，大于6之后，在和9进行比较，然后在和12进行比较……最后比较到21的时候，发现21大于19，说明查找的点在17和21之间，从这个过程中，我们可以看出，查找的时候跳过了3、7、12等点，因此查找的复杂度为O(n/2)。</p><p>跳跃表其实也是一种通过“空间来换取时间”的一个算法，通过在每个节点中增加了向前的指针，从而提升查找的效率。</p><p>跳跃表又被称为概率，或者说是随机化的数据结构，目前开源软件 Redis 和 lucence都有用到它。</p></blockquote><h4 id="3-ConcurrentLinkedQueue-无界非阻塞队列"><a href="#3-ConcurrentLinkedQueue-无界非阻塞队列" class="headerlink" title="3. ConcurrentLinkedQueue  无界非阻塞队列"></a>3. ConcurrentLinkedQueue  无界非阻塞队列</h4><blockquote><p>ConcurrentLinkedQueue   LinkedList 并发版本</p><p>Add,offer：添加元素</p><p>Peek()：get头元素并不把元素拿走</p><p>poll()：get头元素把元素拿走</p></blockquote><h4 id="4-CopyOnWriteArrayList和CopyOnWriteArraySet"><a href="#4-CopyOnWriteArrayList和CopyOnWriteArraySet" class="headerlink" title="4. CopyOnWriteArrayList和CopyOnWriteArraySet"></a><strong>4. CopyOnWriteArrayList和CopyOnWriteArraySet</strong></h4><blockquote><p>写的时候进行复制，可以进行并发的读。</p><p><strong>适用读多写少的场景：</strong>比如白名单，黑名单，商品类目的访问和更新场景，假如我们有一个搜索网站，用户在这个网站的搜索框中，输入关键字搜索内容，但是某些关键字不允许被搜索。这些不能被搜索的关键字会被放在一个黑名单当中，黑名单每天晚上更新一次。当用户搜索时，会检查当前关键字在不在黑名单当中，如果在，则提示不能搜索。</p><p><strong>弱点：内存占用高，数据一致性弱</strong></p><p>总结：写的时候重新复制一份数据，然后在复制的数据里面写入数据，写完以后再把原来的数据的引用执行复制的数据，所以存在数据的弱一致性，适用于读多写少的场景</p></blockquote><h4 id="5-什么是阻塞队列"><a href="#5-什么是阻塞队列" class="headerlink" title="5.什么是阻塞队列"></a>5.什么是阻塞队列</h4><blockquote><p>取数据和存数据不满足要求时，会对线程进行阻塞。例如取数据时发现队列里面没有数据就在那里阻塞等着有数据了再取；存数据时发现队列已经满了就在那里阻塞等着有数据被取走时再存</p></blockquote><p><img src="//zongmansheng.club/2019/07/03/bing-fa-gong-ju-lei-he-bing-fa-rong-qi/005.png" alt></p><h4 id="常用阻塞队列"><a href="#常用阻塞队列" class="headerlink" title="常用阻塞队列"></a><strong>常用阻塞队列</strong></h4><blockquote><p>ArrayBlockingQueue： 数组结构组成有界阻塞队列。</p><p>先进先出原则，初始化必须传大小，take和put时候用的同一把锁</p><p>LinkedBlockingQueue：链表结构组成的有界阻塞队列</p><p>先进先出原则，初始化可以不传大小，put，take锁分离</p><p>PriorityBlockingQueue：支持优先级排序的无界阻塞队列，</p><p>排序，自然顺序升序排列，更改顺序：类自己实现compareTo()方法，初始化PriorityBlockingQueue指定一个比较器Comparator</p><p>DelayQueue： 使用了优先级队列的无界阻塞队列</p><p>支持延时获取，队列里的元素要实现Delay接口。<strong>DelayQueue**</strong>非常有用，可以将<strong><strong>DelayQueue</strong></strong>运用在以下应用场景。**</p></blockquote><blockquote><p><strong>缓存系统的设计：</strong>可以用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue中获取元素时，表示缓存有效期到了。</p><p><strong>还有订单到期，限时支付等等。</strong></p><p>SynchronousQueue：不存储元素的阻塞队列</p><p>每个put操作必须要等take操作</p><p>LinkedTransferQueue：链表结构组成的<strong>无</strong>界阻塞队列</p><p>Transfer,tryTransfer，生产者put时，当前有消费者take，生产者直接把元素传给消费者</p><p>LinkedBlockingDeque：链表结构组成的<strong>双向</strong>阻塞队列</p><p>可以在队列的两端插入和移除，xxxFirst头部操作,xxxLast尾部操作。工作窃取模式。</p></blockquote><h4 id="了解阻塞队列的实现原理"><a href="#了解阻塞队列的实现原理" class="headerlink" title="了解阻塞队列的实现原理"></a><strong>了解阻塞队列的实现原理</strong></h4><blockquote><p>使用了Condition实现。</p></blockquote><h4 id="生产者消费者模式"><a href="#生产者消费者模式" class="headerlink" title="生产者消费者模式"></a><strong>生产者消费者模式</strong></h4><blockquote><p>在并发编程中使用生产者和消费者模式能够解决绝大多数并发问题。该模式通过平衡生</p><p>产线程和消费线程的工作能力来提高程序整体处理数据的速度。</p><p>在线程世界里，生产者就是生产数据的线程，消费者就是消费数据的线程。在多线程开发</p><p>中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理</p><p>完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。为了解决这种生产消费能力不均衡的问题，便有了生产者和消费者模式。</p><p>生产者和消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通信，而是通过阻塞队列来进行通信，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。</p></blockquote><h3 id="什么是Fork-Join框架"><a href="#什么是Fork-Join框架" class="headerlink" title="什么是Fork/Join框架"></a>什么是Fork/Join框架</h3><blockquote><p>并行执行任务的框架，把大任务拆分成很多的小任务，汇总每个小任务的结果得到大任务的结果。</p></blockquote><h5 id="工作窃取算法"><a href="#工作窃取算法" class="headerlink" title="工作窃取算法"></a><strong>工作窃取算法</strong></h5><blockquote><p>工作窃取（work-stealing）算法是指某个线程从其他队列里窃取任务来执行，执行完以后把结果放回去</p><p>那么，为什么需要使用工作窃取算法呢？假如我们需要做一个比较大的任务，可以把这个任务分割为若干互不依赖的子任务，为了减少线程间的竞争，把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应。</p><p>比如A线程负责处理A队列里的任务。但是，有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务等待处理。干完活的线程与其等着，不如去帮其他线程干活，于是它就去其他线程的队列里窃取一个任务来执行。而在这时它们会访问同一个队列，所以为了减少窃取任务线程和被窃取任务线程之间的竞争，通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。</p></blockquote><h5 id="Fork-Join框架的使用"><a href="#Fork-Join框架的使用" class="headerlink" title="Fork/Join框架的使用"></a><strong>Fork/Join框架的使用</strong></h5><blockquote><p>Fork/Join使用两个类来完成以上两件事情。</p><p>①ForkJoinTask：我们要使用ForkJoin框架，必须首先创建一个ForkJoin任务。它提供在任务</p><p>中执行fork()和join()操作的机制。通常情况下，我们不需要直接继承ForkJoinTask类，只需要继承它的子类，Fork/Join框架提供了以下两个子类。</p><p>·RecursiveAction：用于没有返回结果的任务。</p><p>·RecursiveTask：用于有返回结果的任务。</p><p>②ForkJoinPool：ForkJoinTask需要通过ForkJoinPool来执行。</p><p>Fork/Join有同步和异步两种方式。</p></blockquote><h5 id="案例1：孙悟空摘桃子fork-join的案例"><a href="#案例1：孙悟空摘桃子fork-join的案例" class="headerlink" title="案例1：孙悟空摘桃子fork/join的案例"></a><strong>案例1：孙悟空摘桃子fork/join的案例</strong></h5><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 孙悟空摘桃子fork/join的案例，孙悟空去摘桃子时发现桃子太多就让猴子猴孙去帮忙在桃子， * 摘完以后再统一汇总求和 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ForkJoinWuKong</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">XiaoWuKong</span> <span class="token keyword">extends</span> <span class="token class-name">RecursiveTask</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">{</span>      <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">int</span> THRESHOLD <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//阈值，数组多小的时候，不再进行任务拆分操作</span>      <span class="token keyword">private</span> PanTao<span class="token punctuation">[</span><span class="token punctuation">]</span> src<span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token keyword">int</span> fromIndex<span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token keyword">int</span> toIndex<span class="token punctuation">;</span>      <span class="token keyword">private</span> IPickTaoZi pickTaoZi<span class="token punctuation">;</span>      <span class="token keyword">public</span> <span class="token function">XiaoWuKong</span><span class="token punctuation">(</span>PanTao<span class="token punctuation">[</span><span class="token punctuation">]</span> src<span class="token punctuation">,</span> <span class="token keyword">int</span> fromIndex<span class="token punctuation">,</span> <span class="token keyword">int</span> toIndex<span class="token punctuation">,</span> IPickTaoZi pickTaoZi<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>src <span class="token operator">=</span> src<span class="token punctuation">;</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>fromIndex <span class="token operator">=</span> fromIndex<span class="token punctuation">;</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>toIndex <span class="token operator">=</span> toIndex<span class="token punctuation">;</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>pickTaoZi <span class="token operator">=</span> pickTaoZi<span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token annotation punctuation">@Override</span>      <span class="token keyword">protected</span> Integer <span class="token function">compute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">//计算完以后结果汇总</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>toIndex<span class="token operator">-</span>fromIndex<span class="token operator">&lt;</span>THRESHOLD<span class="token punctuation">)</span><span class="token punctuation">{</span>              <span class="token keyword">int</span> count <span class="token operator">=</span><span class="token number">0</span> <span class="token punctuation">;</span>              <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>fromIndex<span class="token punctuation">;</span>i<span class="token operator">&lt;</span>toIndex<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                  <span class="token keyword">if</span> <span class="token punctuation">(</span>pickTaoZi<span class="token punctuation">.</span><span class="token function">pick</span><span class="token punctuation">(</span>src<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> count<span class="token operator">++</span><span class="token punctuation">;</span>              <span class="token punctuation">}</span>              <span class="token keyword">return</span> count<span class="token punctuation">;</span>          <span class="token punctuation">}</span>          <span class="token comment" spellcheck="true">//大任务拆分成小任务</span>          <span class="token keyword">else</span><span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">//fromIndex....mid......toIndex</span>              <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>fromIndex<span class="token operator">+</span>toIndex<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>              XiaoWuKong left <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XiaoWuKong</span><span class="token punctuation">(</span>src<span class="token punctuation">,</span>fromIndex<span class="token punctuation">,</span>mid<span class="token punctuation">,</span>pickTaoZi<span class="token punctuation">)</span><span class="token punctuation">;</span>              XiaoWuKong right <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XiaoWuKong</span><span class="token punctuation">(</span>src<span class="token punctuation">,</span>mid<span class="token punctuation">,</span>toIndex<span class="token punctuation">,</span>pickTaoZi<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token function">invokeAll</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token keyword">return</span> left<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span>right<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ForkJoinPool pool <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ForkJoinPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        PanTao<span class="token punctuation">[</span><span class="token punctuation">]</span> src <span class="token operator">=</span> MakePanTaoArray<span class="token punctuation">.</span><span class="token function">makeArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        IProcessTaoZi processTaoZi <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WuKongProcessImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        IPickTaoZi pickTaoZi <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WuKongPickImpl</span><span class="token punctuation">(</span>processTaoZi<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> start <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//构造一个ForkJoinTask</span>        XiaoWuKong xiaoWuKong <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XiaoWuKong</span><span class="token punctuation">(</span>src<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>                src<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>pickTaoZi<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//ForkJoinTask交给ForkJoinPool来执行。</span>        pool<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>xiaoWuKong<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"The count is "</span><span class="token operator">+</span> xiaoWuKong<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token operator">+</span><span class="token string">" spend time:"</span><span class="token operator">+</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>start<span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"ms"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="案例2：使用Fork-Join框架实现计算1-2-3-…-100的结果"><a href="#案例2：使用Fork-Join框架实现计算1-2-3-…-100的结果" class="headerlink" title="案例2：使用Fork/Join框架实现计算1+2+3+….+100的结果"></a><strong>案例2：使用Fork/Join框架实现计算1+2+3+….+100的结果</strong></h5><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>study<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>forkjoin<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ExecutionException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ForkJoinPool<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>Future<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>RecursiveTask<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * Fork/Join框架设计思路： * 第一步：分割任务。首先我们需要有一个fork类来把大任务分割成子任务，有可能子任务还是很大，所以还需要 *         不停的分割，直到分割出的子任务足够小。 * 第二步：执行任务并合并结果。分割的子任务分别放在双端队列里，然后启动几个线程分别从双端队列里获取任务执行。 *         子任务执行完的结果都统一放在一个队列里，启动一个线程从队列里拿数据，然后合并这些数据。  *  * Fork/Join框架的具体实现： * Fork/Join使用两个类来完成以上两件事情： * ForkJoinTask：我们要使用ForkJoin框架，必须首先创建一个ForkJoin任务。它提供在任务中执行fork()和join() *               操作的机制，通常情况下我们不需要直接继承ForkJoinTask类，而只需要继承它的子类，Fork/Join框架提供了以下两个子类： *               RecursiveAction：用于没有返回结果的任务。 *               RecursiveTask ：用于有返回结果的任务。 * ForkJoinPool ：ForkJoinTask需要通过ForkJoinPool来执行，任务分割出的子任务会添加到当前工作线程所维护的双端队列中， *                进入队列的头部。当一个工作线程的队列里暂时没有任务时，它会随机从其他工作线程的队列的尾部获取一个任务。 *                 * 实战：使用Fork/Join框架实现计算1+2+3+....+100的结果-100个数拆分成10个（阈值）子任务来执行最后汇总结果 * */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CountTask</span> <span class="token keyword">extends</span> <span class="token class-name">RecursiveTask</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 序列化     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 1L<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> THRESHOLD <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 阈值</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> start<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> end<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">CountTask</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>start <span class="token operator">=</span> start<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>end <span class="token operator">=</span> end<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> Integer <span class="token function">compute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果任务足够小就计算任务</span>        <span class="token keyword">boolean</span> canCompute <span class="token operator">=</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> THRESHOLD<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>canCompute<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> end<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                sum <span class="token operator">+=</span> i<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果任务大于阀值，就分裂成两个子任务计算</span>            <span class="token keyword">int</span> middle <span class="token operator">=</span> <span class="token punctuation">(</span>start <span class="token operator">+</span> end<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            CountTask leftTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountTask</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> middle<span class="token punctuation">)</span><span class="token punctuation">;</span>            CountTask rightTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountTask</span><span class="token punctuation">(</span>middle <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 执行子任务</span>            leftTask<span class="token punctuation">.</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            rightTask<span class="token punctuation">.</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 等待子任务执行完，并得到其结果</span>            <span class="token keyword">int</span> leftResult <span class="token operator">=</span> leftTask<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> rightResult <span class="token operator">=</span> rightTask<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 合并子任务</span>            sum <span class="token operator">=</span> leftResult <span class="token operator">+</span> rightResult<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ForkJoinPool forkJoinPool <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ForkJoinPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 生成一个计算任务，负责计算1+2+3+4</span>        CountTask task <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountTask</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 执行一个任务</span>        Future result <span class="token operator">=</span> forkJoinPool<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ExecutionException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="二、并发工具类"><a href="#二、并发工具类" class="headerlink" title="二、并发工具类"></a>二、并发工具类</h3><h4 id="1-CountDownLatch"><a href="#1-CountDownLatch" class="headerlink" title="1. CountDownLatch"></a><strong>1. CountDownLatch</strong></h4><blockquote><p>允许一个或多个线程等待其他线程完成操作。CountDownLatch的构造函数接收一个int类型的参数作为计数器，如果你想等待N个点完成，这里就传入N。当我们调用CountDownLatch的countDown方法时，N就会减1，CountDownLatch的await方法会阻塞当前线程，直到N变成零。</p><p>由于countDown方法可以用在任何地方，所以这里说的N个点，可以是N个线程，也可以是1个线程里的N个执行步骤。用在多个线程时，只需要把这个CountDownLatch的引用传递到线程里即可。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CountDownLatchCase</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> CountDownLatch c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SubThread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            c<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" is done"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                c<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"sleeping..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"sleep is completer"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                c<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span><span class="token number">4</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            Thread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">SubThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        c<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Main will gone....."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="2-CyclicBarrier"><a href="#2-CyclicBarrier" class="headerlink" title="2. CyclicBarrier"></a><strong>2. CyclicBarrier</strong></h4><blockquote><p>CyclicBarrier的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。CyclicBarrier默认的构造方法是CyclicBarrier（int parties），其参数表示屏障拦截的线程数量，每个线程调用await方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CyclicBarrriesBase</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> CyclicBarrier c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CyclicBarrier</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">,</span> BrokenBarrierException <span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    c<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//等待主线程完成</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"is going"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">BrokenBarrierException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"sleeping..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"main will sleep....."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        c<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">////等待子线程完成</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"All are complete."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>CyclicBarrier还提供一个更高级的构造函数CyclicBarrier（int parties，Runnable barrierAction），用于在线程到达屏障时，优先执行barrierAction，方便处理更复杂的业务场景。</p><p>CyclicBarrier可以用于多线程计算数据，最后合并计算结果的场景。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CyclicBarrierSum</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> CyclicBarrier c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CyclicBarrier</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">SumThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//子线程结果存放的缓存</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> ConcurrentHashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>Integer<span class="token operator">></span> resultMap <span class="token operator">=</span>            <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//所有子线程达到屏障后，会执行这个Runnable的任务</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SumThread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> result <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>Integer<span class="token operator">></span> workResult<span class="token operator">:</span>resultMap<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                result <span class="token operator">=</span> result<span class="token operator">+</span>workResult<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"result = "</span><span class="token operator">+</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"完全可以做与子线程，统计无关的事情....."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//工作线程，也就是子线程</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">WorkThread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>        <span class="token keyword">private</span> Random t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> r <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1000</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">":r="</span><span class="token operator">+</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>            resultMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">""</span><span class="token punctuation">,</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token operator">+</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>                c<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">BrokenBarrierException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span><span class="token number">4</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            Thread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">WorkThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="CyclicBarrier和CountDownLatch的区别"><a href="#CyclicBarrier和CountDownLatch的区别" class="headerlink" title="CyclicBarrier和CountDownLatch的区别"></a>CyclicBarrier和CountDownLatch的区别</h5><blockquote><p>CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置，CountDownLatch.await一般阻塞主线程，所有的工作线程执行countDown，而CyclicBarrierton通过工作线程调用await从而阻塞工作线程，直到所有工作线程达到屏障。</p></blockquote><h4 id="4-控制并发线程数的Semaphore"><a href="#4-控制并发线程数的Semaphore" class="headerlink" title="4. 控制并发线程数的Semaphore"></a>4. 控制并发线程数的Semaphore</h4><blockquote><p>Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。应用场景Semaphore可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接。假如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程并发地读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这时我们必须控制只有10个线程同时获取数据库连接保存数据，否则会报错无法获取数据库连接。这个时候，就可以使用Semaphore来做流量控制。。Semaphore的构造方法Semaphore（int permits）接受一个整型的数字，表示可用的许可证数量。Semaphore的用法也很简单，首先线程使用Semaphore的acquire()方法获取一个许可证，使用完之后调用release()方法归还许可证。还可以用tryAcquire()方法尝试获取许可证。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SemaphporeCase</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> Semaphore items<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//有多少元素可拿</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> Semaphore space<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//有多少空位可放元素</span>    <span class="token keyword">private</span> List queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">SemaphporeCase</span><span class="token punctuation">(</span><span class="token keyword">int</span> itemCounts<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>items <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Semaphore</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>space <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Semaphore</span><span class="token punctuation">(</span>itemCounts<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//放入数据</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span>T x<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        space<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//拿空位的许可，没有空位线程会在这个方法上阻塞</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">{</span>            queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        items<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//有元素了，可以释放一个拿元素的许可</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//取数据</span>    <span class="token keyword">public</span> T <span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        items<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//拿元素的许可，没有元素线程会在这个方法上阻塞</span>        T t<span class="token punctuation">;</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">{</span>            t <span class="token operator">=</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span>queue<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        space<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//有空位了，可以释放一个存在空位的许可</span>        <span class="token keyword">return</span> t<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>Semaphore还提供一些其他方法，具体如下。</p><p>·intavailablePermits()：返回此信号量中当前可用的许可证数。</p><p>·intgetQueueLength()：返回正在等待获取许可证的线程数。</p><p>·booleanhasQueuedThreads()：是否有线程正在等待获取许可证。</p><p>·void reducePermits（int reduction）：减少reduction个许可证，是个protected方法。</p></blockquote><h4 id="5-Exchanger"><a href="#5-Exchanger" class="headerlink" title="5. Exchanger"></a>5. Exchanger</h4><blockquote><p>Exchanger（交换者）是一个用于线程间协作的工具类。Exchanger用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。这两个线程通过exchange方法交换数据，如果第一个线程先执行exchange()方法，它会一直等待第二个线程也执行exchange方法，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExchangeCase</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> Exchanger<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>String<span class="token operator">>></span> exgr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Exchanger</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" insert A1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" insert A2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    list <span class="token operator">=</span> exgr<span class="token punctuation">.</span><span class="token function">exchange</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//交换数据</span>                    <span class="token keyword">for</span><span class="token punctuation">(</span>String item<span class="token operator">:</span>list<span class="token punctuation">)</span><span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">":"</span><span class="token operator">+</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" insert B1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" insert B2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" insert B3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" will sleep"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    list <span class="token operator">=</span> exgr<span class="token punctuation">.</span><span class="token function">exchange</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//交换数据</span>                    <span class="token keyword">for</span><span class="token punctuation">(</span>String item<span class="token operator">:</span>list<span class="token punctuation">)</span><span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">":"</span><span class="token operator">+</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;并发工具类和并发容器&quot;&gt;&lt;a href=&quot;#并发工具类和并发容器&quot; class=&quot;headerlink&quot; title=&quot;并发工具类和并发容器&quot;&gt;&lt;/a&gt;并发工具类和并发容器&lt;/h3&gt;&lt;h4 id=&quot;1-ConcurrentHashMap&quot;&gt;&lt;a href=&quot;#1-
      
    
    </summary>
    
      <category term="基础" scheme="http://zongmansheng.club/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="并发" scheme="http://zongmansheng.club/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java内存模型</title>
    <link href="http://zongmansheng.club/2019/07/02/java-nei-cun-mo-xing/"/>
    <id>http://zongmansheng.club/2019/07/02/java-nei-cun-mo-xing/</id>
    <published>2019-07-02T11:23:40.000Z</published>
    <updated>2019-07-02T11:33:27.920Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><h4 id="什么是内存模型"><a href="#什么是内存模型" class="headerlink" title="什么是内存模型"></a>什么是内存模型</h4><blockquote><p>Java内存模型（Java Memory Model ,JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能得到一致效果的机制及规范。目的是解决由于多线程通过共享内存进行通信时，存在的原子性、可见性（缓存一致性）以及有序性问题。</p></blockquote><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><blockquote><p>线程是CPU调度的基本单位。CPU有时间片的概念，会根据不同的调度算法进行线程调度。所以在多线程场景下，就会发生原子性问题。因为线程在执行一个读改写操作时，在执行完读改之后，时间片耗完，就会被要求放弃CPU，并等待重新调度。这种情况下，读改写就不是一个原子操作。即存在原子性问题。</p></blockquote><h4 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h4><blockquote><p>在多核CPU，多线程的场景中，每个核都至少有一个L1 缓存。多个线程访问进程中的某个共享内存，且这多个线程分别在不同的核心上执行，则每个核心都会在各自的caehe中保留一份共享内存的缓冲。由于多核是可以并行的，可能会出现多个线程同时写各自的缓存的情况，而各自的cache之间的数据就有可能不同。</p><p>在CPU和主存之间增加缓存，在多线程场景下就可能存在缓存一致性问题，也就是说，在多核CPU中，每个核的自己的缓存中，关于同一个数据的缓存内容可能不一致。</p></blockquote><h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><blockquote><p>除了引入了时间片以外，由于处理器优化和指令重排等，CPU还可能对输入代码进行乱序执行，比如load-&gt;add-&gt;save 有可能被优化成load-&gt;save-&gt;add 。这就是有序性问题。</p><p>多CPU多级缓存导致的一致性问题、CPU时间片机制导致的原子性问题、以及处理器优化和指令重排导致的有序性问题等，都硬件的不断升级导致的。那么，有没有什么机制可以很好的解决上面的这些问题呢？</p><p>最简单直接的做法就是废除处理器和处理器的优化技术、废除CPU缓存，让CPU直接和主存交互。但是，这么做虽然可以保证多线程下的并发问题。但是，这就有点因噎废食了。</p><p>所以，为了保证并发编程中可以满足原子性、可见性及有序性。有一个重要的概念，那就是——<strong>内存模型</strong>。</p></blockquote><blockquote><p>为了保证共享内存的正确性（可见性、有序性、原子性），内存模型定义了共享内存系统中多线程程序读写操作行为的规范。通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。它与处理器有关、与缓存有关、与并发有关、与编译器也有关。他解决了CPU多级缓存、处理器优化、指令重排等导致的内存访问问题，保证了并发场景下的一致性、原子性和有序性。</p><p>针对上面的这些问题，不同的操作系统都有不同的解决方案，而Java语言为了屏蔽掉底层的差异，定义了一套属于Java语言的内存模型规范，即Java内存模型。</p><p>Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。</p><p>而JMM就作用于工作内存和主存之间数据同步过程。他规定了如何做数据同步以及什么时候做数据同步。</p></blockquote><p><img src="//zongmansheng.club/2019/07/02/java-nei-cun-mo-xing/001.png" alt></p><h4 id="Java内存模型的实现"><a href="#Java内存模型的实现" class="headerlink" title="Java内存模型的实现"></a>Java内存模型的实现</h4><blockquote><p>了解Java多线程的朋友都知道，在Java中提供了一系列和并发处理相关的关键字，比如volatile、synchronized、final、concurren包等。其实这些就是Java内存模型封装了底层的实现后提供给程序员使用的一些关键字。</p><p>在开发多线程的代码的时候，我们可以直接使用synchronized等关键字来控制并发，从来就不需要关心底层的编译器优化、缓存一致性等问题。所以，Java内存模型，除了定义了一套规范，还提供了一系列原语，封装了底层实现后，供开发者直接使用。</p><p>本文并不准备把所有的关键字逐一介绍其用法，因为关于各个关键字的用法，网上有很多资料。读者可以自行学习。本文还有一个重点要介绍的就是，我们前面提到，并发编程要解决原子性、有序性和一致性的问题，我们就再来看下，在Java中，分别使用什么方式来保证。</p></blockquote><h5 id="原子性-1"><a href="#原子性-1" class="headerlink" title="原子性"></a><strong>原子性</strong></h5><blockquote><p>在Java中，为了保证原子性，提供了两个高级的字节码指令monitorenter和monitorexit。在synchronized的实现原理文章中，介绍过，这两个字节码，在Java中对应的关键字就是synchronized。</p><p>因此，在Java中可以使用synchronized来保证方法和代码块内的操作是原子性的。</p></blockquote><p><strong>可见性</strong></p><blockquote><p>Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值的这种依赖主内存作为传递媒介的方式来实现的。</p><p>Java中的volatile关键字提供了一个功能，那就是被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次是用之前都从主内存刷新。因此，可以使用volatile来保证多线程操作时变量的可见性。</p><p>除了volatile，Java中的synchronized和final两个关键字也可以实现可见性。只不过实现方式不同，这里不再展开了。</p></blockquote><h5 id="有序性-1"><a href="#有序性-1" class="headerlink" title="有序性"></a><strong>有序性</strong></h5><blockquote><p>在Java中，可以使用synchronized和volatile来保证多线程之间操作的有序性。实现方式有所区别：</p><p>volatile关键字会禁止指令重排。synchronized关键字保证同一时刻只允许一条线程操作。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java内存模型&quot;&gt;&lt;a href=&quot;#Java内存模型&quot; class=&quot;headerlink&quot; title=&quot;Java内存模型&quot;&gt;&lt;/a&gt;Java内存模型&lt;/h1&gt;&lt;h4 id=&quot;什么是内存模型&quot;&gt;&lt;a href=&quot;#什么是内存模型&quot; class=&quot;header
      
    
    </summary>
    
      <category term="日常学习" scheme="http://zongmansheng.club/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="JMM Java内存模型" scheme="http://zongmansheng.club/tags/JMM-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>MySql主从复制与读写分离</title>
    <link href="http://zongmansheng.club/2019/06/30/mysql-zhu-cong-fu-zhi-yu-du-xie-fen-chi/"/>
    <id>http://zongmansheng.club/2019/06/30/mysql-zhu-cong-fu-zhi-yu-du-xie-fen-chi/</id>
    <published>2019-06-30T07:39:46.000Z</published>
    <updated>2019-06-30T07:50:29.949Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySql主从复制与读写分离"><a href="#MySql主从复制与读写分离" class="headerlink" title="MySql主从复制与读写分离"></a>MySql主从复制与读写分离</h1><p><img src="//zongmansheng.club/2019/06/30/mysql-zhu-cong-fu-zhi-yu-du-xie-fen-chi/Snipaste_2019-06-30_15-40-57.png" alt></p><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><blockquote><p>影响MySQL-A数据库的操作，在数据库执行后，都会写入本地的日志系统A中。</p><p>假设，实时的将变化了的日志系统中的数据库事件操作，在MYSQL-A的3306端口，通过网络发给MYSQL-B。</p><p>MYSQL-B收到后，写入本地日志系统B，然后一条条的将数据库事件在数据库中完成。</p><p>那么，MYSQL-A的变化，MYSQL-B也会变化，这样就是所谓的MYSQL的复制，即MYSQL replication。</p><p>在上面的模型中，MYSQL-A就是主服务器，即master，MYSQL-B就是从服务器，即slave。</p><p>日志系统A，其实它是MYSQL的日志类型中的二进制日志，也就是专门用来保存修改数据库表的所有动作，即bin log。【注意MYSQL会在执行语句之后，释放锁之前，写入二进制日志，确保事务安全】</p><p>日志系统B，并不是二进制日志，由于它是从MYSQL-A的二进制日志复制过来的，并不是自己的数据库变化产生的，有点接力的感觉，称为中继日志，即relay log。</p><p>可以发现，通过上面的机制，可以保证MYSQL-A和MYSQL-B的数据库数据一致，但是时间上肯定有延迟，即MYSQL-B的数据是滞后的。</p><p>【即便不考虑什么网络的因素，MYSQL-A的数据库操作是可以并发的执行的，但是MYSQL-B只能从relay log中读一条，执行下。因此MYSQL-A的写操作很频繁，MYSQL-B很可能跟不上。】</p></blockquote><h4 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h4><blockquote><p>数据如何不被丢失</p><p>备份</p><p>读写分离</p><p>数据库负载均衡</p><p>高可用</p></blockquote><h4 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a><strong>环境搭建</strong></h4><blockquote><p>1.准备环境</p><p>两台windows操作系统 ip分别为: 172.27.185.1(主)、172.27.185.2(从)</p><p>2.连接到主服务(172.27.185.1)服务器上，给从节点分配账号权限。</p><p>GRANT REPLICATION SLAVE ON <em>.</em> TO ‘root’@‘172.27.185.2’ IDENTIFIED BY ‘root’;</p><p>3.在主服务my.ini文件新增</p></blockquote><pre class=" language-mysql"><code class="language-mysql">server-id=200log-bin=mysql-binrelay-log=relay-binrelay-log-index=relay-bin-index</code></pre><blockquote><p>重启mysql服务</p><p>4.在从服务my.ini文件新增</p></blockquote><pre class=" language-mysql"><code class="language-mysql">server-id = 210replicate-do-db =itmayiedu #需要同步数据库</code></pre><blockquote><p>重启mysql服务</p><p>5.从服务同步主数据库</p></blockquote><pre class=" language-mysql"><code class="language-mysql">stop slave;changemaster to master_host='172.27.185.1',master_user='root',master_password='root';start slave;show slave status;</code></pre><blockquote><p>注意事项</p><p>①一定要在同一个局域网中</p><p>②使用360WiFi创建局域网</p><p>③最好把防火墙全部关闭掉</p></blockquote><h4 id="什么是读写分离"><a href="#什么是读写分离" class="headerlink" title="什么是读写分离"></a>什么是读写分离</h4><blockquote><p>在数据库集群架构中，让主库负责处理事务性查询，而从库只负责处理select查询，让两者分工明确达到提高数据库整体读写性能。当然，主数据库另外一个功能就是负责将事务性查询导致的数据变更同步到从库中，也就是写操作。</p></blockquote><h4 id="读写分离的好处"><a href="#读写分离的好处" class="headerlink" title="读写分离的好处"></a>读写分离的好处</h4><blockquote><p>1）分摊服务器压力，提高机器的系统处理效率</p><p>读写分离适用于读远比写的场景，如果有一台服务器，当select很多时，update和delete会被这些select访问中的数据堵塞，等待select结束，并发性能并不高，而主从只负责各自的写和读，极大程度的缓解X锁和S锁争用；</p><p>假如我们有1主3从，不考虑上述1中提到的从库单方面设置，假设现在1分钟内有10条写入，150条读取。那么，1主3从相当于共计40条写入，而读取总数没变，因此平均下来每台服务器承担了10条写入和50条读取（主库不承担读取操作）。因此，虽然写入没变，但是读取大大分摊了，提高了系统性能。另外，当读取被分摊后，又间接提高了写入的性能。所以，总体性能提高了，说白了就是拿机器和带宽换性能；</p><p>2）增加冗余，提高服务可用性，当一台数据库服务器宕机后可以调整另外一台从库以最快速度恢复服务</p></blockquote><h4 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h4><blockquote><p>依赖于二进制日志，binary-log.</p><p>二进制日志中记录引起数据库发生改变的语句</p><p>Insert 、delete、update、create table</p><p><strong>Scale-up与Scale-out区别</strong></p><p>Scale Out是指Application可以在水平方向上扩展。一般对数据中心的应用而言，Scale out指的是当添加更多的机器时，应用仍然可以很好的利用这些机器的资源来提升自己的效率从而达到很好的扩展性。</p><p>Scale Up是指Application可以在垂直方向上扩展。一般对单台机器而言，Scale Up值得是当某个计算节点（机器）添加更多的CPU Cores，存储设备，使用更大的内存时，应用可以很充分的利用这些资源来提升自己的效率从而达到很好的扩展性。</p></blockquote><h4 id="MyCat"><a href="#MyCat" class="headerlink" title="MyCat"></a>MyCat</h4><h5 id="什么是-Mycat"><a href="#什么是-Mycat" class="headerlink" title="什么是 Mycat"></a>什么是 Mycat</h5><blockquote><p>是一个开源的分布式数据库系统，但是因为数据库一般都有自己的数据库引擎，而Mycat并没有属于自己的独有数据库引擎，所有严格意义上说并不能算是一个完整的数据库系统，只能说是一个在应用和数据库之间起桥梁作用的中间件。</p><p>在Mycat中间件出现之前，MySQL主从复制集群，如果要实现读写分离，一般是在程序段实现，这样就带来了一个问题，即数据段和程序的耦合度太高，如果数据库的地址发生了改变，那么我的程序也要进行相应的修改，如果数据库不小心挂掉了，则同时也意味着程序的不可用，而对于很多应用来说，并不能接受；</p><p>引入Mycat中间件能很好地对程序和数据库进行解耦，这样，程序只需关注数据库中间件的地址，而无需知晓底层数据库是如何提供服务的，大量的通用数据聚合、事务、数据源切换等工作都由中间件来处理；</p><p>Mycat中间件的原理是对数据进行分片处理，从原有的一个库，被切分为多个分片数据库，所有的分片数据库集群构成完成的数据库存储，有点类似磁盘阵列中的RAID0.</p></blockquote><h5 id="Mycat安装"><a href="#Mycat安装" class="headerlink" title="Mycat安装"></a>Mycat安装</h5><blockquote><p><strong>创建表结构</strong></p><p>CREATE DATABASE IF NOT EXISTS <code>weibo_simple</code>;</p><hr><p>– Table structure for <code>t_users</code> 用户表</p><hr><p>DROP TABLE IF EXISTS <code>t_users</code>;</p><p>CREATE TABLE <code>t_users</code> (</p><p><code>user_id</code> varchar(64) NOT NULL COMMENT ‘注册用户ID’,</p><p><code>user_email</code> varchar(64) NOT NULL COMMENT ‘注册用户邮箱’,</p><p><code>user_password</code> varchar(64) NOT NULL COMMENT ‘注册用户密码’,</p><p><code>user_nikename</code> varchar(64) NOT NULL COMMENT ‘注册用户昵称’,</p><p><code>user_creatime</code> datetime NOT NULL COMMENT ‘注册时间’,</p><p><code>user_status</code> tinyint(1) NOT NULL COMMENT ‘验证状态 1：已验证 0：未验证’,</p><p><code>user_deleteflag</code> tinyint(1) NOT NULL COMMENT ‘删除标记 1：已删除 0：未删除’,</p><p>PRIMARY KEY (<code>user_id</code>)</p><p>) ENGINE=InnoDB DEFAULT CHARSET=utf8;</p><hr><p>– Table structure for <code>t_message</code>微博表</p><hr><p>DROP TABLE IF EXISTS <code>t_message</code>;</p><p>CREATE TABLE <code>t_message</code> (</p><p><code>messages_id</code> varchar(64) NOT NULL COMMENT ‘微博ID’,</p><p><code>user_id</code> varchar(64) NOT NULL COMMENT ‘发表用户’,</p><p><code>messages_info</code> varchar(255) DEFAULT NULL COMMENT ‘微博内容’,</p><p><code>messages_time</code> datetime DEFAULT NULL COMMENT ‘发布时间’,</p><p><code>messages_commentnum</code> int(12) DEFAULT NULL COMMENT ‘评论次数’,</p><p><code>message_deleteflag</code> tinyint(1) NOT NULL COMMENT ‘删除标记 1：已删除 0：未删除’,</p><p><code>message_viewnum</code> int(12) DEFAULT NULL COMMENT ‘被浏览量’,</p><p>PRIMARY KEY (<code>messages_id</code>),</p><p>KEY <code>user_id</code> (<code>user_id</code>),</p><p>CONSTRAINT <code>t_message_ibfk_1</code> FOREIGN KEY (<code>user_id</code>) REFERENCES <code>t_users</code> (<code>user_id</code>)</p><p>) ENGINE=InnoDB DEFAULT CHARSET=utf8;</p></blockquote><h5 id="配置server-xml"><a href="#配置server-xml" class="headerlink" title="配置server.xml"></a>配置server.xml</h5><pre class=" language-xml"><code class="language-xml">    <span class="token comment" spellcheck="true">&lt;!-- 添加user --></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>user</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mycat<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>mycat<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>schemas<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>mycat<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>user</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 添加user --></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>user</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mycat_red<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>mycat_red<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>schemas<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>mycat<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>readOnly<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>user</span><span class="token punctuation">></span></span></code></pre><h5 id="配置schema-xml"><a href="#配置schema-xml" class="headerlink" title="配置schema.xml"></a>配置schema.xml</h5><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0"?></span><span class="token doctype">&lt;!DOCTYPE mycat:schema SYSTEM "schema.dtd"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mycat:</span>schema</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>mycat</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://org.opencloudb/<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!-- 与server.xml中user的schemas名一致 --></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>schema</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mycat<span class="token punctuation">"</span></span> <span class="token attr-name">checkSQLschema</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token attr-name">sqlMaxLimit</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>t_users<span class="token punctuation">"</span></span> <span class="token attr-name">primaryKey</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user_id<span class="token punctuation">"</span></span> <span class="token attr-name">dataNode</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn1<span class="token punctuation">"</span></span> <span class="token attr-name">rule</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>rule1<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>t_message<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>global<span class="token punctuation">"</span></span> <span class="token attr-name">primaryKey</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>messages_id<span class="token punctuation">"</span></span> <span class="token attr-name">dataNode</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn1<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>schema</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataNode</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn1<span class="token punctuation">"</span></span> <span class="token attr-name">dataHost</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jdbchost<span class="token punctuation">"</span></span> <span class="token attr-name">database</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>weibo_simple<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataHost</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jdbchost<span class="token punctuation">"</span></span> <span class="token attr-name">maxCon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1000<span class="token punctuation">"</span></span> <span class="token attr-name">minCon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>10<span class="token punctuation">"</span></span> <span class="token attr-name">balance</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span> <span class="token attr-name">writeType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token attr-name">dbType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mysql<span class="token punctuation">"</span></span> <span class="token attr-name">dbDriver</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>native<span class="token punctuation">"</span></span> <span class="token attr-name">switchType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span> <span class="token attr-name">slaveThreshold</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>heartbeat</span><span class="token punctuation">></span></span>select user()<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>heartbeat</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>writeHost</span> <span class="token attr-name">host</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>hostMaster<span class="token punctuation">"</span></span> <span class="token attr-name">url</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>172.27.185.1:3306<span class="token punctuation">"</span></span> <span class="token attr-name">user</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span> <span class="token attr-name">password</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>writeHost</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>writeHost</span> <span class="token attr-name">host</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>hostSlave<span class="token punctuation">"</span></span> <span class="token attr-name">url</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>172.27.185.2:3306<span class="token punctuation">"</span></span> <span class="token attr-name">user</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span> <span class="token attr-name">password</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dataHost</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">mycat:</span>schema</span><span class="token punctuation">></span></span></code></pre><h5 id="配置rule-xml文件"><a href="#配置rule-xml文件" class="headerlink" title="配置rule.xml文件"></a>配置rule.xml文件</h5><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token comment" spellcheck="true">&lt;!-- - - Licensed under the Apache License, Version 2.0 (the "License");     - you may not use this file except in compliance with the License. - You     may obtain a copy of the License at - - http://www.apache.org/licenses/LICENSE-2.0     - - Unless required by applicable law or agreed to in writing, software -     distributed under the License is distributed on an "AS IS" BASIS, - WITHOUT     WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. - See the     License for the specific language governing permissions and - limitations     under the License. --></span><span class="token doctype">&lt;!DOCTYPE mycat:rule SYSTEM "rule.dtd"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mycat:</span>rule</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>mycat</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://org.opencloudb/<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tableRule</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>rule1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>rule</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>columns</span><span class="token punctuation">></span></span>user_id<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>columns</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>algorithm</span><span class="token punctuation">></span></span>func1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>algorithm</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>rule</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tableRule</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>function</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>func1<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.opencloudb.route.function.AutoPartitionByLong<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mapFile<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>autopartition-long.txt<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>function</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">mycat:</span>rule</span><span class="token punctuation">></span></span></code></pre><blockquote><p><strong>为了更好地定位错误，修改log4j.xml</strong></p><p>双击startup_nowrap.bat开始启动</p><p><strong>常见问题</strong></p><p>SHOW MASTER STATUS 如果为，则在my.ini文件中添加一行</p><p>log-bin=mysql-bin</p><p>给账号分配权限</p><p>grant all privileges on <em>.</em> to ‘root’@‘172.27.185.1’ identified by ‘root’;</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySql主从复制与读写分离&quot;&gt;&lt;a href=&quot;#MySql主从复制与读写分离&quot; class=&quot;headerlink&quot; title=&quot;MySql主从复制与读写分离&quot;&gt;&lt;/a&gt;MySql主从复制与读写分离&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;//zongmanshe
      
    
    </summary>
    
    
      <category term="MySql" scheme="http://zongmansheng.club/tags/MySql/"/>
    
      <category term="MyCat" scheme="http://zongmansheng.club/tags/MyCat/"/>
    
  </entry>
  
  <entry>
    <title>SSM框架常见面试题</title>
    <link href="http://zongmansheng.club/2019/06/29/ssm-kuang-jia-chang-jian-mian-shi-ti/"/>
    <id>http://zongmansheng.club/2019/06/29/ssm-kuang-jia-chang-jian-mian-shi-ti/</id>
    <published>2019-06-29T11:35:18.000Z</published>
    <updated>2019-07-02T12:28:44.978Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SSM框架常见面试题"><a href="#SSM框架常见面试题" class="headerlink" title="SSM框架常见面试题"></a>SSM框架常见面试题</h1><h3 id="一、Spring面试题"><a href="#一、Spring面试题" class="headerlink" title="一、Spring面试题"></a>一、Spring面试题</h3><h4 id="1、Spring-在ssm中起什么作用？"><a href="#1、Spring-在ssm中起什么作用？" class="headerlink" title="1、Spring 在ssm中起什么作用？"></a>1、Spring 在ssm中起什么作用？</h4><blockquote><ul><li>Spring：轻量级框架</li><li>作用：Bean工厂，用来管理Bean的生命周期和框架集成。</li><li>两大核心：1、IOC/DI(控制反转/依赖注入) ：把dao依赖注入到service层，service层反转给action层，Spring顶层容器为BeanFactory。2、AOP：面向切面编程</li></ul></blockquote><h4 id="2、Spring的事务？"><a href="#2、Spring的事务？" class="headerlink" title="2、Spring的事务？"></a>2、Spring的事务？</h4><blockquote><ul><li>编程式事务管理：编程方式管理事务，极大灵活性，难维护。</li><li>声明式事务管理：可以将业务代码和事务管理分离，用注解和xml配置来管理事务。</li></ul></blockquote><h4 id="3、IOC-在项目中的作用？"><a href="#3、IOC-在项目中的作用？" class="headerlink" title="3、IOC 在项目中的作用？"></a>3、IOC 在项目中的作用？</h4><blockquote><p>作用：Ioc解决对象之间的依赖问题，把所有Bean的依赖关系通过配置文件或注解关联起来，降低了耦合度。</p></blockquote><h4 id="4、Spring的配置文件中的内容？"><a href="#4、Spring的配置文件中的内容？" class="headerlink" title="4、Spring的配置文件中的内容？"></a>4、Spring的配置文件中的内容？</h4><blockquote><ul><li>开启事务注解驱动</li><li>事务管理器</li><li>开启注解功能，并配置扫描包</li><li>配置数据库</li><li>配置SQL会话工厂，别名，映射文件</li><li>不用编写Dao层的实现类</li></ul></blockquote><h4 id="5、Spring下的注解？"><a href="#5、Spring下的注解？" class="headerlink" title="5、Spring下的注解？"></a>5、Spring下的注解？</h4><blockquote><ul><li>注册：@Controller @Service @Component</li><li>注入：@Autowired @Resource</li><li>请求地址：@RequestMapping</li><li>返回具体数据类型而非跳转：@ResponseBody</li></ul></blockquote><h4 id="6、Spring-DI-的三种方式"><a href="#6、Spring-DI-的三种方式" class="headerlink" title="6、Spring DI 的三种方式?"></a>6、Spring DI 的三种方式?</h4><blockquote><p>构造器注入：通过构造方法初始化</p><p>setter方法注入：通过setter方法初始化</p><p>接口注入</p></blockquote><h4 id="7、Spring主要使用了什么模式？"><a href="#7、Spring主要使用了什么模式？" class="headerlink" title="7、Spring主要使用了什么模式？"></a>7、Spring主要使用了什么模式？</h4><blockquote><ul><li>工厂模式：每个Bean的创建通过方法</li><li>单例模式：默认的每个Bean的作用域都是单例</li><li>代理模式：关于Aop的实现通过代理模式</li></ul></blockquote><h4 id="8、IOC，AOP的实现原理？"><a href="#8、IOC，AOP的实现原理？" class="headerlink" title="8、IOC，AOP的实现原理？"></a>8、IOC，AOP的实现原理？</h4><blockquote><ul><li>IOC：通过反射机制生成对象注入</li><li>AOP：动态代理</li></ul></blockquote><h3 id="二、SpringMvc面试题"><a href="#二、SpringMvc面试题" class="headerlink" title="二、SpringMvc面试题"></a>二、SpringMvc面试题</h3><h4 id="1、SpringMvc-的控制器是不是单例模式，如果是，有什么问题，怎么解决？"><a href="#1、SpringMvc-的控制器是不是单例模式，如果是，有什么问题，怎么解决？" class="headerlink" title="1、SpringMvc 的控制器是不是单例模式，如果是，有什么问题，怎么解决？"></a>1、SpringMvc 的控制器是不是单例模式，如果是，有什么问题，怎么解决？</h4><blockquote><ul><li>问题：单例模式，在多线程访问时有线程安全问题</li><li>解决方法：不要用同步，在控制器里面不能写字段</li></ul></blockquote><h4 id="2、SpringMvc-中控制器的注解？"><a href="#2、SpringMvc-中控制器的注解？" class="headerlink" title="2、SpringMvc 中控制器的注解？"></a>2、SpringMvc 中控制器的注解？</h4><blockquote><p>@Controller：该注解表明该类扮演控制器的角色</p></blockquote><h4 id="3、-RequestMapping-注解用在类上的作用？"><a href="#3、-RequestMapping-注解用在类上的作用？" class="headerlink" title="3、@RequestMapping 注解用在类上的作用？"></a>3、@RequestMapping 注解用在类上的作用？</h4><blockquote><p>作用：用来映射一个URL到一个类或者一个特定的处理方法上</p></blockquote><h4 id="4、前台多个参数，这些参数都是一个对象，快速得到对象？"><a href="#4、前台多个参数，这些参数都是一个对象，快速得到对象？" class="headerlink" title="4、前台多个参数，这些参数都是一个对象，快速得到对象？"></a>4、前台多个参数，这些参数都是一个对象，快速得到对象？</h4><blockquote><p>方法：直接在方法中声明这个对象，SpringMvc就自动把属性赋值到这个对象里面</p></blockquote><h4 id="5、SpringMvc中函数的返回值？"><a href="#5、SpringMvc中函数的返回值？" class="headerlink" title="5、SpringMvc中函数的返回值？"></a>5、SpringMvc中函数的返回值？</h4><blockquote><p>String，ModelAndView，List，Set 等</p><p>一般String，Ajax请求，返回一个List集合</p></blockquote><h5 id="6、SpringMvc中的转发和重定向"><a href="#6、SpringMvc中的转发和重定向" class="headerlink" title="6、SpringMvc中的转发和重定向?"></a>6、SpringMvc中的转发和重定向?</h5><blockquote><ul><li>转发：return：“hello”</li><li>重定向 ：return：“redirect:hello.jsp”</li></ul></blockquote><h5 id="7、SpringMvc和Ajax之间的相互调用？"><a href="#7、SpringMvc和Ajax之间的相互调用？" class="headerlink" title="7、SpringMvc和Ajax之间的相互调用？"></a>7、SpringMvc和Ajax之间的相互调用？</h5><p>通过JackSon框架把java里面对象直接转换成js可识别的json对象，具体步骤如下：</p><blockquote><ul><li>加入JackSon.jar</li><li>在配置文件中配置json的映射</li><li>在接受Ajax方法里面直接返回Object，list等，方法前面需要加上注解@ResponseBody</li></ul></blockquote><h4 id="8、SpringMvc的工作流程图"><a href="#8、SpringMvc的工作流程图" class="headerlink" title="8、SpringMvc的工作流程图?"></a>8、SpringMvc的工作流程图?</h4><p><img src="//zongmansheng.club/2019/06/29/ssm-kuang-jia-chang-jian-mian-shi-ti/001.png" alt></p><h4 id="9、Struts2-和-SpringMvc的区别"><a href="#9、Struts2-和-SpringMvc的区别" class="headerlink" title="9、Struts2 和 SpringMvc的区别?"></a>9、Struts2 和 SpringMvc的区别?</h4><blockquote><p>入口不同：</p></blockquote><ul><li>Struts2：filter过滤器</li><li>SpringMvc：一个Servlet即前端控制器</li></ul><blockquote><p>开发方式不同：</p></blockquote><ul><li>Struts2：基于类开发，传递参数通过类的属性，只能设置为多例</li><li>SpringMvc：基于方法开发(一个url对应一个方法)，请求参数传递到方法形参，可以为单例也可以为多例(建议单例)</li></ul><blockquote><p>请求方式不同：</p></blockquote><ul><li>Struts2：值栈村塾请求和响应的数据，通过OGNL存取数据</li><li>SpringMvc：通过参数解析器将request请求内容解析，给方法形参赋值，将数据和视图封装成ModelAndView对象，最后又将ModelAndView中的模型数据通过request域传输到页面，jsp视图解析器默认使用的是jstl。</li></ul><h3 id="三、Mybatis面试题"><a href="#三、Mybatis面试题" class="headerlink" title="三、Mybatis面试题"></a>三、Mybatis面试题</h3><h4 id="1、Ibatis和Mybatis？"><a href="#1、Ibatis和Mybatis？" class="headerlink" title="1、Ibatis和Mybatis？"></a>1、Ibatis和Mybatis？</h4><ul><li>Ibatis：2010年，apache的Ibatis框架停止更新，并移交给了google团队，同时更名为MyBatis。从2010年后Ibatis在没更新过，彻底变成了一个孤儿框架。一个没人维护的框架注定被mybatis拍在沙滩上。</li><li>Mybatis：Ibatis的升级版本。</li></ul><h4 id="2、什么是Mybatis的接口绑定，有什么好处？"><a href="#2、什么是Mybatis的接口绑定，有什么好处？" class="headerlink" title="2、什么是Mybatis的接口绑定，有什么好处？"></a>2、什么是Mybatis的接口绑定，有什么好处？</h4><p>Mybatis实现了DAO接口与xml映射文件的绑定，自动为我们生成接口的具体实现，使用起来变得更加省事和方便。</p><h4 id="3、什么情况用注解，什么情况用xml绑定？"><a href="#3、什么情况用注解，什么情况用xml绑定？" class="headerlink" title="3、什么情况用注解，什么情况用xml绑定？"></a>3、什么情况用注解，什么情况用xml绑定？</h4><ul><li>注解使用情况：Sql语句简单时</li><li>xml绑定使用情况：xml绑定 (@RequestMap用来绑定xml文件)</li></ul><h4 id="4、Mybatis在核心处理类叫什么"><a href="#4、Mybatis在核心处理类叫什么" class="headerlink" title="4、Mybatis在核心处理类叫什么?"></a>4、Mybatis在核心处理类叫什么?</h4><p>SqlSession</p><h4 id="5、查询表名和返回实体Bean对象不一致，如何处理？"><a href="#5、查询表名和返回实体Bean对象不一致，如何处理？" class="headerlink" title="5、查询表名和返回实体Bean对象不一致，如何处理？"></a>5、查询表名和返回实体Bean对象不一致，如何处理？</h4><p>映射键值对即可</p><h5 id="6、Mybatis的好处？"><a href="#6、Mybatis的好处？" class="headerlink" title="6、Mybatis的好处？"></a>6、Mybatis的好处？</h5><ul><li>把Sql语句从Java中独立出来。</li><li>封装了底层的JDBC，API的调用，并且能够将结果集自动转换成JavaBean对象，简化了Java数据库编程的重复工作。</li><li>自己编写Sql语句，更加的灵活。</li><li>入参无需用对象封装（或者map封装）,使用@Param注解</li></ul><h5 id="7、Mybatis配置一对多？"><a href="#7、Mybatis配置一对多？" class="headerlink" title="7、Mybatis配置一对多？"></a>7、Mybatis配置一对多？</h5><pre><code>&lt;collection property=&quot;topicComment&quot; column =&quot;id&quot; ofType=&quot;com.zms.pojo.Comment&quot;select = &quot;selectComment&quot;/&gt;</code></pre><ul><li>property：属性名</li><li>column：共同列</li><li>ofType：集合中元素的类型</li><li>select：要连接的查询</li></ul><h5 id="8、Mybatis配置一对一？"><a href="#8、Mybatis配置一对一？" class="headerlink" title="8、Mybatis配置一对一？"></a>8、Mybatis配置一对一？</h5><pre><code>&lt;association  property=&quot;topicType&quot; select=&quot;selectType&quot; column=&quot;topics_type_id&quot; javaType=&quot;com.zms.pojo.Type&quot;/&gt;</code></pre><ul><li>property：属性名</li><li>select：要连接的查询</li><li>column：共同列</li><li>javaType：集合中元素的类型</li></ul><h5 id="9-、-和-的区别？"><a href="#9-、-和-的区别？" class="headerlink" title="9 、${} 和 #{}的区别？"></a>9 、${} 和 #{}的区别？</h5><blockquote><ul><li>${}：简单字符串替换，把${}直接替换成变量的值，不做任何转换，这种是取值以后再去编译SQL语句。</li><li>#{}：预编译处理，sql中的#{}替换成？，补全预编译语句，有效的防止Sql语句注入，这种取值是编译好SQL语句再取值。</li></ul><p>总结：一般用#{}来进行列的代替</p></blockquote><h5 id="10、获取上一次自动生成的主键值？"><a href="#10、获取上一次自动生成的主键值？" class="headerlink" title="10、获取上一次自动生成的主键值？"></a>10、获取上一次自动生成的主键值？</h5><pre><code>select last_insert_id()</code></pre><h4 id="11、Mybatis如何分页，分页原理？"><a href="#11、Mybatis如何分页，分页原理？" class="headerlink" title="11、Mybatis如何分页，分页原理？"></a>11、Mybatis如何分页，分页原理？</h4><ul><li>RowBounds对象分页</li><li>在Sql内直接书写，带有物理分页</li></ul><h5 id="12、Mybatis工作原理？"><a href="#12、Mybatis工作原理？" class="headerlink" title="12、Mybatis工作原理？"></a>12、Mybatis工作原理？</h5><p><img src="//zongmansheng.club/2019/06/29/ssm-kuang-jia-chang-jian-mian-shi-ti/002.png" alt></p><blockquote><p>原理：</p><ul><li>通过SqlSessionFactoryBuilder从mybatis-config.xml配置文件中构建出SqlSessionFactory。</li><li>SqlSessionFactory开启一个SqlSession，通过SqlSession实例获得Mapper对象并且运行Mapper映射的Sql语句。</li><li>完成数据库的CRUD操作和事务提交，关闭SqlSession。</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SSM框架常见面试题&quot;&gt;&lt;a href=&quot;#SSM框架常见面试题&quot; class=&quot;headerlink&quot; title=&quot;SSM框架常见面试题&quot;&gt;&lt;/a&gt;SSM框架常见面试题&lt;/h1&gt;&lt;h3 id=&quot;一、Spring面试题&quot;&gt;&lt;a href=&quot;#一、Spring面试
      
    
    </summary>
    
      <category term="面试题" scheme="http://zongmansheng.club/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="SSM" scheme="http://zongmansheng.club/tags/SSM/"/>
    
  </entry>
  
  <entry>
    <title>平衡二叉树、B树、B+树，B*树的区别</title>
    <link href="http://zongmansheng.club/2019/06/27/ping-heng-er-cha-shu-b-shu-b-shu-b-shu-de-qu-bie/"/>
    <id>http://zongmansheng.club/2019/06/27/ping-heng-er-cha-shu-b-shu-b-shu-b-shu-de-qu-bie/</id>
    <published>2019-06-27T07:12:33.000Z</published>
    <updated>2019-07-02T12:30:50.219Z</updated>
    
    <content type="html"><![CDATA[<h1 id="平衡二叉树、B树、B-树，B-树的区别"><a href="#平衡二叉树、B树、B-树，B-树的区别" class="headerlink" title="平衡二叉树、B树、B+树，B*树的区别"></a>平衡二叉树、B树、B+树，B*树的区别</h1><h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><blockquote><p>定义：<strong>基于</strong>二分法<strong>的策略</strong>提高数据的查找速度**的一种二叉树数据结构；</p><p><strong>特点：</strong>平衡二叉树是采用<strong>二分法</strong>思想把数据按规则组装成一个树形结构的数据，用这个树形结构的数据减少无关数据的检索，大大的提升了数据检索的速度；平衡二叉树的数据结构组装过程遵循以下规则：</p><p>（1）<strong>非叶子节点</strong>只能允许<strong>最多两个子节点</strong>存在。</p><p>（2）每一个非叶子节点数据分布规则为<strong>左边的子节点小当前节点的值</strong>，<strong>右边的子节点大于当前节点的值</strong>(这里值是基于自己的算法规则而定的，比如hash值)；</p></blockquote><p><img src="//zongmansheng.club/2019/06/27/ping-heng-er-cha-shu-b-shu-b-shu-b-shu-de-qu-bie/001.png" alt></p><blockquote><p>平衡树的层级结构：因为平衡二叉树<strong>查询复杂度</strong>和<strong>树的层级（h高度）</strong>成反比，h值越小查询越快，为了保证树的左右两端数据大致平衡以<strong>降低二叉树的查询难度</strong>一般会采用一种算法机制实现<strong>节点数据结构的平</strong>衡，实现了这种算法的有比如<strong>AVL</strong>、<strong>Treap</strong>、<strong>红黑树</strong>等，使用平衡二叉树能保证数据的<strong>左右两边的节点层级相差不会大于1</strong>，这样可以避免树形结构由于删除增加变成线性链表进而影响查询效率。保证数据平衡的情况下查找数据的速度近于二分法查找。</p></blockquote><h5 id="总结平衡二叉树特点："><a href="#总结平衡二叉树特点：" class="headerlink" title="总结平衡二叉树特点："></a>总结平衡二叉树特点：</h5><blockquote><ol><li>非叶子节点最多拥有两个子节点；</li><li>非叶子节值大于左边子节点、小于右边子节点；</li><li>树的左右两边的层级数相差不会大于1;</li><li>没有值相等重复的节点;</li></ol></blockquote><h4 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h4><blockquote><p>定义：B树和平衡二叉树稍有不同的是B树属于<strong>多叉树</strong>又名<strong>平衡多路查找树</strong>（查找路径不只两个），<strong>数据库索引</strong>技术里大量使用者B树和B+树的数据结构</p></blockquote><h5 id="规则："><a href="#规则：" class="headerlink" title="规则："></a>规则：</h5><blockquote><ol><li><strong>排序方式</strong>：所有节点关键字是按<strong>递增次序</strong>排列，并遵循<strong>左小右大</strong>原则；</li><li><strong>子节点数</strong>：非叶节点的<strong>子节点数&gt;1</strong>，且<strong>&lt;=M （M&gt;=2）</strong>，空树除外（注：M阶代表一个树节点最多有多少个查找路径，M=M路,当M=2则是2叉树,M=3则是3叉）；</li><li><strong>关键字数</strong>：枝节点的<strong>关键字数量</strong>大于等于ceil(m/2)-1个且小于等于M-1个（注：ceil()是个朝正无穷方向取整的函数 如ceil(1.1)结果为2);</li><li>所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null对应下图最后一层节点的空格子;</li></ol><p>示意图如下图所示，这里假设字母的排序规则为A&gt;B&gt;C…：</p></blockquote><p><img src="//zongmansheng.club/2019/06/27/ping-heng-er-cha-shu-b-shu-b-shu-b-shu-de-qu-bie/002.png" alt></p><blockquote><p>如上图我要从上图中找到E，查找流程如下</p><ol><li>获取根节点的关键字进行比较，当前根节点关键字为M，E&lt;M，所以往找到指向左边的子节点（二分法规则，左小右大，左边放小于当前节点值的子节点、右边放大于当前节点值的子节点）；</li><li>拿到关键字D和G，D&lt;E&lt;G 所以直接找到D和G中间的节点；</li><li>拿到E和F，因为E=E 所以直接返回关键字和指针信息（如果树结构里面没有包含所要查找的节点则返回null）；</li></ol></blockquote><h4 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h4><blockquote><p><strong>概念：</strong>B+树是B树的一个升级版，相对于B树来说B+树更充分的利用了节点的空间，让查询速度更加稳定，其速度完全接近于二分法查找。为什么说B+树查找的效率要比B树更高、更稳定；</p></blockquote><p><img src="//zongmansheng.club/2019/06/27/ping-heng-er-cha-shu-b-shu-b-shu-b-shu-de-qu-bie/003.png" alt></p><blockquote><p>如上图所示，我们看看B+树遵循的规则：</p><ol><li>B+跟B树不同之处在于B+树的<strong>非叶子</strong>节点不保存关键字记录的指针，只进行数据索引，即有k个子树的中间节点包含有k个元素，而B树中是k-1个元素，这样使得B+树每个<strong>非叶子</strong>节点所能保存的关键字大大增加；</li><li>B+树<strong>叶子</strong>节点保存了父节点的所有关键字记录的指针，所有数据地址必须要到叶子节点才能获取到，所以<strong>每次数据查询的次数都一样</strong>；</li><li>B+树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针（如图中红色虚线框中所示）。</li><li>所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素(如图中黑色和红色标出的数字)</li><li>非叶子节点的子节点数=关键字数，另一种规则是非叶节点的关键字数=子节点数-1，虽然这两种规则数据排列结构不一样，但其原理还是一样的<strong>Mysql 的B+树是用第一种方式实现</strong>;</li></ol><p>可能有的读者对上面的第1点不太理解，从图上看B树和B+树的节点中都是数字啊，有什么不一样，为什么说B+树的非叶子节点不保存关键字记录的指针？这里引入一个<strong>“卫星数据”</strong>的概念来给大家解释，所谓卫星数据，指的是<strong>索引元素所指向的数据记录</strong>，也就是我们这里说的<strong>“关键字记录的指针”</strong>，比如数据库中的某一行。在B树中，无论中间节点还是叶子节点都带有卫星数据，而B+树只有叶子节点才带有卫星数据，我们来给一张对比图：</p></blockquote><p><img src="//zongmansheng.club/2019/06/27/ping-heng-er-cha-shu-b-shu-b-shu-b-shu-de-qu-bie/004.png" alt></p><p><img src="//zongmansheng.club/2019/06/27/ping-heng-er-cha-shu-b-shu-b-shu-b-shu-de-qu-bie/005.png" alt></p><blockquote><p>从上面两幅图就可以就看出，B树的每一个节点都有一个<strong>“关键字记录的指针”</strong>（即图中的data部分），而B+树只有叶子节点才有。</p><p><strong>特点：</strong></p><p>1、B+<strong>树的层级更少</strong>：相较于B树B+每个<strong>非叶子</strong>节点存储的关键字数更多，树的层级更少所以查询数据更快；</p><p>2、B+<strong>树查询速度更稳定</strong>：B+所有关键字数据地址都存在<strong>叶子</strong>节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;</p><p>3、B+<strong>树天然具备排序功能：</strong>B+树所有的<strong>叶子</strong>节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。</p><p>4、B+<strong>树全节点遍历更快：</strong>B+树遍历整棵树只需要遍历所有的<strong>叶子</strong>节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。</p><p><strong>B树</strong>相对于<strong>B+树</strong>的优点是，如果经常访问的数据离根节点很近，而<strong>B树</strong>的<strong>非叶子</strong>节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比<strong>B+树</strong>快</p></blockquote><p><img src="//zongmansheng.club/2019/06/27/ping-heng-er-cha-shu-b-shu-b-shu-b-shu-de-qu-bie/006.png" alt></p><blockquote><p>规则：B*树是B+树的变种，相对于B+树他们的不同之处如下：</p><ol><li>首先是关键字个数限制问题，B+树初始化的关键字初始化个数是ceil(m/2)，b*树的初始化个数为$ceil(rac{2}{3}m)$</li><li>B<em>树中**</em>非根<strong><em>和</em></strong>非叶子结点<em>**增加\</em>指向兄弟的指针*，如上图的红色箭头所示。</li><li>B+树节点满时就会分裂，而B<em>树节点满时会**</em>检查兄弟节点是否满<em>**（因为每个节点都有指向兄弟的指针），如果兄弟节点未满则向兄弟节点转移关键字，如果兄弟节点已满，则\</em>从当前节点和兄弟节点各拿出1/3的数据创建一个新的节点出来*；</li></ol><p>特点：</p><p>在B+树的基础上因其初始化的容量变大，使得节点空间使用率更高，而又存有兄弟节点的指针，可以向兄弟节点转移关键字的特性使得B*树的分解次数变得更少；</p></blockquote><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote><p><strong>1、相同思想和策略</strong></p><p>从平衡二叉树、B树、B+树、B*树总体来看它们的贯彻的思想是相同的，都是采用二分法和数据平衡策略来提升查找数据的速度；</p><p><strong>2、不同的方式的磁盘空间利用</strong></p><p>不同点是他们一个一个在演变的过程中通过IO从磁盘读取数据的原理进行一步步的演变，每一次演变都是为了让节点的空间更合理的运用起来，从而使树的层级减少达到快速查找数据的目的；</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;平衡二叉树、B树、B-树，B-树的区别&quot;&gt;&lt;a href=&quot;#平衡二叉树、B树、B-树，B-树的区别&quot; class=&quot;headerlink&quot; title=&quot;平衡二叉树、B树、B+树，B*树的区别&quot;&gt;&lt;/a&gt;平衡二叉树、B树、B+树，B*树的区别&lt;/h1&gt;&lt;h4 i
      
    
    </summary>
    
      <category term="日常学习" scheme="http://zongmansheng.club/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="平衡二叉树 B树 B+树" scheme="http://zongmansheng.club/tags/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91-B%E6%A0%91-B-%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>JVM的垃圾回收机制</title>
    <link href="http://zongmansheng.club/2019/06/20/jvm-de-la-ji-hui-shou-ji-zhi/"/>
    <id>http://zongmansheng.club/2019/06/20/jvm-de-la-ji-hui-shou-ji-zhi/</id>
    <published>2019-06-20T04:30:11.000Z</published>
    <updated>2019-07-03T05:25:49.430Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM的垃圾回收机制"><a href="#JVM的垃圾回收机制" class="headerlink" title="JVM的垃圾回收机制"></a>JVM的垃圾回收机制</h1><h4 id="一、-技术背景"><a href="#一、-技术背景" class="headerlink" title="一、 技术背景"></a>一、 技术背景</h4><blockquote><p>说起垃圾回收（GC），大部分人都把这项技术当做Java语言的伴生产物。</p><p>事实上，GC的历史比Java久远，早在1960年Lisp这门语言中就使用了内存动态分配和垃圾回收技术。</p></blockquote><h4 id="二、-哪些内存需要回收？"><a href="#二、-哪些内存需要回收？" class="headerlink" title="二、 哪些内存需要回收？"></a>二、 哪些内存需要回收？</h4><blockquote><p>JVM的内存结构包括五大区域：程序计数器、虚拟机栈、本地方法栈、堆区、方法区。</p><p>其中程序计数器、虚拟机栈、本地方法栈3个区域随线程而生、随线程而灭，因此这几个区域的内存分配和回收都具备确定性，就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。</p><p>而Java堆区和方法区则不一样，这部分内存的分配和回收是动态的，正是垃圾收集器所需关注的部分。</p><p>垃圾收集器在对堆区和方法区进行回收前，首先要确定这些区域的对象哪些可以被回收，哪些暂时还不能回收，这就要用到判断对象是否存活的算法！</p></blockquote><h5 id="2-1-引用计数算法"><a href="#2-1-引用计数算法" class="headerlink" title="2.1 引用计数算法"></a>2.1 引用计数算法</h5><h6 id="2-1-1-算法分析"><a href="#2-1-1-算法分析" class="headerlink" title="2.1.1 算法分析"></a>2.1.1 算法分析</h6><blockquote><p>引用计数是垃圾收集器中的早期策略。在这种方法中，堆中每个对象实例都有一个引用计数。</p><p>当一个对象被创建时，就将该对象实例分配给一个变量，该变量计数设置为1。</p><p>当任何其它变量被赋值为这个对象的引用时，计数加1（a = b,则b引用的对象实例的计数器+1），但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数器减1。</p><p>任何引用计数器为0的对象实例可以被当作垃圾收集。当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器减1。</p></blockquote><h6 id="2-1-2-优缺点"><a href="#2-1-2-优缺点" class="headerlink" title="2.1.2 优缺点"></a>2.1.2 优缺点</h6><blockquote><p><strong>优点</strong>：引用计数收集器可以很快的执行，交织在程序运行中。对程序需要不被长时间打断的实时环境比较有利。</p><p><strong>缺点</strong>：无法检测出循环引用。如父对象有一个对子对象的引用，子对象反过来引用父对象。这样，他们的引用计数永远不可能为0。</p></blockquote><p>2.1.3 示例代码</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReferenceFindTest</span> <span class="token punctuation">{</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>         MyObject object1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         MyObject object2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         object1<span class="token punctuation">.</span>object <span class="token operator">=</span> object2<span class="token punctuation">;</span>         object2<span class="token punctuation">.</span>object <span class="token operator">=</span> object1<span class="token punctuation">;</span>         object1 <span class="token operator">=</span> null<span class="token punctuation">;</span>         object2 <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>这段代码是用来验证引用计数算法不能检测出循环引用。最后面两句将object1和object2赋值为null</p><p>也就是说object1和object2指向的对象已经不可能再被访问，但是由于它们互相引用对方，导致它们的引用计数器都不为0，那么垃圾收集器就永远不会回收它们。</p></blockquote><h5 id="2-2-可达性分析算法"><a href="#2-2-可达性分析算法" class="headerlink" title="2.2 可达性分析算法"></a>2.2 可达性分析算法</h5><blockquote><p>可达性分析算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点</p></blockquote><p><img src="//zongmansheng.club/2019/06/20/jvm-de-la-ji-hui-shou-ji-zhi/001.png" alt></p><blockquote><p>找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点，无用的节点将会被判定为是可回收的对象。</p></blockquote><blockquote><p>在Java语言中，可作为GC Roots的对象包括下面几种：</p><ul><li>虚拟机栈中引用的对象（栈帧中的本地变量表）；</li><li>方法区中类静态属性引用的对象；</li><li>方法区中常量引用的对象；</li><li>本地方法栈中JNI（Native方法）引用的对象。</li></ul></blockquote><h5 id="2-3-Java中的引用"><a href="#2-3-Java中的引用" class="headerlink" title="2.3 Java中的引用"></a>2.3 Java中的引用</h5><blockquote><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与“引用”有关。</p><p>在Java语言中，将引用又分为强引用、软引用、弱引用、虚引用4种，这四种引用强度依次逐渐减弱。</p></blockquote><h6 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h6><blockquote><p>在程序代码中普遍存在的，类似 Object obj = new Object() 这类引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</p></blockquote><h6 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h6><blockquote><p>用来描述一些还有用但并非必须的对象。</p><p>对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存溢出异常。</p></blockquote><h6 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h6><blockquote><p>也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。</p><p>当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</p></blockquote><h6 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h6><blockquote><p>也叫幽灵引用或幻影引用（名字真会取，很魔幻的样子），是最弱的一种引用关系。</p><p>一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。</p><p>它的作用是能在这个对象被收集器回收时收到一个系统通知。</p><p>不要被概念吓到，也别担心，还没跑题，再深入，可就不好说了。小编罗列这四个概念的目的是为了说明，无论引用计数算法还是可达性分析算法都是基于强引用而言的。</p></blockquote><h5 id="2-4-对象死亡（被回收）前的最后一次挣扎"><a href="#2-4-对象死亡（被回收）前的最后一次挣扎" class="headerlink" title="2.4 对象死亡（被回收）前的最后一次挣扎"></a>2.4 对象死亡（被回收）前的最后一次挣扎</h5><blockquote><p>即使在可达性分析算法中不可达的对象，也并非是“非死不可”，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程。</p><p><strong>第一次标记</strong>：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记；</p><p><strong>第二次标记</strong>：第一次标记后接着会进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。在finalize()方法中没有重新与引用链建立关联关系的，将被进行第二次标记。</p><p>第二次标记成功的对象将真的会被回收，如果对象在finalize()方法中重新与引用链建立了关联关系，那么将会逃离本次回收，继续存活。</p></blockquote><h5 id="2-5-方法区如何判断是否需要回收"><a href="#2-5-方法区如何判断是否需要回收" class="headerlink" title="2.5 方法区如何判断是否需要回收"></a>2.5 方法区如何判断是否需要回收</h5><blockquote><p>方法区存储内容是否需要回收的判断可就不一样咯。方法区主要回收的内容有：废弃常量和无用的类。</p><p>对于废弃常量也可通过引用的可达性来判断，但是对于无用的类则需要同时满足下面3个条件：</p><ul><li>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例；</li><li>加载该类的ClassLoader已经被回收；</li><li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul></blockquote><h4 id="三、常用的垃圾收集算法"><a href="#三、常用的垃圾收集算法" class="headerlink" title="三、常用的垃圾收集算法"></a>三、常用的垃圾收集算法</h4><h5 id="3-1-标记-清除算法"><a href="#3-1-标记-清除算法" class="headerlink" title="3.1 标记-清除算法"></a>3.1 标记-清除算法</h5><blockquote><p>标记-清除算法采用从根集合（GC Roots）进行扫描，对存活的对象进行标记</p><p>标记完毕后，再扫描整个空间中未被标记的对象，进行回收，如下图所示。</p><p>标记-清除算法不需要进行对象的移动，只需对不存活的对象进行处理，在存活对象比较多的情况下极为高效</p><p>但由于标记-清除算法直接回收不存活的对象，因此会造成<strong>内存碎片</strong></p></blockquote><p><img src="//zongmansheng.club/2019/06/20/jvm-de-la-ji-hui-shou-ji-zhi/002.png" alt></p><h5 id="3-2-复制算法"><a href="#3-2-复制算法" class="headerlink" title="3.2 复制算法"></a>3.2 复制算法</h5><blockquote><p>复制算法的提出是为了克服句柄的开销和解决内存碎片的问题。</p><p>它开始时把堆分成 一个对象面和多个空闲面， 程序从对象面为对象分配空间，当对象满了，基于copying算法的垃圾收集就从根集合（GC Roots）中扫描活动对象，并将每个活动对象复制到空闲面(使得活动对象所占的内存之间没有空闲洞)</p><p>这样空闲面变成了对象面，原来的对象面变成了空闲面，程序会在新的对象面中分配内存。</p></blockquote><p><img src="//zongmansheng.club/2019/06/20/jvm-de-la-ji-hui-shou-ji-zhi/003.png" alt></p><h5 id="3-3-标记-整理算法"><a href="#3-3-标记-整理算法" class="headerlink" title="3.3 标记-整理算法"></a>3.3 标记-整理算法</h5><blockquote><p>标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往左端空闲空间移动，并更新对应的指针。</p><p>标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。</p><p>具体流程见下图：</p></blockquote><p><img src="//zongmansheng.club/2019/06/20/jvm-de-la-ji-hui-shou-ji-zhi/004.png" alt></p><h5 id="3-4-分代收集算法"><a href="#3-4-分代收集算法" class="headerlink" title="3.4 分代收集算法"></a>3.4 分代收集算法</h5><blockquote><p>分代收集算法是目前大部分JVM的垃圾收集器采用的算法。它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。</p><p>一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），在堆区之外还有一个代就是永久代（Permanet Generation）。</p><p>老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法。</p></blockquote><p><img src="//zongmansheng.club/2019/06/20/jvm-de-la-ji-hui-shou-ji-zhi/005.png" alt></p><h6 id="3-4-1-年轻代（Young-Generation）的回收算法"><a href="#3-4-1-年轻代（Young-Generation）的回收算法" class="headerlink" title="3.4.1 年轻代（Young Generation）的回收算法"></a>3.4.1 年轻代（Young Generation）的回收算法</h6><blockquote><p><strong>a)</strong> 所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。</p><p><strong>b)</strong> 新生代内存按照8:1:1的比例分为一个eden区和两个survivor(survivor0,survivor1)区。</p><p>大部分对象在Eden区中生成，回收时先将eden区存活对象复制到一个survivor0区，然后清空eden区。</p><p>当这个survivor0区也存放满了时，则将eden区和survivor0区存活对象复制到另一个survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的</p><p>然后将survivor0区和survivor1区交换，即保持survivor1区为空， 如此往复。</p><p><strong>c)</strong> 当survivor1区不足以存放 eden和survivor0的存活对象时，就将存活对象直接存放到老年代。</p><p>若是老年代也满了就会触发一次Full GC，也就是新生代、老年代都进行回收。</p><p><strong>d)</strong> 新生代发生的GC也叫做Minor GC，MinorGC发生频率比较高(不一定等Eden区满了才触发)。</p></blockquote><h6 id="3-4-2-年老代（Old-Generation）的回收算法"><a href="#3-4-2-年老代（Old-Generation）的回收算法" class="headerlink" title="3.4.2 年老代（Old Generation）的回收算法"></a><strong>3.4.2 年老代（Old Generation）的回收算法</strong></h6><blockquote><p><strong>a)</strong> 在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。</p><p>因此，可以认为年老代中存放的都是一些生命周期较长的对象。</p><p><strong>b)</strong> 内存比新生代也大很多(大概比例是1:2)，当老年代内存满时触发Major GC即Full GC，Full GC发生频率比较低，老年代对象存活时间比较长，存活率标记高。</p></blockquote><h6 id="3-4-3-持久代（Permanent-Generation）的回收算法"><a href="#3-4-3-持久代（Permanent-Generation）的回收算法" class="headerlink" title="3.4.3 持久代（Permanent Generation）的回收算法"></a><strong>3.4.3 持久代（Permanent Generation）的回收算法</strong></h6><blockquote><p>用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate 等，</p><p>在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。</p><p>持久代也称方法区，具体的回收可参见上文2.5节。</p></blockquote><h4 id="四、常见的垃圾收集器"><a href="#四、常见的垃圾收集器" class="headerlink" title="四、常见的垃圾收集器"></a><strong>四、常见的垃圾收集器</strong></h4><blockquote><p>下面一张图是HotSpot虚拟机包含的所有收集器:</p></blockquote><p><img src="//zongmansheng.club/2019/06/20/jvm-de-la-ji-hui-shou-ji-zhi/006.png" alt></p><blockquote><ul><li><strong>Serial收集器（复制算法)</strong></li><li>新生代单线程收集器，标记和清理都是单线程，优点是简单高效。是client级别默认的GC方式，可以通过-XX:+UseSerialGC来强制指定。</li></ul></blockquote><blockquote><ul><li><strong>Serial Old收集器(标记-整理算法)</strong></li><li>老年代单线程收集器，Serial收集器的老年代版本</li></ul></blockquote><blockquote><ul><li><strong>ParNew收集器(停止-复制算法)</strong>　</li><li>新生代收集器，可以认为是Serial收集器的多线程版本,在多核CPU环境下有着比Serial更好的表现。</li></ul></blockquote><blockquote><ul><li><strong>Parallel Scavenge收集器(停止-复制算法)</strong></li><li>并行收集器，追求高吞吐量，高效利用CPU。吞吐量一般为99%， 吞吐量= 用户线程时间/(用户线程时间+GC线程时间)。适合后台应用等对交互相应要求不高的场景。是server级别默认采用的GC方式，可用-XX:+UseParallelGC来强制指定，用-XX:ParallelGCThreads=4来指定线程数</li></ul></blockquote><blockquote><ul><li><strong>Parallel Old收集器(停止-复制算法)</strong></li><li>Parallel Scavenge收集器的老年代版本，并行收集器，吞吐量优先。</li></ul></blockquote><blockquote><ul><li><strong>CMS(Concurrent Mark Sweep)收集器（标记-清理算法）</strong></li><li>高并发、低停顿，追求最短GC回收停顿时间，cpu占用比较高，响应时间快，停顿时间短，多核cpu 追求高响应时间的选择。</li></ul></blockquote><h4 id="五、GC什么时候触发的"><a href="#五、GC什么时候触发的" class="headerlink" title="五、GC什么时候触发的"></a><strong>五、GC什么时候触发的</strong></h4><blockquote><p>由于对象进行了分代处理，因此垃圾回收区域、时间也不一样。GC有两种类型：Scavenge GC和Full GC。</p></blockquote><h5 id="5-1-Scavenge-GC"><a href="#5-1-Scavenge-GC" class="headerlink" title="5.1 Scavenge GC"></a><strong>5.1 Scavenge GC</strong></h5><blockquote><p>一般情况下，当新对象生成，并且在Eden申请空间失败时，就会触发Scavenge GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区。然后整理Survivor的两个区。</p><p>这种方式的GC是对年轻代的Eden区进行，不会影响到年老代。因为大部分对象都是从Eden区开始的，同时Eden区不会分配的很大，所以Eden区的GC会频繁进行。</p><p>因而，一般在这里需要使用速度快、效率高的算法，使Eden去能尽快空闲出来。</p></blockquote><h5 id="5-2-Full-GC"><a href="#5-2-Full-GC" class="headerlink" title="5.2 Full GC"></a><strong>5.2 Full GC</strong></h5><blockquote><p>对整个堆进行整理，包括Young、Tenured和Perm。</p><p>Full GC因为需要对整个堆进行回收，所以比Scavenge GC要慢，因此应该尽可能减少Full GC的次数。</p><p>在对JVM调优的过程中，很大一部分工作就是对于Full GC的调节。</p><p>有如下原因可能导致Full GC：</p><ul><li>老年代（Tenured）被写满；</li><li>持久代（Perm）被写满；</li><li>System.gc()被显示调用；</li><li>上一次GC之后Heap的各域分配策略动态变化；</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JVM的垃圾回收机制&quot;&gt;&lt;a href=&quot;#JVM的垃圾回收机制&quot; class=&quot;headerlink&quot; title=&quot;JVM的垃圾回收机制&quot;&gt;&lt;/a&gt;JVM的垃圾回收机制&lt;/h1&gt;&lt;h4 id=&quot;一、-技术背景&quot;&gt;&lt;a href=&quot;#一、-技术背景&quot; class
      
    
    </summary>
    
      <category term="日常学习" scheme="http://zongmansheng.club/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="JVM" scheme="http://zongmansheng.club/tags/JVM/"/>
    
      <category term="回收机制" scheme="http://zongmansheng.club/tags/%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Java8之lambda表达式</title>
    <link href="http://zongmansheng.club/2019/06/17/java8-zhi-lambda-biao-da-shi/"/>
    <id>http://zongmansheng.club/2019/06/17/java8-zhi-lambda-biao-da-shi/</id>
    <published>2019-06-17T12:24:29.000Z</published>
    <updated>2019-06-17T14:56:26.253Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><h4 id="一、java重要的函数式接口"><a href="#一、java重要的函数式接口" class="headerlink" title="一、java重要的函数式接口"></a>一、java重要的函数式接口</h4><h5 id="1、什么是函数式接口"><a href="#1、什么是函数式接口" class="headerlink" title="1、什么是函数式接口"></a><strong>1、什么是函数式接口</strong></h5><pre><code>        函数接口是只有一个抽象方法的接口，用作 Lambda 表达式的类型。使用@FunctionalInterface注解修饰的类，编译器会检测该类是否只有一个抽象方法或接口，否则，会报错。可以有多个默认方法，静态方法。</code></pre><h5 id="2、Java8将函数式接口封装到流中如何高效的帮助我们处理集合。"><a href="#2、Java8将函数式接口封装到流中如何高效的帮助我们处理集合。" class="headerlink" title="2、Java8将函数式接口封装到流中如何高效的帮助我们处理集合。"></a>2、Java8将函数式接口封装到流中如何高效的帮助我们处理集合。</h5><pre><code>本篇所有示例都基于以下三个类。OutstandingClass：班级；Student：学生；SpecialityEnum：特长。</code></pre><p><img src="//zongmansheng.club/2019/06/17/java8-zhi-lambda-biao-da-shi/001.png" alt="001"></p><h6 id="2-1-惰性求值与及早求值"><a href="#2-1-惰性求值与及早求值" class="headerlink" title="2.1 惰性求值与及早求值"></a><strong>2.1 惰性求值与及早求值</strong></h6><pre><code>惰性求值：只描述Stream，操作的结果也是Stream，这样的操作称为惰性求值。惰性求值可以像建造者模式一样链式使用，最后再使用及早求值得到最终结果。及早求值：得到最终的结果而不是Stream，这样的操作称为及早求值</code></pre><h6 id="3、常用的流"><a href="#3、常用的流" class="headerlink" title="3、常用的流"></a>3、常用的流</h6><p>3.1 collect(Collectors.toList())</p><pre><code>将流转换为list。还有toSet()，toMap()等。及早求值。</code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019-06-17 * @Time: 21:26 * @Vsersion: 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestCase</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>Student<span class="token operator">></span> studentList <span class="token operator">=</span> Stream<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"路飞"</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">185</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"红发"</span><span class="token punctuation">,</span><span class="token number">34</span><span class="token punctuation">,</span><span class="token number">178</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"白胡子"</span><span class="token punctuation">,</span><span class="token number">32</span><span class="token punctuation">,</span><span class="token number">189</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>studentList<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>3.2 filter</p><pre><code>顾名思义，起过滤筛选的作用。内部就是Predicate接口。惰性求值。</code></pre><pre><code>比如我们筛选出出身高小于180的同学。</code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019-06-17 * @Time: 22:32 * @Vsersion: 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test02</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>Student<span class="token operator">></span> students <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        students<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"路飞"</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">175</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        students<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"红发"</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">180</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        students<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"白胡子"</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">185</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>Student<span class="token operator">></span> list <span class="token operator">=</span> students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>student <span class="token operator">-</span><span class="token operator">></span> student<span class="token punctuation">.</span><span class="token function">getStature</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token number">180</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>3.3 map</p><pre><code>转换功能，内部就是Function接口。惰性求值</code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019-06-17 * @Time: 22:47 * @Vsersion: 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test03</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>Student<span class="token operator">></span> students <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        students<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"路飞"</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">175</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        students<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"红发"</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">180</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        students<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"白胡子"</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">185</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>String<span class="token operator">></span> names <span class="token operator">=</span> students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>student <span class="token operator">-</span><span class="token operator">></span> student<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>names<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>3.4 flatMap</p><pre><code>将多个Stream合并为一个Stream。惰性求值</code></pre><p><img src="//zongmansheng.club/2019/06/17/java8-zhi-lambda-biao-da-shi/004.png" alt="004"></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @Author: ZongMan * @Date: 2019-06-17 * @Time: 22:51 * @Vsersion: 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test04</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>Student<span class="token operator">></span> students <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        students<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"路飞"</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">175</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        students<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"红发"</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">180</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        students<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"白胡子"</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">185</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>Student<span class="token operator">></span> studentList <span class="token operator">=</span> Stream<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>students<span class="token punctuation">,</span>                <span class="token function">asList</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"艾斯"</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">,</span> <span class="token number">183</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                        <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"雷利"</span><span class="token punctuation">,</span> <span class="token number">48</span><span class="token punctuation">,</span> <span class="token number">176</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span>students1 <span class="token operator">-</span><span class="token operator">></span> students1<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>studentList<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>调用Stream.of的静态方法将两个list转换为Stream，再通过flatMap将两个流合并为一个。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Lambda表达式&quot;&gt;&lt;a href=&quot;#Lambda表达式&quot; class=&quot;headerlink&quot; title=&quot;Lambda表达式&quot;&gt;&lt;/a&gt;Lambda表达式&lt;/h1&gt;&lt;h4 id=&quot;一、java重要的函数式接口&quot;&gt;&lt;a href=&quot;#一、java重要的函数
      
    
    </summary>
    
      <category term="日常学习" scheme="http://zongmansheng.club/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Lambda" scheme="http://zongmansheng.club/tags/Lambda/"/>
    
  </entry>
  
  <entry>
    <title>springcloud（一）</title>
    <link href="http://zongmansheng.club/2019/06/15/springcloud-yi/"/>
    <id>http://zongmansheng.club/2019/06/15/springcloud-yi/</id>
    <published>2019-06-15T10:47:08.000Z</published>
    <updated>2019-07-07T13:43:58.479Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringCloud（一）"><a href="#SpringCloud（一）" class="headerlink" title="SpringCloud（一）"></a>SpringCloud（一）</h1><p><img src="//zongmansheng.club/2019/06/15/springcloud-yi/001.png" alt></p><blockquote><p>开发web程序的最早期时间，最被广泛使用的企业程序架构是将程序的服务器端组件打包为单个单元。例如很多企业将Java应用程序打包为单个WAR完整运行。单体架构在很多小型的Web服务中很常见，因为其优点很明显：</p><p>服务量级较小，开发人员协调型不高，只需要少数开发配合。</p><p>开发简单直接，集中式管理, 基本不会重复开发。</p><p>功能都在本地，没有分布式的管理开销和调用开销。</p><p>但是随着业务的衍生与扩展，服务量增加的时候，它的缺点也很明显：</p><p>开发效率低：所有的开发人员在一个项目改代码，耦合依赖性太高，提交代码相互等待，功能互相依赖。</p><p>代码维护难：代码功能耦合在一起，新人不知道何从下手</p><p>部署不灵活：构建时间长，任何小修改必须重新构建整个项目，这个过程往往很长</p><p>稳定性不高：一个微不足道的小问题，可以导致整个应用挂掉，或者最常见为了更新一个小服务需要重新打包整个应用。</p><p>-扩展性不够：无法满足高并发情况下的业务需求</p></blockquote><h4 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h4><blockquote><p>微服务最早由Martin Fowler与James Lewis于2014年共同提出，微服务是指开发一个个(或一系列)单个小型的但有业务功能的服务，每个服务都有自己的处理和轻量通讯机制，可以部署在单个或多个服务器上。微服务也指一种松耦合的、有一定的有界上下文的面向服务架构。也就是说，如果每个服务都要同时修改，那么它们就不是微服务，因为它们紧耦合在一起；如果你需要掌握一个服务太多的上下文场景使用条件，那么它就是一个有上下文边界的服务，这个定义来自DDD领域驱动设计。</p><p>相对于单体架构和SOA，它的主要特点是组件化、松耦合、自治、去中心化，体现在以下几个方面：</p><p>一组小的服务 : 服务粒度要小，而每个服务是针对一个单一职责的业务能力的封装，专注做好一件事情。</p><p>独立部署运行和扩展 :每个服务能够独立被部署并运行在一个进程内。这种运行和部署方式能够赋予系统灵活的代码组织方式和发布节奏，使得快速交付和应对变化成为可能。</p><p>独立开发和演化 :技术选型灵活，不受遗留系统技术约束。合适的业务问题选择合适的技术可以独立演化。服务与服务之间采取与语言无关的API进行集成。相对单体架构，微服务架构是更面向业务创新的一种架构模式。</p><p>独立团队和自治 : 团队对服务的整个生命周期负责，工作在独立的上下文中，自己决策自己治理，而不需要统一的指挥中心。团队和团队之间通过松散的社区部落进行衔接。</p><p>我们可以看到整个微服务的思想就如我们现在面对信息爆炸、知识爆炸是一样的：通过解耦我们所做的事情，分而治之以减少不必要的损耗，使得整个复杂的系统和组织能够快速的应对变化。</p></blockquote><h4 id="为什么采用微服务呢？"><a href="#为什么采用微服务呢？" class="headerlink" title="为什么采用微服务呢？"></a>为什么采用微服务呢？</h4><blockquote><p>“让我们的系统尽可能快地响应变化” - Rebecca Parson</p><p>让我们的系统尽可能快地去响应变化.其实几十年来我们一直在尝试解决这个问题。如果一定要在前面加个限制的话，那就是低成本的快速响应变化。上世纪90年代Kent Beck提出要拥抱变化，在同期出现了诸多轻量级开发方法（诸如 XP、Scrum）；2001年敏捷宣言诞生，之后又出现了精益、看板等新的管理方式。如果说，这些是为了尽快的响应变化，在软件开发流程和实践方面提出的解决方案，那么微服务架构就是在软件技术和架构层面提出的应对之道。</p></blockquote><h4 id="服务注册、发现、负载均衡和健康检查"><a href="#服务注册、发现、负载均衡和健康检查" class="headerlink" title="服务注册、发现、负载均衡和健康检查"></a>服务注册、发现、负载均衡和健康检查</h4><blockquote><p>和单体 (Monolithic) 架构的结构不同，微服务架构是由一系列职责单一的细粒度服务构成的分布式网状结构，服务之间通过轻量机制进行通信，这时候必然引入一个服务注册发现问题，也就是说服务提供方要注册通告服务地址，服务的调用方要能发现目标服务，同时服务提供方一般以集群方式提供服务，也就引入了负载均衡和健康检查问题。根据负载均衡 LB 所在位置的不同，目前主要的服务注册、发现和负载均衡方案有三种：</p></blockquote><h5 id="集中式-LB-方案"><a href="#集中式-LB-方案" class="headerlink" title="集中式 LB 方案"></a>集中式 LB 方案</h5><blockquote><p>集中式 LB 方案,在服务消费者和服务提供者之间有一个独立的 LoadBalance(后面简称LB)，LB 通常是专门的硬件设备如 F5，或者基于软件如 LVS，HAproxy 等实现。LB 上有所有服务的地址映射表，通常由运维配置注册，当服务消费方调用某个目标服务时，它向 LB 发起请求，由 LB 以某种策略（比如 Round-Robin）做负载均衡后将请求转发到目标服务。LB 一般具备健康检查能力，能自动摘除不健康的服务实例。服务消费方如何发现 LB 呢？通常的做法是通过 DNS，运维人员为服务配置一个 DNS 域名，这个域名指向 LB。</p></blockquote><p><img src="//zongmansheng.club/2019/06/15/springcloud-yi/002.png" alt></p><blockquote><p>集中式LB方案实现简单，在LB上也容易做集中式的访问控制，这一方案目前还是业界主流。集中式LB的主要问题是单点问题，所有服务调用流量都经过LB，当服务数量和调用量大的时候，LB容易成为瓶颈，且一旦LB发生故障对整个系统的影响是灾难性的。另外，LB在服务消费方和服务提供方之间增加了一跳(hop)，有一定性能开销。</p></blockquote><h5 id="进程内LB方案"><a href="#进程内LB方案" class="headerlink" title="进程内LB方案"></a>进程内LB方案</h5><blockquote><p>针对集中式LB的不足，进程内LB方案将LB的功能以库的形式集成到服务消费方进程里头，该方案也被称为软负载(Soft Load Balancing)或者客户端负载方案，如图展示了这种方案的工作原理。这一方案需要一个服务注册表(Service Registry)配合支持服务自注册和自发现，服务提供方启动时，首先将服务地址注册到服务注册表（同时定期报心跳到服务注册表以表明服务的存活状态，相当于健康检查），服务消费方要访问某个服务时，它通过内置的LB组件向服务注册表查询（同时缓存并定期刷新）目标服务地址列表，然后以某种负载均衡策略选择一个目标服务地址，最后向目标服务发起请求。这一方案对服务注册表的可用性(Availability)要求很高，一般采用能满足高可用分布式一致的组件（例如Zookeeper, Consul, Etcd等）来实现。</p></blockquote><p><img src="//zongmansheng.club/2019/06/15/springcloud-yi/003.png" alt></p><blockquote><p>进程内LB方案是一种分布式方案，LB和服务发现能力被分散到每一个服务消费者的进程内部，同时服务消费方和服务提供方之间是直接调用，没有额外开销，性能比较好。但是，该方案以客户库(Client Library)的方式集成到服务调用方进程里头，如果企业内有多种不同的语言栈，就要配合开发多种不同的客户端，有一定的研发和维护成本。另外，一旦客户端跟随服务调用方发布到生产环境中，后续如果要对客户库进行升级，势必要求服务调用方修改代码并重新发布，所以该方案的升级推广有不小的阻力。</p><p>进程内LB的案例是Netflix的开源服务框架，对应的组件分别是：Eureka服务注册表，Karyon服务端框架支持服务自注册和健康检查，Ribbon客户端框架支持服务自发现和软路由。另外，阿里开源的服务框架Dubbo也是采用类似机制。</p></blockquote><h5 id="主机独立LB进程方案"><a href="#主机独立LB进程方案" class="headerlink" title="主机独立LB进程方案"></a>主机独立LB进程方案</h5><blockquote><p>主机独立LB进程方案是针对第二种方案的不足而提出的一种折中方案，原理和第二种方案基本类似，不同之处是，他将LB和服务发现功能从进程内移出来，变成主机上的一个独立进程，主机上的一个或者多个服务要访问目标服务时，他们都通过同一主机上的独立LB进程做服务发现和负载均衡，见下图</p></blockquote><p><img src="//zongmansheng.club/2019/06/15/springcloud-yi/004.png" alt></p><blockquote><p>该方案也是一种分布式方案，没有单点问题，一个LB进程挂了只影响该主机上的服务调用方，服务调用方和LB之间是进程内调用，性能好，同时，该方案还简化了服务调用方，不需要为不同语言开发客户库，LB的升级不需要服务调用方改代码。该方案的不足是部署较复杂，环节多，出错调试排查问题不方便。</p><p>该方案的典型案例是Airbnb的SmartStack服务发现框架，对应组件分别是：Zookeeper作为服务注册表，Nerve独立进程负责服务注册和健康检查，Synapse/HAproxy独立进程负责服务发现和负载均衡。Google最新推出的基于容器的PaaS平台Kubernetes，其内部服务发现采用类似的机制。</p></blockquote><h4 id="服务前端路由"><a href="#服务前端路由" class="headerlink" title="服务前端路由"></a>服务前端路由</h4><blockquote><p>微服务除了内部相互之间调用和通信之外，最终要以某种方式暴露出去，才能让外界系统（例如客户的浏览器、移动设备等等）访问到，这就涉及服务的前端路由，对应的组件是服务网关(Service Gateway)，见下图，网关是连接企业内部和外部系统的一道门，有如下关键作用：</p><p>服务反向路由，网关要负责将外部请求反向路由到内部具体的微服务，这样虽然企业内部是复杂的分布式微服务结构，但是外部系统从网关上看到的就像是一个统一的完整服务，网关屏蔽了后台服务的复杂性，同时也屏蔽了后台服务的升级和变化。</p><p>安全认证和防爬虫，所有外部请求必须经过网关，网关可以集中对访问进行安全控制，比如用户认证和授权，同时还可以分析访问模式实现防爬虫功能，网关是连接企业内外系统的安全之门。</p><p>限流和容错，在流量高峰期，网关可以限制流量，保护后台系统不被大流量冲垮，在内部系统出现故障时，网关可以集中做容错，保持外部良好的用户体验。</p><p>监控，网关可以集中监控访问量，调用延迟，错误计数和访问模式，为后端的性能优化或者扩容提供数据支持。</p><p>日志，网关可以收集所有的访问日志，进入后台系统做进一步分析。</p></blockquote><p><img src="//zongmansheng.club/2019/06/15/springcloud-yi/005.png" alt></p><blockquote><p>除以上基本能力外，网关还可以实现线上引流，线上压测，线上调试(Surgical debugging)，金丝雀测试(Canary Testing)，数据中心双活(Active-Active HA)等高级功能。</p><p>网关通常工作在7层，有一定的计算逻辑，一般以集群方式部署，前置LB进行负载均衡。</p><p>开源的网关组件有Netflix的Zuul，特点是动态可热部署的过滤器(filter)机制，其它如HAproxy，Nginx等都可以扩展作为网关使用。</p><p>在介绍过服务注册表和网关等组件之后，我们可以通过一个简化的微服务架构图来更加直观地展示整个微服务体系内的服务注册发现和路由机制，该图假定采用进程内LB服务发现和负载均衡机制。在下图的微服务架构中，服务简化为两层，后端通用服务（也称中间层服务Middle Tier Service）和前端服务（也称边缘服务Edge Service，前端服务的作用是对后端服务做必要的聚合和裁剪后暴露给外部不同的设备，如PC，Pad或者Phone）。后端服务启动时会将地址信息注册到服务注册表，前端服务通过查询服务注册表就可以发现然后调用后端服务；前端服务启动时也会将地址信息注册到服务注册表，这样网关通过查询服务注册表就可以将请求路由到目标前端服务，这样整个微服务体系的服务自注册自发现和软路由就通过服务注册表和网关串联起来了。如果以面向对象设计模式的视角来看，网关类似Proxy代理或者Façade门面模式，而服务注册表和服务自注册自发现类似IoC依赖注入模式，微服务可以理解为基于网关代理和注册表IoC构建的分布式系统。</p></blockquote><p><img src="//zongmansheng.club/2019/06/15/springcloud-yi/006.png" alt></p><h4 id="服务容错"><a href="#服务容错" class="headerlink" title="服务容错"></a>服务容错</h4><blockquote><p>当企业微服务化以后，服务之间会有错综复杂的依赖关系，例如，一个前端请求一般会依赖于多个后端服务，技术上称为1 -&gt; N扇出(见下图1)。在实际生产环境中，服务往往不是百分百可靠，服务可能会出错或者产生延迟，如果一个应用不能对其依赖的故障进行容错和隔离，那么该应用本身就处在被拖垮的风险中。在一个高流量的网站中，某个单一后端一旦发生延迟，可能在数秒内导致所有应用资源(线程，队列等)被耗尽，造成所谓的雪崩效应(Cascading Failure，见下图2)，严重时可致整个网站瘫痪。</p><p>服务多依赖：</p></blockquote><p><img src="//zongmansheng.club/2019/06/15/springcloud-yi/007.png" alt></p><blockquote><p>高峰期单个服务延迟致雪崩效应：</p></blockquote><p><img src="//zongmansheng.club/2019/06/15/springcloud-yi/008.png" alt></p><blockquote><p>经过多年的探索和实践，业界在分布式服务容错一块探索出了一套有效的容错模式和最佳实践，主要包括：</p></blockquote><p><img src="//zongmansheng.club/2019/06/15/springcloud-yi/009.png" alt></p><blockquote><p>电路熔断器模式(Circuit Breaker Patten), 该模式的原理类似于家里的电路熔断器，如果家里的电路发生短路，熔断器能够主动熔断电路，以避免灾难性损失。在分布式系统中应用电路熔断器模式后，当目标服务慢或者大量超时，调用方能够主动熔断，以防止服务被进一步拖垮；如果情况又好转了，电路又能自动恢复，这就是所谓的弹性容错，系统有自恢复能力。上图是一个典型的具备弹性恢复能力的电路保护器状态图，正常状态下，电路处于关闭状态(Closed)，如果调用持续出错或者超时，电路被打开进入熔断状态(Open)，后续一段时间内的所有调用都会被拒绝(Fail Fast)，一段时间以后，保护器会尝试进入半熔断状态(Half-Open)，允许少量请求进来尝试，如果调用仍然失败，则回到熔断状态，如果调用成功，则回到电路闭合状态。</p><p>舱壁隔离模式(Bulkhead Isolation Pattern)，顾名思义，该模式像舱壁一样对资源或失败单元进行隔离，如果一个船舱破了进水，只损失一个船舱，其它船舱可以不受影响 。线程隔离(Thread Isolation)就是舱壁隔离模式的一个例子，假定一个应用程序A调用了Svc1/Svc2/Svc3三个服务，且部署A的容器一共有120个工作线程，采用线程隔离机制，可以给对Svc1/Svc2/Svc3的调用各分配40个线程，当Svc2慢了，给Svc2分配的40个线程因慢而阻塞并最终耗尽，线程隔离可以保证给Svc1/Svc3分配的80个线程可以不受影响，如果没有这种隔离机制，当Svc2慢的时候，120个工作线程会很快全部被对Svc2的调用吃光，整个应用程序会全部慢下来。</p><p>限流(Rate Limiting/Load Shedder)，服务总有容量限制，没有限流机制的服务很容易在突发流量(秒杀，双十一)时被冲垮。限流通常指对服务限定并发访问量，比如单位时间只允许100个并发调用，对超过这个限制的请求要拒绝并回退。</p><p>回退(fallback)，在熔断或者限流发生的时候，应用程序的后续处理逻辑是什么？回退是系统的弹性恢复能力，常见的处理策略有，直接抛出异常，也称快速失败(Fail Fast)，也可以返回空值或缺省值，还可以返回备份数据，如果主服务熔断了，可以从备份服务获取数据。</p><p>Netflix将上述容错模式和最佳实践集成到一个称为Hystrix的开源组件中，凡是需要容错的依赖点(服务，缓存，数据库访问等)，开发人员只需要将调用封装在Hystrix Command里头，则相关调用就自动置于Hystrix的弹性容错保护之下。Hystrix组件已经在Netflix经过多年运维验证，是Netflix微服务平台稳定性和弹性的基石，正逐渐被社区接受为标准容错组件。</p></blockquote><h4 id="服务框架"><a href="#服务框架" class="headerlink" title="服务框架"></a>服务框架</h4><blockquote><p>微服务化以后，为了让业务开发人员专注于业务逻辑实现，避免冗余和重复劳动，规范研发提升效率，必然要将一些公共关注点推到框架层面。下图服务框架主要封装公共关注点逻辑，包括：</p></blockquote><p><img src="//zongmansheng.club/2019/06/15/springcloud-yi/010.png" alt></p><blockquote><p>服务注册、发现、负载均衡和健康检查，假定采用进程内LB方案，那么服务自注册一般统一做在服务器端框架中，健康检查逻辑由具体业务服务定制，框架层提供调用健康检查逻辑的机制，服务发现和负载均衡则集成在服务客户端框架中。</p><p>监控日志，框架一方面要记录重要的框架层日志、metrics和调用链数据，还要将日志、metrics等接口暴露出来，让业务层能根据需要记录业务日志数据。在运行环境中，所有日志数据一般集中落地到企业后台日志系统，做进一步分析和处理。</p><p>REST/RPC和序列化，框架层要支持将业务逻辑以HTTP/REST或者RPC方式暴露出来，HTTP/REST是当前主流API暴露方式，在性能要求高的场合则可采用Binary/RPC方式。针对当前多样化的设备类型(浏览器、普通PC、无线设备等)，框架层要支持可定制的序列化机制，例如，对浏览器，框架支持输出Ajax友好的JSON消息格式，而对无线设备上的Native App，框架支持输出性能高的Binary消息格式。</p><p>配置，除了支持普通配置文件方式的配置，框架层还可集成动态运行时配置，能够在运行时针对不同环境动态调整服务的参数和配置。</p><p>限流和容错，框架集成限流容错组件，能够在运行时自动限流和容错，保护服务，如果进一步和动态配置相结合，还可以实现动态限流和熔断。</p><p>管理接口，框架集成管理接口，一方面可以在线查看框架和服务内部状态，同时还可以动态调整内部状态，对调试、监控和管理能提供快速反馈。Spring Boot微框架的Actuator模块就是一个强大的管理接口。</p><p>统一错误处理，对于框架层和服务的内部异常，如果框架层能够统一处理并记录日志，对服务监控和快速问题定位有很大帮助。</p><p>安全，安全和访问控制逻辑可以在框架层统一进行封装，可做成插件形式，具体业务服务根据需要加载相关安全插件。</p><p>文档自动生成，文档的书写和同步一直是一个痛点，框架层如果能支持文档的自动生成和同步，会给使用API的开发和测试人员带来极大便利。Swagger是一种流行Restful API的文档方案。</p><p>当前业界比较成熟的微服务框架有Netflix的Karyon/Ribbon，Spring的Spring Boot/Cloud，阿里的Dubbo等。</p><p><strong>运行期配置管理</strong></p><p>服务一般有很多依赖配置，例如访问数据库有连接字符串配置，连接池大小和连接超时配置，这些配置在不同环境(开发/测试/生产)一般不同，比如生产环境需要配连接池，而开发测试环境可能不配，另外有些参数配置在运行期可能还要动态调整，例如，运行时根据流量状况动态调整限流和熔断阀值。目前比较常见的做法是搭建一个运行时配置中心支持微服务的动态配置，简化架构如下图</p></blockquote><p><img src="//zongmansheng.club/2019/06/15/springcloud-yi/011.png" alt></p><blockquote><p>动态配置存放在集中的配置服务器上，用户通过管理界面配置和调整服务配置，具体服务通过定期拉(Scheduled Pull)的方式或者服务器推(Server-side Push)的方式更新动态配置，拉方式比较可靠，但会有延迟同时有无效网络开销(假设配置不常更新)，服务器推方式能及时更新配置，但是实现较复杂，一般在服务和配置服务器之间要建立长连接。配置中心还要解决配置的版本控制和审计问题，对于大规模服务化环境，配置中心还要考虑分布式和高可用问题。</p><p>配置中心比较成熟的开源方案有百度的Disconf，360的QConf，Spring的Cloud Config和阿里的Diamond等。</p><p><strong>Netflix的微服务框架</strong></p><p>Netflix是一家成功实践微服务架构的互联网公司，几年前，Netflix就把它的几乎整个微服务框架栈开源贡献给了社区，这些框架和组件包括：</p><p>Eureka:　服务注册发现框架</p><p>Zuul:　服务网关</p><p>Karyon:　服务端框架</p><p>Ribbon:　客户端框架</p><p>Hystrix: 服务容错组件</p><p>Archaius: 服务配置组件</p><p>Servo: Metrics组件</p><p>Blitz4j: 日志组件</p><p>下图展示了基于这些组件构建的一个微服务框架体系，来自recipes-rss。</p></blockquote><p><img src="//zongmansheng.club/2019/06/15/springcloud-yi/012.png" alt></p><blockquote><p>Netflix的开源框架组件已经在Netflix的大规模分布式微服务环境中经过多年的生产实战验证，正逐步被社区接受为构造微服务框架的标准组件。Pivotal去年推出的Spring Cloud开源产品，主要是基于对Netflix开源组件的进一步封装，方便Spring开发人员构建微服务基础框架。对于一些打算构建微服务框架体系的公司来说，充分利用或参考借鉴Netflix的开源微服务组件(或Spring Cloud)，在此基础上进行必要的企业定制，无疑是通向微服务架构的捷径。</p><p><strong>Spring Cloud</strong></p><p>Spring Cloud为开发人员提供了快速构建分布式系统中一些常见模式的工具（例如配置管理，服务发现注册、微代理、消息总线、负载均衡、断路器、数据监控等）。分布式系统的协调导致了样板模式, 使用Spring Cloud开发人员可以快速地支持实现这些模式的服务和应用程序。他们将在任何分布式环境中运行良好，包括开发人员自己的笔记本电脑，裸机数据中心，以及Cloud Foundry等托管平台。</p><p><strong>大道至简的分布式系统</strong></p><p>协调一切: 大道至简的分布式系统</p></blockquote><p><img src="//zongmansheng.club/2019/06/15/springcloud-yi/013.png" alt></p><blockquote><p>构建分布式系统不需要复杂和容易出错。Spring Cloud为最常见的分布式系统模式提供了一个简单易访问的编程模型，帮助开发人员构建有弹性、可靠和协调的应用程序. Spring Cloud 是建立在Spring Boot之上使得开发者很容易开始和快速生产。</p><p><strong>特性</strong></p><p>Spring Cloud专注于提供良好的开箱即用经验的典型用例和可扩展性机制覆盖。</p><p>分布式/版本化配置</p><p>服务注册和发现</p><p>路由</p><p>service - to - service调用</p><p>负载均衡</p><p>断路器</p><p>分布式消息传递</p></blockquote><h4 id="SpringCloud-家族"><a href="#SpringCloud-家族" class="headerlink" title="SpringCloud 家族"></a>SpringCloud 家族</h4><p><img src="//zongmansheng.club/2019/06/15/springcloud-yi/014.png" alt></p><p><img src="//zongmansheng.club/2019/06/15/springcloud-yi/015.png" alt></p><h4 id="Spring-Cloud-Netflix"><a href="#Spring-Cloud-Netflix" class="headerlink" title="Spring Cloud Netflix"></a><img src="//zongmansheng.club/2019/06/15/springcloud-yi/016.png" alt><strong>Spring Cloud Netflix</strong></h4><blockquote><p>Spring Cloud Netflix 为Spring Boot 应用程序利用autoconfiguration绑定Spring上下文环境的方式或者其他的Spring系程序提供了 Netflix OSS 集成 。通过一些简单的注解，我们可以快速的在我们的应用程序内部启用和配置常用属性从而利用强悍的Netflix 组件构建我的分布式系统。 Netflix提供的组件包括服务发现（Eureka）、断路器（Hystrix）、智能路由（Zuul）和客户端负载平衡（Ribbon）。</p></blockquote><h4 id="Spring-Cloud-Netflix-特征"><a href="#Spring-Cloud-Netflix-特征" class="headerlink" title="Spring Cloud Netflix 特征:"></a>Spring Cloud Netflix 特征:</h4><blockquote><p>服务发现: Eureka 实例会被注册并且客户端可以通过Spring托管的beans发现Eureka 实例。</p><p>服务发现: 内嵌的 Eureka server 使用简单的Java申明式注解实现。</p><p>断路器: Hystrix 客户端可以使用一些简单注解装饰实现。</p><p>断路器: 内嵌的 Hystrix 控制台使用简单的Java申明式注解实现。</p><p>声明性REST客户端: Feign 用JAX-RS或Spring MVC注解创建可以实现的动态接口。</p><p>客户端负载均衡 ：Ribbon</p><p>外部配置: Spring 环境 和 Archaius (使用Spring Boot约定启用Netflix组件的本地配置)的桥梁。</p><p>路由器和过滤器: Zuul过滤器的自动重新定位，以及反向代理创建的配置方法上的简单约定。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SpringCloud（一）&quot;&gt;&lt;a href=&quot;#SpringCloud（一）&quot; class=&quot;headerlink&quot; title=&quot;SpringCloud（一）&quot;&gt;&lt;/a&gt;SpringCloud（一）&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;//zongmanshe
      
    
    </summary>
    
      <category term="springcloud" scheme="http://zongmansheng.club/categories/springcloud/"/>
    
    
      <category term="springcloud" scheme="http://zongmansheng.club/tags/springcloud/"/>
    
  </entry>
  
  <entry>
    <title>MySQL——存储引擎</title>
    <link href="http://zongmansheng.club/2019/06/14/mysql-cun-chu-yin-qing/"/>
    <id>http://zongmansheng.club/2019/06/14/mysql-cun-chu-yin-qing/</id>
    <published>2019-06-14T00:29:39.000Z</published>
    <updated>2019-07-04T13:59:38.052Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL——存储引擎"><a href="#MySQL——存储引擎" class="headerlink" title="MySQL——存储引擎"></a>MySQL——存储引擎</h1><blockquote><pre><code>MySQL中的数据用不同的技术存储在文件或内存中。每一种技术都有自己不同的存储机制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力。选择不同的技术，你能够得到不同的速度或功能，从而改善你的应用的整体功能。这些技术以及配套的相关功能在MySQL中被称作存储引擎。</code></pre></blockquote><h4 id="存储引擎作用"><a href="#存储引擎作用" class="headerlink" title="存储引擎作用"></a>存储引擎作用</h4><blockquote><p>存储引擎说白了就是如何存储数据、如何为存储的数据建立索引和如何更新、查询数据等技术的实现方法。</p><p>因为在关系数据库中数据的存储是以表的形式存储的，所以存储引擎也可以称为表类型（即存储和操作此表的类型）。</p></blockquote><h4 id="存储引擎类型"><a href="#存储引擎类型" class="headerlink" title="存储引擎类型"></a>存储引擎类型</h4><blockquote><p>通过命令可以查看支持的引擎列表</p><p>show engines;</p></blockquote><p><img src="/Volumes/work/hexo/source/_posts/MySQL——存储引擎/001.png" alt></p><h4 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a>InnoDB存储引擎</h4><blockquote><p>InnoDB是MySQL的默认事务型引擎，它被设计用来处理大量的短期(short-lived)事务。除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎。</p><p>InnoDB采用MVCC来支持高并发，并且实现了四个标准的隔离级别。其默认级别是REPEATABLE READ(可重复读)，并且通过间隙锁(next-key locking)策略防止幻读的出现。</p><p>InnoDB是基于聚簇索引建立的，聚簇索引对主键查询有很高的性能。不过它的二级索引(secondary index，非主键索引)中必须包含主键列，所以如果主键列很大的话，其他的所有索引都会很大。因此表上的索引较多的话，主键应当尽可能的小。</p><p>InnoDB的存储格式是平台独立的，可以将数据和索引文件从Intel平台复制到Sun SPARC平台或其他平台。</p><p>InnoDB通过一些机制和工具支持真正的热备份，MySQL的其他存储引擎不支持热备份。</p></blockquote><h4 id="MyISAM存储引擎"><a href="#MyISAM存储引擎" class="headerlink" title="MyISAM存储引擎"></a>MyISAM存储引擎</h4><blockquote><p>MyISAM提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但MyISAM不支持事务和行级锁，有一个毫无疑问的缺陷就是崩溃后无法安全恢复。</p><p>MyISAM会将表存储在两个文件在中：数据文件和索引文件，分别是.MYD和.MYI为扩展名。</p><p>在MySQL5.0以前，只能处理4G的数据，5.0中可以处理256T的数据。</p><p>在数据不再进行修改操作时，可以对MyISAM表进行压缩，压缩后可以提高读能力，原因是减少了磁盘I/O。</p></blockquote><h4 id="Archive引擎"><a href="#Archive引擎" class="headerlink" title="Archive引擎"></a>Archive引擎</h4><blockquote><p>Archive存储引擎只支持INSERT和SELECT操作，在MySQL5.1之前不支持索引。</p><p>Archive表适合日志和数据采集类应用。</p><p>Archive引擎支持行级锁和专用的缓存区，所以可以实现高并发的插入，但它不是一个事物型的引擎，而是一个针对高速插入和压缩做了优化的简单引擎。</p></blockquote><h4 id="Blackhole引擎"><a href="#Blackhole引擎" class="headerlink" title="Blackhole引擎"></a>Blackhole引擎</h4><blockquote><p>Blackhole引擎没有实现任何存储机制，它会丢弃所有插入的数据，不做任何保存。但服务器会记录Blackhole表的日志，所以可以用于复制数据到备库，或者简单地记录到日志。但这种应用方式会碰到很多问题，因此并不推荐。</p></blockquote><h4 id="CSV引擎"><a href="#CSV引擎" class="headerlink" title="CSV引擎"></a>CSV引擎</h4><blockquote><p>CSV引擎可以将普通的SCV文件作为MySQL的表来处理，但不支持索引。</p><p>CSV引擎可以作为一种数据交换的机制，非常有用。</p></blockquote><h4 id="Federated引擎"><a href="#Federated引擎" class="headerlink" title="Federated引擎"></a>Federated引擎</h4><blockquote><p>Federated引擎是访问其他MySQL服务器的一个代理，尽管该引擎看起来提供了一种很好的跨服务器的灵活性，但也经常带来问题，因此默认是禁用的。</p></blockquote><h4 id="Memory引擎"><a href="#Memory引擎" class="headerlink" title="Memory引擎"></a>Memory引擎</h4><blockquote><p>如果需要快速地访问数据，并且这些数据不会被修改，重启以后丢失也没有关系，那么使用Memory表是非常有用。Memory表至少比MyISAM表要快一个数量级。</p><p>Memory表是表级锁，因此并发写入的性能较低。它不支持BLOB或TEXT类型的列，并且每行的长度是固定的，这可能呆滞部分内存的浪费。</p><p>临时表和Memory表不是一回事。临时表是指使用CREATE TEMPORARY TABLE语句创建的表，它可以使用任何存储引擎，只在单个连接中可见，当连接断开时，临时表也将不复存在。</p></blockquote><h4 id="MRG-MYISAM-MERGE-引擎"><a href="#MRG-MYISAM-MERGE-引擎" class="headerlink" title="MRG_MYISAM(MERGE)引擎"></a>MRG_MYISAM(MERGE)引擎</h4><blockquote><p>MERGE存储引擎是一组MyISAM表的组合，这些MyISAM表结构必须完全相同，尽管其使用不如其它引擎突出，但是在某些情况下非常有用。说白了，Merge表就是几个相同MyISAM表的聚合器；Merge表中并没有数据，对Merge类型的表可以进行查询、更新、删除操作，这些操作实际上是对内部的MyISAM表进行操作。</p></blockquote><h4 id="PERFORMANCE-SCHEMA"><a href="#PERFORMANCE-SCHEMA" class="headerlink" title="PERFORMANCE_SCHEMA"></a>PERFORMANCE_SCHEMA</h4><blockquote><p>主要用于收集数据库服务器性能参数。</p><p>MySQL用户是不能创建存储引擎为PERFORMANCE_SCHEMA的表，一般用于记录binlog做复制的中继。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL——存储引擎&quot;&gt;&lt;a href=&quot;#MySQL——存储引擎&quot; class=&quot;headerlink&quot; title=&quot;MySQL——存储引擎&quot;&gt;&lt;/a&gt;MySQL——存储引擎&lt;/h1&gt;&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;MySQL中的数据用不同的
      
    
    </summary>
    
      <category term="数据库" scheme="http://zongmansheng.club/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySql" scheme="http://zongmansheng.club/tags/MySql/"/>
    
      <category term="存储引擎" scheme="http://zongmansheng.club/tags/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://zongmansheng.club/2019/06/09/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/"/>
    <id>http://zongmansheng.club/2019/06/09/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/</id>
    <published>2019-06-09T14:21:10.521Z</published>
    <updated>2019-07-04T00:31:49.897Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL事务及ACID特性的实现原理"><a href="#MySQL事务及ACID特性的实现原理" class="headerlink" title="MySQL事务及ACID特性的实现原理"></a>MySQL事务及ACID特性的实现原理</h1><h4 id="一、MySQL-事务基础概念"><a href="#一、MySQL-事务基础概念" class="headerlink" title="一、MySQL 事务基础概念"></a>一、MySQL 事务基础概念</h4><blockquote><p>​    事务(Transaction)是访问和更新数据库的程序执行单元;事务中可能包含一个或多个 sql 语句，这些语句要么都执行，要么都不执行。</p></blockquote><blockquote><p>​    作为一个关系型数据库，MySQL 支持事务，本文介绍基于 MySQL 5.6。首先回顾一下 MySQL 事务的基础知识。</p></blockquote><h4 id="二、逻辑架构和存储引擎"><a href="#二、逻辑架构和存储引擎" class="headerlink" title="二、逻辑架构和存储引擎"></a>二、逻辑架构和存储引擎</h4><p><img src="//zongmansheng.club/2019/06/09/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/001.jpg" alt="001"></p><blockquote><p>如上图所示，MySQL 服务器逻辑架构从上往下可以分为三层：</p></blockquote><p>++++</p><ul><li>第一层：处理客户端连接、授权认证等。</li><li>第二层：服务器层，负责查询语句的解析、优化、缓存以及内置函数的实现、存储过程等。</li><li>第三层：存储引擎，负责 MySQL 中数据的存储和提取。MySQL 中服务器层不管理事务，事务是由存储引擎实现的。</li></ul><blockquote><p>MySQL 支持事务的存储引擎有 InnoDB、NDB Cluster 等，其中 InnoDB 的使用最为广泛;其他存储引擎不支持事务，如 MyIsam、Memory 等。</p></blockquote><blockquote><p>如无特殊说明，后文中描述的内容都是基于 InnoDB。</p></blockquote><h4 id="三、提交和回滚"><a href="#三、提交和回滚" class="headerlink" title="三、提交和回滚"></a>三、提交和回滚</h4><blockquote><p>典型的 MySQL 事务是如下操作的：</p></blockquote><pre class=" language-java"><code class="language-java">start transaction<span class="token punctuation">;</span> …… #一条或多条sql语句 commit<span class="token punctuation">;</span> </code></pre><blockquote><p>其中 start transaction 标识事务开始，commit 提交事务，将执行结果写入到数据库。</p></blockquote><blockquote><p>如果 sql 语句执行出现问题，会调用 rollback，回滚所有已经执行成功的 sql 语句。当然，也可以在事务中直接使用 rollback 语句进行回滚。</p></blockquote><h4 id="四、自动提交"><a href="#四、自动提交" class="headerlink" title="四、自动提交"></a>四、自动提交</h4><blockquote><p>MySQL 中默认采用的是自动提交(autocommit)模式，如下所示：</p></blockquote><p><img src="//zongmansheng.club/2019/06/09/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/002.jpg" alt="002"></p><blockquote><p>在自动提交模式下，如果没有 start transaction 显式地开始一个事务，那么每个 sql 语句都会被当做一个事务执行提交操作。</p></blockquote><blockquote><p>通过如下方式，可以关闭 autocommit;需要注意的是，autocommit 参数是针对连接的，在一个连接中修改了参数，不会对其他连接产生影响。</p></blockquote><blockquote><p><img src="//zongmansheng.club/2019/06/09/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/003.jpg" alt="003"></p></blockquote><blockquote><p>如果关闭了 autocommit，则所有的 sql 语句都在一个事务中，直到执行了 commit 或 rollback，该事务结束，同时开始了另外一个事务。</p></blockquote><h4 id="五、特殊操作"><a href="#五、特殊操作" class="headerlink" title="五、特殊操作"></a>五、特殊操作</h4><blockquote><p>在 MySQL 中，存在一些特殊的命令，如果在事务中执行了这些命令，会马上强制执行 commit 提交事务;如 DDL 语句(create table/drop table/alter/table)、lock tables 语句等等。</p></blockquote><blockquote><p>不过，常用的 select、insert、update 和 delete 命令，都不会强制提交事务。</p></blockquote><h4 id="六、ACID-特性"><a href="#六、ACID-特性" class="headerlink" title="六、ACID 特性"></a>六、ACID 特性</h4><blockquote><p>ACID 是衡量事务的四个特性：</p></blockquote><ul><li><strong>原子性(Atomicity，或称不可分割性)</strong></li><li><strong>一致性(Consistency)</strong></li><li><strong>隔离性(Isolation)</strong></li><li><strong>持久性(Durability)</strong></li></ul><blockquote><p>按照严格的标准，只有同时满足 ACID 特性才是事务;但是在各大数据库厂商的实现中，真正满足 ACID 的事务少之又少。</p></blockquote><blockquote><p>例如 MySQL 的 NDB Cluster 事务不满足持久性和隔离性;InnoDB 默认事务隔离级别是可重复读，不满足隔离性;Oracle 默认的事务隔离级别为 READ COMMITTED，不满足隔离性……</p></blockquote><blockquote><p>因此与其说 ACID 是事务必须满足的条件，不如说它们是衡量事务的四个维度。</p></blockquote><blockquote><p>下面将详细介绍 ACID 特性及其实现原理，为了便于理解，介绍的顺序不是严格按照 A-C-I-D。</p></blockquote><h4 id="七、ACID-特性及其实现原理"><a href="#七、ACID-特性及其实现原理" class="headerlink" title="七、ACID 特性及其实现原理"></a>七、ACID 特性及其实现原理</h4><h5 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a><strong>原子性</strong></h5><p><strong>定义</strong></p><blockquote><p>原子性是指一个事务是一个不可分割的工作单位，其中的操作要么都做，要么都不做。</p></blockquote><blockquote><p>如果事务中一个 sql 语句执行失败，则已执行的语句也必须回滚，数据库退回到事务前的状态。</p></blockquote><p><strong>实现原理：undo log</strong></p><blockquote><p>在说明原子性原理之前，首先介绍一下 MySQL 的事务日志。MySQL 的日志有很多种，如二进制日志、错误日志、查询日志、慢查询日志等。</p></blockquote><blockquote><p>此外 InnoDB 存储引擎还提供了两种事务日志：</p></blockquote><ul><li><strong>redo log(重做日志)</strong></li><li><strong>undo log(回滚日志)</strong></li></ul><blockquote><p>其中 redo log 用于保证事务持久性;undo log 则是事务原子性和隔离性实现的基础。</p></blockquote><blockquote><p>下面说回 undo log。实现原子性的关键，是当事务回滚时能够撤销所有已经成功执行的 sql 语句。</p></blockquote><blockquote><p>InnoDB 实现回滚，靠的是 undo log：</p></blockquote><ul><li>当事务对数据库进行修改时，InnoDB 会生成对应的 undo log。</li><li>如果事务执行失败或调用了 rollback，导致事务需要回滚，便可以利用 undo log 中的信息将数据回滚到修改之前的样子。</li></ul><blockquote><p>undo log 属于逻辑日志，它记录的是 sql 执行相关的信息。当发生回滚时，InnoDB 会根据 undo log 的内容做与之前相反的工作：</p></blockquote><ul><li>对于每个 insert，回滚时会执行 delete。</li><li>对于每个 delete，回滚时会执行 insert。</li><li>对于每个 update，回滚时会执行一个相反的 update，把数据改回去。</li></ul><blockquote><p>以 update 操作为例：当事务执行 update 时，其生成的 undo log 中会包含被修改行的主键(以便知道修改了哪些行)、修改了哪些列、这些列在修改前后的值等信息，回滚时便可以使用这些信息将数据还原到 update 之前的状态。</p></blockquote><h5 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a><strong>持久性</strong></h5><p><strong>定义</strong></p><blockquote><p>持久性是指事务一旦提交，它对数据库的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。</p></blockquote><p><strong>实现原理：redo log</strong></p><blockquote><p>redo log 和 undo log 都属于 InnoDB 的事务日志。下面先聊一下 redo log 存在的背景。</p></blockquote><blockquote><p>InnoDB 作为 MySQL 的存储引擎，数据是存放在磁盘中的，但如果每次读写数据都需要磁盘 IO，效率会很低。</p></blockquote><blockquote><p>为此，InnoDB 提供了缓存(Buffer Pool)，Buffer Pool 中包含了磁盘中部分数据页的映射，作为访问数据库的缓冲：</p></blockquote><ul><li>当从数据库读取数据时，会首先从 Buffer Pool 中读取，如果 Buffer Pool 中没有，则从磁盘读取后放入 Buffer Pool。</li><li>当向数据库写入数据时，会首先写入 Buffer Pool，Buffer Pool 中修改的数据会定期刷新到磁盘中(这一过程称为刷脏)。</li></ul><blockquote><p>Buffer Pool 的使用大大提高了读写数据的效率，但是也带来了新的问题：如果 MySQL 宕机，而此时 Buffer Pool 中修改的数据还没有刷新到磁盘，就会导致数据的丢失，事务的持久性无法保证。</p></blockquote><blockquote><p>于是，redo log 被引入来解决这个问题：当数据修改时，除了修改 Buffer Pool 中的数据，还会在 redo log 记录这次操作;当事务提交时，会调用 fsync 接口对 redo log 进行刷盘。</p></blockquote><blockquote><p>如果 MySQL 宕机，重启时可以读取 redo log 中的数据，对数据库进行恢复。</p></blockquote><blockquote><p>redo log 采用的是 WAL(Write-ahead logging，预写式日志)，所有修改先写入日志，再更新到 Buffer Pool，保证了数据不会因 MySQL 宕机而丢失，从而满足了持久性要求。</p></blockquote><blockquote><p>既然 redo log 也需要在事务提交时将日志写入磁盘，为什么它比直接将 Buffer Pool 中修改的数据写入磁盘(即刷脏)要快呢?</p></blockquote><blockquote><p>主要有以下两方面的原因：</p></blockquote><ul><li>刷脏是随机 IO，因为每次修改的数据位置随机，但写 redo log 是追加操作，属于顺序 IO。</li><li>刷脏是以数据页(Page)为单位的，MySQL 默认页大小是 16KB，一个 Page 上一个小修改都要整页写入;而 redo log 中只包含真正需要写入的部分，无效 IO 大大减少。</li></ul><p><strong>redo log 与 binlog</strong></p><blockquote><p>我们知道，在 MySQL 中还存在 binlog(二进制日志)也可以记录写操作并用于数据的恢复，但二者是有着根本的不同的。</p></blockquote><blockquote><p>作用不同：</p></blockquote><ul><li>redo log 是用于 crash recovery 的，保证 MySQL 宕机也不会影响持久性;</li><li>binlog 是用于 point-in-time recovery 的，保证服务器可以基于时间点恢复数据，此外 binlog 还用于主从复制。</li></ul><blockquote><p>层次不同：</p></blockquote><ul><li>redo log 是 InnoDB 存储引擎实现的，</li><li>而 binlog 是 MySQL 的服务器层(可以参考文章前面对 MySQL 逻辑架构的介绍)实现的，同时支持 InnoDB 和其他存储引擎。</li></ul><blockquote><p>内容不同：</p></blockquote><ul><li>redo log 是物理日志，内容基于磁盘的 Page。</li><li>binlog 是逻辑日志，内容是一条条 sql。</li></ul><blockquote><p>写入时机不同：</p></blockquote><ul><li>redo log 的写入时机相对多元。前面曾提到，当事务提交时会调用 fsync 对 redo log 进行刷盘;这是默认情况下的策略，修改 innodb_flush_log_at_trx_commit 参数可以改变该策略，但事务的持久性将无法保证。</li></ul><blockquote><p>除了事务提交时，还有其他刷盘时机：如 master thread 每秒刷盘一次 redo log 等，这样的好处是不一定要等到 commit 时刷盘，commit 速度大大加快。</p></blockquote><ul><li>binlog 在事务提交时写入。</li></ul><h5 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a><strong>隔离性</strong></h5><p><strong>定义</strong></p><blockquote><p>与原子性、持久性侧重于研究事务本身不同，隔离性研究的是不同事务之间的相互影响。</p></blockquote><blockquote><p>隔离性是指事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p></blockquote><blockquote><p>严格的隔离性，对应了事务隔离级别中的 Serializable(可串行化)，但实际应用中出于性能方面的考虑很少会使用可串行化。</p></blockquote><blockquote><p>隔离性追求的是并发情形下事务之间互不干扰。简单起见，我们仅考虑最简单的读操作和写操作(暂时不考虑带锁读等特殊操作)。</p></blockquote><blockquote><p>那么隔离性的探讨，主要可以分为两个方面：</p></blockquote><ul><li>(一个事务)写操作对(另一个事务)写操作的影响：锁机制保证隔离性。</li><li>(一个事务)写操作对(另一个事务)读操作的影响：MVCC 保证隔离性。</li></ul><h5 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a><strong>锁机制</strong></h5><blockquote><p>首先来看两个事务的写操作之间的相互影响。隔离性要求同一时刻只能有一个事务对数据进行写操作，InnoDB 通过锁机制来保证这一点。</p></blockquote><blockquote><p>锁机制的基本原理可以概括为：</p></blockquote><ul><li>事务在修改数据之前，需要先获得相应的锁。</li><li>获得锁之后，事务便可以修改数据。</li><li>该事务操作期间，这部分数据是锁定的，其他事务如果需要修改数据，需要等待当前事务提交或回滚后释放锁。</li></ul><blockquote><p>行锁与表锁：按照粒度，锁可以分为表锁、行锁以及其他位于二者之间的锁。</p></blockquote><blockquote><p>表锁在操作数据时会锁定整张表，并发性能较差;行锁则只锁定需要操作的数据，并发性能好。</p></blockquote><blockquote><p>但是由于加锁本身需要消耗资源(获得锁、检查锁、释放锁等都需要消耗资源)，因此在锁定数据较多情况下使用表锁可以节省大量资源。</p></blockquote><blockquote><p>MySQL 中不同的存储引擎支持的锁是不一样的，例如 MyIsam 只支持表锁，而 InnoDB 同时支持表锁和行锁，且出于性能考虑，绝大多数情况下使用的都是行锁。</p></blockquote><blockquote><p>如何查看锁信息?有多种方法可以查看 InnoDB 中锁的情况，例如：</p></blockquote><pre class=" language-mysql"><code class="language-mysql">select * from information_schema.innodb_locks; #锁的概况 show engine innodb status; #InnoDB整体状态，其中包括锁的情况 </code></pre><p>下面来看一个例子：</p><pre class=" language-mysql"><code class="language-mysql">#在事务A中执行： start transaction; update account SET balance = 1000 where id = 1; 在事务B中执行： start transaction; update account SET balance = 2000 where id = 1; </code></pre><p>此时查看锁的情况：</p><p><img src="//zongmansheng.club/2019/06/09/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/004.jpg" alt="004"></p><p>show engine innodb status 查看锁相关的部分：</p><p><img src="//zongmansheng.club/2019/06/09/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/005.jpg" alt="005"></p><blockquote><p>通过上述命令可以查看事务 24052 和 24053 占用锁的情况;其中 lock_type 为 RECORD，代表锁为行锁(记录锁);lock_mode 为 X，代表排它锁(写锁)。</p></blockquote><blockquote><p>除了排它锁(写锁)之外，MySQL 中还有共享锁(读锁)的概念。由于本文重点是 MySQL 事务的实现原理，因此对锁的介绍到此为止。</p></blockquote><blockquote><p>介绍完写操作之间的相互影响，下面讨论写操作对读操作的影响。</p></blockquote><h5 id="脏读、不可重复读和幻读"><a href="#脏读、不可重复读和幻读" class="headerlink" title="脏读、不可重复读和幻读"></a><strong>脏读、不可重复读和幻读</strong></h5><blockquote><p>首先来看并发情况下，读操作可能存在的三类问题。</p></blockquote><blockquote><p>①脏读：当前事务(A)中可以读到其他事务(B)未提交的数据(脏数据)，这种现象是脏读。</p></blockquote><p>举例如下(以账户余额表为例)：</p><p><img src="//zongmansheng.club/2019/06/09/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/006.jpg" alt="006"></p><blockquote><p>②不可重复读：在事务 A 中先后两次读取同一个数据，两次读取的结果不一样，这种现象称为不可重复读。</p></blockquote><blockquote><p>脏读与不可重复读的区别在于：前者读到的是其他事务未提交的数据，后者读到的是其他事务已提交的数据。</p></blockquote><p>举例如下：</p><p><img src="//zongmansheng.club/2019/06/09/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/007.jpg" alt="007"></p><blockquote><p>③幻读：在事务 A 中按照某个条件先后两次查询数据库，两次查询结果的条数不同，这种现象称为幻读。</p></blockquote><blockquote><p>不可重复读与幻读的区别可以通俗的理解为：前者是数据变了，后者是数据的行数变了。</p></blockquote><p>举例如下：</p><p><img src="//zongmansheng.club/2019/06/09/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/008.jpg" alt="008"></p><h5 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a><strong>事务隔离级别</strong></h5><blockquote><p>sql 标准中定义了四种隔离级别，并规定了每种隔离级别下上述几个问题是否存在。</p></blockquote><blockquote><p>一般来说，隔离级别越低，系统开销越低，可支持的并发越高，但隔离性也越差。</p></blockquote><blockquote><p>隔离级别与读问题的关系如下：</p></blockquote><p><img src="//zongmansheng.club/2019/06/09/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/009.jpg" alt="009"></p><blockquote><p>在实际应用中，读未提交在并发时会导致很多问题，而性能相对于其他隔离级别提高却很有限，因此使用较少。</p></blockquote><blockquote><p>可串行化强制事务串行，并发效率很低，只有当对数据一致性要求极高且可以接受没有并发时使用，因此使用也较少。</p></blockquote><blockquote><p>因此在大多数数据库系统中，默认的隔离级别是读已提交(如 Oracle)或可重复读(后文简称 RR)。</p></blockquote><blockquote><p>可以通过如下两个命令分别查看全局隔离级别和本次会话的隔离级别：</p></blockquote><p><img src="//zongmansheng.club/2019/06/09/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/010.jpg" alt="010"></p><h4 id="八、MVCC"><a href="#八、MVCC" class="headerlink" title="八、MVCC"></a>八、MVCC</h4><blockquote><p>RR 解决脏读、不可重复读、幻读等问题，使用的是 MVCC：MVCC 全称 Multi-Version Concurrency Control，即多版本的并发控制协议。</p></blockquote><blockquote><p>下面的例子很好的体现了 MVCC 的特点：在同一时刻，不同的事务读取到的数据可能是不同的(即多版本)——在 T5 时刻，事务 A 和事务 C 可以读取到不同版本的数据。</p></blockquote><p><img src="//zongmansheng.club/2019/06/09/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/011.jpg" alt="011"></p><blockquote><p>MVCC 最大的优点是读不加锁，因此读写不冲突，并发性能好。InnoDB 实现 MVCC，多个版本的数据可以共存，主要是依靠数据的隐藏列(也可以称之为标记位)和 undo log。</p></blockquote><blockquote><p>其中数据的隐藏列包括了该行数据的版本号、删除时间、指向 undo log 的指针等等。</p></blockquote><blockquote><p>当读取数据时，MySQL 可以通过隐藏列判断是否需要回滚并找到回滚需要的 undo log，从而实现 MVCC;隐藏列的详细格式不再展开。</p></blockquote><blockquote><p>下面结合前文提到的几个问题分别说明。</p></blockquote><h5 id="①脏读"><a href="#①脏读" class="headerlink" title="①脏读"></a><strong>①脏读</strong></h5><p><img src="//zongmansheng.club/2019/06/09/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/012.jpg" alt="012"></p><blockquote><p>当事务 A 在 T3 时间节点读取 zhangsan 的余额时，会发现数据已被其他事务修改，且状态为未提交。</p></blockquote><blockquote><p>此时事务 A 读取最新数据后，根据数据的 undo log 执行回滚操作，得到事务 B 修改前的数据，从而避免了脏读。</p></blockquote><h5 id="②不可重复读"><a href="#②不可重复读" class="headerlink" title="②不可重复读"></a>②不可重复读</h5><p><img src="//zongmansheng.club/2019/06/09/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/013.jpg" alt="013"></p><blockquote><p>当事务 A 在 T2 节点第一次读取数据时，会记录该数据的版本号(数据的版本号是以 row 为单位记录的)，假设版本号为 1;当事务 B 提交时，该行记录的版本号增加，假设版本号为 2。</p></blockquote><blockquote><p>当事务 A 在 T5 再一次读取数据时，发现数据的版本号(2)大于第一次读取时记录的版本号(1)，因此会根据 undo log 执行回滚操作，得到版本号为 1 时的数据，从而实现了可重复读。</p></blockquote><h5 id="③幻读"><a href="#③幻读" class="headerlink" title="③幻读"></a>③幻读</h5><blockquote><p>InnoDB 实现的 RR 通过 next-keylock 机制避免了幻读现象。</p></blockquote><blockquote><p>next-keylock 是行锁的一种，实现相当于 record lock(记录锁) + gap lock(间隙锁);其特点是不仅会锁住记录本身(record lock 的功能)，还会锁定一个范围(gap lock 的功能)。</p></blockquote><blockquote><p>当然，这里我们讨论的是不加锁读：此时的 next-key lock 并不是真的加锁，只是为读取的数据增加了标记(标记内容包括数据的版本号等);准确起见姑且称之为类 next-key lock 机制。</p></blockquote><blockquote><p>还是以前面的例子来说明：</p></blockquote><p><img src="//zongmansheng.club/2019/06/09/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/014.jpg" alt="014"></p><blockquote><p>当事务 A 在 T2 节点第一次读取 0</p></blockquote><blockquote><p>这样当 T5 时刻再次读取 0</p></blockquote><blockquote><p>小结：概括来说，InnoDB 实现的 RR，通过锁机制、数据的隐藏列、undo log 和类 next-key lock，实现了一定程度的隔离性，可以满足大多数场景的需要。</p></blockquote><blockquote><p>不过需要说明的是，RR 虽然避免了幻读问题，但是毕竟不是 Serializable，不能保证完全的隔离。</p></blockquote><blockquote><p>下面是一个例子，大家可以自己验证一下：</p></blockquote><p><img src="//zongmansheng.club/2019/06/09/mysql-shi-wu-ji-acid-te-xing-de-shi-xian-yuan-li/015.jpg" alt="015"></p><p><strong>一致性</strong></p><p><strong>基本概念</strong></p><p>一致性是指事务执行结束后，数据库的完整性约束没有被破坏，事务执行的前后都是合法的数据状态。</p><p>数据库的完整性约束包括但不限于：</p><ul><li>实体完整性(如行的主键存在且唯一)</li><li>列完整性(如字段的类型、大小、长度要符合要求)</li><li>外键约束</li><li>用户自定义完整性(如转账前后，两个账户余额的和应该不变)</li></ul><p><strong>实现</strong></p><p>可以说，一致性是事务追求的最终目标：前面提到的原子性、持久性和隔离性，都是为了保证数据库状态的一致性。此外，除了数据库层面的保障，一致性的实现也需要应用层面进行保障。</p><p>实现一致性的措施包括：</p><ul><li>保证原子性、持久性和隔离性，如果这些特性无法保证，事务的一致性也无法保证。</li><li>数据库本身提供保障，例如不允许向整形列插入字符串值、字符串长度不能超过列的限制等。</li><li>应用层面进行保障，例如如果转账操作只扣除转账者的余额，而没有增加接收者的余额，无论数据库实现的多么完美，也无法保证状态的一致。</li></ul><p><strong>总结</strong></p><p>下面总结一下 ACID 特性及其实现原理：</p><ul><li>原子性：语句要么全执行，要么全不执行，是事务最核心的特性。事务本身就是以原子性来定义的;实现主要基于 undo log。</li><li>持久性：保证事务提交后不会因为宕机等原因导致数据丢失;实现主要基于 redo log。</li><li>隔离性：保证事务执行尽可能不受其他事务影响;InnoDB 默认的隔离级别是 RR，RR 的实现主要基于锁机制、数据的隐藏列、undo log 和类 next-key lock 机制。</li><li>一致性：事务追求的最终目标，一致性的实现既需要数据库层面的保障，也需要应用层面的保障。</li></ul><h4 id="九、参考文献："><a href="#九、参考文献：" class="headerlink" title="九、参考文献："></a>九、参考文献：</h4><ul><li>《MySQL 技术内幕：InnoDB 存储引擎》</li><li>《高性能 MySQL》</li><li>《MySQL 运维内参》</li><li><a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_acid" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_acid</a></li><li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-next-key-locking.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.6/en/innodb-next-key-locking.html</a></li><li><a href="http://blog.sina.com.cn/s/blog_499740cb0100ugs7.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_499740cb0100ugs7.html</a></li><li><a href="https://mp.weixin.qq.com/s/2dwGBTmu_da2x-HiHlN0vw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/2dwGBTmu_da2x-HiHlN0vw</a></li><li><a href="http://www.cnblogs.com/chenpingzhao/p/5065316.html" target="_blank" rel="noopener">http://www.cnblogs.com/chenpingzhao/p/5065316.html</a></li><li><a href="https://juejin.im/entry/5ba0a254e51d450e735e4a1f" target="_blank" rel="noopener">https://juejin.im/entry/5ba0a254e51d450e735e4a1f</a></li><li><a href="http://hedengcheng.com/?p=771" target="_blank" rel="noopener">http://hedengcheng.com/?p=771</a></li></ul><p>转发自：<a href="https://www.toutiao.com/i6651767011648995843/" target="_blank" rel="noopener">https://www.toutiao.com/i6651767011648995843/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL事务及ACID特性的实现原理&quot;&gt;&lt;a href=&quot;#MySQL事务及ACID特性的实现原理&quot; class=&quot;headerlink&quot; title=&quot;MySQL事务及ACID特性的实现原理&quot;&gt;&lt;/a&gt;MySQL事务及ACID特性的实现原理&lt;/h1&gt;&lt;h4 i
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>建造者模式</title>
    <link href="http://zongmansheng.club/2019/05/10/jian-zao-zhe-mo-shi/"/>
    <id>http://zongmansheng.club/2019/05/10/jian-zao-zhe-mo-shi/</id>
    <published>2019-05-10T12:09:32.000Z</published>
    <updated>2019-05-10T12:49:46.035Z</updated>
    
    <content type="html"><![CDATA[<h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><h4 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h4><blockquote><p><strong>意图：</strong>将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</p><p><strong>主要解决：</strong>主要解决在软件系统中，有时候面临着”一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。</p><p><strong>何时使用：</strong>一些基本部件不会变，而其组合经常变化的时候。</p><p><strong>如何解决：</strong>将变与不变分离开。</p><p><strong>关键代码：</strong>建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。</p><p><strong>应用实例：</strong> 1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的”套餐”。</p></blockquote><h4 id="二、JAVA-中的-StringBuilder"><a href="#二、JAVA-中的-StringBuilder" class="headerlink" title="二、JAVA 中的 StringBuilder"></a>二、JAVA 中的 StringBuilder</h4><blockquote><p><strong>优点：</strong> 1、建造者独立，易扩展。 2、便于控制细节风险。 </p><p><strong>缺点：</strong> 1、产品必须有共同点，范围有限制。 2、如内部变化复杂，会有很多的建造类。 </p><p><strong>使用场景：</strong> 1、需要生成的对象具有复杂的内部结构。 2、需要生成的对象内部属性本身相互依赖。 </p><p><strong>注意事项：</strong>与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。</p></blockquote><h4 id="三、实现"><a href="#三、实现" class="headerlink" title="三、实现"></a>三、实现</h4><blockquote><p>我们假设一个快餐店的商业案例，其中，一个典型的套餐可以是一个汉堡（Burger）和一杯冷饮（Cold drink）。汉堡（Burger）可以是素食汉堡（Veg Burger）或鸡肉汉堡（Chicken Burger），它们是包在纸盒中。冷饮（Cold drink）可以是可口可乐（coke）或百事可乐（pepsi），它们是装在瓶子中。</p><p>我们将创建一个表示食物条目（比如汉堡和冷饮）的 <em>Item</em> 接口和实现 <em>Item</em> 接口的实体类，以及一个表示食物包装的 <em>Packing</em> 接口和实现 <em>Packing</em> 接口的实体类，汉堡是包在纸盒中，冷饮是装在瓶子中。</p><p>然后我们创建一个 <em>Meal</em> 类，带有 <em>Item</em> 的 <em>ArrayList</em> 和一个通过结合 <em>Item</em> 来创建不同类型的 <em>Meal</em> 对象的 <em>MealBuilder</em>。<em>BuilderPatternDemo</em>，我们的演示类使用 <em>MealBuilder</em> 来创建一个 <em>Meal</em>。</p></blockquote><p><img src="//zongmansheng.club/2019/05/10/jian-zao-zhe-mo-shi/001.jpg" alt="001"></p><h5 id="步骤1"><a href="#步骤1" class="headerlink" title="步骤1"></a>步骤1</h5><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>desigpattern<span class="token punctuation">.</span>builderpattern<span class="token punctuation">.</span>dao<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author ZongMan * 食物条目接口 */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Item</span> <span class="token punctuation">{</span>    String <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Packing <span class="token function">packing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">float</span> <span class="token function">price</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 食物包装接口 */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Packing</span> <span class="token punctuation">{</span>    String <span class="token function">pack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h5 id="步骤2"><a href="#步骤2" class="headerlink" title="步骤2"></a>步骤2</h5><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @author ZongMan * 创建实现 Packing 接口的实体类。 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Wrapper</span> <span class="token keyword">implements</span> <span class="token class-name">Packing</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">pack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"Wrapper"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Bottle</span> <span class="token keyword">implements</span> <span class="token class-name">Packing</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">pack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"Bottle"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="步骤3"><a href="#步骤3" class="headerlink" title="步骤3"></a>步骤3</h5><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Burger</span> <span class="token keyword">implements</span> <span class="token class-name">Item</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"------->Burger"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Packing <span class="token function">packing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Wrapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">float</span> <span class="token function">price</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ColdDrink</span> <span class="token keyword">implements</span> <span class="token class-name">Item</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"--------->ColdDrink"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Packing <span class="token function">packing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Bottle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">float</span> <span class="token function">price</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="步骤4"><a href="#步骤4" class="headerlink" title="步骤4"></a>步骤4</h5><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @author ZongMan * 创建扩展了 Burger 和 ColdDrink 的实体类。 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VegBurger</span> <span class="token keyword">extends</span> <span class="token class-name">Burger</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"Veg Burger"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">float</span> <span class="token function">price</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">25.0f</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Pepsi</span> <span class="token keyword">extends</span> <span class="token class-name">ColdDrink</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"Pepsi"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">float</span> <span class="token function">price</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">35.0f</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Coke</span> <span class="token keyword">extends</span> <span class="token class-name">ColdDrink</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"Coke"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">float</span> <span class="token function">price</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">30.0f</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ChickenBurger</span> <span class="token keyword">extends</span> <span class="token class-name">Burger</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"Chicken Burger"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">float</span> <span class="token function">price</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">50.5f</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="步骤5"><a href="#步骤5" class="headerlink" title="步骤5"></a>步骤5</h5><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @author ZongMan * 创建一个 Meal 类，带有上面定义的 Item 对象。 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Meal</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> List<span class="token operator">&lt;</span>Item<span class="token operator">></span> items <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addItem</span><span class="token punctuation">(</span>Item item<span class="token punctuation">)</span> <span class="token punctuation">{</span>        items<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">float</span> <span class="token function">getCost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">float</span> cost <span class="token operator">=</span> <span class="token number">0.0f</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Item item <span class="token operator">:</span> items<span class="token punctuation">)</span> <span class="token punctuation">{</span>            cost <span class="token operator">+=</span> item<span class="token punctuation">.</span><span class="token function">price</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> cost<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">showItems</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Item item <span class="token operator">:</span> items<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Item : "</span><span class="token operator">+</span>item<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">", Packing : "</span><span class="token operator">+</span>item<span class="token punctuation">.</span><span class="token function">packing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">pack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">", Price : "</span><span class="token operator">+</span>item<span class="token punctuation">.</span><span class="token function">price</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="步骤6"><a href="#步骤6" class="headerlink" title="步骤6"></a>步骤6</h5><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @author ZongMan * 创建一个 MealBuilder 类，实际的 builder 类负责创建 Meal 对象。 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MealBuilder</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> Meal <span class="token function">prepareVegMeal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Meal meal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Meal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        meal<span class="token punctuation">.</span><span class="token function">addItem</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">VegBurger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        meal<span class="token punctuation">.</span><span class="token function">addItem</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Coke</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> meal<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> Meal <span class="token function">prepareNonVegMeal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Meal meal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Meal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        meal<span class="token punctuation">.</span><span class="token function">addItem</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChickenBurger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        meal<span class="token punctuation">.</span><span class="token function">addItem</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Pepsi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> meal<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="步骤7"><a href="#步骤7" class="headerlink" title="步骤7"></a>步骤7</h5><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @author ZongMan * BuiderPatternDemo 使用 MealBuider 来演示建造者模式（Builder Pattern） */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BuiderPatternDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        MealBuilder mealBuilder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MealBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Meal vegMeal <span class="token operator">=</span> mealBuilder<span class="token punctuation">.</span><span class="token function">prepareVegMeal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Veg Meal"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vegMeal<span class="token punctuation">.</span><span class="token function">showItems</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Total Cost: "</span> <span class="token operator">+</span> vegMeal<span class="token punctuation">.</span><span class="token function">getCost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Meal nonVegMeal <span class="token operator">=</span> mealBuilder<span class="token punctuation">.</span><span class="token function">prepareNonVegMeal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"\n\nNon-Veg Meal"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        nonVegMeal<span class="token punctuation">.</span><span class="token function">showItems</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Total Cost: "</span> <span class="token operator">+</span> nonVegMeal<span class="token punctuation">.</span><span class="token function">getCost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="步骤-8"><a href="#步骤-8" class="headerlink" title="步骤 8"></a>步骤 8</h5><p>​    执行程序，输出结果：</p><pre class=" language-java"><code class="language-java"><span class="token string">"C:\Program Files\Java\jdk1.8.0_181\bin\java.exe"</span> "<span class="token operator">-</span>javaagent<span class="token operator">:</span>I<span class="token operator">:</span>\Program Veg MealItem <span class="token operator">:</span> Veg Burger<span class="token punctuation">,</span> Packing <span class="token operator">:</span> Wrapper<span class="token punctuation">,</span> Price <span class="token operator">:</span> <span class="token number">25.0</span>Item <span class="token operator">:</span> Coke<span class="token punctuation">,</span> Packing <span class="token operator">:</span> Bottle<span class="token punctuation">,</span> Price <span class="token operator">:</span> <span class="token number">30.0</span>Total Cost<span class="token operator">:</span> <span class="token number">55.0</span>Non<span class="token operator">-</span>Veg MealItem <span class="token operator">:</span> Chicken Burger<span class="token punctuation">,</span> Packing <span class="token operator">:</span> Wrapper<span class="token punctuation">,</span> Price <span class="token operator">:</span> <span class="token number">50.5</span>Item <span class="token operator">:</span> Pepsi<span class="token punctuation">,</span> Packing <span class="token operator">:</span> Bottle<span class="token punctuation">,</span> Price <span class="token operator">:</span> <span class="token number">35.0</span>Total Cost<span class="token operator">:</span> <span class="token number">85.5</span>Process finished with exit code <span class="token number">0</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;建造者模式&quot;&gt;&lt;a href=&quot;#建造者模式&quot; class=&quot;headerlink&quot; title=&quot;建造者模式&quot;&gt;&lt;/a&gt;建造者模式&lt;/h1&gt;&lt;h4 id=&quot;一、介绍&quot;&gt;&lt;a href=&quot;#一、介绍&quot; class=&quot;headerlink&quot; title=&quot;一、介绍&quot;
      
    
    </summary>
    
      <category term="设计模式" scheme="http://zongmansheng.club/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Builder Pattern" scheme="http://zongmansheng.club/tags/Builder-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>线程池底层</title>
    <link href="http://zongmansheng.club/2019/05/09/xian-cheng-chi-di-ceng/"/>
    <id>http://zongmansheng.club/2019/05/09/xian-cheng-chi-di-ceng/</id>
    <published>2019-05-09T00:01:18.000Z</published>
    <updated>2019-05-09T00:22:50.650Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程池底层"><a href="#线程池底层" class="headerlink" title="线程池底层"></a>线程池底层</h1><h4 id="一、ThreadPoolExecutor"><a href="#一、ThreadPoolExecutor" class="headerlink" title="一、ThreadPoolExecutor"></a>一、ThreadPoolExecutor</h4><blockquote><p>在深入源码之前先来看看J.U.C包中的线程池类图：</p></blockquote><p><img src="//zongmansheng.club/2019/05/09/xian-cheng-chi-di-ceng/001.jpg" alt="001"></p><blockquote><p>它们的最顶层是一个Executor接口，它只有一个方法：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Executor</span> <span class="token punctuation">{</span>     <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span>Runnable command<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>​    它提供了一个运行新任务的简单方法，Java线程池也称之为Executor框架。</p><p>ExecutorService扩展了Executor，添加了操控线程池生命周期的方法，如shutDown()，shutDownNow()等。</p><p>​    此外，它扩展了可异步跟踪执行任务生成返回值Future的方法，如submit()等方法。</p><p>​    ThreadPoolExecutor继承自AbstractExecutorService，同时实现了ExecutorService接口，也是Executor框架默认的线程池实现类，也是这篇文章重点分析的对象</p><p>​    一般我们使用线程池，如没有特殊要求，直接创建ThreadPoolExecutor，初始化一个线程池</p><p>​    如果需要特殊的线程池，则直接继承ThreadPoolExecutor，并实现特定的功能。</p><p>​    比如ScheduledThreadPoolExecutor，它是一个具有定时执行任务的线程池。</p><p>​    接下来，我们就开始ThreadPoolExecutor的源码分析（以下源码为JDK8版本）</p></blockquote><h4 id="二、ctl变量"><a href="#二、ctl变量" class="headerlink" title="二、ctl变量"></a>二、ctl变量</h4><blockquote><p>​    ctl是一个Integer值，它是对线程池运行状态和线程池中有效线程数量进行控制的字段</p><p>Integer值一共有32位，<strong>其中高3位表示”线程池状态”，低29位表示”线程池中的任务数量”</strong></p><p>我们看看Doug Lea大神是如何实现的：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> AtomicInteger ctl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token function">ctlOf</span><span class="token punctuation">(</span>RUNNING<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> COUNT_BITS <span class="token operator">=</span> Integer<span class="token punctuation">.</span>SIZE <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CAPACITY <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// runState is stored in the high-order bits</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> RUNNING <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SHUTDOWN <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> STOP <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TIDYING <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TERMINATED <span class="token operator">=</span> <span class="token number">3</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Packing and unpacking ctl</span><span class="token comment" spellcheck="true">// 通过位运算获取线程池运行状态</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> c <span class="token operator">&amp;</span> <span class="token operator">~</span>CAPACITY<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 通过位运算获取线程池中有效的工作线程数</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> c <span class="token operator">&amp;</span> CAPACITY<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 初始化ctl变量值</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">ctlOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> rs<span class="token punctuation">,</span> <span class="token keyword">int</span> wc<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> rs <span class="token operator">|</span> wc<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><blockquote><p>线程池一共有状态5种状态，分别是：</p><p>1.<strong>Running</strong>：线程池初始化时默认的状态，表示线程正处于运行状态，能够接受新提交的任务，同时也能够处理阻塞队列中的任务；</p><p>2.<strong>SHUTDOWN</strong>：调用shutdown()方法会使线程池进入到该状态，该状态下不再继续接受新提交的任务，但是还会处理阻塞队列中的任务；</p><p>3.<strong>STOP</strong>：调用shutdownNow()方法会使线程池进入到该状态，该状态下不再继续接受新提交的任务，同时不再处理阻塞队列中的任务；</p><p>4.<strong>TIDYING</strong>：如果线程池中workerCount=0，即有效线程数量为0时，会进入该状态；</p><p>5.<strong>TERMINATED</strong>：在terminated()方法执行完后进入该状态，只不过terminated()方法需要我们自行实现。</p></blockquote><blockquote><p>我们再来看看位运算：</p><ul><li><strong>COUNT_BITS</strong>表示ctl变量中表示有效线程数量的位数，这里COUNT_BITS=29；</li><li><strong>CAPACITY</strong>表示最大有效线程数，根据位运算得出；</li><li><strong>COUNT_MASK</strong>=11111111111111111111111111111，折算成十进制大约是5亿，在设计之初就已经想到不会开启超过5亿条线程，所以完全够用了；</li></ul><p>线程池状态的位运算得到以下值：</p><p><strong>RUNNING</strong>：高三位值1112.</p><p><strong>SHUTDOWN</strong>：高三位值0003.</p><p><strong>STOP</strong>：高三位值0014.</p><p><strong>TIDYING：</strong>高三位值0105.</p><p><strong>TERMINATED：</strong>高三位值011</p><p>这里简单解释一下Doug Lea大神为什么使用一个Integer变量表示两个值：很多人会想，一个变量表示两个值，就节省了存储空间。</p><p>但是这里很显然不是为了节省空间而设计的，即使将这两个值拆分成两个Integer值，一个线程池也就多了4个字节而已</p><p>为了这4个字节而去大费周章地设计一通，显然不是Doug Lea大神的初衷。</p><p>在多线程的环境下，运行状态和有效线程数量往往需要保证统一，不能出现一个改而另一个没有改的情况。</p><p>如果将他们放在同一个AtomicInteger中，利用AtomicInteger的原子操作，就可以保证这两个值始终是统一的。</p><p><strong>Worker</strong></p><p>Worker类继承了AQS，并实现了Runnable接口，它有两个重要的成员变量：<strong>firstTask</strong>和<strong>thread</strong></p><p>​    firstTask用于保存第一次新建的任务；thread是在调用构造方法时通过ThreadFactory来创建的线程，是用来处理任务的线程。</p></blockquote><h4 id="三、如何在线程池中添加任务？"><a href="#三、如何在线程池中添加任务？" class="headerlink" title="三、如何在线程池中添加任务？"></a>三、如何在线程池中添加任务？</h4><blockquote><p>​    线程池要执行任务，那么必须先添加任务，execute()虽说是执行任务的意思，但里面也包含了添加任务的步骤在里面。</p><p>来看下面源码：</p><p>java.util.concurrent.ThreadPoolExecutor#execute：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span>Runnable command<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果添加订单任务为空，则空指针异常</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>command <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 获取ctl值</span> <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1.如果当前有效线程数小于核心线程数，调用addWorker执行任务（即创建一条线程执行该任务）</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&lt;</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 2.如果当前有效线程大于等于核心线程数，并且当前线程池状态为运行状态，则将任务添加到阻塞队列中，等待空闲线程取出队列执行</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRunning</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> workQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">int</span> recheck <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> <span class="token function">isRunning</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">remove</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">addWorker</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 3.如果阻塞队列已满，则调用addWorker执行任务（即创建一条线程执行该任务）</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 如果创建线程失败，则调用线程拒绝策略</span> <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="四、execute执行任务的流程图"><a href="#四、execute执行任务的流程图" class="headerlink" title="四、execute执行任务的流程图"></a>四、execute执行任务的流程图</h4><p><img src="//zongmansheng.club/2019/05/09/xian-cheng-chi-di-ceng/002.jpg" alt="002"></p><blockquote><p>​    继续往下看，addWorker添加任务，方法源码有点长，我按照逻辑拆分成两部分讲解：</p><p>java.util.concurrent.ThreadPoolExecutor#addWorker：</p></blockquote><pre class=" language-java"><code class="language-java">retry<span class="token operator">:</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 获取线程池当前运行状态</span> <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果rs大于SHUTDOWN，则说明此时线程池不在接受新任务了</span> <span class="token comment" spellcheck="true">// 如果rs等于SHUTDOWN，同时满足firstTask为空，且阻塞队列如果有任务，则继续执行任务</span> <span class="token comment" spellcheck="true">// 也就说明了如果线程池处于SHUTDOWN状态时，可以继续执行阻塞队列中的任务，但不能继续往线程池中添加任务了</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">>=</span> SHUTDOWN <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span> <span class="token punctuation">(</span>rs <span class="token operator">==</span> SHUTDOWN <span class="token operator">&amp;&amp;</span> firstTask <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 获取有效线程数量</span> <span class="token keyword">int</span> wc <span class="token operator">=</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果有效线程数大于等于线程池所容纳的最大线程数（基本不可能发生），不能添加任务</span> <span class="token comment" spellcheck="true">// 或者有效线程数大于等于当前限制的线程数，也不能添加任务</span> <span class="token comment" spellcheck="true">// 限制线程数量有任务是否要核心线程执行决定，core=true使用核心线程执行任务</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>wc <span class="token operator">>=</span> CAPACITY <span class="token operator">||</span> wc <span class="token operator">>=</span> <span class="token punctuation">(</span>core <span class="token operator">?</span> corePoolSize <span class="token operator">:</span> maximumPoolSize<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 使用AQS增加有效线程数量</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndIncrementWorkerCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">break</span> retry<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果再次获取ctl变量值</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Re-read ctl</span> <span class="token comment" spellcheck="true">// 再次对比运行状态，如果不一致，再次循环执行</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">!=</span> rs<span class="token punctuation">)</span> <span class="token keyword">continue</span> retry<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// else CAS failed due to workerCount change; retry inner loop</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p><strong>    这里特别强调：</strong>firstTask是开启线程执行的首个任务，之后常驻在线程池中的线程执行的任务都是从阻塞队列中取出的，需要注意。</p><p>以上for循环代码主要作用是判断 ctl 变量当前的状态是否可以添加任务，特别说明了如果线程池处于SHUTDOWN状态时，可以继续执行阻塞队列中的任务，但不能继续往线程池中添加任务了；</p><p>同时增加工作线程数量使用了AQS作同步，如果同步失败，则继续循环执行。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 任务是否已执行</span><span class="token keyword">boolean</span> workerStarted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 任务是否已添加</span><span class="token keyword">boolean</span> workerAdded <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 任务包装类，我们的任务都需要添加到Worker中</span>Worker w <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 创建一个Worker</span> w <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span>firstTask<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 获取Worker中的Thread值</span> <span class="token keyword">final</span> Thread t <span class="token operator">=</span> w<span class="token punctuation">.</span>thread<span class="token punctuation">;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 操作workers HashSet 数据结构需要同步加锁</span> <span class="token keyword">final</span> ReentrantLock mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span> mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">try</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// Recheck while holding lock.</span> <span class="token comment" spellcheck="true">// Back out on ThreadFactory failure or if</span> <span class="token comment" spellcheck="true">// shut down before lock acquired.</span> <span class="token comment" spellcheck="true">// 获取当前线程池的运行状态</span> <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// rs &lt; SHUTDOWN表示是RUNNING状态；</span> <span class="token comment" spellcheck="true">// 如果rs是RUNNING状态或者rs是SHUTDOWN状态并且firstTask为null，向线程池中添加线程。</span> <span class="token comment" spellcheck="true">// 因为在SHUTDOWN时不会在添加新的任务，但还是会执行workQueue中的任务</span> <span class="token comment" spellcheck="true">// rs是RUNNING状态时，直接创建线程执行任务</span> <span class="token comment" spellcheck="true">// 当rs等于SHUTDOWN时，并且firstTask为空，也可以创建线程执行任务，也说说明了SHUTDOWN状态时不再接受新任务</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">&lt;</span> SHUTDOWN <span class="token operator">||</span> <span class="token punctuation">(</span>rs <span class="token operator">==</span> SHUTDOWN <span class="token operator">&amp;&amp;</span> firstTask <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// precheck that t is startable</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalThreadStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> workers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">int</span> s <span class="token operator">=</span> workers<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">></span> largestPoolSize<span class="token punctuation">)</span> largestPoolSize <span class="token operator">=</span> s<span class="token punctuation">;</span> workerAdded <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span> mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 启动线程执行任务</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>workerAdded<span class="token punctuation">)</span> <span class="token punctuation">{</span> t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> workerStarted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> workerStarted<span class="token punctuation">)</span> <span class="token function">addWorkerFailed</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> workerStarted<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>以上源码主要的作用是创建一个Worker对象，并将新的任务装进Worker中，开启同步将Worker添加进workers中</p><p><strong>这里需要注意workers的数据结构为HashSet，非线程安全，所以操作workers需要加同步锁</strong>。</p><p>添加步骤做完后就启动线程来执行任务了，继续往下看。</p><p>如何执行任务？</p><p>我们注意到上面的代码中：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 启动线程执行任务</span><span class="token keyword">if</span> <span class="token punctuation">(</span>workerAdded<span class="token punctuation">)</span> <span class="token punctuation">{</span> t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> workerStarted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>​    这里的t是w.thread得到的，即是Worker中用于执行任务的线程，该线程由ThreadFactory创建，我们再看看生成Worker的构造方法：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token function">Worker</span><span class="token punctuation">(</span>Runnable firstTask<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token function">setState</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// inhibit interrupts until runWorker</span>     <span class="token keyword">this</span><span class="token punctuation">.</span>firstTask <span class="token operator">=</span> firstTask<span class="token punctuation">;</span>     <span class="token keyword">this</span><span class="token punctuation">.</span>thread <span class="token operator">=</span> <span class="token function">getThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newThread</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p><strong>    newThread传的参数是Worker本身，而Worker实现了Runnable接口</strong></p><p><strong>所以当我们执行t.start()时，执行的是Worker的run()方法</strong>，找到入口了：</p><p>java.util.concurrent.ThreadPoolExecutor.Worker#run：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token function">runWorker</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>java.util.concurrent.ThreadPoolExecutor#runWorker：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">runWorker</span><span class="token punctuation">(</span>Worker w<span class="token punctuation">)</span> <span class="token punctuation">{</span> Thread wt <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> Runnable task <span class="token operator">=</span> w<span class="token punctuation">.</span>firstTask<span class="token punctuation">;</span> w<span class="token punctuation">.</span>firstTask <span class="token operator">=</span> null<span class="token punctuation">;</span> w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// allow interrupts</span> <span class="token keyword">boolean</span> completedAbruptly <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token keyword">try</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 循环从workQueue阻塞队列中获取任务并执行</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>task <span class="token operator">!=</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>task <span class="token operator">=</span> <span class="token function">getTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 加同步锁的目的是为了防止同一个任务出现多个线程执行的问题</span> w<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果线程池正在关闭，须确保中断当前线程</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> STOP<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> STOP<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>wt<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> wt<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">try</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 执行任务前可以做一些操作</span> <span class="token function">beforeExecute</span><span class="token punctuation">(</span>wt<span class="token punctuation">,</span> task<span class="token punctuation">)</span><span class="token punctuation">;</span> Throwable thrown <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token keyword">try</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 执行任务</span> task<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RuntimeException</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span> thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Error</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span> thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span> thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 执行任务后可以做一些操作</span> <span class="token function">afterExecute</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> thrown<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 将task置为空，让线程自行调用getTask()方法从workQueue阻塞队列中获取任务</span> task <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 记录Worker执行了多少次任务</span> w<span class="token punctuation">.</span>completedTasks<span class="token operator">++</span><span class="token punctuation">;</span> w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span> completedAbruptly <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 线程回收过程</span> <span class="token function">processWorkerExit</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> completedAbruptly<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>​    这一步是执行任务的核心方法，首次执行不为空的firstTask任务，之后便一直从workQueue阻塞队列中获取任务并执行</p><p>​    如果你想在任务执行前后做点啥不可告人的小动作，你可以实现ThreadPoolExecutor以下两个方法：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">beforeExecute</span><span class="token punctuation">(</span>Thread t<span class="token punctuation">,</span> Runnable r<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">afterExecute</span><span class="token punctuation">(</span>Runnable r<span class="token punctuation">,</span> Throwable t<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span></code></pre><blockquote><p>这样一来，我们就可以对任务的执行进行实时监控了。</p><p>这里还需要注意，在finally块中，将task置为空，目的是为了让线程自行调用getTask()方法从workQueue阻塞队列中获取任务。</p><p>如何保证核心线程不被销毁？</p><p>我们之前已经知道线程池中可维持corePoolSize数量的常驻核心线程，那么它们是如何保证执行完任务而不被线程池回收的呢？</p><p><strong>在前面的章节中你可能已经会从workQueue队列中阻塞式地获取任务，如果没有获取任务，那么就会一直阻塞下去</strong></p><p>很聪明，你已经知道答案了，现在我们来看Doug Lea大神是如何实现的。</p><p>java.util.concurrent.ThreadPoolExecutor#getTask：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> Runnable <span class="token function">getTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 超时标记，默认为false，如果调用workQueue.poll()方法超时了，会标记为true</span> <span class="token comment" spellcheck="true">// 这个标记非常之重要，下面会说到</span> <span class="token keyword">boolean</span> timedOut <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 获取ctl变量值</span> <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果当前状态大于等于SHUTDOWN，并且workQueue中的任务为空或者状态大于等于STOP</span> <span class="token comment" spellcheck="true">// 则操作AQS减少工作线程数量，并且返回null，线程被回收</span> <span class="token comment" spellcheck="true">// 也说明假设状态为SHUTDOWN的情况下，如果workQueue不为空，那么线程池还是可以继续执行剩下的任务</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">>=</span> SHUTDOWN <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>rs <span class="token operator">>=</span> STOP <span class="token operator">||</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 操作AQS将线程池中的线程数量减一</span> <span class="token function">decrementWorkerCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> null<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 获取线程池中的有效线程数量</span> <span class="token keyword">int</span> wc <span class="token operator">=</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果开发者主动开启allowCoreThreadTimeOut并且获取当前工作线程大于corePoolSize，那么该线程是可以被超时回收的</span> <span class="token comment" spellcheck="true">// allowCoreThreadTimeOut默认为false，即默认不允许核心线程超时回收</span> <span class="token comment" spellcheck="true">// 这里也说明了在核心线程以外的线程都为“临时”线程，随时会被线程池回收</span> <span class="token keyword">boolean</span> timed <span class="token operator">=</span> allowCoreThreadTimeOut <span class="token operator">||</span> wc <span class="token operator">></span> corePoolSize<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 这里说明了两点销毁线程的条件：</span> <span class="token comment" spellcheck="true">// 1.原则上线程池数量不可能大于maximumPoolSize，但可能会出现并发时操作了setMaximumPoolSize方法，如果此时将最大线程数量调少了，很可能会出现当前工作线程大于最大线程的情况，这时就需要线程超时回收，以维持线程池最大线程小于maximumPoolSize，</span> <span class="token comment" spellcheck="true">// 2.timed &amp;&amp; timedOut 如果为true，表示当前操作需要进行超时控制，这里的timedOut为true，说明该线程已经从workQueue.poll()方法超时了</span> <span class="token comment" spellcheck="true">// 以上两点满足其一，都可以触发线程超时回收</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>wc <span class="token operator">></span> maximumPoolSize <span class="token operator">||</span> <span class="token punctuation">(</span>timed <span class="token operator">&amp;&amp;</span> timedOut<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>wc <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">||</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 尝试用AQS将线程池线程数量减一</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndDecrementWorkerCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 减一成功后返回null，线程被回收</span> <span class="token keyword">return</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 否则循环重试</span> <span class="token keyword">continue</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">try</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果timed为true，阻塞超时获取任务，否则阻塞获取任务</span> Runnable r <span class="token operator">=</span> timed <span class="token operator">?</span> workQueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span>keepAliveTime<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>NANOSECONDS<span class="token punctuation">)</span> <span class="token operator">:</span> workQueue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> r<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果poll超时获取任务超时了, 将timeOut设置为true</span> <span class="token comment" spellcheck="true">// 继续循环执行，如果碰巧开发者开启了allowCoreThreadTimeOut，那么该线程就满足超时回收了</span> timedOut <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> retry<span class="token punctuation">)</span> <span class="token punctuation">{</span> timedOut <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>我把我对 getTask() 方法源码的深度解析写在源码对应的地方了，该方法就是实现默认的情况下核心线程不被销毁的核心实现，其实现思路大致是：</p><p><strong>1.将timedOut超时标记默认设置为false；</strong></p><p><strong>2.计算timed的值，该值决定了线程的生死大权</strong></p><p>(timed &amp;&amp; timedOut) 即是线程超时回收的条件之一，需要注意的是第一次(timed &amp;&amp; timedOut) 为false，因为timedOut默认值为false，此时还没到poll超时获取的操作；</p><p><strong>3.根据timed值来决定是用阻塞超时获取任务还是阻塞获取任务</strong></p><p>如果用阻塞超时获取任务，超时后timedOut会被设置为true，接着继续循环，若 (timed &amp;&amp; timedOut) 为true，满足线程超时回收。</p></blockquote><blockquote><p>转自：<a href="https://www.toutiao.com/a6686773038484029955/" target="_blank" rel="noopener">https://www.toutiao.com/a6686773038484029955/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;线程池底层&quot;&gt;&lt;a href=&quot;#线程池底层&quot; class=&quot;headerlink&quot; title=&quot;线程池底层&quot;&gt;&lt;/a&gt;线程池底层&lt;/h1&gt;&lt;h4 id=&quot;一、ThreadPoolExecutor&quot;&gt;&lt;a href=&quot;#一、ThreadPoolExecutor&quot;
      
    
    </summary>
    
      <category term="java高级" scheme="http://zongmansheng.club/categories/java%E9%AB%98%E7%BA%A7/"/>
    
    
      <category term="ThreadPool" scheme="http://zongmansheng.club/tags/ThreadPool/"/>
    
  </entry>
  
  <entry>
    <title>消息队列的高可用</title>
    <link href="http://zongmansheng.club/2019/05/05/xiao-xi-dui-lie-de-gao-ke-yong/"/>
    <id>http://zongmansheng.club/2019/05/05/xiao-xi-dui-lie-de-gao-ke-yong/</id>
    <published>2019-05-05T12:58:37.000Z</published>
    <updated>2019-05-05T13:29:54.128Z</updated>
    
    <content type="html"><![CDATA[<h1 id="消息队列的高可用"><a href="#消息队列的高可用" class="headerlink" title="消息队列的高可用"></a>消息队列的高可用</h1><h4 id="一、RabbitMQ-的高可用性"><a href="#一、RabbitMQ-的高可用性" class="headerlink" title="一、RabbitMQ 的高可用性"></a>一、RabbitMQ 的高可用性</h4><blockquote><p>​    RabbitMQ 是比较有代表性的，因为是基于主从（非分布式）做高可用性的，我们就以 RabbitMQ 为例子讲解第一种 MQ 的高可用性怎么实现。</p><p>RabbitMQ 有三种模式：单机模式、普通集群模式、镜像集群模式。</p></blockquote><h5 id="1-1、单机模式"><a href="#1-1、单机模式" class="headerlink" title="1.1、单机模式"></a>1.1、单机模式</h5><blockquote><p>单机模式，就是 Demo 级别的，一般就是你本地启动了玩玩儿的，没人生产用单机模式。</p><p>普通集群模式（无高可用性）</p><p>普通集群模式，意思就是在多台机器上启动多个 RabbitMQ 实例，每个机器启动一个。你创建的 queue，只会放在一个 RabbitMQ 实例上，但是每个实例都同步 queue 的元数据（元数据可以认为是 queue 的一些配置信息，通过元数据，可以找到 queue 所在实例）。你消费的时候，实际上如果连接到了另外一个实例，那么那个实例会从 queue 所在实例上拉取数据过来。</p></blockquote><p><img src="//zongmansheng.club/2019/05/05/xiao-xi-dui-lie-de-gao-ke-yong/001.jpg" alt="001"></p><h4 id="二、Kafka-的高可用性"><a href="#二、Kafka-的高可用性" class="headerlink" title="二、Kafka 的高可用性"></a>二、Kafka 的高可用性</h4><blockquote><p>​    Kafka 一个最基本的架构认识：由多个 broker 组成，每个 broker 是一个节点；你创建一个 topic，这个 topic 可以划分为多个 partition，每个 partition 可以存在于不同的 broker 上，每个 partition 就放一部分数据。</p><p>​    这就是天然的分布式消息队列，就是说一个 topic 的数据，是分散放在多个机器上的，每个机器就放一部分数据。</p><p>​    实际上 RabbmitMQ 之类的，并不是分布式消息队列，它就是传统的消息队列，只不过提供了一些集群、HA(High Availability, 高可用性) 的机制而已，因为无论怎么玩儿，RabbitMQ 一个 queue 的数据都是放在一个节点里的，镜像集群下，也是每个节点都放这个 queue 的完整数据。</p><p>​    Kafka 0.8 以前，是没有 HA 机制的，就是任何一个 broker 宕机了，那个 broker 上的 partition 就废了，没法写也没法读，没有什么高可用性可言。</p><p>​    比如说，我们假设创建了一个 topic，指定其 partition 数量是 3 个，分别在三台机器上。但是，如果第二台机器宕机了，会导致这个 topic 的 1/3 的数据就丢了，因此这个是做不到高可用的。</p></blockquote><p><img src="//zongmansheng.club/2019/05/05/xiao-xi-dui-lie-de-gao-ke-yong/002.jpg" alt="002"></p><blockquote><p>​    这么搞，就有所谓的高可用性了，因为如果某个 broker 宕机了，没事儿，那个 broker上面的 partition 在其他机器上都有副本的，如果这上面有某个 partition 的 leader，那么此时会从 follower 中重新选举一个新的 leader 出来，大家继续读写那个新的 leader 即可。这就有所谓的高可用性了。</p><p>​    写数据的时候，生产者就写 leader，然后 leader 将数据落地写本地磁盘，接着其他 follower 自己主动从 leader 来 pull 数据。一旦所有 follower 同步好数据了，就会发送 ack 给 leader，leader 收到所有 follower 的 ack 之后，就会返回写成功的消息给生产者。（当然，这只是其中一种模式，还可以适当调整这个行为）</p><p>​    消费的时候，只会从 leader 去读，但是只有当一个消息已经被所有 follower 都同步成功返回 ack 的时候，这个消息才会被消费者读到。</p><p>​    看到这里，相信你大致明白了 Kafka 是如何保证高可用机制的了，对吧？不至于一无所知，现场还能给面试官画画图。要是遇上面试官确实是 Kafka 高手，深挖了问，那你只能说不好意思，太深入的你没研究过。</p><p>​    这种方式确实很麻烦，也不怎么好，没做到所谓的分布式，就是个普通集群。因为这导致你要么消费者每次随机连接一个实例然后拉取数据，要么固定连接那个 queue 所在实例消费数据，前者有数据拉取的开销，后者导致单实例性能瓶颈。</p><p>​    而且如果那个放 queue 的实例宕机了，会导致接下来其他实例就无法从那个实例拉取，如果你开启了消息持久化，让 RabbitMQ 落地存储消息的话，消息不一定会丢，得等这个实例恢复了，然后才可以继续从这个 queue 拉取数据。</p><p>​    所以这个事儿就比较尴尬了，这就没有什么所谓的高可用性，这方案主要是提高吞吐量的，就是说让集群中多个节点来服务某个 queue 的读写操作。</p><p>镜像集群模式（高可用性）</p><p>​    这种模式，才是所谓的 RabbitMQ 的高可用模式。跟普通集群模式不一样的是，在镜像集群模式下，你创建的 queue，无论元数据还是 queue 里的消息都会存在于多个实例上，就是说，每个 RabbitMQ 节点都有这个 queue 的一个完整镜像，包含 queue 的全部数据的意思。然后每次你写消息到 queue 的时候，都会自动把消息同步到多个实例的 queue 上。</p></blockquote><p><img src="//zongmansheng.club/2019/05/05/xiao-xi-dui-lie-de-gao-ke-yong/003.jpg" alt="003"></p><blockquote><p>​    那么如何开启这个镜像集群模式呢？其实很简单，RabbitMQ 有很好的管理控制台，就是在后台新增一个策略，这个策略是镜像集群模式的策略，指定的时候是可以要求数据同步到所有节点的，也可以要求同步到指定数量的节点，再次创建 queue 的时候，应用这个策略，就会自动将数据同步到其他的节点上去了。</p><p>这样的话，好处在于，你任何一个机器宕机了，没事儿，其它机器（节点）还包含了这个 queue 的完整数据，别的 consumer 都可以到其它节点上去消费数据。坏处在于，第一，这个性能开销也太大了吧，消息需要同步到所有机器上，导致网络带宽压力和消耗很重！第二，这么玩儿，不是分布式的，就没有扩展性可言了，如果某个 queue 负载很重，你加机器，新增的机器也包含了这个 queue 的所有数据，并没有办法线性扩展你的 queue。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;消息队列的高可用&quot;&gt;&lt;a href=&quot;#消息队列的高可用&quot; class=&quot;headerlink&quot; title=&quot;消息队列的高可用&quot;&gt;&lt;/a&gt;消息队列的高可用&lt;/h1&gt;&lt;h4 id=&quot;一、RabbitMQ-的高可用性&quot;&gt;&lt;a href=&quot;#一、RabbitMQ-的高
      
    
    </summary>
    
      <category term="java高级" scheme="http://zongmansheng.club/categories/java%E9%AB%98%E7%BA%A7/"/>
    
    
      <category term="分布式，MQ" scheme="http://zongmansheng.club/tags/%E5%88%86%E5%B8%83%E5%BC%8F%EF%BC%8CMQ/"/>
    
  </entry>
  
  <entry>
    <title>在Mac上使用Markdown</title>
    <link href="http://zongmansheng.club/2019/05/05/zai-mac-shang-shi-yong-markdown/"/>
    <id>http://zongmansheng.club/2019/05/05/zai-mac-shang-shi-yong-markdown/</id>
    <published>2019-05-05T07:29:58.000Z</published>
    <updated>2019-06-30T07:37:16.870Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在Mac上使用Markdown"><a href="#在Mac上使用Markdown" class="headerlink" title="在Mac上使用Markdown"></a>在Mac上使用Markdown</h1><h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>MarkDown是一种轻量级的标记语言，他的开发者为John Gruber。通过简单的标记语法，它可以使普通文本具有一定的格式</p><p>​        最近入手一台macbook  pro，已经把这个博客从windows迁移到mac上来了！！！</p></blockquote><h4 id="一、常用语法及快捷键"><a href="#一、常用语法及快捷键" class="headerlink" title="一、常用语法及快捷键"></a>一、常用语法及快捷键</h4><h5 id="1-1标题"><a href="#1-1标题" class="headerlink" title="1.1标题"></a>1.1标题</h5><blockquote><p>##一级标题</p><p>####二级标题</p><p>######三级标题</p><p>########四级标题</p><p>##########五级标题</p><p>############六级标题</p><p>快捷键为cmd+X（X为几级标题就写数字几，如二级标题为：cmd+2）</p></blockquote><h5 id="1-2引用"><a href="#1-2引用" class="headerlink" title="1.2引用"></a>1.2引用</h5><blockquote><p>当你需要引用别人的话时，可以在引用的文字前面添加引用标记 <strong>&gt;</strong>，<br>即表示此后的内容为引用，这时候，文字的背景色也会改变。</p><p>如：&gt;这是一段引用</p></blockquote><h5 id="1-3链接"><a href="#1-3链接" class="headerlink" title="1.3链接"></a>1.3链接</h5><blockquote><p>链接分为图片链接和网址链接。</p><p><strong>图片链接</strong></p><pre><code>![图片描述] (图片地址)</code></pre><p>快捷键为：shift + cmd + I</p><p><strong>网页链接</strong></p><pre><code>[网页描述](网页地址)</code></pre><p>快捷键为 sihft + cmd + k</p></blockquote><h5 id="1-4代码"><a href="#1-4代码" class="headerlink" title="1.4代码"></a>1.4代码</h5><blockquote><p>使用两个 <strong>`</strong>符号把单行代码包裹起来。</p><p>多行代码两个用<strong><code>`</code></strong>包起来。</p></blockquote><h5 id="1-5表格"><a href="#1-5表格" class="headerlink" title="1.5表格"></a>1.5表格</h5><blockquote><p>| 1 | 2 | 3 |</p><p>| —- |:—-:| —:|</p><p>| a | d | g |</p><p>| b | e | h |</p><p>| c | f | I |</p><p><strong>| —- |:—-:| —:|</strong>表示对其方式。:—表示左对齐；—:表示右对齐；:—-:表示中间对齐。</p></blockquote><p>效果为：</p><table><thead><tr><th>1</th><th style="text-align:center">2</th><th style="text-align:right">3</th></tr></thead><tbody><tr><td>a</td><td style="text-align:center">d</td><td style="text-align:right">g</td></tr><tr><td>b</td><td style="text-align:center">e</td><td style="text-align:right">h</td></tr><tr><td>c</td><td style="text-align:center">f</td><td style="text-align:right">I</td></tr></tbody></table><h5 id="1-6其他"><a href="#1-6其他" class="headerlink" title="1.6其他"></a>1.6其他</h5><pre><code>加粗 :**Bold**斜体字 :*Italics*高亮 :==text==段落 : 段落之间空一行画水平线 (HR) :--------方框：- [ ] -</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;在Mac上使用Markdown&quot;&gt;&lt;a href=&quot;#在Mac上使用Markdown&quot; class=&quot;headerlink&quot; title=&quot;在Mac上使用Markdown&quot;&gt;&lt;/a&gt;在Mac上使用Markdown&lt;/h1&gt;&lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="皮一下" scheme="http://zongmansheng.club/categories/%E7%9A%AE%E4%B8%80%E4%B8%8B/"/>
    
    
      <category term="Mac Markdown" scheme="http://zongmansheng.club/tags/Mac-Markdown/"/>
    
  </entry>
  
  <entry>
    <title>nginx惊群</title>
    <link href="http://zongmansheng.club/2019/04/28/nginx-liang-qun/"/>
    <id>http://zongmansheng.club/2019/04/28/nginx-liang-qun/</id>
    <published>2019-04-28T00:04:23.000Z</published>
    <updated>2019-05-03T08:54:07.863Z</updated>
    
    <content type="html"><![CDATA[<h1 id="nginx惊群"><a href="#nginx惊群" class="headerlink" title="nginx惊群"></a>nginx惊群</h1><h4 id="一、什么是惊群"><a href="#一、什么是惊群" class="headerlink" title="一、什么是惊群"></a>一、什么是惊群</h4><blockquote><p>​    多线程/多进程（linux下线程进程也没多大区别）等待同一个socket事件，当这个事件发生时，这些线程/进程被同时唤醒，就是惊群。可以想见，效率很低下，许多进程被内核重新调度唤醒，同时去响应这一个事件，当然只有一个进程能处理事件成功，其他的进程在处理该事件失败后重新休眠（也有其他选择）。这种性能浪费现象就是惊群。</p></blockquote><blockquote><p>​    惊群通常发生在server 上，当父进程绑定一个端口监听socket，然后fork出多个子进程，子进程们开始循环处理（比如accept）这个socket。每当用户发起一个TCP连接时，多个子进程同时被唤醒，然后其中一个子进程accept新连接成功，余者皆失败，重新休眠。</p></blockquote><h4 id="二、如何解决惊群问题-post事件处理机制"><a href="#二、如何解决惊群问题-post事件处理机制" class="headerlink" title="二、如何解决惊群问题-post事件处理机制"></a>二、如何解决惊群问题-post事件处理机制</h4><blockquote><p>​    很多操作系统的最新版本的内核已经在事件驱动机制中解决了惊群问题，但Nginx作为可移植性极高的web服务器，还是在自身的应用层面上较好的解决了这一问题。<br>Nginx规定了同一时刻只有唯一一个worker子进程监听web端口，这一就不会发生惊群了，此时新连接事件只能唤醒唯一的正在监听端口的worker子进程。</p><p>​    如何限制在某一时刻是有一个子进程监听web端口呢？在打开accept_mutex锁的情况下，只有调用ngx_trylock_accept_mutex方法后，当前的worker进程才会去试着监听web端口。</p><p>​    那么，什么时候释放ngx_accept_mutex锁呢？<br>​    显然不能等到这批事件全部执行完。因为这个worker进程上可能有许多活跃的连接，处理这些连接上的事件会占用很长时间，其他worker进程很难得到处理新连接的机会。</p><p>​    如何解决长时间占用ngx_accept_mutex的问题呢？</p><p>​    这就要依靠post事件处理机制，Nginx设计了两个队列：ngx_posted_accept_events队列（存放新连接事件的队列）和ngx_posted_events队列（存放普通事件的队列）。这两个队列都是ngx_event_t类型的双链表。定义如下：</p></blockquote><pre class=" language-java"><code class="language-java">ngx_thread_volatile ngx_event_t  <span class="token operator">*</span>ngx_posted_accept_events<span class="token punctuation">;</span>ngx_thread_volatile ngx_event_t  <span class="token operator">*</span>ngx_posted_events<span class="token punctuation">;</span></code></pre><blockquote><p>​    下面结合具体代码进行分析惊群问题的解决。</p><p>​    首先看worker进程中ngx_process_events_and_timers事件处理函数（src/event/ngx.event.c），它处于worker进程的ngx_worker_process_cycle方法中，循环处理时间，是事件驱动机制的核心，既会处理普通的网络事件，也会处理定时器事件。ngx_process_events_and_timers是Nginx实际处理web业务的方法，所有业务的执行都是由它开始的，它涉及Nginx完整的事件驱动机制！！特别重要~</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span><span class="token function">ngx_process_events_and_timers</span><span class="token punctuation">(</span>ngx_cycle_t <span class="token operator">*</span>cycle<span class="token punctuation">)</span><span class="token punctuation">{</span>    ngx_uint_t  flags<span class="token punctuation">;</span>    ngx_msec_t  timer<span class="token punctuation">,</span> delta<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ngx_timer_resolution<span class="token punctuation">)</span> <span class="token punctuation">{</span>        timer <span class="token operator">=</span> NGX_TIMER_INFINITE<span class="token punctuation">;</span>        flags <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        timer <span class="token operator">=</span> <span class="token function">ngx_event_find_timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        flags <span class="token operator">=</span> NGX_UPDATE_TIME<span class="token punctuation">;</span>#<span class="token keyword">if</span> <span class="token punctuation">(</span>NGX_THREADS<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>timer <span class="token operator">==</span> NGX_TIMER_INFINITE <span class="token operator">||</span> timer <span class="token operator">></span> <span class="token number">500</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            timer <span class="token operator">=</span> <span class="token number">500</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>#endif    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*ngx_use_accept_mutex表示是否需要通过对accept加锁来解决惊群问题。当使用了master模式，nginx worker进程数>1时且配置文件中打开accept_mutex时，这个标志置为1     它在函数ngx_event_process_int中被设置，源代码为：    if (ccf->master &amp;&amp; ccf->worker_processes > 1 &amp;&amp; ecf->accept_mutex) {        ngx_use_accept_mutex = 1;        ngx_accept_mutex_held = 0;        ngx_accept_mutex_delay = ecf->accept_mutex_delay;    } else {        ngx_use_accept_mutex = 0;    }*/</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ngx_use_accept_mutex<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//负载均衡处理</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ngx_accept_disabled <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            ngx_accept_disabled<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//调用ngx_trylock_accept_mutex方法，尝试获取accept锁</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ngx_trylock_accept_mutex</span><span class="token punctuation">(</span>cycle<span class="token punctuation">)</span> <span class="token operator">==</span> NGX_ERROR<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//拿到锁</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ngx_accept_mutex_held<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">/*给flags增加标记NGX_POST_EVENTS，这个标记作为处理时间核心函数ngx_process_events的一个参数，这个函数中所有事件将延后处理。会把accept事件都放到ngx_posted_accept_events链表中，epollin|epollout普通事件都放到ngx_posted_events链表中 */</span>                flags <span class="token operator">|=</span> NGX_POST_EVENTS<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">/*获取锁失败，意味着既不能让当前worker进程频繁的试图抢锁，也不能让它经过太长事件再去抢锁                下面的代码：即使开启了timer_resolution时间精度，牙需要让ngx_process_change方法在没有新事件的时候至少等待ngx_accept_mutex_delay毫秒之后再去试图抢锁                而没有开启时间精度时，如果最近一个定时器事件的超时时间距离现在超过了ngx_accept_mutex_delay毫秒，也要把timer设置为ngx_accept_mutex_delay毫秒，这是因为当前进程虽然没有抢到accept_mutex锁，但也不能让ngx_process_change方法在没有新事件的时候等待的时间超过ngx_accept_mutex_delay，这会影响整个负载均衡机制*/</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>timer <span class="token operator">==</span> NGX_TIMER_INFINITE                    <span class="token operator">||</span> timer <span class="token operator">></span> ngx_accept_mutex_delay<span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    timer <span class="token operator">=</span> ngx_accept_mutex_delay<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//计算ngx_process_events消耗的时间</span>    delta <span class="token operator">=</span> ngx_current_msec<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//事件处理核心函数</span>    <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token function">ngx_process_events</span><span class="token punctuation">(</span>cycle<span class="token punctuation">,</span> timer<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>    delta <span class="token operator">=</span> ngx_current_msec <span class="token operator">-</span> delta<span class="token punctuation">;</span>    <span class="token function">ngx_log_debug1</span><span class="token punctuation">(</span>NGX_LOG_DEBUG_EVENT<span class="token punctuation">,</span> cycle<span class="token operator">-</span><span class="token operator">></span>log<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>                   <span class="token string">"timer delta: %M"</span><span class="token punctuation">,</span> delta<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//ngx_posted_accept_events链表有数据，开始accept新连接</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ngx_posted_accept_events<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">ngx_event_process_posted</span><span class="token punctuation">(</span>cycle<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ngx_posted_accept_events<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//释放锁后再处理ngx_posted_events链表中的普通事件</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ngx_accept_mutex_held<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">ngx_shmtx_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ngx_accept_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//如果ngx_process_events消耗的时间大于0，那么这是可能有新的定时器事件触发</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>delta<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//处理定时器事件</span>        <span class="token function">ngx_event_expire_timers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">ngx_log_debug1</span><span class="token punctuation">(</span>NGX_LOG_DEBUG_EVENT<span class="token punctuation">,</span> cycle<span class="token operator">-</span><span class="token operator">></span>log<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>                   <span class="token string">"posted events %p"</span><span class="token punctuation">,</span> ngx_posted_events<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//ngx_posted_events链表中有数据，进行处理</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ngx_posted_events<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ngx_threaded<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">ngx_wakeup_worker_thread</span><span class="token punctuation">(</span>cycle<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token function">ngx_event_process_posted</span><span class="token punctuation">(</span>cycle<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ngx_posted_events<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>​    上面代码中要进行说明的是，flags被设置后作为函数ngx_process_events方法的一个参数，在epoll模块中这个接口的实现方法是ngx_epoll_process_events（其具体代码见<a href="http://blog.csdn.net/xiajun07061225/article/details/9250341）。当falgs标志位含有nGX_POST_EVENTS时是不会立即调用事件的handler回调方法的，代码如下所示：" target="_blank" rel="noopener">http://blog.csdn.net/xiajun07061225/article/details/9250341）。当falgs标志位含有nGX_POST_EVENTS时是不会立即调用事件的handler回调方法的，代码如下所示：</a></p></blockquote><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//事件需要延后处理</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> NGX_POST_EVENTS<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">/*如果要在post队列中延后处理该事件，首先要判断它是新连接时间还是普通事件                以确定是把它加入到ngx_posted_accept_events队列或者ngx_posted_events队列中。*/</span>                queue <span class="token operator">=</span> <span class="token punctuation">(</span>ngx_event_t <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>rev<span class="token operator">-</span><span class="token operator">></span>accept <span class="token operator">?</span>                               <span class="token operator">&amp;</span>ngx_posted_accept_events <span class="token operator">:</span> <span class="token operator">&amp;</span>ngx_posted_events<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//将该事件添加到相应的延后队列中</span>                <span class="token function">ngx_locked_post_event</span><span class="token punctuation">(</span>rev<span class="token punctuation">,</span> queue<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//立即调用事件回调方法来处理这个事件</span>                rev<span class="token operator">-</span><span class="token operator">></span><span class="token function">handler</span><span class="token punctuation">(</span>rev<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span></code></pre><blockquote><p>通过上面的代码可以看出，先处理ngx_posted_accept_events队列中的事件，处理完毕后立即释放ngx_accept_mutex锁，接着再处理ngx_posted_events队列中事件。这样大大减少了ngx_accept_mutex锁占用的时间</p><p>下面看看ngx_trylock_accept_mutex的具体实现（src/event/ngx_event_accept.c）：</p></blockquote><pre class=" language-java"><code class="language-java">ngx_int_t<span class="token function">ngx_trylock_accept_mutex</span><span class="token punctuation">(</span>ngx_cycle_t <span class="token operator">*</span>cycle<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//尝试获取accept_mutex锁。注意是非阻塞的。返回1表示成功，返回0表示失败。</span>    <span class="token comment" spellcheck="true">//ngx_accept_mutex 定义：ngx_shmtx_t    ngx_accept_mutex;（ngx_shmtx_t是Nginx封装的互斥锁，用于经常间同步）</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ngx_shmtx_trylock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ngx_accept_mutex<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">ngx_log_debug0</span><span class="token punctuation">(</span>NGX_LOG_DEBUG_EVENT<span class="token punctuation">,</span> cycle<span class="token operator">-</span><span class="token operator">></span>log<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>                       <span class="token string">"accept mutex locked"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//获取到锁，但是标志位ngx_accept_mutex_held为1，表示当前进程已经获取到锁了，立即返回。</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ngx_accept_mutex_held            <span class="token operator">&amp;&amp;</span> ngx_accept_events <span class="token operator">==</span> <span class="token number">0</span>            <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>ngx_event_flags <span class="token operator">&amp;</span> NGX_USE_RTSIG_EVENT<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">return</span> NGX_OK<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//将所有监听事件添加到当前的epoll等事件驱动模块中</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ngx_enable_accept_events</span><span class="token punctuation">(</span>cycle<span class="token punctuation">)</span> <span class="token operator">==</span> NGX_ERROR<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//添加失败，必须释放互斥锁</span>            <span class="token function">ngx_shmtx_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ngx_accept_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> NGX_ERROR<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//标志位设置</span>        ngx_accept_events <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//当前进程已经获取到锁</span>        ngx_accept_mutex_held <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> NGX_OK<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">ngx_log_debug1</span><span class="token punctuation">(</span>NGX_LOG_DEBUG_EVENT<span class="token punctuation">,</span> cycle<span class="token operator">-</span><span class="token operator">></span>log<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>                   <span class="token string">"accept mutex lock failed: %ui"</span><span class="token punctuation">,</span> ngx_accept_mutex_held<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//获取锁失败，但是标志位ngx_accept_mutex_held仍然为1，即当前进程还处在获取到锁的状态，这是不正确的</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ngx_accept_mutex_held<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//将所有监听事件从事件驱动模块中移除</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ngx_disable_accept_events</span><span class="token punctuation">(</span>cycle<span class="token punctuation">)</span> <span class="token operator">==</span> NGX_ERROR<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> NGX_ERROR<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//没有获取到锁，设置标志位</span>        ngx_accept_mutex_held <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> NGX_OK<span class="token punctuation">;</span></code></pre><blockquote><p>​    调用这个方法的结果是，要么唯一获取到锁且其epoll等事件驱动模块开始监控web端口上的新连接事件。这种情况下调用process_events方法时就会既处理已有连接上的事件，也处理新连接的事件。要么没有获取到锁，当前进程不会收到新连接事件。这种情况下process_events只处理已有连接上的事件。</p></blockquote><h4 id="三、参考资料"><a href="#三、参考资料" class="headerlink" title="三、参考资料"></a>三、参考资料</h4><blockquote><p><a href="http://russelltao.iteye.com/blog/1405352" target="_blank" rel="noopener">http://russelltao.iteye.com/blog/1405352</a></p><p>《深入理解Nginx》</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;nginx惊群&quot;&gt;&lt;a href=&quot;#nginx惊群&quot; class=&quot;headerlink&quot; title=&quot;nginx惊群&quot;&gt;&lt;/a&gt;nginx惊群&lt;/h1&gt;&lt;h4 id=&quot;一、什么是惊群&quot;&gt;&lt;a href=&quot;#一、什么是惊群&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="进阶" scheme="http://zongmansheng.club/categories/%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="nginx" scheme="http://zongmansheng.club/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>SQL注入XSS和CSRF</title>
    <link href="http://zongmansheng.club/2019/04/25/sql-zhu-ru-xss-he-csrf/"/>
    <id>http://zongmansheng.club/2019/04/25/sql-zhu-ru-xss-he-csrf/</id>
    <published>2019-04-25T00:31:32.000Z</published>
    <updated>2019-04-26T13:34:18.699Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SQL注入、XSS和CSRF"><a href="#SQL注入、XSS和CSRF" class="headerlink" title="SQL注入、XSS和CSRF"></a>SQL注入、XSS和CSRF</h1><h4 id="一、SQL注入"><a href="#一、SQL注入" class="headerlink" title="一、SQL注入"></a>一、SQL注入</h4><pre><code>SQL注入是属于注入式攻击，这种攻击是因为在项目中没有将代码与数据（比如用户敏感数据）隔离，在读取数据的时候，错误的将数据作为代码的一部分执行而导致的。典型的例子就是当对SQL语句进行字符串拼接的时候，直接使用未转义的用户输入内容作为变量。这时，只要在sql语句的中间做修改，比如加上drop、delete等关键字，执行之后后果不堪设想。说到这里，那么该怎么处理这种情况呢？三个方面：1、过滤用户输入参数中的特殊字符，降低风险。2、禁止通过字符串拼接sql语句，要严格使用参数绑定来传入参数。3、合理使用数据库框架提供的机制。就比如Mybatis提供的传入参数的方式 #{}，禁止使用${}，后者相当于是字符串拼接sql，要使用参数化的语句。总结下，就是要正确使用参数化绑定sql变量。</code></pre><h4 id="二、XSS"><a href="#二、XSS" class="headerlink" title="二、XSS"></a>二、XSS</h4><p>​    </p><blockquote><p>​       XSS：跨站脚本攻击，Cross-Site Scripting，为了和前端的css避免重名，简称为XSS，是指通过技术手段，向正常用户请求的HTML页面中插入恶意脚本，执行。</p></blockquote><blockquote><p>​    这种攻击主要是用于信息窃取和破坏等目的。比如2011年的微博XSS攻击事件，攻击者利用了微博发布功能中未对action-data漏洞做有效的过滤，在发布微博信息的时候带上了包含攻击脚本的URL，用户访问就会加载恶意脚本，导致大量用户被攻击。</p></blockquote><blockquote><p>​    关于防范XSS上，主要就是通过对用户输入的数据做过滤或者是转义，可以使用框架提供的工具类HtmlUtil。另外前端在浏览器展示数据的时候，要使用安全的API展示数据。比如使用innerText而不是innerHTML。</p></blockquote><h4 id="三、CSRF"><a href="#三、CSRF" class="headerlink" title="三、CSRF"></a>三、CSRF</h4><blockquote><p>​    跨站请求伪造，在用户并不知情的情况下，冒充用户发送请求，在当前已经登录的web网站上执行恶意操作，比如恶意发帖，修改密码等。</p></blockquote><blockquote><p>​    大致来看，与XSS有重合的地方，前者是黑客盗用用户浏览器中的登录信息，冒充用户去执行操作。后者是在正常用户请求的HTML中放入恶意代码，</p></blockquote><blockquote><p>​    XSS问题出在用户数据没有转义，过滤；CSRF问题出现在HTTP接口没有防范不守信用的调用。</p></blockquote><blockquote><p>防范CSRF的漏洞方式：</p></blockquote><blockquote><p>​    1、CSRF Token验证，利用浏览器的同源限制，在HTTP接口执行前验证Cookie中的Token，验证通过才会继续执行请求。</p></blockquote><blockquote><p>​    2、人机交互，例如短信验证码、界面的滑块。</p></blockquote><blockquote><p>之前在会议上也有一个思考，在人机验证这块，如果不用验证码的方式，用界面上的滑块这种方式，而且滑块还是第三方的。在APP的注册、登录使用这种人机验证的方式的话，如果第三方出现了问题，那么自己的APP就完全崩掉了，发版之后的APP什么也改不了。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SQL注入、XSS和CSRF&quot;&gt;&lt;a href=&quot;#SQL注入、XSS和CSRF&quot; class=&quot;headerlink&quot; title=&quot;SQL注入、XSS和CSRF&quot;&gt;&lt;/a&gt;SQL注入、XSS和CSRF&lt;/h1&gt;&lt;h4 id=&quot;一、SQL注入&quot;&gt;&lt;a href=
      
    
    </summary>
    
      <category term="日常学习" scheme="http://zongmansheng.club/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="SQL" scheme="http://zongmansheng.club/tags/SQL/"/>
    
      <category term="XSS" scheme="http://zongmansheng.club/tags/XSS/"/>
    
      <category term="CSRF" scheme="http://zongmansheng.club/tags/CSRF/"/>
    
  </entry>
  
  <entry>
    <title>一致性Hash</title>
    <link href="http://zongmansheng.club/2019/04/24/yi-zhi-xing-hash/"/>
    <id>http://zongmansheng.club/2019/04/24/yi-zhi-xing-hash/</id>
    <published>2019-04-24T13:17:59.000Z</published>
    <updated>2019-04-26T13:31:08.144Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一致性Hash"><a href="#一致性Hash" class="headerlink" title="一致性Hash"></a>一致性Hash</h1><blockquote><p>一致性Hash是分布式架构最重要最基础的东西，作为一个后端必须要了解，这里以分布式图片缓存服务器为例进行讲述。</p></blockquote><p><strong>原始问题：假设我们需要对一堆图片做缓存，缓存的图片放在了2台服务器上，当到来一个请求，应该如何知道请求的图片在哪台上面呢？</strong></p><blockquote><p>暴力遍历就不要去想了，否则缓存就没有意义了。一个自然的想法就是根据图片的名字做一个映射（Hash），将图片名字映射到0，1两个数字上面，例如有这样的映射函数：</p></blockquote><blockquote><p>f(图片名称) = md5(图片名称) % 2</p></blockquote><blockquote><p>md5是一个典型的哈希函数，会产生128bit的值，模2后只可能是0或1，那么我们就根据这个值把图片存入0、1两台服务器，当请求过来，根据图片名称计算出值，就可以知道图片缓存放在第几号服务器了：</p></blockquote><p><img src="/一致性Hash\001.jpg" alt="001"></p><blockquote><p>但假设现在我们图片太多了，需要再增加一台服务器分担压力，哈希函数必须更改成0、1、2映射，我们改为：</p></blockquote><blockquote><p>f(图片名称) = md5(图片名称) % 3</p></blockquote><blockquote><p>理论上讲，会有(N-1)/N的缓存会失效，其中N是服务器的数量，例如上述图片缓存，除了0图片、1图片，其余图片的存放位置都变了，失效的缓存有 2/3 * 6 = 4张图片：</p></blockquote><p><img src="/一致性Hash\002.jpg" alt="002"></p><p>减少图片服务器数量造成的后果亦是如此——在同一个时刻将会有大量缓存同时失效，称为“缓存雪崩”。失效了就会直接去后端服务器取，大量的请求直接透过缓存打到后端服务器，后端服务器极有可能承受不住压力而接连崩溃，最终造成整个系统瘫痪。</p><p><strong>所以出现进阶问题：当缓存服务器数量发生变化时，如何尽可能避免大量缓存同时失效？</strong></p><p>答案就是一致性Hash。</p><h4 id="一、一致性Hash原理"><a href="#一、一致性Hash原理" class="headerlink" title="一、一致性Hash原理"></a>一、一致性Hash原理</h4><h5 id="1、放置服务器"><a href="#1、放置服务器" class="headerlink" title="1、放置服务器"></a><strong>1、放置服务器</strong></h5><blockquote><p>我们将服务器像图片一样也进行哈希，服务器的“图片名称”一般就使用固定IP地址，Hash取模也不再是服务器数量，而是2^32，Hash的方法也不局限于md5，用一个抽象的函数表示：</p></blockquote><blockquote><p>f(服务器IP地址) = Hash(服务器IP地址) % 2^32</p></blockquote><blockquote><p>于是服务器被放置到了0~2^32-1某个数字对应的位置上去：</p></blockquote><p><img src="/一致性Hash\003.jpg" alt="003"></p><blockquote><p>为什么是2^32-1呢？因为第一次提出一致性Hash的论文是1997年发表的，那时候32位机器还是主流，2^32-1是最大的Integer。而现在64位早就普及了，完全可以将这个值扩大到2^64-1。</p></blockquote><h5 id="2、放置数据"><a href="#2、放置数据" class="headerlink" title="2、放置数据"></a><strong>2、放置数据</strong></h5><blockquote><p>我们将数据也按照相同的方式放到0~2^32-1的某个数字上去：</p></blockquote><blockquote><p>f(图片名称) = Hash(图片名称) % 2^32</p></blockquote><p><img src="//zongmansheng.club/2019/04/24/yi-zhi-xing-hash/004.jpg" alt="004"></p><h5 id="3、把数据放到服务器上"><a href="#3、把数据放到服务器上" class="headerlink" title="3、把数据放到服务器上"></a><strong>3、把数据放到服务器上</strong></h5><blockquote><p>对于每个数据，从映射的位置开始，顺时针行走，放置到碰到的第一个服务器上。例如3、230将会放到0号图片服务器，232将会放到1号图片服务器，4175556547将会放到2号图片服务器：</p></blockquote><p><img src="//zongmansheng.club/2019/04/24/yi-zhi-xing-hash/005.jpg" alt="005"></p><blockquote><p>这样一致性Hash就完成了。查找数据也是先映射、再顺时针行走找到第一台服务器。</p></blockquote><h4 id="二、一致性Hash如何缓解数据失效问题"><a href="#二、一致性Hash如何缓解数据失效问题" class="headerlink" title="二、一致性Hash如何缓解数据失效问题"></a>二、一致性Hash如何缓解数据失效问题</h4><blockquote><p>假设现在1号服务器崩溃，图片232找不到1号服务器，顺时针行走的第一台服务器是2号服务器，于是232的缓存位置发生了改变，变为了2号：</p></blockquote><p><img src="//zongmansheng.club/2019/04/24/yi-zhi-xing-hash/006.jpg" alt="006"></p><blockquote><p>而对于其他图片来说，缓存位置并没有发生变化，影响的数据量从（N-1）/ N 降为了 M，其中M是0号图片服务器到1号图片服务器之间的图片数量。需要重新获取的缓存数据量降低了，雪崩问题自然也就能够得到缓解。</p></blockquote><h4 id="三、Hash环偏斜和虚拟节点"><a href="#三、Hash环偏斜和虚拟节点" class="headerlink" title="三、Hash环偏斜和虚拟节点"></a>三、Hash环偏斜和虚拟节点</h4><blockquote><p>前面讨论得太理想了，实际的服务器分布和数据分布很可能是这样的：</p></blockquote><p><img src="//zongmansheng.club/2019/04/24/yi-zhi-xing-hash/007.jpg" alt="007"></p><blockquote><p>0、1、2三台服务器并没有均匀分布在环上，大量的图片数据都被放到了0号服务器上，而很少数据放到1、2号等其他图片服务器上，这种情况称之为Hash环偏斜。如果存放的是缓存则0号服务器崩溃就会引起缓存雪崩，如果存放的是数据则0号服务器就可能单点故障。</p></blockquote><blockquote><p>很自然可以想到，增加多台服务器就好了嘛。我们在Hash环上生成0、1、2三台服务器的虚拟节点：</p></blockquote><p><img src="//zongmansheng.club/2019/04/24/yi-zhi-xing-hash/008.jpg" alt="008"></p><blockquote><p>具体的做法是，在服务器IP后面增加编号，每一台服务器产生多个Hash值，就能放置在0~2^32-1的多个位置上了。这样一来，顺时针行走能找到不同的服务器概率将会大大提高，避免了偏斜问题。虚拟的服务器节点数越多，偏斜出现的概率就越低。通常都需要设置32或以上的虚拟节点数目，我见过甚至有设置500的。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一致性Hash&quot;&gt;&lt;a href=&quot;#一致性Hash&quot; class=&quot;headerlink&quot; title=&quot;一致性Hash&quot;&gt;&lt;/a&gt;一致性Hash&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;一致性Hash是分布式架构最重要最基础的东西，作为一个后端必须要了解，这里
      
    
    </summary>
    
      <category term="后端" scheme="http://zongmansheng.club/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="算法" scheme="http://zongmansheng.club/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Hash" scheme="http://zongmansheng.club/tags/Hash/"/>
    
  </entry>
  
  <entry>
    <title>三次握手和四次挥手</title>
    <link href="http://zongmansheng.club/2019/04/20/san-ci-wo-shou-he-si-ci-hui-shou/"/>
    <id>http://zongmansheng.club/2019/04/20/san-ci-wo-shou-he-si-ci-hui-shou/</id>
    <published>2019-04-20T12:31:54.000Z</published>
    <updated>2019-04-20T13:04:25.221Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三次握手和四次挥手"><a href="#三次握手和四次挥手" class="headerlink" title="三次握手和四次挥手"></a>三次握手和四次挥手</h1><h4 id="常用的熟知端口号"><a href="#常用的熟知端口号" class="headerlink" title="常用的熟知端口号"></a>常用的熟知端口号</h4><p><img src="//zongmansheng.club/2019/04/20/san-ci-wo-shou-he-si-ci-hui-shou/004.jpg" alt="004"></p><h4 id="TCP的概述"><a href="#TCP的概述" class="headerlink" title="TCP的概述"></a>TCP的概述</h4><pre><code>TCP把连接作为最基本的对象，每一条TCP连接都有两个端点，这种断点我们叫作套接字（socket），它的定义为端口号拼接到IP地址即构成了套接字，例如，若IP地址为192.3.4.16 而端口号为80，那么得到的套接字为192.3.4.16:80。</code></pre><h4 id="TCP报文首部"><a href="#TCP报文首部" class="headerlink" title="TCP报文首部"></a>TCP报文首部</h4><pre><code>1、源端口和目的端口，各占2个字节，分别写入源端口和目的端口；2、序号，占4个字节，TCP连接中传送的字节流中的每个字节都按顺序编号。例如，一段报文的序号字段值是 301 ，而携带的数据共有100字段，显然下一个报文段（如果还有的话）的数据序号应该从401开始；3、确认号，占4个字节，是期望收到对方下一个报文的第一个数据字节的序号。例如，B收到了A发送过来的报文，其序列号字段是501，而数据长度是200字节，这表明B正确的收到了A发送的到序号700为止的数据。因此，B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701；4、数据偏移，占4位，它指出TCP报文的数据距离TCP报文段的起始处有多远；5、保留，占6位，保留今后使用，但目前应都位0；6、紧急URG，当URG=1，表明紧急指针字段有效。告诉系统此报文段中有紧急数据；7、确认ACK，仅当ACK=1时，确认号字段才有效。TCP规定，在连接建立后所有报文的传输都必须把ACK置1；8、推送PSH，当两个应用进程进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应，这时候就将PSH=1；9、复位RST，当RST=1，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立连接；10、同步SYN，在连接建立时用来同步序号。当SYN=1，ACK=0，表明是连接请求报文，若同意连接，则响应报文中应该使SYN=1，ACK=1；11、终止FIN，用来释放连接。当FIN=1，表明此报文的发送方的数据已经发送完毕，并且要求释放；12、窗口，占2字节，指的是通知接收方，发送本报文你需要有多大的空间来接受；13、检验和，占2字节，校验首部和数据这两部分；14、紧急指针，占2字节，指出本报文段中的紧急数据的字节数；15、选项，长度可变，定义一些其他的可选的参数。</code></pre><pre><code>为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。漫画图解：图片来源：《图解HTTP》</code></pre><p><img src="//zongmansheng.club/2019/04/20/san-ci-wo-shou-he-si-ci-hui-shou/001.jpg" alt="001"></p><p>简单示意图：</p><p><img src="//zongmansheng.club/2019/04/20/san-ci-wo-shou-he-si-ci-hui-shou/002.jpg" alt="002"></p><p>动图：</p><p><img src="//zongmansheng.club/2019/04/20/san-ci-wo-shou-he-si-ci-hui-shou/005.gif" alt="005"></p><pre><code>- 客户端–发送带有 SYN 标志的数据包–一次握手–服务端- 服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端- 客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端</code></pre><pre><code>最开始的时候客户端和服务器都是处于CLOSED状态。主动打开连接的为客户端，被动打开连接的是服务器</code></pre><pre><code>1、TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态；2、TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。3、TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。4、TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。5、当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。</code></pre><p><img src="//zongmansheng.club/2019/04/20/san-ci-wo-shou-he-si-ci-hui-shou/006.png" alt="006"></p><h4 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h4><pre><code>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。第一次握手：Client 什么都不能确认；Server 确认了对方发送正常第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己接收正常，对方发送正常第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送接收正常所以三次握手就能确认双发收发功能都正常，缺一不可。</code></pre><h4 id="为什么要传回-SYN"><a href="#为什么要传回-SYN" class="headerlink" title="为什么要传回 SYN"></a>为什么要传回 SYN</h4><pre><code>接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。SYN 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement[汉译：确认字符 ,在数据通信传输中，接收站发给发送站的一种传输控制字符。它表示确认发来的数据已经接受无误。 ]）消息响应。这样在客户机和服务器之间才能建立起可靠的TCP连接，数据才可以在客户机和服务器之间传递。</code></pre><h4 id="传了-SYN-为啥还要传-ACK"><a href="#传了-SYN-为啥还要传-ACK" class="headerlink" title="传了 SYN,为啥还要传 ACK"></a>传了 SYN,为啥还要传 ACK</h4><pre><code>双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证。</code></pre><p><img src="//zongmansheng.club/2019/04/20/san-ci-wo-shou-he-si-ci-hui-shou/003.jpg" alt="003"></p><pre><code>断开一个 TCP 连接则需要“四次挥手”：- 客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送- 服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号- 服务器-关闭与客户端的连接，发送一个FIN给客户端- 客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1</code></pre><h4 id="TCP连接的释放（四次挥手）"><a href="#TCP连接的释放（四次挥手）" class="headerlink" title="TCP连接的释放（四次挥手）"></a>TCP连接的释放（四次挥手）</h4><p><img src="//zongmansheng.club/2019/04/20/san-ci-wo-shou-he-si-ci-hui-shou/007.gif" alt="007"></p><pre><code>数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于ESTABLISHED状态，然后客户端主动关闭，服务器被动关闭。</code></pre><pre><code>1、客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。2、服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。3、客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。4、服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。5、客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗ *∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。6、服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</code></pre><p><img src="//zongmansheng.club/2019/04/20/san-ci-wo-shou-he-si-ci-hui-shou/008.png" alt="008"></p><h4 id="为什么客户端最后还要等待2MSL？"><a href="#为什么客户端最后还要等待2MSL？" class="headerlink" title="为什么客户端最后还要等待2MSL？"></a>为什么客户端最后还要等待2MSL？</h4><pre><code>MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</code></pre><h4 id="为什么建立连接是三次握手，关闭连接确是四次挥手呢？"><a href="#为什么建立连接是三次握手，关闭连接确是四次挥手呢？" class="headerlink" title="为什么建立连接是三次握手，关闭连接确是四次挥手呢？"></a>为什么建立连接是三次握手，关闭连接确是四次挥手呢？</h4><pre><code>建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。</code></pre><h4 id="为什么要四次挥手"><a href="#为什么要四次挥手" class="headerlink" title="为什么要四次挥手"></a>为什么要四次挥手</h4><pre><code>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。</code></pre><h4 id="如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办？</h4><pre><code>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;三次握手和四次挥手&quot;&gt;&lt;a href=&quot;#三次握手和四次挥手&quot; class=&quot;headerlink&quot; title=&quot;三次握手和四次挥手&quot;&gt;&lt;/a&gt;三次握手和四次挥手&lt;/h1&gt;&lt;h4 id=&quot;常用的熟知端口号&quot;&gt;&lt;a href=&quot;#常用的熟知端口号&quot; class=&quot;
      
    
    </summary>
    
      <category term="计算机网络" scheme="http://zongmansheng.club/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="TCP" scheme="http://zongmansheng.club/tags/TCP/"/>
    
  </entry>
  
</feed>
